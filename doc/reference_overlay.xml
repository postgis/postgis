<?xml version="1.0" encoding="UTF-8"?>
    <sect1 id="Overlay_Functions">
    <sect1info>
    <abstract>
    <para>These functions compute results arising from the overlay of two geometries.
    These are also known as point-set theoretic boolean operations.
    Some related functions are also provided.
    </para>
    </abstract>
    </sect1info>

    <title>Overlay Functions</title>

    <refentry id="ST_ClipByBox2D">
      <refnamediv>
        <refname>ST_ClipByBox2D</refname>
        <refpurpose>Returns the portion of a geometry falling within a rectangle.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
            <funcprototype>
                <funcdef>geometry <function>ST_ClipByBox2D</function></funcdef>
                <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
                <paramdef><type>box2d</type> <parameter>box</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>
        Clips a geometry by a 2D box in a fast and tolerant but possibly invalid way.
        Topologically invalid input geometries do not result in exceptions being thrown.
        The output geometry is not guaranteed to be valid
        (in particular, self-intersections for a polygon may be introduced).
        </para>

        <para>Performed by the GEOS module.</para>

        <para>Availability: 2.2.0</para>

      </refsection>

      <refsection>
        <title>Examples</title>
            <programlisting>
-- Rely on implicit cast from geometry to box2d for the second parameter
SELECT ST_ClipByBox2D(the_geom, ST_MakeEnvelope(0,0,10,10)) FROM mytab;
      </programlisting>
      </refsection>
      <refsection>
        <title>See Also</title>
        <para>
<xref linkend="ST_Intersection" />,
<xref linkend="ST_MakeBox2D" />,
<xref linkend="ST_MakeEnvelope" />
    </para>
      </refsection>
    </refentry>

    <refentry id="ST_Difference">
      <refnamediv>
        <refname>ST_Difference</refname>

        <refpurpose>Returns a geometry representing the part of geometry A
            that does not intersect geometry B.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_Difference</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
            <paramdef choice="opt"><type>float8 </type> <parameter>gridSize = -1</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>Returns a geometry representing the part of geometry A
            that does not intersect geometry B.
            This is equivalent to <code>A - ST_Intersection(A,B)</code>.
            If A is completely contained in B
            then an empty geometry is returned.</para>
        <note><para>This is the only overlay function where input order matters.
            ST_Difference(A, B) always returns a portion of A.</para></note>

            <para>
If the optional <code>gridSize</code> argument is provided, the inputs are
snapped to a grid of the given size, and the result vertices are computed
on that same grid. (Requires GEOS-3.9.0 or higher)
            </para>

        <para>Performed by the GEOS module</para>
        <para>Enhanced: 3.1.0 accept a gridSize parameter - requires GEOS &gt;= 3.9.0</para>

        <para>&sfs_compliant; s2.1.1.3</para>
        <para>&sqlmm_compliant; SQL-MM 3: 5.1.20</para>
        <para>&Z_support; However, the result is computed using XY only.
            The result Z values are copied, averaged or interpolated.</para>
      </refsection>

      <refsection>
        <title>Examples</title>
            <informaltable>
              <tgroup cols="2">
                <tbody>
                  <row>
                    <entry>
                        <para>
                            <informalfigure>
                                <mediaobject>
                                  <imageobject>
                                    <imagedata fileref="images/st_symdifference01.png" />
                                  </imageobject>
                                  <caption><para>The input linestrings </para></caption>
                                </mediaobject>
                            </informalfigure>
                        </para>
                    </entry>

                    <entry>
                        <para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_difference01.png" />
                              </imageobject>
                              <caption><para>The difference of the two linestrings</para></caption>
                            </mediaobject>
                          </informalfigure>
                    </para>
                </entry>
                  </row>
        </tbody>
    </tgroup>
</informaltable>
<para>The difference of 2D linestrings.</para>
<programlisting>SELECT ST_AsText(
    ST_Difference(
            'LINESTRING(50 100, 50 200)'::geometry,
            'LINESTRING(50 50, 50 150)'::geometry
        )
    );

st_astext
---------
LINESTRING(50 150,50 200)
</programlisting>

<para>The difference of 3D points.</para>
<programlisting>SELECT ST_AsEWKT( ST_Difference(
                   'MULTIPOINT(-118.58 38.38 5,-118.60 38.329 6,-118.614 38.281 7)' :: geometry,
                   'POINT(-118.614 38.281 5)' :: geometry
                  ) );

st_asewkt
---------
MULTIPOINT(-118.6 38.329 6,-118.58 38.38 5)
</programlisting>
      </refsection>

      <refsection>
        <title>See Also</title>

        <para><xref linkend="ST_SymDifference" />, <xref linkend="ST_Intersection" />, <xref linkend="ST_Union" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_Intersection">
        <refnamediv>
            <refname>ST_Intersection</refname>

            <refpurpose>
Returns a geometry representing the shared portion of geometries A and B.
            </refpurpose>
        </refnamediv>
        <refsynopsisdiv>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>geometry <function>ST_Intersection</function></funcdef>
                    <paramdef>
                        <type>geometry</type>
                        <parameter>geomA</parameter>
                    </paramdef>
                    <paramdef>
                        <type>geometry</type>
                        <parameter>geomB</parameter>
                    </paramdef>
                    <paramdef choice="opt">
                        <type>float8</type>
                        <parameter>gridSize = -1</parameter>
                    </paramdef>
                </funcprototype>
                <funcprototype>
                    <funcdef>geography <function>ST_Intersection</function></funcdef>
                    <paramdef>
                        <type>geography</type>
                        <parameter>geogA</parameter>
                    </paramdef>
                    <paramdef>
                        <type>geography</type>
                        <parameter>geogB</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
        </refsynopsisdiv>
        <refsection>
            <title>Description</title>
            <para>Returns a geometry representing the point-set
                intersection of two geometries.
                In other words, that portion of geometry A and geometry B
                that is shared between the two geometries.</para>

            <para>If the geometries do not share any space (are disjoint), then an empty geometry collection
            is returned.</para>
            <para>ST_Intersection in conjunction with ST_Intersects is very useful for clipping geometries such as in bounding box, buffer, region
                queries where you only want to return that portion of a geometry that sits in a country or region of interest.</para>

            <para>
If the optional <code>gridSize</code> argument is provided, the inputs are
snapped to a grid of the given size, and the result vertices are computed
on that same grid.  (Requires GEOS-3.9.0 or higher)
            </para>

            <note><para>Geography: For geography this is really a thin wrapper around the geometry implementation. It first determines the best SRID that
                    fits the bounding box of the 2 geography objects (if geography objects are within one half zone UTM but not same UTM will pick one of those) (favoring UTM or Lambert Azimuthal Equal Area (LAEA) north/south pole, and falling back on mercator in worst case scenario)  and then intersection in that best fit planar spatial ref and retransforms back to WGS84 geography.</para></note>

        <warning><para>This function will drop the M coordinate values if present.</para></warning>

          <warning><para>If working with 3D geometries, you may want to use SFGCAL based <xref linkend="ST_3DIntersection" /> which does a proper 3D intersection for 3D geometries.  Although this function works with Z-coordinate, it does an averaging of Z-Coordinate.</para></warning>

        <para>Performed by the GEOS module</para>

        <para>Enhanced: 3.1.0 accept a gridSize parameter - requires GEOS &gt;= 3.9.0</para>
        <para>Changed: 3.0.0 does not depend on SFCGAL.</para>
        <para>Availability: 1.5 support for geography data type was introduced.</para>

        <para>&sfs_compliant; s2.1.1.3</para>
        <para>&sqlmm_compliant; SQL-MM 3: 5.1.18</para>
        <para>&Z_support; However, the result is computed using XY only.
            The result Z values are copied, averaged or interpolated.</para>
        </refsection>
        <refsection>
        <title>Examples</title>
<programlisting>SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry));
 st_astext
---------------
GEOMETRYCOLLECTION EMPTY

SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::geometry));
 st_astext
---------------
POINT(0 0)</programlisting>
<para>
Clip all lines (trails) by country. Hhere we assume country geom are POLYGON or MULTIPOLYGONS.
NOTE: we are only keeping intersections that result in a LINESTRING or MULTILINESTRING because we don't
care about trails that just share a point. The dump is needed to expand a geometry collection into individual single MULT* parts.
The below is fairly generic and will work for polys, etc. by just changing the where clause.</para>
<programlisting>select clipped.gid, clipped.f_name, clipped_geom
from (
         select trails.gid, trails.f_name,
             (ST_Dump(ST_Intersection(country.geom, trails.geom))).geom clipped_geom
         from country
              inner join trails on ST_Intersects(country.geom, trails.geom)
     ) as clipped
where ST_Dimension(clipped.clipped_geom) = 1;</programlisting>
<para>For polys e.g. polygon landmarks, you can also use the sometimes faster hack that buffering anything by 0.0 except a polygon results in an empty geometry collection.
(So a geometry collection containing polys, lines and points buffered by 0.0 would only leave the polygons and dissolve the collection shell.)</para>
<programlisting>select poly.gid,
    ST_Multi(
        ST_Buffer(
            ST_Intersection(country.geom, poly.geom),
            0.0
        )
    ) clipped_geom
from country
     inner join poly on ST_Intersects(country.geom, poly.geom)
where not ST_IsEmpty(ST_Buffer(ST_Intersection(country.geom, poly.geom), 0.0));</programlisting>
        </refsection>

        <refsection>
        <title>Examples: 2.5Dish</title>
        <para>Note this is not a true intersection, compare to the same example using <xref linkend="ST_3DIntersection" />.</para>
        <programlisting>
select ST_AsText(ST_Intersection(linestring, polygon)) As wkt
from  ST_GeomFromText('LINESTRING Z (2 2 6,1.5 1.5 7,1 1 8,0.5 0.5 8,0 0 10)') AS linestring
 CROSS JOIN ST_GeomFromText('POLYGON((0 0 8, 0 1 8, 1 1 8, 1 0 8, 0 0 8))') AS polygon;

               st_astext
---------------------------------------
 LINESTRING Z (1 1 8,0.5 0.5 8,0 0 10)
        </programlisting>
      </refsection>
        <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_3DIntersection" />, <xref linkend="ST_Difference"/>, <xref linkend="ST_Union"/>, <xref linkend="ST_Dimension"/>, <xref linkend="ST_Dump"/>, <xref linkend="ST_Force2D" />, <xref linkend="ST_SymDifference"/>, <xref linkend="ST_Intersects"/>, <xref linkend="ST_Multi"/></para>
        </refsection>
    </refentry>


    <refentry id="ST_MemUnion">
      <refnamediv>
        <refname>ST_MemUnion</refname>

        <refpurpose>Aggregate function which unions geometry in a memory-efficent but slower way</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_MemUnion</function></funcdef>
            <paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
          </funcprototype>

        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

    <para>Unions the input geometries, merging geometry to produce a result geometry
        with no overlaps.
        The output may be a single geometry, a MultiGeometry, or a Geometry Collection.
        </para>

        <!-- optionally mention that this function uses indexes if appropriate -->
        <note>
          <para>Produces the same result as <xref linkend="ST_Union" />, but uses less memory
            and more processor time.
            This aggregate function works by unioning the geometries incrementally, as opposed to
            the ST_Union aggregate which first accumulates an array and then unions the contents
            using a fast algorithm.</para>
        </note>

        <para>&Z_support; However, the result is computed using XY only.
            The result Z values are copied, averaged or interpolated.</para>
      </refsection>


      <refsection>
        <title>Examples</title>

        <programlisting>See ST_Union</programlisting>
      </refsection>

      <!-- Optionally add a "See Also" section -->
      <refsection>
        <title>See Also</title>

        <para><xref linkend="ST_Union" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_Node">
      <refnamediv>
        <refname>ST_Node</refname>

        <refpurpose>
Nodes a collection of lines.
        </refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_Node</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
          </funcprototype>

        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>
Returns a (Multi)LineString representing the fully noded version of a collection of linestrings.
The noding preserves all of the input nodes,
and introduces the least possible number of new nodes.
The resulting linework is dissolved (duplicate lines are removed).
        </para>

        <para>This is a good way to create fully-noded linework suitable for use as input to <xref linkend="ST_Polygonize" />.</para>

        <para>&Z_support;</para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 2.0.0</para>

        <para>
Changed: 2.4.0 this function uses GEOSNode internally instead of GEOSUnaryUnion.
This may cause the resulting linestrings to have a different order and direction compared to Postgis &lt; 2.4.
        </para>
      </refsection>
      <refsection>
        <title>Examples</title>
        <para>Noding a 3D LineString which self-intersects</para>
        <programlisting>
SELECT ST_AsText(
        ST_Node('LINESTRINGZ(0 0 0, 10 10 10, 0 10 5, 10 0 3)'::geometry)
    ) As  output;
output
-----------
MULTILINESTRING Z ((0 0 0,5 5 4.5),(5 5 4.5,10 10 10,0 10 5,5 5 4.5),(5 5 4.5,10 0 3))
        </programlisting>

        <para>Noding two LineStrings which share common linework.
        Note that the result linework is dissolved.</para>
        <programlisting>
SELECT ST_AsText(
        ST_Node('MULTILINESTRING ((2 5, 2 1, 7 1), (6 1, 4 1, 2 3, 2 5))'::geometry)
    ) As  output;
output
-----------
MULTILINESTRING((2 5,2 3),(2 3,2 1,4 1),(4 1,2 3),(4 1,6 1),(6 1,7 1))
        </programlisting>

      </refsection>

      <!-- Optionally add a "See Also" section -->
      <refsection>
        <title>See Also</title>

        <para>
            <xref linkend="ST_UnaryUnion" />
        </para>
      </refsection>
    </refentry>

    <refentry id="ST_Split">
        <refnamediv>
            <refname>ST_Split</refname>
            <refpurpose>Returns a collection of geometries created by splitting a geometry by another geometry.</refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>
              <funcprototype>
                <funcdef>geometry <function>ST_Split</function></funcdef>
                <paramdef><type>geometry</type> <parameter>input</parameter></paramdef>
                <paramdef><type>geometry</type> <parameter>blade</parameter></paramdef>
              </funcprototype>
            </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>
            <para>
            The function supports splitting a line by a (multi)point, (multi)line or (multi)polygon boundary,
            or a (multi)polygon by line.
            The returned geometry is always a collection.
            </para>

            <para>
            Think of this function as the opposite of ST_Union.
            Theoretically applying ST_Union to the elements of the returned collection
            should always yield the original geometry.
            </para>

            <para>Availability: 2.0.0 requires GEOS</para>
            <para>Enhanced: 2.2.0 support for splitting a line by a multiline, a multipoint or (multi)polygon boundary was introduced.</para>
            <para>Enhanced: 2.5.0 support for splitting a polygon by a multiline was introduced.</para>

            <note><para>To improve the robustness of ST_Split it may be convenient to <xref linkend="ST_Snap"/> the input to the blade in advance using a very low tolerance. Otherwise the internally used coordinate grid may cause tolerance problems, where coordinates of input and blade do not fall onto each other and the input is not being split correctly (see <ulink url="http://trac.osgeo.org/postgis/ticket/2192">#2192</ulink>).</para></note>

            <note><para>
When a (multi)polygon is passed as as the blade, its linear component
(the boundary) is used for cutting the input.
            </para></note>

        </refsection>
        <refsection>
            <title>Examples</title>
            <para>Polygon Cut by Line</para>
            <informaltable>
                <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split01.png" />
                              </imageobject>
                              <caption><para>Before Split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                               </para>
                        </entry>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split02.png" />
                              </imageobject>
                              <caption><para>After split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                              </para>
                        </entry>
                    </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <programlisting>
-- this creates a geometry collection consisting of the 2 halves of the polygon
-- this is similar to the example we demonstrated in ST_BuildArea
SELECT ST_Split(circle, line)
FROM (SELECT
    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,
    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

-- result --
 GEOMETRYCOLLECTION(POLYGON((150 90,149.039264020162 80.2454838991936,146.193976625564 70.8658283817455,..), POLYGON(..)))

-- To convert to individual polygons, you can use ST_Dump or ST_GeometryN
SELECT ST_AsText((ST_Dump(ST_Split(circle, line))).geom) As wkt
FROM (SELECT
    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,
    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

-- result --
wkt
---------------
POLYGON((150 90,149.039264020162 80.2454838991936,..))
POLYGON((60.1371179574584 60.1371179574584,58.4265193848728 62.2214883490198,53.8060233744357 ..))
            </programlisting>
            <para>Multilinestring Cut by point</para>
            <informaltable>
                <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split03.png" />
                              </imageobject>
                              <caption><para>Before Split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                               </para>
                        </entry>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split04.png" />
                              </imageobject>
                              <caption><para>After split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                               </para>
                        </entry>
                    </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <programlisting>
SELECT ST_AsText(ST_Split(mline, pt)) As wktcut
        FROM (SELECT
    ST_GeomFromText('MULTILINESTRING((10 10, 190 190), (15 15, 30 30, 100 90))') As mline,
    ST_Point(30,30) As pt) As foo;

wktcut
------
GEOMETRYCOLLECTION(
    LINESTRING(10 10,30 30),
    LINESTRING(30 30,190 190),
    LINESTRING(15 15,30 30),
    LINESTRING(30 30,100 90)
)
            </programlisting>
        </refsection>
        <refsection>
        <title>See Also</title>
        <para>
<xref linkend="ST_AsText" />,
<xref linkend="ST_BuildArea" />,
<xref linkend="ST_CollectionExtract" />,
<xref linkend="ST_Dump" />,
<xref linkend="ST_GeometryN" />,
<xref linkend="ST_Subdivide" />,
<xref linkend="ST_Union" />
        </para>
        </refsection>
    </refentry>

   <refentry id="ST_Subdivide">
      <refnamediv>
        <refname>ST_Subdivide</refname>
        <refpurpose>Computes a rectilinear subdivision of a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
            <funcprototype>
                <funcdef>setof geometry <function>ST_Subdivide</function></funcdef>
                <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
                <paramdef><type>integer</type> <parameter>max_vertices=256</parameter></paramdef>
                <paramdef choice="opt"><type>float8</type> <parameter>gridSize = -1</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
    </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>
            Divides geometry into parts using rectilinear lines, until each part can be represented using no more than <code>max_vertices</code>.
            Point-in-polygon and other spatial operations are normally faster for indexed subdivided dataset:
            "miss" cases are faster to check as boxes for all parts typically cover smaller area than original geometry box,
            "hit" cases are faster because recheck operates on less points.
            <code>max_vertices</code> must be 5 or more, as 5 points are needed to represent a closed box.
            <code>gridSize</code> can be specified to have clipping work in fixed-precision space (requires GEOS-3.9.0+).
        </para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 2.2.0</para>
        <para>Enhanced: 2.5.0 reuses existing points on polygon split, vertex count is lowered from 8 to 5.</para>
        <para>Enhanced: 3.1.0 accept a gridSize parameter, requires GEOS &gt;= 3.9.0 to use this new feature.</para>
      </refsection>

      <refsection>
        <title>Examples</title>
            <programlisting>-- Subdivide complex geometries in table, in place
with complex_areas_to_subdivide as (
    delete from polygons_table
    where ST_NPoints(geom) > 255
    returning id, column1, column2, column3, geom
)
insert into polygons_table (fid, column1, column2, column3, geom)
    select
        fid, column1, column2, column3,
        ST_Subdivide(geom, 255) as geom
    from complex_areas_to_subdivide;
 </programlisting>

            <programlisting>-- Create a new subdivided table suitable for joining to the original
CREATE TABLE subdivided_geoms AS
SELECT pkey, ST_Subdivide(geom) AS geom
FROM original_geoms;
 </programlisting>

                <informaltable>
                  <tgroup cols="1">
                    <tbody>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_subdivide01.png" />
                              </imageobject>
                              <caption><para>Subdivide max 10 vertices</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>SELECT row_number() OVER() As rn, ST_AsText(geom) As wkt
FROM ( SELECT ST_SubDivide('POLYGON((132 10,119 23,85 35,68 29,66 28,49 42,32 56,22 64,32 110,40 119,36 150,
57 158,75 171,92 182,114 184,132 186,146 178,176 184,179 162,184 141,190 122,
190 100,185 79,186 56,186 52,178 34,168 18,147 13,132 10))'::geometry,10))  As f(geom);</programlisting>
<screen> rn │                                                      wkt
────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────
  1 │ POLYGON((119 23,85 35,68 29,66 28,32 56,22 64,29.8260869565217 100,119 100,119 23))
  2 │ POLYGON((132 10,119 23,119 56,186 56,186 52,178 34,168 18,147 13,132 10))
  3 │ POLYGON((119 56,119 100,190 100,185 79,186 56,119 56))
  4 │ POLYGON((29.8260869565217 100,32 110,40 119,36 150,57 158,75 171,92 182,114 184,114 100,29.8260869565217 100))
  5 │ POLYGON((114 184,132 186,146 178,176 184,179 162,184 141,190 122,190 100,114 100,114 184))</screen>
                          </para></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_subdivide02.png" />
                              </imageobject>
                              <caption><para>Useful in conjunction with ST_Segmentize(geography) to create additional vertices that can then be used for splitting.</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>SELECT ST_AsText(ST_Subdivide(ST_Segmentize('LINESTRING(0 0, 85 85)'::geography,1200000)::geometry,8));</programlisting>
                <screen>
LINESTRING(0 0,0.487578359029357 5.57659056746196,0.984542144675897 11.1527721155093,1.50101059639722 16.7281035483571,1.94532113630331 21.25)
LINESTRING(1.94532113630331 21.25,2.04869538062779 22.3020741387339,2.64204641967673 27.8740533545155,3.29994062412787 33.443216802941,4.04836719489742 39.0084282520239,4.59890468420694 42.5)
LINESTRING(4.59890468420694 42.5,4.92498503922732 44.5680389206321,5.98737409390639 50.1195229244701,7.3290919767674 55.6587646879025,8.79638749938413 60.1969505994924)
LINESTRING(8.79638749938413 60.1969505994924,9.11375579533779 61.1785363177625,11.6558166691368 66.6648504160202,15.642041247655 72.0867690601745,22.8716627200212 77.3609628116894,24.6991785131552 77.8939011989848)
LINESTRING(24.6991785131552 77.8939011989848,39.4046096622744 82.1822848017636,44.7994523421035 82.5156766227011)
LINESTRING(44.7994523421035 82.5156766227011,85 85)</screen>
                          </para></entry>
                      </row>
                </tbody></tgroup></informaltable>
      </refsection>
      <refsection>
        <title>See Also</title>
        <para>
<xref linkend="ST_AsText" />,
<xref linkend="ST_ClipByBox2D" />,
<xref linkend="ST_Segmentize" />,
<xref linkend="ST_Split" />,
<xref linkend="ST_NPoints" />
    </para>
      </refsection>
    </refentry>

    <refentry id="ST_SymDifference">
      <refnamediv>
        <refname>ST_SymDifference</refname>

        <refpurpose>Returns a geometry representing the portions of geometries A and B
            that do not intersect.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_SymDifference</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
            <paramdef choice="opt"><type>float8 </type> <parameter>gridSize = -1</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>Returns a geometry representing the portions of geonetries A and B
            that do not intersect.
            This is equivalent to <code>ST_Union(A,B) - ST_Intersection(A,B)</code>.
            It is called a symmetric difference because <code>ST_SymDifference(A,B) = ST_SymDifference(B,A)</code>.
            </para>

            <para>
If the optional <code>gridSize</code> argument is provided, the inputs are
snapped to a grid of the given size, and the result vertices are computed
on that same grid. (Requires GEOS-3.9.0 or higher)
            </para>

        <para>Performed by the GEOS module</para>

        <para>Enhanced: 3.1.0 accept a gridSize parameter - requires GEOS &gt;= 3.9.0</para>

        <para>&sfs_compliant; s2.1.1.3</para>
        <para>&sqlmm_compliant; SQL-MM 3: 5.1.21</para>
        <para>&Z_support; However, the result is computed using XY only.
            The result Z values are copied, averaged or interpolated.</para>
      </refsection>


      <refsection>
        <title>Examples</title>

        <informaltable>
              <tgroup cols="2">
                <tbody>
                  <row>
                    <entry>
                        <para>
                            <informalfigure>
                                <mediaobject>
                                  <imageobject>
                                    <imagedata fileref="images/st_symdifference01.png" />
                                  </imageobject>
                                  <caption><para>The original linestrings shown together</para></caption>
                                </mediaobject>
                            </informalfigure>
                        </para>
                    </entry>

                    <entry>
                        <para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_symdifference02.png" />
                              </imageobject>
                              <caption><para>The symmetric difference of the two linestrings</para></caption>
                            </mediaobject>
                          </informalfigure>
                    </para>
                </entry>
                  </row>
        </tbody>
    </tgroup>
</informaltable>
<programlisting>
--Safe for 2d - symmetric difference of 2 linestrings
SELECT ST_AsText(
    ST_SymDifference(
        ST_GeomFromText('LINESTRING(50 100, 50 200)'),
        ST_GeomFromText('LINESTRING(50 50, 50 150)')
    )
);

st_astext
---------
MULTILINESTRING((50 150,50 200),(50 50,50 100))
</programlisting>

<programlisting>

--When used in 3d doesn't quite do the right thing
SELECT ST_AsEWKT(ST_SymDifference(ST_GeomFromEWKT('LINESTRING(1 2 1, 1 4 2)'),
    ST_GeomFromEWKT('LINESTRING(1 1 3, 1 3 4)')))

st_astext
------------
MULTILINESTRING((1 3 2.75,1 4 2),(1 1 3,1 2 2.25))
        </programlisting>
      </refsection>

      <!-- Optionally add a "See Also" section -->
      <refsection>
        <title>See Also</title>

        <para><xref linkend="ST_Difference" />, <xref linkend="ST_Intersection" />, <xref linkend="ST_Union" /></para>
      </refsection>
</refentry>


<refentry id="ST_Union">
  <refnamediv>
    <refname>ST_Union</refname>
    <refpurpose>Returns a geometry representing the point-set union of
        the input geometries.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <funcsynopsis>
      <funcprototype>
        <funcdef>geometry <function>ST_Union</function></funcdef>
        <paramdef><type>geometry</type> <parameter>g1</parameter></paramdef>
        <paramdef><type>geometry</type> <parameter>g2</parameter></paramdef>
      </funcprototype>
      <funcprototype>
        <funcdef>geometry <function>ST_Union</function></funcdef>
        <paramdef><type>geometry</type> <parameter>g1</parameter></paramdef>
        <paramdef><type>geometry</type> <parameter>g2</parameter></paramdef>
        <paramdef><type>float8</type> <parameter>gridSize</parameter></paramdef>
      </funcprototype>
      <funcprototype>
        <funcdef>geometry <function>ST_Union</function></funcdef>
        <paramdef><type>geometry[]</type> <parameter>g1_array</parameter></paramdef>
      </funcprototype>
      <funcprototype>
        <funcdef>geometry <function>ST_Union</function></funcdef>
        <paramdef><type>geometry set</type> <parameter>g1field</parameter></paramdef>
      </funcprototype>
      <funcprototype>
        <funcdef>geometry <function>ST_Union</function></funcdef>
        <paramdef><type>geometry set</type> <parameter>g1field</parameter></paramdef>
        <paramdef><type>float8</type> <parameter>gridSize</parameter></paramdef>
      </funcprototype>
    </funcsynopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Description</title>
    <para>Unions the input geometries, merging geometry to produce a result geometry
        with no overlaps.
        The output may be a single geometry, a MultiGeometry, or a Geometry Collection.
        Comes in several variants:</para>

    <para><emphasis role="bold">Two-input variant:</emphasis>
        returns a geometry that is the union of two input geometries.
        If either input is NULL, then NULL is returned.
        </para>

    <para><emphasis role="bold">Array variant:</emphasis>
        returns a geometry that is the union of an array of geometries.
    </para>

    <para><emphasis role="bold">Aggregate variant:</emphasis>
        returns a geometry that is the union of a rowset of geometries.
        The ST_Union() function is an "aggregate"
        function in the terminology of PostgreSQL. That means that it
        operates on rows of data, in the same way the SUM() and AVG()
        functions do and like most aggregates, it also ignores NULL geometries.</para>

    <para>See also <xref linkend="ST_UnaryUnion" /> for a non-aggregate, single-input variant.</para>

    <para>The ST_Union array and set variants use the fast Cascaded Union algorithm described in <ulink
        url="http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html">http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html</ulink>
    </para>

    <para>A <code>gridSize</code> can be specified to work in fixed-precision space.
        The inputs are snapped to a grid of the given size, and the result vertices are computed
        on that same grid.
        (Requires GEOS-3.9.0 or higher)
    </para>

    <note><para><xref linkend="ST_Collect" /> may sometimes be used in place of ST_Union,
        if the result is not required to be non-overlapping.
        ST_Collect is usually faster than ST_Union because it performs no processing
        on the collected geometries.
        </para></note>

    <para>Performed by the GEOS module.</para>
    <para>NOTE: this function was formerly called GeomUnion(), which
        was renamed from "Union" because UNION is an SQL reserved
        word.</para>

    <para>Enhanced: 3.1.0 accept a gridSize parameter - requires GEOS &gt;= 3.9.0</para>
    <para>Changed: 3.0.0 does not depend on SFCGAL.</para>
    <para>Availability: 1.4.0 - ST_Union was enhanced. ST_Union(geomarray) was introduced and also faster aggregate collection in PostgreSQL.</para>

    <para>&sfs_compliant; s2.1.1.3</para>
    <note><para>Aggregate version is not explicitly defined in OGC SPEC.</para></note>
    <para>&sqlmm_compliant; SQL-MM 3: 5.1.19
        the z-index (elevation) when polygons are involved.</para>
    <para>&Z_support; However, the result is computed using XY only.
        The result Z values are copied, averaged or interpolated.</para>
      </refsection>

      <refsection>
        <title>Examples</title>
        <para>Aggregate example</para>
            <programlisting>
SELECT stusps,
       ST_Union(f.geom) as singlegeom
FROM sometable f
GROUP BY stusps
              </programlisting>
        <para>Non-Aggregate example</para>
            <programlisting>
select ST_AsText(ST_Union('POINT(1 2)' :: geometry, 'POINT(-2 3)' :: geometry))

st_astext
----------
MULTIPOINT(-2 3,1 2)

select ST_AsText(ST_Union('POINT(1 2)' :: geometry, 'POINT(1 2)' :: geometry))

st_astext
----------
POINT(1 2)</programlisting>
<para>3D example - sort of supports 3D (and with mixed dimensions!)</para>
<programlisting>select ST_AsEWKT(ST_Union(geom))
from (
         select 'POLYGON((-7 4.2,-7.1 4.2,-7.1 4.3, -7 4.2))'::geometry geom
         union all
         select 'POINT(5 5 5)'::geometry geom
         union all
         select 'POINT(-2 3 1)'::geometry geom
         union all
         select 'LINESTRING(5 5 5, 10 10 10)'::geometry geom
     ) as foo;

st_asewkt
---------
GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 4.2 5,-7.1 4.2 5,-7.1 4.3 5,-7 4.2 5)));
</programlisting>
<para>3d example not mixing dimensions</para>
<programlisting>select ST_AsEWKT(ST_Union(geom))
from (
         select 'POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2, -7 4.2 2))'::geometry geom
         union all
         select 'POINT(5 5 5)'::geometry geom
         union all
         select 'POINT(-2 3 1)'::geometry geom
         union all
         select 'LINESTRING(5 5 5, 10 10 10)'::geometry geom
     ) as foo;

st_asewkt
---------
GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2,-7 4.2 2)))

--Examples using new Array construct
SELECT ST_Union(ARRAY(SELECT the_geom FROM sometable));

SELECT ST_AsText(ST_Union(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 4)'),
            ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As wktunion;

--wktunion---
MULTILINESTRING((3 4,4 5),(1 2,3 4))

              </programlisting>
      </refsection>
      <refsection>
        <title>See Also</title>
        <para>
            <xref linkend="ST_Collect" />,
            <xref linkend="ST_UnaryUnion" />,
            <xref linkend="ST_Intersection" />,
            <xref linkend="ST_Difference" />,
            <xref linkend="ST_SymDifference" />
        </para>
      </refsection>
    </refentry>

    <refentry id="ST_UnaryUnion">
      <refnamediv>
        <refname>ST_UnaryUnion</refname>

        <refpurpose>Computes the union of the components of a single geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_UnaryUnion</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
            <paramdef choice="opt"><type>float8 </type> <parameter>gridSize = -1</parameter></paramdef>
          </funcprototype>

        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>
        A single-input variant of <xref linkend="ST_Union" />.
        The input may be a single geometry, a MultiGeometry, or a GeometryCollection.
        The union is applied to the individual components of the input.
        This allow using this function to fix MultiPolygons which  are
        invalid due to overlapping components.
        (However, the input components must each be valid.
        An invalid input component such as a bow-tie polygon may cause an error.)
        </para>

        <para>
        Another use of this function is to node and dissolve a collection of linestrings.
        (This can also be done with <xref linkend="ST_Node" />.)
        </para>

        <para>
        It is possible to mix ST_UnaryUnion with <xref linkend="ST_Collect" /> to fine-tune
        how many geometries are be unioned at once.
        This allows trading off between memory usage and compute time,
        striking a balance between ST_Union and <xref linkend="ST_MemUnion" />.
        </para>

        <para>
If the optional <code>gridSize</code> argument is provided, the inputs are
snapped to a grid of the given size, and the result vertices are computed
on that same grid. (Requires GEOS-3.9.0 or higher)
        </para>

        <para>&Z_support; However, the result is computed using XY only.
            The result Z values are copied, averaged or interpolated.</para>
        <para>Enhanced: 3.1.0 accept a gridSize parameter - requires GEOS &gt;= 3.9.0</para>
        <para>Availability: 2.0.0</para>

      </refsection>


      <!-- Optionally add a "See Also" section -->
      <refsection>
        <title>See Also</title>

        <para>
            <xref linkend="ST_Union" />,
            <xref linkend="ST_MemUnion" />,
            <xref linkend="ST_Collect" />,
            <xref linkend="ST_Node" />
        </para>
      </refsection>
    </refentry>


</sect1>
