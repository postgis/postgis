# SOME DESCRIPTIVE TITLE.
#
# Translators:
# TERAMOTO Ikuhiro <yellow@affrc.go.jp>, 2016
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2017-09-19 15:47+0000\n"
"PO-Revision-Date: 2016-02-15 12:29+0000\n"
"Last-Translator: Sandro Santilli <strk@kbt.io>\n"
"Language-Team: Japanese (http://www.transifex.com/postgis/postgis/language/"
"ja/)\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. Tag: title
#: using_postgis_dataman.xml:3
#, no-c-format
msgid "Using PostGIS: Data Management and Queries"
msgstr "PostGISを使う: データ管理とクエリ"

#. Tag: title
#: using_postgis_dataman.xml:6
#, no-c-format
msgid "GIS Objects"
msgstr "GISオブジェクト"

#. Tag: para
#: using_postgis_dataman.xml:8
#, no-c-format
msgid ""
"The GIS objects supported by PostGIS are a superset of the \"Simple Features"
"\" defined by the OpenGIS Consortium (OGC). As of version 0.9, PostGIS "
"supports all the objects and functions specified in the OGC \"Simple "
"Features for SQL\" specification."
msgstr ""
"PostGISでサポートされるGISオブジェクトは、OpenGIS Consortium (OGC)が定義する"
"\"Simple Features\" のスーパーセットです。 PostGIS 0.9版からOGCの\"Simple "
"Features for SQL\"仕様で定められた全てのオブジェクトと関数をサポートしていま"
"す。"

#. Tag: para
#: using_postgis_dataman.xml:13
#, no-c-format
msgid ""
"PostGIS extends the standard with support for 3DZ,3DM and 4D coordinates."
msgstr ""
"PostGISは標準から拡張して 3DZ, 3DM, 4D 座標 (訳注: それぞれXYZ, XYM, XYZM)を"
"サポートしています。"

#. Tag: title
#: using_postgis_dataman.xml:17
#, no-c-format
msgid "OpenGIS WKB and WKT"
msgstr "OpenGIS WKBとWKT"

#. Tag: para
#: using_postgis_dataman.xml:19
#, no-c-format
msgid ""
"The OpenGIS specification defines two standard ways of expressing spatial "
"objects: the Well-Known Text (WKT) form and the Well-Known Binary (WKB) "
"form. Both WKT and WKB include information about the type of the object and "
"the coordinates which form the object."
msgstr ""
"OpenGIS仕様は空間オブジェクトの表現について二つの標準を定義しています。Well-"
"Knownテキスト (WKT)形式とWell-Knownバイナリ (WKB)形式です。WKTもWKBも、オブ"
"ジェクトの型とオブジェクトを形成する座標に関する情報を持っています。"

#. Tag: para
#: using_postgis_dataman.xml:24
#, no-c-format
msgid ""
"Examples of the text representations (WKT) of the spatial objects of the "
"features are as follows:"
msgstr ""
"フィーチャーの空間オブジェクトのテキスト表現 (WKT)の例は、次の通りです。"

#. Tag: para
#: using_postgis_dataman.xml:29
#, no-c-format
msgid "POINT(0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:33
#, no-c-format
msgid "LINESTRING(0 0,1 1,1 2)"
msgstr "LINESTRING(0 0,1 1,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:37
#, no-c-format
msgid "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"
msgstr "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"

#. Tag: para
#: using_postgis_dataman.xml:41
#, no-c-format
msgid "MULTIPOINT((0 0),(1 2))"
msgstr "MULTIPOINT((0 0),(1 2))"

#. Tag: para
#: using_postgis_dataman.xml:45
#, no-c-format
msgid "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"
msgstr "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"

#. Tag: para
#: using_postgis_dataman.xml:49
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"
msgstr ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"

#. Tag: para
#: using_postgis_dataman.xml:54
#, no-c-format
msgid "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"
msgstr "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"

#. Tag: para
#: using_postgis_dataman.xml:58
#, no-c-format
msgid ""
"The OpenGIS specification also requires that the internal storage format of "
"spatial objects include a spatial referencing system identifier (SRID). The "
"SRID is required when creating spatial objects for insertion into the "
"database."
msgstr ""
"OpenGIS仕様では、空間オブジェクトの内部保存書式は空間参照系識別子 (Spatial "
"Referencing System IDentifier, SRID)を含むことも求められます。SRIDはデータ"
"ベースへの挿入のために空間オブジェクトが生成される時に求められます。"

#. Tag: para
#: using_postgis_dataman.xml:63 using_postgis_dataman.xml:151
#, no-c-format
msgid ""
"Input/Output of these formats are available using the following interfaces:"
msgstr "これらの書式の入出力は次のインタフェースを用いて実現できます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:66
#, no-c-format
msgid ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"
msgstr ""
"バイト配列 WKB = ST_AsBinary(geometry);\n"
"テキスト WKT = ST_AsText(geometry);\n"
"ジオメトリ = ST_GeomFromWKB (bytea WKB、SRID);\n"
"ジオメトリ = ST_GeometryFromText (テキスト WKT、SRID);"

#. Tag: para
#: using_postgis_dataman.xml:68
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert an OGC spatial "
"object would be:"
msgstr ""
"たとえば、OGC空間オブジェクトを生成して挿入する妥当なINSERTステートメントは次"
"の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:71
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"

#. Tag: title
#: using_postgis_dataman.xml:75
#, no-c-format
msgid "PostGIS EWKB, EWKT and Canonical Forms"
msgstr "PostGIS EWKB, EWKTと標準形式"

#. Tag: para
#: using_postgis_dataman.xml:77
#, no-c-format
msgid ""
"OGC formats only support 2d geometries, and the associated SRID is *never* "
"embedded in the input/output representations."
msgstr ""
"OGC書式は2次元ジオメトリしかサポートされておらず、また、入出力の表現において"
"SRID群は*決して*埋め込まれません。"

#. Tag: para
#: using_postgis_dataman.xml:80
#, no-c-format
msgid ""
"PostGIS extended formats are currently superset of OGC one (every valid WKB/"
"WKT is a valid EWKB/EWKT) but this might vary in the future, specifically if "
"OGC comes out with a new format conflicting with our extensions. Thus you "
"SHOULD NOT rely on this feature!"
msgstr ""
"PostGIS拡張書式は現在のところOGC書式のスーパーセットとなっています (全ての妥"
"当なWKB/WKTは妥当なEWKB/EWKTです)。しかし、特にもしOGCがPostGIS拡張と矛盾する"
"新しい書式を出すことがあるなら、これは将来変更されるかも知れません。ゆえにこ"
"の機能に頼るべきではありません。"

#. Tag: para
#: using_postgis_dataman.xml:85
#, no-c-format
msgid ""
"PostGIS EWKB/EWKT add 3dm,3dz,4d coordinates support and embedded SRID "
"information."
msgstr ""
"PostGIS EWKB/EWKT では 3dm, 3dz, 4d の座標サポートが追加され、SRID情報が埋め"
"込まれます。"

#. Tag: para
#: using_postgis_dataman.xml:88
#, fuzzy, no-c-format
msgid ""
"Examples of the text representations (EWKT) of the extended spatial objects "
"of the features are as follows."
msgstr ""
"フィーチャーの空間オブジェクトのテキスト表現 (WKT)の例は、次の通りです。"

#. Tag: para
#: using_postgis_dataman.xml:93
#, no-c-format
msgid "POINT(0 0 0) -- XYZ"
msgstr "POINT(0 0 0) -- XYZ"

#. Tag: para
#: using_postgis_dataman.xml:97
#, no-c-format
msgid "SRID=32632;POINT(0 0) -- XY with SRID"
msgstr "SRID=32632;POINT(0 0) -- SRID付きXY"

#. Tag: para
#: using_postgis_dataman.xml:101
#, no-c-format
msgid "POINTM(0 0 0) -- XYM"
msgstr "POINTM(0 0 0) -- XYM"

#. Tag: para
#: using_postgis_dataman.xml:105
#, no-c-format
msgid "POINT(0 0 0 0) -- XYZM"
msgstr "POINT(0 0 0 0) -- XYZM"

#. Tag: para
#: using_postgis_dataman.xml:109
#, no-c-format
msgid "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"
msgstr "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- SRID付きXYM"

#. Tag: para
#: using_postgis_dataman.xml:113
#, no-c-format
msgid "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"
msgstr "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"

#. Tag: para
#: using_postgis_dataman.xml:118
#, no-c-format
msgid ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"
msgstr ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"

#. Tag: para
#: using_postgis_dataman.xml:123
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"
msgstr ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"

#. Tag: para
#: using_postgis_dataman.xml:128
#, no-c-format
msgid "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"
msgstr "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"

#. Tag: para
#: using_postgis_dataman.xml:132
#, no-c-format
msgid "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"
msgstr "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"

#. Tag: para
#: using_postgis_dataman.xml:136
#, no-c-format
msgid ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"
msgstr ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"

#. Tag: para
#: using_postgis_dataman.xml:142
#, no-c-format
msgid "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"
msgstr "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"

#. Tag: para
#: using_postgis_dataman.xml:146
#, no-c-format
msgid "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"
msgstr "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"

#. Tag: programlisting
#: using_postgis_dataman.xml:154
#, no-c-format
msgid ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"
msgstr ""
"バイト配列 EWKB = ST_AsEWKB(geometry);\n"
"テキスト EWKT = ST_AsEWKT(geometry);\n"
"ジオメトリ = ST_GeomFromEWKB(bytea EWKB);\n"
"ジオメトリ = ST_GeomFromEWKT(text EWKT);"

#. Tag: para
#: using_postgis_dataman.xml:156
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert a PostGIS spatial "
"object would be:"
msgstr ""
"たとえば、PostGISの空間オブジェクトを作成し挿入する妥当なINSERTステートメント"
"は次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:159
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"

#. Tag: para
#: using_postgis_dataman.xml:161
#, no-c-format
msgid ""
"The \"canonical forms\" of a PostgreSQL type are the representations you get "
"with a simple query (without any function call) and the one which is "
"guaranteed to be accepted with a simple insert, update or copy. For the "
"postgis 'geometry' type these are:"
msgstr ""
"PostgreSQLの「標準的な形式」は単純なクエリ (全く関数呼び出しが無い)で表現でで"
"きていて、INSERT, UPDATE, COPYで受け付けられることが保障されるものです。"
"PostGISの\"geometory\"型の場合は次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:164
#, no-c-format
msgid ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"
msgstr ""
"- 出力\n"
"  - バイナリ: EWKB\n"
"        ascii: HEXEWKB (EWKBのHEX表現)\n"
"- 入力\n"
"  - バイナリ: EWKB\n"
"        ascii: HEXEWKB|EWKT"

#. Tag: para
#: using_postgis_dataman.xml:166
#, no-c-format
msgid ""
"For example this statement reads EWKT and returns HEXEWKB in the process of "
"canonical ascii input/output:"
msgstr ""
"たとえば、次のステートメントは、標準的なASCII文字列による入出力の処理でEWKTを"
"読み、HEXEWKBを返すものです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:169
#, no-c-format
msgid ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"
msgstr ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"

#. Tag: title
#: using_postgis_dataman.xml:172
#, no-c-format
msgid "SQL-MM Part 3"
msgstr "SQL-MM第3部"

#. Tag: para
#: using_postgis_dataman.xml:174
#, no-c-format
msgid ""
"The SQL Multimedia Applications Spatial specification extends the simple "
"features for SQL spec by defining a number of circularly interpolated curves."
msgstr ""
"SQLマルチメディア・アプリケーション空間仕様は、円弧補完曲線を定義したSQL仕様"
"の拡張です。"

#. Tag: para
#: using_postgis_dataman.xml:178
#, no-c-format
msgid ""
"The SQL-MM definitions include 3dm, 3dz and 4d coordinates, but do not allow "
"the embedding of SRID information."
msgstr ""
"TSQL-MMの定義では、3dm、3dzと4dの座標を含みますが、SRID情報の埋め込みはできま"
"せん。"

#. Tag: para
#: using_postgis_dataman.xml:181
#, no-c-format
msgid ""
"The well-known text extensions are not yet fully supported. Examples of some "
"simple curved geometries are shown below:"
msgstr ""
"WKT拡張はまだ完全にはサポートされていません。単純な曲線ジオメトリの例を次に示"
"します。"

#. Tag: para
#: using_postgis_dataman.xml:186
#, no-c-format
msgid "CIRCULARSTRING(0 0, 1 1, 1 0)"
msgstr "CIRCULARSTRING(0 0, 1 1, 1 0)"

#. Tag: para
#: using_postgis_dataman.xml:187
#, no-c-format
msgid "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"
msgstr "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"

#. Tag: para
#: using_postgis_dataman.xml:188
#, fuzzy, no-c-format
msgid ""
"The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the "
"linear world. A single segment required three points, the start and end "
"points (first and third) and any other point on the arc. The exception to "
"this is for a closed circle, where the start and end points are the same. In "
"this case the second point MUST be the center of the arc, ie the opposite "
"side of the circle. To chain arcs together, the last point of the previous "
"arc becomes the first point of the next arc, just like in LINESTRING. This "
"means that a valid circular string must have an odd number of points greater "
"than 1."
msgstr ""
"CIRCULARSTRINGは基本的な曲線型で、線型のLINESTRINGに似ています。一つのセグメ"
"ントで、始点、終点 (一つめと三つめ)と弧上の任意の点、の3点が必要です。例外と"
"して、始点と終点が同じとなる閉曲線があります。閉曲線では二つ目の点が弧の中"
"心、すなわち円の反対側にならなければなりません。弧の連結では、LINESTRINGと同"
"じように、前の弧の最後の点が次の弧の最初の点となります。よって、妥当な"
"CIRCULARSTRINGは1以上の奇数になります。"

#. Tag: para
#: using_postgis_dataman.xml:201
#, no-c-format
msgid "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"
msgstr "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"

#. Tag: para
#: using_postgis_dataman.xml:202
#, no-c-format
msgid ""
"A compound curve is a single, continuous curve that has both curved "
"(circular) segments and linear segments. That means that in addition to "
"having well-formed components, the end point of every component (except the "
"last) must be coincident with the start point of the following component."
msgstr ""
"複合曲線は、曲線 (円弧)セグメントと線型セグメントの両方を持つ、単一の連続した"
"曲線です。 よって、要素が的確である必要があることに加え、各要素 (最終要素は除"
"く)の終点は次の要素の始点と同じになる必要があります。"

#. Tag: para
#: using_postgis_dataman.xml:210
#, no-c-format
msgid ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"
msgstr ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"

#. Tag: para
#: using_postgis_dataman.xml:212
#, no-c-format
msgid ""
"Example compound curve in a curve polygon: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"
msgstr ""
"曲線ポリゴンの中に複合ポリゴンがある例は次の通りです。 "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"

#. Tag: para
#: using_postgis_dataman.xml:216
#, no-c-format
msgid ""
"A CURVEPOLYGON is just like a polygon, with an outer ring and zero or more "
"inner rings. The difference is that a ring can take the form of a circular "
"string, linear string or compound string."
msgstr ""
"CURVEPOLYGONは外環と0以上の内環とを持つ点でPOLYGONと似ています。 異なる点は、"
"環に曲線ストリング、線型ストリング、複合ストリングのいずれも取れる点です。"

#. Tag: para
#: using_postgis_dataman.xml:220
#, no-c-format
msgid "As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon."
msgstr ""
"PostGIS 1.4から、PostGISで曲線ポリゴンで複合曲線をサポートするようになりまし"
"た。"

#. Tag: para
#: using_postgis_dataman.xml:224
#, no-c-format
msgid "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"
msgstr "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"

#. Tag: para
#: using_postgis_dataman.xml:225
#, no-c-format
msgid ""
"The MULTICURVE is a collection of curves, which can include linear strings, "
"circular strings or compound strings."
msgstr ""
"MULTICURVEは曲線のコレクションで、線型ストリング、曲線ストリング、複合ストリ"
"ングを取れます。"

#. Tag: para
#: using_postgis_dataman.xml:230
#, no-c-format
msgid ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"
msgstr ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"

#. Tag: para
#: using_postgis_dataman.xml:233
#, no-c-format
msgid ""
"This is a collection of surfaces, which can be (linear) polygons or curve "
"polygons."
msgstr "サーフェスのコレクションです。(線型)ポリゴンか曲線ポリゴンを取れます。"

#. Tag: para
#: using_postgis_dataman.xml:239
#, no-c-format
msgid ""
"PostGIS prior to 1.4 does not support compound curves in a curve polygon, "
"but PostGIS 1.4 and above do support the use of Compound Curves in a Curve "
"Polygon."
msgstr ""
"PostGIS 1.4より前では、曲線ポリゴンで複合曲線をサポートしていませんでしたが、"
"PostGIS 1.4以降は曲線ポリゴンでの複合曲線に対応するようになりました。"

#. Tag: para
#: using_postgis_dataman.xml:245
#, no-c-format
msgid ""
"All floating point comparisons within the SQL-MM implementation are "
"performed to a specified tolerance, currently 1E-8."
msgstr ""
"SQL-MM実装での全ての浮動小数点数の比較では、所定の丸め誤差があります。現在は"
"1E-8です。"

#. Tag: title
#: using_postgis_dataman.xml:251
#, no-c-format
msgid "PostGIS Geography Type"
msgstr "PostGISジオグラフィ型"

#. Tag: para
#: using_postgis_dataman.xml:253
#, no-c-format
msgid ""
"The geography type provides native support for spatial features represented "
"on \"geographic\" coordinates (sometimes called \"geodetic\" coordinates, or "
"\"lat/lon\", or \"lon/lat\"). Geographic coordinates are spherical "
"coordinates expressed in angular units (degrees)."
msgstr ""
"ジオグラフィ型は、「地理」座標 (しばしば「測地」座標、\"lat/lon\"、\"lon/lat"
"\"、緯度経度, 経度緯度などとも呼ばれます)上で表現された空間フィーチャーのネイ"
"ティブサポートするためのものです。地理座標は角度の単位 (度)で表現される球面座"
"標です。"

#. Tag: para
#: using_postgis_dataman.xml:255
#, no-c-format
msgid ""
"The basis for the PostGIS geometry type is a plane. The shortest path "
"between two points on the plane is a straight line. That means calculations "
"on geometries (areas, distances, lengths, intersections, etc) can be "
"calculated using cartesian mathematics and straight line vectors."
msgstr ""
"PostGISジオメトリ型の基礎は平面です。平面上の二点間の最短コースは直線になりま"
"す。よって、ジオメトリ上の計算 (面積、距離、長さ、インタセクション等)は、デカ"
"ルト座標と線型ベクトルを使用することができます。"

#. Tag: para
#: using_postgis_dataman.xml:257
#, no-c-format
msgid ""
"The basis for the PostGIS geographic type is a sphere. The shortest path "
"between two points on the sphere is a great circle arc. That means that "
"calculations on geographies (areas, distances, lengths, intersections, etc) "
"must be calculated on the sphere, using more complicated mathematics. For "
"more accurate measurements, the calculations must take the actual spheroidal "
"shape of the world into account, and the mathematics becomes very "
"complicated indeed."
msgstr ""
"PostGISのジオグラフィ型の基礎は球面です。球面上での二点間の最短距離は大圏の弧"
"です。よって、ジオグラフィ上の計算 (面積、距離、長さ、インタセクション等)は、"
"球面上で計算しなければならず、複雑な計算が必要となります。より正確な計測のた"
"めには、世界の実際の回転楕円体の形を考慮に入れなければならず、非常に複雑で"
"す。"

#. Tag: para
#: using_postgis_dataman.xml:259
#, no-c-format
msgid ""
"Because the underlying mathematics is much more complicated, there are fewer "
"functions defined for the geography type than for the geometry type. Over "
"time, as new algorithms are added, the capabilities of the geography type "
"will expand."
msgstr ""
"基礎となる数学が大変に複雑なので、ジオグラフィ型用に定義された関数は、ジオメ"
"トリ型よりも少ないです。時間とともに、新しいアルゴリズムが追加されて、ジオグ"
"ラフィ型の能力は拡大していくでしょう。"

#. Tag: para
#: using_postgis_dataman.xml:262
#, no-c-format
msgid ""
"One restriction is that it only supports WGS 84 long lat (SRID:4326). It "
"uses a new data type called geography. None of the GEOS functions support "
"this new type. As a workaround one can convert back and forth between "
"geometry and geography types."
msgstr ""
"WGS84経度緯度 (SRID:4326)のみサポートしているという制限があります。GEOGRAPHY"
"と呼ばれる新しいデータ型を使用します。GEOS関数にこの新しい型をサポートする関"
"数がありません。回避策として、ジオメトリとジオグラフィの型変換を行うことがで"
"きます。"

#. Tag: para
#: using_postgis_dataman.xml:266
#, no-c-format
msgid ""
"The new geography type uses the PostgreSQL 8.3+ typmod definition format so "
"that a table with a geography field can be added in a single step. All the "
"standard OGC formats except for curves are supported."
msgstr ""
"ジオグラフィ型はPostgreSQL 8.3以上のtypmod定義書式を使います。ジオグラフィカ"
"ラムを持つテーブルに1ステップで追加できます。標準OGC書式は曲線を除いてサポー"
"トします。"

#. Tag: title
#: using_postgis_dataman.xml:270
#, no-c-format
msgid "Geography Basics"
msgstr "ジオグラフィ基礎"

#. Tag: para
#: using_postgis_dataman.xml:271
#, no-c-format
msgid ""
"The geography type only supports the simplest of simple features. Standard "
"geometry type data will autocast to geography if it is of SRID 4326. You can "
"also use the EWKT and EWKB conventions to insert data."
msgstr ""
"ジオグラフィ型はシンプルフィーチャーの最も簡単なもののみサポートします。標準"
"的なジオメトリ型データで、SRIDが4326の場合は、ジオグラフィに自動でキャストさ"
"れます。またEWKTとEWKBの取り決めを使うこともできます。"

#. Tag: para
#: using_postgis_dataman.xml:276
#, no-c-format
msgid "POINT: Creating a table with 2d point geometry:"
msgstr "POINT: 2次元のポイントジオメトリを持つテーブルの作成は次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:277
#, no-c-format
msgid ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:278
#, no-c-format
msgid "Creating a table with z coordinate point"
msgstr "Z値を持つポイントの場合は次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:279
#, no-c-format
msgid ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINTZ,4326) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINTZ,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:282
#, no-c-format
msgid "LINESTRING"
msgstr "LINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:285
#, no-c-format
msgid "POLYGON"
msgstr "POLYGON"

#. Tag: para
#: using_postgis_dataman.xml:288
#, no-c-format
msgid "MULTIPOINT"
msgstr "MULTIPOINT"

#. Tag: para
#: using_postgis_dataman.xml:291
#, no-c-format
msgid "MULTILINESTRING"
msgstr "MULTILINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:294
#, no-c-format
msgid "MULTIPOLYGON"
msgstr "MULTIPOLYGON"

#. Tag: para
#: using_postgis_dataman.xml:297
#, no-c-format
msgid "GEOMETRYCOLLECTION"
msgstr "GEOMETRYCOLLECTION"

#. Tag: para
#: using_postgis_dataman.xml:301
#, no-c-format
msgid ""
"The new geography fields don't get registered in the "
"<varname>geometry_columns</varname>. They get registered in a new view "
"called geography_columns which is a view against the system catalogs so is "
"always automatically kept up to date without need for an AddGeom... like "
"function."
msgstr ""
"新しいジオグラフィカラムは<varname>geometry_columns</varname>に登録されませ"
"ん。システムカタログを見るgeography_columnsという新しいビューに登録されるの"
"で、AddGeom... といった関数を使わずに、自動管理されます。"

#. Tag: para
#: using_postgis_dataman.xml:305
#, no-c-format
msgid ""
"Now, check the \"geography_columns\" view and see that your table is listed."
msgstr ""
"\"geography_columns\"ビューをチェックして、テーブルが一覧にあるか見て下さい。"

#. Tag: para
#: using_postgis_dataman.xml:307
#, no-c-format
msgid ""
"You can create a new table with a GEOGRAPHY column using the CREATE TABLE "
"syntax. Unlike GEOMETRY, there is no need to run a separate "
"AddGeometryColumns() process to register the column in metadata."
msgstr ""
"CREATE TABLEでジオグラフィカラムを持つテーブルを作ることができます。ジオメト"
"リと違って、AddGeometryColumns()でメタデータにカラム情報を登録する処理を別に"
"行う必要がなくなりました。"

#. Tag: programlisting
#: using_postgis_dataman.xml:311
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"
msgstr ""
"CREATE TABLE global_points ( \n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"

#. Tag: para
#: using_postgis_dataman.xml:314
#, no-c-format
msgid ""
"Note that the location column has type GEOGRAPHY and that geography type "
"supports two optional modifier: a type modifier that restricts the kind of "
"shapes and dimensions allowed in the column; an SRID modifier that restricts "
"the coordinate reference identifier to a particular number."
msgstr ""
"locationカラムはジオグラフィ型で、二つのオプション修飾子をサポートすることに"
"ご注意ください。一つは、そのカラムで使用できる形状と次元を限定する型修飾子で"
"す。もう一つは、座標参照IDを特定の数に限定するSRID修飾子です。"

#. Tag: para
#: using_postgis_dataman.xml:315
#, no-c-format
msgid ""
"Allowable values for the type modifier are: POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. The modifier also supports "
"dimensionality restrictions through suffixes: Z, M and ZM. So, for example a "
"modifier of 'LINESTRINGM' would only allow line strings with three "
"dimensions in, and would treat the third dimension as a measure. Similarly, "
"'POINTZM' would expect four dimensional data."
msgstr ""
"型修飾子として受け付ける値は、POINT, LINESTRING, POLYGON, MULTIPOINT, "
"MULTILINESTRING, MULTIPOLYGONです。型修飾子は、Z, M, ZMの後置子を付けることで"
"次元制限にも対応します。たとえば、'LINESTRINGM'という型修飾子で、三つ目の次元"
"をMとする3次元のラインストリングのみ受け付けることになります。同じよう"
"に'POINTZM'で、4次元データを期待します。"

#. Tag: para
#: using_postgis_dataman.xml:317
#, no-c-format
msgid ""
"The SRID modifier is currently of limited use: only 4326 (WGS84) is allowed "
"as a value. If you do not specify an SRID, the a value 0 (undefined "
"spheroid) will be used, and all calculations will proceed using WGS84 "
"anyways."
msgstr ""
"SRID修飾子には、現在は4326 (WGS84)のみ許されるという制限があります。SRIDを指"
"定したくない場合は0 (未定義の回転楕円体面)を使います。この場合の全ての計算"
"は、WGS84とします。"

#. Tag: para
#: using_postgis_dataman.xml:318
#, no-c-format
msgid ""
"In the future, alternate SRIDs will allow calculations on spheroids other "
"than WGS84."
msgstr ""
"将来的には、他のSRIDによって、WGS84以外の回転楕円体に関する計算ができるように"
"します。"

#. Tag: para
#: using_postgis_dataman.xml:319
#, no-c-format
msgid ""
"Once you have created your table, you can see it in the GEOGRAPHY_COLUMNS "
"table:"
msgstr ""
"テーブルを作ったら、次のようにしてGEOGRAPHY_COLUMNSを見ることができます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:320
#, no-c-format
msgid ""
"-- See the contents of the metadata view\n"
"SELECT * FROM geography_columns;"
msgstr ""
"-- メタデータビューの中身を見る\n"
"SELECT * FROM geography_columns;"

#. Tag: para
#: using_postgis_dataman.xml:322
#, no-c-format
msgid ""
"You can insert data into the table the same as you would if it was using a "
"GEOMETRY column:"
msgstr ""
"ジオメトリカラムを使うのと同じようにテーブルへのデータの挿入ができます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:324
#, no-c-format
msgid ""
"-- Add some data into the test table\n"
"INSERT INTO global_points (name, location) VALUES ('Town', "
"ST_GeographyFromText('SRID=4326;POINT(-110 30)') );\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', "
"ST_GeographyFromText('SRID=4326;POINT(-109 29)') );\n"
"INSERT INTO global_points (name, location) VALUES ('London', "
"ST_GeographyFromText('SRID=4326;POINT(0 49)') );"
msgstr ""
"-- testテーブルにデータを追加する\n"
"INSERT INTO global_points (name, location) VALUES ('Town', "
"ST_GeographyFromText('SRID=4326;POINT(-110 30)') );\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', "
"ST_GeographyFromText('SRID=4326;POINT(-109 29)') );\n"
"INSERT INTO global_points (name, location) VALUES ('London', "
"ST_GeographyFromText('SRID=4326;POINT(0 49)') );"

#. Tag: para
#: using_postgis_dataman.xml:326
#, no-c-format
msgid ""
"Creating an index works the same as GEOMETRY. PostGIS will note that the "
"column type is GEOGRAPHY and create an appropriate sphere-based index "
"instead of the usual planar index used for GEOMETRY."
msgstr ""
"ジオメトリと同じ操作でインデクスを作成します。PostGISは、カラム型がジオグラ"
"フィであるかを見て、ジオメトリで使われる平面用インデクスの代わりに球面ベース"
"のインデクスを作成します。"

#. Tag: programlisting
#: using_postgis_dataman.xml:329
#, no-c-format
msgid ""
"-- Index the test table with a spherical index\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"
msgstr ""
"-- testテーブルに球面インデクスを作成\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"

#. Tag: para
#: using_postgis_dataman.xml:332
#, no-c-format
msgid ""
"Query and measurement functions use units of meters. So distance parameters "
"should be expressed in meters, and return values should be expected in "
"meters (or square meters for areas)."
msgstr ""
"クエリと計測関数はメートル単位となります。そのため距離パラメータはメートル "
"(面積の場合は平方メートル)単位となります。"

#. Tag: programlisting
#: using_postgis_dataman.xml:334
#, no-c-format
msgid ""
"-- Show a distance query and note, London is outside the 1000km tolerance\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, "
"ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);"
msgstr ""
"-- 距離クエリの表示。ロンドンは1000km範囲外です\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, "
"ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);"

#. Tag: para
#: using_postgis_dataman.xml:337
#, no-c-format
msgid ""
"You can see the power of GEOGRAPHY in action by calculating the how close a "
"plane flying from Seattle to London (LINESTRING(-122.33 47.606, 0.0 51.5)) "
"comes to Reykjavik (POINT(-21.96 64.15))."
msgstr ""
"ジオグラフィの威力については、シアトルからロンドンまで (LINESTRING(-122.33 "
"47.606, 0.0 51.5))の飛行機がレイキャビク (POINT(-21.96 64.15))に最も近くなる"
"ときの距離を求めてみると分かります。"

#. Tag: programlisting
#: using_postgis_dataman.xml:339
#, no-c-format
msgid ""
"-- Distance calculation using GEOGRAPHY (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)':: geography);"
msgstr ""
"-- ジオグラフィを使った距離計算 (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)':: geography);"

#. Tag: programlisting
#: using_postgis_dataman.xml:342
#, no-c-format
msgid ""
"-- Distance calculation using GEOMETRY (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)':: geometry);"
msgstr ""
"-- ジオメトリを使った計算 (13.3 \"度\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)':: geometry);"

#. Tag: para
#: using_postgis_dataman.xml:345
#, no-c-format
msgid ""
"The GEOGRAPHY type calculates the true shortest distance over the sphere "
"between Reykjavik and the great circle flight path between Seattle and "
"London."
msgstr ""
"ジオグラフィ型は、レイキャビクとシアトル-ロンドン間の飛行機の大圏コースとの間"
"の、球面上での本当に最も近い距離を計算します。"

#. Tag: para
#: using_postgis_dataman.xml:347
#, no-c-format
msgid ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> The GEOMETRY type calculates a meaningless cartesian distance "
"between Reykjavik and the straight line path from Seattle to London plotted "
"on a flat map of the world. The nominal units of the result might be called "
"\"degrees\", but the result doesn't correspond to any true angular "
"difference between the points, so even calling them \"degrees\" is "
"inaccurate."
msgstr ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">大圏コースマップ</"
"ulink> ジオメトリ型は、平面の世界地図上にプロットされたレイキャビクとシアト"
"ル-ロンドン間の直線とのデカルト距離という意味のない値を出します。結果の名目上"
"の単位は「度」ですが、点間の本当の角度差にあっていませんので、「度」と言うこ"
"と自体不正確です。"

#. Tag: title
#: using_postgis_dataman.xml:351
#, no-c-format
msgid "When to use Geography Data type over Geometry data type"
msgstr "ジオグラフィ型をジオメトリ型にして使用すべき時"

#. Tag: para
#: using_postgis_dataman.xml:352
#, no-c-format
msgid ""
"The new GEOGRAPHY type allows you to store data in longitude/latitude "
"coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY "
"than there are on GEOMETRY; those functions that are defined take more CPU "
"time to execute."
msgstr ""
"ジオグラフィ型によって、経度緯度座標でデータを格納できるようになりましたが、"
"ジオグラフィで定義されている関数が、ジオメトリより少ないのと、実行にCPU時間が"
"かかる、というところが犠牲になっています。"

#. Tag: para
#: using_postgis_dataman.xml:353
#, no-c-format
msgid ""
"The type you choose should be conditioned on the expected working area of "
"the application you are building. Will your data span the globe or a large "
"continental area, or is it local to a state, county or municipality?"
msgstr ""
"選択した型が、期待する領域から出ないことを、ジオメトリ型にして使用する条件と"
"すべきです。使用するデータは地球全体か、大陸か、州か、自治体か?"

#. Tag: para
#: using_postgis_dataman.xml:355
#, no-c-format
msgid ""
"If your data is contained in a small area, you might find that choosing an "
"appropriate projection and using GEOMETRY is the best solution, in terms of "
"performance and functionality available."
msgstr ""
"データが小さいエリア内におさまるなら、適切な投影を選択してジオメトリを使うの"
"が、効率面でも機能面でも最も良い方法です。"

#. Tag: para
#: using_postgis_dataman.xml:356
#, no-c-format
msgid ""
"If your data is global or covers a continental region, you may find that "
"GEOGRAPHY allows you to build a system without having to worry about "
"projection details. You store your data in longitude/latitude, and use the "
"functions that have been defined on GEOGRAPHY."
msgstr ""
"データが地球全体か大陸なら、ジオグラフィで投影法の細かい問題を気にせずにシス"
"テムを構築できるでしょう。経度/緯度のデータを保存して、ジオグラフィで定義され"
"た関数使います。"

#. Tag: para
#: using_postgis_dataman.xml:358
#, no-c-format
msgid ""
"If you don't understand projections, and you don't want to learn about them, "
"and you're prepared to accept the limitations in functionality available in "
"GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. "
"Simply load your data up as longitude/latitude and go from there."
msgstr ""
"投影法を理解していなくて、学習したくもなくて、かつ、ジオグラフィで使える関数"
"が限られていることを受け入れるのなら、ジオグラフィを使った方が簡単です。単純"
"にデータを経度/緯度でロードして、そこから進めて下さい。"

#. Tag: para
#: using_postgis_dataman.xml:361
#, no-c-format
msgid ""
"Refer to <xref linkend=\"PostGIS_TypeFunctionMatrix\"/> for compare between "
"what is supported for Geography vs. Geometry. For a brief listing and "
"description of Geography functions, refer to <xref linkend="
"\"PostGIS_GeographyFunctions\"/>"
msgstr ""
"ジオグラフィとジオメトリ間のサポート状況の比較については<xref linkend="
"\"PostGIS_TypeFunctionMatrix\"/>をご覧下さい。ジオグラフィ関数の簡潔なリスト"
"と説明については<xref linkend=\"PostGIS_GeographyFunctions\"/>をご覧下さい。"

#. Tag: title
#: using_postgis_dataman.xml:367
#, no-c-format
msgid "Geography Advanced FAQ"
msgstr "ジオグラフィに関する高度なよくある質問"

#. Tag: para
#: using_postgis_dataman.xml:371
#, no-c-format
msgid "Do you calculate on the sphere or the spheroid?"
msgstr "球または回転楕円体のどちらで計算するのでしょうか?"

#. Tag: para
#: using_postgis_dataman.xml:375
#, no-c-format
msgid ""
"By default, all distance and area calculations are done on the spheroid. You "
"should find that the results of calculations in local areas match up will "
"with local planar results in good local projections. Over larger areas, the "
"spheroidal calculations will be more accurate than any calculation done on a "
"projected plane."
msgstr ""
"デフォルトでは、全ての距離と面積の計算は回転楕円体で行います。局所的なエリア"
"での計算結果と良好な投影を施した平面での結果と比較して下さい。大きなエリアの"
"場合は、回転楕円体計算は、投影平面上でのどの計算よりも精度が高くなります。"

#. Tag: para
#: using_postgis_dataman.xml:378
#, no-c-format
msgid ""
"All the geography functions have the option of using a sphere calculation, "
"by setting a final boolean parameter to 'FALSE'. This will somewhat speed up "
"calculations, particularly for cases where the geometries are very simple."
msgstr ""
"全てのジオグラフィ関数には、最後の真偽パラメータを'FALSE'にすると球面を使った"
"計算を行うというオプションがあります。これは、特にジオメトリが非常に単純であ"
"る場合に計算を速くするためのものです。"

#. Tag: para
#: using_postgis_dataman.xml:384
#, no-c-format
msgid "What about the date-line and the poles?"
msgstr "日付変更線や極に関してはどうなっていますか?"

#. Tag: para
#: using_postgis_dataman.xml:388
#, no-c-format
msgid ""
"All the calculations have no conception of date-line or poles, the "
"coordinates are spherical (longitude/latitude) so a shape that crosses the "
"dateline is, from a calculation point of view, no different from any other "
"shape."
msgstr ""
"全ての計算に日付変更線や極の概念がありません。座標は球 (経度/緯度)であるの"
"で、日付変更線とクロスする形状は、計算の観点からは、他のものと変わりありませ"
"ん。"

#. Tag: para
#: using_postgis_dataman.xml:396
#, no-c-format
msgid "What is the longest arc you can process?"
msgstr "処理できる最も長い弧はどうなりますか?"

#. Tag: para
#: using_postgis_dataman.xml:400
#, no-c-format
msgid ""
"We use great circle arcs as the \"interpolation line\" between two points. "
"That means any two points are actually joined up two ways, depending on "
"which direction you travel along the great circle. All our code assumes that "
"the points are joined by the *shorter* of the two paths along the great "
"circle. As a consequence, shapes that have arcs of more than 180 degrees "
"will not be correctly modelled."
msgstr ""
"大圏の弧を2点の「補完線」として使用しています。任意の2点は、実際には2方向につ"
"ながっていて、どちらの方向に行くかに依存します。PostGISの全てのコードは、大圏"
"コースの2コースのうち*短い*方でつながっていると仮定しています。結果として、"
"180度以上の弧を持つ形状は正しくモデル化されません。"

#. Tag: para
#: using_postgis_dataman.xml:407
#, no-c-format
msgid ""
"Why is it so slow to calculate the area of Europe / Russia / insert big "
"geographic region here ?"
msgstr ""
"なぜヨーロッパやロシアといった大きな範囲の面積計算はとても遅いのですか?"

#. Tag: para
#: using_postgis_dataman.xml:411
#, no-c-format
msgid ""
"Because the polygon is so darned huge! Big areas are bad for two reasons: "
"their bounds are huge, so the index tends to pull the feature no matter what "
"query you run; the number of vertices is huge, and tests (distance, "
"containment) have to traverse the vertex list at least once and sometimes N "
"times (with N being the number of vertices in the other candidate feature)."
msgstr ""
"ポリゴンがとんでもなく大きいからです。二つの理由から、大きなエリアは悪いで"
"す。一つは、バウンダリボックスが大きいため、どのようなクエリを走らせても、イ"
"ンデクスがフィーチャーを引っ張ってくる傾向にあるためです。もう一つは、頂点数"
"が巨大で、テスト (距離、包含)関数では、少なくとも1回、通常はN (Nは、もう一方"
"のフィーチャーの頂点数)回、頂点を横断しなければならないためです。"

#. Tag: para
#: using_postgis_dataman.xml:416
#, no-c-format
msgid ""
"As with GEOMETRY, we recommend that when you have very large polygons, but "
"are doing queries in small areas, you \"denormalize\" your geometric data "
"into smaller chunks so that the index can effectively subquery parts of the "
"object and so queries don't have to pull out the whole object every time. "
"Just because you *can* store all of Europe in one polygon doesn't mean you "
"*should*."
msgstr ""
"ジオメトリでは、大きなポリゴンを持っているけれども小さな範囲のクエリを実行す"
"る時、ジオメトリデータ情報を小片に「非正常化」します。これにより、インデクス"
"が効果的にオブジェクトの一部を問い合わせるようになり、またクエリが常にオブ"
"ジェクト全体を引っ張りこむようなことがないようになります。ヨーロッパ全体を一"
"つのポリゴンに*格納できる*からといって、*そうすべき*だというわけではありませ"
"ん。"

#. Tag: title
#: using_postgis_dataman.xml:425
#, no-c-format
msgid "Using OpenGIS Standards"
msgstr "OpenGIS標準を使う"

#. Tag: para
#: using_postgis_dataman.xml:427
#, no-c-format
msgid ""
"The OpenGIS \"Simple Features Specification for SQL\" defines standard GIS "
"object types, the functions required to manipulate them, and a set of meta-"
"data tables. In order to ensure that meta-data remain consistent, operations "
"such as creating and removing a spatial column are carried out through "
"special procedures defined by OpenGIS."
msgstr ""
"OpenGISの「SQL用シンプルフィーチャー仕様」では、標準GISオブジェクト型とこれら"
"を操作するために必要な関数、メタデータテーブルのセットが定義されています。メ"
"タデータが一貫性を維持していることを保証するために、空間カラムの生成、消去と"
"いった操作はOpenGISで定義されている空間プロシージャを通して実行されます。"

#. Tag: para
#: using_postgis_dataman.xml:433
#, no-c-format
msgid ""
"There are two OpenGIS meta-data tables: <varname>SPATIAL_REF_SYS</varname> "
"and <varname>GEOMETRY_COLUMNS</varname>. The <varname>SPATIAL_REF_SYS</"
"varname> table holds the numeric IDs and textual descriptions of coordinate "
"systems used in the spatial database."
msgstr ""
"OpenGISメタデータテーブルには<varname>SPATIAL_REF_SYS</varname>と"
"<varname>GEOMETRY_COLUMNS</varname>の二つがあります。"
"<varname>SPATIAL_REF_SYS</varname>テーブルは空間データベースで用いられる座標"
"系の、数字によるIDと文字による説明を持っています。"

#. Tag: title
#: using_postgis_dataman.xml:440
#, no-c-format
msgid "The SPATIAL_REF_SYS Table and Spatial Reference Systems"
msgstr "SPATIAL_REF_SYSテーブルと空間参照系"

#. Tag: para
#: using_postgis_dataman.xml:442
#, no-c-format
msgid ""
"The spatial_ref_sys table is a PostGIS included and OGC compliant database "
"table that lists over 3000 known <ulink url=\"http://www.sharpgis.net/"
"post/2007/05/Spatial-references2c-coordinate-systems2c-projections2c-"
"datums2c-ellipsoids-e28093-confusing.aspx\">spatial reference systems</"
"ulink> and details needed to transform/reproject between them."
msgstr ""
"spatial_ref_sysテーブルは、PostGISに含まれるもので、3000以上の<ulink url="
"\"http://www.sharpgis.net/post/2007/05/Spatial-references2c-coordinate-"
"systems2c-projections2c-datums2c-ellipsoids-e28093-confusing.aspx\">空間参照"
"系</ulink>と、座標変換/投影変換を行うのに必要な詳細情報との一覧を持つ、OGC準"
"拠のデータベーステーブルです。"

#. Tag: para
#: using_postgis_dataman.xml:446
#, no-c-format
msgid ""
"Although the PostGIS spatial_ref_sys table contains over 3000 of the more "
"commonly used spatial reference system definitions that can be handled by "
"the proj library, it does not contain all known to man and you can even "
"define your own custom projection if you are familiar with proj4 constructs. "
"Keep in mind that most spatial reference systems are regional and have no "
"meaning when used outside of the bounds they were intended for."
msgstr ""
"PostGISのspatial_ref_sysテーブルには、projライブラリで使われる3000以上の一般"
"に使われる空間参照系定義がありますが、全てを持っているわけではなく、projライ"
"ブラリの構築に慣れているならカスタム投影を定義することができます。ほとんどの"
"空間参照系は地域限定のもので、想定されている範囲の外で使うと意味が無いことに"
"注意して下さい。"

#. Tag: para
#: using_postgis_dataman.xml:449
#, no-c-format
msgid ""
"An excellent resource for finding spatial reference systems not defined in "
"the core set is <ulink url=\"http://spatialreference.org/\">http://"
"spatialreference.org/</ulink>"
msgstr ""
"PostGISのコアセットに入っていない空間参照系を探すための素晴らしい資料が"
"<ulink url=\"http://spatialreference.org/\">http://spatialreference.org/</"
"ulink>にあります。"

#. Tag: para
#: using_postgis_dataman.xml:451
#, no-c-format
msgid ""
"Some of the more commonly used spatial reference systems are: <ulink url="
"\"http://spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD "
"83 Long Lat</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/"
"\">3395 - WGS 84 World Mercator</ulink>, <ulink url=\"http://"
"spatialreference.org/ref/epsg/2163/\">2163 - US National Atlas Equal Area</"
"ulink>, Spatial reference systems for each NAD 83, WGS 84 UTM zone - UTM "
"zones are one of the most ideal for measurement, but only cover 6-degree "
"regions."
msgstr ""
"よく共通的に使われる空間参照系は次の通りです (訳注: 日本では状況が異なりま"
"す)。<ulink url=\"http://spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 "
"経度緯度</ulink>、<ulink url=\"http://spatialreference.org/ref/epsg/4269/"
"\">4269 - NAD 83 経度緯度</ulink>、<ulink url=\"http://spatialreference.org/"
"ref/epsg/3395/\">3395 - WGS 84 メルカトル図法</ulink>、<ulink url=\"http://"
"spatialreference.org/ref/epsg/2163/\">2163 - 米国ナショナルアトラス正積図法</"
"ulink>、NAD83とWGS84のUTM空間参照系 - UTMゾーンは計測に最も理想的なものの一つ"
"ですが6度 (訳注: 経度)の領域しかカバーしません。"

#. Tag: para
#: using_postgis_dataman.xml:457
#, no-c-format
msgid ""
"Various US state plane spatial reference systems (meter or feet based) - "
"usually one or 2 exists per US state. Most of the meter ones are in the core "
"set, but many of the feet based ones or ESRI created ones you will need to "
"pull from <ulink url=\"http://spatialreference.org\">spatialreference.org</"
"ulink>."
msgstr ""
"まざまな米国の州の平面空間参照系 (メートルまたはフィート単位) - 通常は州ごと"
"に一つか二つあります。メートル単位のもののほとんどがPostGISのコアセットに入っ"
"ていますが、多数のフィート単位のものやESRIが作ったものについては<ulink url="
"\"http://spatialreference.org\">spatialreference.org</ulink>から取得して下さ"
"い。"

#. Tag: para
#: using_postgis_dataman.xml:461
#, no-c-format
msgid ""
"For details on determining which UTM zone to use for your area of interest, "
"check out the <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
"UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper function</"
"ulink>."
msgstr ""
"対象領域がどのUTMゾーンになるかを決めるには、<ulink url=\"http://trac.osgeo."
"org/postgis/wiki/UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql "
"helper function</ulink>を参照して下さい。"

#. Tag: para
#: using_postgis_dataman.xml:465
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> table definition is as follows:"
msgstr "<varname>SPATIAL_REF_SYS</varname>テーブル定義は次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:468
#, no-c-format
msgid ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"
msgstr ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"

#. Tag: para
#: using_postgis_dataman.xml:470
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> columns are as follows:"
msgstr "<varname>SPATIAL_REF_SYS</varname>のカラムは次の通りです。"

#. Tag: ulink
#: using_postgis_dataman.xml:475
#, no-c-format
msgid "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"
msgstr "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:478
#, no-c-format
msgid ""
"An integer value that uniquely identifies the Spatial Referencing System "
"(SRS) within the database."
msgstr ""
"一意に定められた整数値で、データベースで空間参照系 (SRS)を識別するものです。"

#. Tag: term
#: using_postgis_dataman.xml:484
#, no-c-format
msgid "AUTH_NAME"
msgstr "AUTH_NAME"

#. Tag: para
#: using_postgis_dataman.xml:487
#, no-c-format
msgid ""
"The name of the standard or standards body that is being cited for this "
"reference system. For example, \"EPSG\" would be a valid <varname>AUTH_NAME</"
"varname>."
msgstr ""
"その参照系の引用元である標準の名前です。たとえば「EPSG」は妥当な"
"<varname>AUTH_NAME</varname>です。"

#. Tag: term
#: using_postgis_dataman.xml:494
#, no-c-format
msgid "AUTH_SRID"
msgstr "AUTH_SRID"

#. Tag: para
#: using_postgis_dataman.xml:497
#, no-c-format
msgid ""
"The ID of the Spatial Reference System as defined by the Authority cited in "
"the <varname>AUTH_NAME</varname>. In the case of EPSG, this is where the "
"EPSG projection code would go."
msgstr ""
"<varname>AUTH_NAME</varname>で引用される団体によって定義された空間参照系のID"
"です。EPSGの場合、EPSG投影コードが入ります。"

#. Tag: term
#: using_postgis_dataman.xml:504
#, no-c-format
msgid "SRTEXT"
msgstr "SRTEXT"

#. Tag: para
#: using_postgis_dataman.xml:507
#, no-c-format
msgid ""
"The Well-Known Text representation of the Spatial Reference System. An "
"example of a WKT SRS representation is:"
msgstr ""
"空間参照系のWell-Knownテキスト表現です。たとえば、WKT SRSの表現は、次のように"
"なります。"

#. Tag: programlisting
#: using_postgis_dataman.xml:510
#, no-c-format
msgid ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"
msgstr ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"

#. Tag: para
#: using_postgis_dataman.xml:512
#, no-c-format
msgid ""
"For a listing of EPSG projection codes and their corresponding WKT "
"representations, see <ulink url=\"http://www.opengeospatial.org/\">http://"
"www.opengeospatial.org/</ulink>. For a discussion of WKT in general, see the "
"OpenGIS \"Coordinate Transformation Services Implementation Specification\" "
"at <ulink url=\"http://www.opengeospatial.org/standards\">http://www."
"opengeospatial.org/standards</ulink>. For information on the European "
"Petroleum Survey Group (EPSG) and their database of spatial reference "
"systems, see <ulink url=\"http://www.epsg.org/\">http://www.epsg.org</ulink>."
msgstr ""
"EPSG投影コードと対応するWKT表現の一覧については、<ulink url=\"http://www."
"opengeospatial.org/\">http://www.opengeospatial.org/</ulink>をご覧下さい。WKT"
"の一般的な議論については、OpenGISの<ulink url=\"http://www.opengeospatial."
"org/standards\">http://www.opengeospatial.org/standards</ulink>にある「座標変"
"換サービス実装仕様」をご覧下さい。欧州石油調査グループ(European Petroleum "
"Survey Group, EPSG)とEPSG空間参照系のデータベースに関する情報は、<ulink url="
"\"http://www.epsg.org/\">http://www.epsg.org/</ulink>をご覧下さい。"

#. Tag: term
#: using_postgis_dataman.xml:525
#, no-c-format
msgid "PROJ4TEXT"
msgstr "PROJ4TEXT"

#. Tag: para
#: using_postgis_dataman.xml:528
#, no-c-format
msgid ""
"PostGIS uses the Proj4 library to provide coordinate transformation "
"capabilities. The <varname>PROJ4TEXT</varname> column contains the Proj4 "
"coordinate definition string for a particular SRID. For example:"
msgstr ""
"PostGISは座標変換機能を提供するためにProj4ライブラリを用いています。 "
"<varname>PROJ4TEXT</varname>カラムには、特定のSRIDを示すProj4座標定義文字列が"
"入ります。たとえば次のようになります。"

#. Tag: programlisting
#: using_postgis_dataman.xml:533
#, no-c-format
msgid "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"
msgstr "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"

#. Tag: para
#: using_postgis_dataman.xml:535
#, no-c-format
msgid ""
"For more information about, see the Proj4 web site at <ulink url=\"http://"
"trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. The "
"<filename>spatial_ref_sys.sql</filename> file contains both <varname>SRTEXT</"
"varname> and <varname>PROJ4TEXT</varname> definitions for all EPSG "
"projections."
msgstr ""
"詳細情報については、Proj4ウェブサイト<ulink url=\"http://trac.osgeo.org/proj/"
"\">http://trac.osgeo.org/proj/</ulink>をご覧下さい。"
"<filename>spatial_ref_sys.sql</filename>は、全てのEPSG投影法のための"
"<varname>SRTEXT</varname>と<varname>PROJ4TEXT</varname>とを持っています。"

#. Tag: title
#: using_postgis_dataman.xml:546
#, no-c-format
msgid "The GEOMETRY_COLUMNS VIEW"
msgstr "GEOMETRY_COLUMNSビュー"

#. Tag: para
#: using_postgis_dataman.xml:548
#, no-c-format
msgid ""
"In versions of PostGIS prior to 2.0.0, geometry_columns was a table that "
"could be directly edited, and sometimes got out of synch with the actual "
"definition of the geometry columns. In PostGIS 2.0.0, "
"<varname>GEOMETRY_COLUMNS</varname> became a view with the same front-facing "
"structure as prior versions, but reading from database system catalogs Its "
"structure is as follows:"
msgstr ""
"2.0.0より前のPostGISでは、geometry_columnsは直接編集可能なテーブルでした。"
"時々、実際のジオメトリカラムとの同期が取れていませんでした。PostGIS 2.0.0で"
"は、<varname>GEOMETRY_COLUMNS</varname>は、以前の版と同じ外見構造を持ちます"
"が、データベースシステムカタログから読むビューになりました。構造は次の通りで"
"す。"

#. Tag: programlisting
#: using_postgis_dataman.xml:552
#, no-c-format
msgid "\\d geometry_columns"
msgstr "\\d geometry_columns"

#. Tag: screen
#: using_postgis_dataman.xml:553
#, no-c-format
msgid ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"
msgstr ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"

#. Tag: para
#: using_postgis_dataman.xml:555
#, no-c-format
msgid "The column meanings have not changed from prior versions and are:"
msgstr "カラムは以前の版と変わりません。カラムについては次の通りです。"

#. Tag: term
#: using_postgis_dataman.xml:559
#, no-c-format
msgid "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"
msgstr "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"

#. Tag: para
#: using_postgis_dataman.xml:562
#, no-c-format
msgid ""
"The fully qualified name of the feature table containing the geometry "
"column. Note that the terms \"catalog\" and \"schema\" are Oracle-ish. There "
"is not PostgreSQL analogue of \"catalog\" so that column is left blank -- "
"for \"schema\" the PostgreSQL schema name is used (<varname>public</varname> "
"is the default)."
msgstr ""
"ジオメトリカラムを持つフィーチャーテーブルの完全修飾名。\"catalog\"および"
"\"schema\"の語はOracle風であることに注意して下さい。\"catalog\"に類似するもの"
"はPostgreSQLになく、このカラムは空白にされます。\"schema\"については"
"PostgreSQLスキーマ名が使われています (<varname>public</varname>がデフォルトで"
"す)。"

#. Tag: term
#: using_postgis_dataman.xml:571
#, no-c-format
msgid "F_GEOMETRY_COLUMN"
msgstr "F_GEOMETRY_COLUMN"

#. Tag: para
#: using_postgis_dataman.xml:574
#, no-c-format
msgid "The name of the geometry column in the feature table."
msgstr "フィーチャーテーブル内のジオメトリカラムの名前。"

#. Tag: term
#: using_postgis_dataman.xml:579
#, no-c-format
msgid "COORD_DIMENSION"
msgstr "COORD_DIMENSION"

#. Tag: para
#: using_postgis_dataman.xml:582
#, no-c-format
msgid "The spatial dimension (2, 3 or 4 dimensional) of the column."
msgstr "そのカラムの空間の次元 (2, 3 または 4)。"

#. Tag: term
#: using_postgis_dataman.xml:588
#, no-c-format
msgid "<term>SRID</term>"
msgstr "<term>SRID</term>"

#. Tag: para
#: using_postgis_dataman.xml:591
#, no-c-format
msgid ""
"The ID of the spatial reference system used for the coordinate geometry in "
"this table. It is a foreign key reference to the <varname>SPATIAL_REF_SYS</"
"varname>."
msgstr ""
"このテーブルの座標ジオメトリのために使われる空間参照系のID。"
"<varname>SPATIAL_REF_SYS</varname>への外部キーになっています。"

#. Tag: term
#: using_postgis_dataman.xml:598
#, no-c-format
msgid "TYPE"
msgstr "TYPE"

#. Tag: para
#: using_postgis_dataman.xml:601
#, no-c-format
msgid ""
"The type of the spatial object. To restrict the spatial column to a single "
"type, use one of: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, "
"MULTIPOLYGON, GEOMETRYCOLLECTION or corresponding XYM versions POINTM, "
"LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, "
"GEOMETRYCOLLECTIONM. For heterogeneous (mixed-type) collections, you can use "
"\"GEOMETRY\" as the type."
msgstr ""
"空間オブジェクトの型。空間カラムを単一型に制限するには、POINT、LINESTRING、"
"POLYGON、MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTIONのうち"
"のいずれかを、また、XYMで使う場合には、LINESTRINGM、POLYGONM、MULTIPOINTM、"
"MULTILINESTRINGM、MULTIPOLYGONM、GEOMETRYCOLLECTIONMのうちのいずれかを使いま"
"す。複数の型が混合するコレクションの場合は\"GEOMETRY\"を型とすることができま"
"す。"

#. Tag: para
#: using_postgis_dataman.xml:610
#, no-c-format
msgid ""
"This attribute is (probably) not part of the OpenGIS specification, but is "
"required for ensuring type homogeneity."
msgstr ""
"この属性は (おそらく)OpenGIS仕様に入っていませんが、型の同一性を保証するため"
"に必要です。"

#. Tag: title
#: using_postgis_dataman.xml:620
#, no-c-format
msgid "Creating a Spatial Table"
msgstr "空間テーブルを作る"

#. Tag: para
#: using_postgis_dataman.xml:622
#, no-c-format
msgid ""
"Creating a table with spatial data, can be done in one step. As shown in the "
"following example which creates a roads table with a 2D linestring geometry "
"column in WGS84 long lat"
msgstr ""
"空間データを持つテーブルの生成は、1段階でできます。2次元ラインストリングで"
"WGS84経度緯度のジオメトリカラムを持つroadsテーブルの生成の例を次に示します。"

#. Tag: programlisting
#: using_postgis_dataman.xml:624
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE ROADS ( ID int4\n"
"                , ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) );"
msgstr ""
"CREATE TABLE ROADS ( ID int4\n"
"                  , ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:626
#, no-c-format
msgid ""
"We can add additional columns using standard ALTER TABLE command as we do in "
"this next example where we add a 3-D linestring."
msgstr ""
"次の、3次元ラインストリングを追加する例で示す通り、標準的なALTER TABLEコマン"
"ドを使ってカラムを追加できます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:627
#, no-c-format
msgid "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"
msgstr "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"

#. Tag: para
#: using_postgis_dataman.xml:629
#, no-c-format
msgid ""
"For backwards compability, you can still create a spatial table in two "
"stages using the management functions."
msgstr ""
"後方互換のため、今でも、管理関数を使って空間テーブルを2段階で生成することもで"
"きます。"

#. Tag: para
#: using_postgis_dataman.xml:633
#, no-c-format
msgid "Create a normal non-spatial table."
msgstr "通常の非空間テーブルを生成します。"

#. Tag: para
#: using_postgis_dataman.xml:635
#, no-c-format
msgid ""
"For example: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME varchar(25) )</"
"command>"
msgstr ""
"例: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME varchar(25) )</command>"

#. Tag: para
#: using_postgis_dataman.xml:640
#, no-c-format
msgid ""
"Add a spatial column to the table using the OpenGIS \"AddGeometryColumn\" "
"function. Refer to <xref linkend=\"AddGeometryColumn\"/> for more details."
msgstr ""
"OpenGISの\"AddGeometryColumn\"関数によって空間カラムをテーブルに追加します。"
"詳細情報については<xref linkend=\"AddGeometryColumn\"/>を参照して下さい。"

#. Tag: para
#: using_postgis_dataman.xml:643
#, no-c-format
msgid ""
"The syntax is: <programlisting>AddGeometryColumn(\n"
"  &lt;schema_name&gt;,\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")</programlisting> Or, using current schema:"
msgstr ""
"文法は次の通りです。<programlisting>AddGeometryColumn(\n"
"  &lt;schema_name&gt;,\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")</programlisting>現在のスキーマを使う場合には次のようにします。"

#. Tag: programlisting
#: using_postgis_dataman.xml:643
#, no-c-format
msgid ""
"AddGeometryColumn(\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")"
msgstr ""
"AddGeometryColumn(\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")"

#. Tag: para
#: using_postgis_dataman.xml:645
#, no-c-format
msgid ""
"Example1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"
msgstr ""
"例1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"

#. Tag: para
#: using_postgis_dataman.xml:648
#, no-c-format
msgid ""
"Example2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"
msgstr ""
"例2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, 'LINESTRING', "
"2)</command>"

#. Tag: para
#: using_postgis_dataman.xml:653
#, no-c-format
msgid ""
"Here is an example of SQL used to create a table and add a spatial column "
"(assuming that an SRID of 128 exists already):"
msgstr ""
"次はテーブルを作成して空間カラムを作る例です (128というSRIDがあると仮定しま"
"す)。"

#. Tag: programlisting
#: using_postgis_dataman.xml:656
#, no-c-format
msgid ""
"CREATE TABLE parks (\n"
"  park_id    INTEGER,\n"
"  park_name  VARCHAR,\n"
"  park_date  DATE,\n"
"  park_type  VARCHAR\n"
");\n"
"SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"
msgstr ""
"CREATE TABLE parks (\n"
"  park_id    INTEGER,\n"
"  park_name  VARCHAR,\n"
"  park_date  DATE,\n"
"  park_type  VARCHAR\n"
");\n"
"SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"

#. Tag: para
#: using_postgis_dataman.xml:658
#, no-c-format
msgid ""
"Here is another example, using the generic \"geometry\" type and the "
"undefined SRID value of 0:"
msgstr ""
"もう一つ、ジェネリックな\"geometry\"型とSRID不明を示す0を使った例を挙げます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:661
#, no-c-format
msgid ""
"CREATE TABLE roads (\n"
"  road_id INTEGER,\n"
"  road_name VARCHAR\n"
");\n"
"SELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"
msgstr ""
"CREATE TABLE roads (\n"
"  road_id INTEGER,\n"
"  road_name VARCHAR\n"
");\n"
"SELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"

#. Tag: title
#: using_postgis_dataman.xml:665
#, no-c-format
msgid "Manually Registering Geometry Columns in geometry_columns"
msgstr "手動でジオメトリカラムをgeometry_columnsに登録する"

#. Tag: para
#: using_postgis_dataman.xml:666
#, fuzzy, no-c-format
msgid ""
"The AddGeometryColumn() approach creates a geometry column of specified "
"type. This type and dimension are queryable from the "
"<varname>geometry_columns</varname> view. Starting with PostGIS 2.0, "
"geometry_columns is no longer editable and all geometry columns are "
"autoregistered."
msgstr ""
"AddGeometryColumn()アプローチでは、ジオメトリカラムを作成して、新しいカラムを"
"geometry_columnsテーブルに登録します。ソフトウェアでgeometry_columnsを使う場"
"合には、クエリに必要なジオメトリカラムの全てがこのビューに登録されている必要"
"があります。PostGIS 2.0からは、geometry_columnsは編集可能でなく、全てのジオメ"
"トリカラムは自動登録されます。"

#. Tag: para
#: using_postgis_dataman.xml:669
#, no-c-format
msgid ""
"If your geometry columns were created as generic in a table or view and no "
"constraints applied, they will not have a dimension, type or srid in "
"geometry_columns views, but will still be listed."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:671
#, fuzzy, no-c-format
msgid ""
"Two of the cases where this may happen, but you can't use AddGeometryColumn, "
"is in the case of SQL Views and bulk inserts. For bulk insert case, you can "
"correct the registration in the geometry_columns table by constraining the "
"column or doing an alter table. For views, you could expose using a CAST "
"operation. Note in PostGIS 2.0+ if your column is typmod based, the creation "
"process would register it correctly, so no need to do anything. Also views "
"that have no spatial function applied to the geometry will register the same "
"as the underlying table geometry column."
msgstr ""
"こういうことが発生してAddGeometryColumnが使えなくなる事例に、SQLビューとバル"
"クインサートの二つがあります。これらの場合には、カラムに制約を与えることで、"
"geometry_columnsテーブル内の登録を訂正することができます。 PostGIS 2.0以上で"
"は、カラムが型修飾に基づく場合には、生成処理によって正しく登録されるので、何"
"も行う必要がありません。"

#. Tag: programlisting
#: using_postgis_dataman.xml:678
#, fuzzy, no-c-format
msgid ""
"--Lets say you have a view created like this\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- For it to register correctly in PostGIS 2.0+\n"
"-- You need to cast the geometry\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- If you know the geometry type for sure is a 2D POLYGON then you could do\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"
msgstr ""
"-- 次のようなビューがあるとします\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"        \n"
"-- PostGIS 2.0以上で正しく登録するには、\n"
"-- ジオメトリをキャストします。\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"        \n"
"-- ジオメトリタイプが確実に2次元ポリゴンだと知っているなら\n"
"-- 次のようにできます。\n"
"-- If you know the geometry type for sure is a 2D POLYGON then you could do\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"

#. Tag: programlisting
#: using_postgis_dataman.xml:679
#, fuzzy, no-c-format
msgid ""
"--Lets say you created a derivative table by doing a bulk insert\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"--Create 2d index on new table\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"\n"
"-- If your points are 3D points or 3M points,\n"
"-- then you might want to create an nd index instead of a 2d index\n"
"-- like so\n"
"CREATE INDEX my_special_pois_geom_gist_nd\n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"--To manually register this new table's geometry column in geometry_columns\n"
"-- Note that this approach will work for both PostGIS 2.0+ and PostGIS 1.4+\n"
"-- For PostGIS 2.0 it will also change the underlying structure of the table "
"to\n"
"-- to make the column typmod based.\n"
"-- For PostGIS prior to 2.0, this technique can also be used to register "
"views\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n"
"\n"
"--If you are using PostGIS 2.0 and for whatever reason, you\n"
"-- you need the old constraint based definition behavior\n"
"-- (such as case of inherited tables where all children do not have the same "
"type and srid)\n"
"-- set new optional  use_typmod argument to false\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"
msgstr ""
"-- 次のように、バルクインサートで派生テーブルを生成したとしましょう\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"-- 新しいテーブルに2次元インデクスを作ります\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"  \n"
"-- ポイントが3次元ポイントであったり、XYMポイントであったりした場合には、\n"
"-- 次のように、2次元インデクスでなくN次元インデクスを作るかも知れません。\n"
"CREATE INDEX my_special_pois_geom_gist_nd \n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"-- 新しいテーブルのジオメトリカラムをgeometry_columnsに手動登録するには、\n"
"-- 次のようにします。\n"
"-- この手法はPostGIS 2.0以上でもPostGIS 1.4以上でも動くことに注意して下さ"
"い。\n"
"-- PostGIS 2.0では、基のテーブル構造について\n"
"-- 型修飾子に基づくカラムになるように変更します。\n"
"-- PostGIS 2.0より前では、この技術はビューの登録にも使います。\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass); \n"
"\n"
"-- PostGIS 2.0を使っていて、何らかの理由で古い制約をもとにした定義を行う\n"
"-- (派生テーブルが同じタイプやSRIDを持たないといった場合)ことが必要な場合に"
"は、\n"
"-- 新しいオプション引数use_typemodをfalseにします。\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"

#. Tag: para
#: using_postgis_dataman.xml:681
#, fuzzy, no-c-format
msgid ""
"Although the old-constraint based method is still supported, a constraint-"
"based geometry column used directly in a view, will not register correctly "
"in geometry_columns, as will a typmod one. In this example we define a "
"column using typmod and another using constraints."
msgstr ""
"古い制約を基にした手法は現在も対応していますが、制約を基にしたジオメトリカラ"
"ムで直接的にビューで使われている場合は、型修飾子のようには正しく"
"geometry_columnsに登録されません。次の例では、型修飾子を使ったカラム定義と、"
"制約に基づくカラムの定義とを行っています。"

#. Tag: programlisting
#: using_postgis_dataman.xml:684
#, no-c-format
msgid ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY\n"
"   , poi_name text, cat varchar(20)\n"
"   , geom geometry(POINT,4326) );\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"
msgstr ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY\n"
"   , poi_name text, cat varchar(20)\n"
"   , geom geometry(POINT,4326) );\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"

#. Tag: para
#: using_postgis_dataman.xml:685
#, no-c-format
msgid "If we run in psql"
msgstr "psqlで次を実行します。"

#. Tag: programlisting
#: using_postgis_dataman.xml:686
#, no-c-format
msgid "\\d pois_ny;"
msgstr "\\d pois_ny;"

#. Tag: para
#: using_postgis_dataman.xml:687
#, no-c-format
msgid ""
"We observe they are defined differently -- one is typmod, one is constraint"
msgstr "型修飾子と制約に基づくのとでは異なった定義になっているのが見えます。"

#. Tag: screen
#: using_postgis_dataman.xml:688
#, fuzzy, no-c-format
msgid ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"
msgstr ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text \n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"

#. Tag: para
#: using_postgis_dataman.xml:689
#, no-c-format
msgid "In geometry_columns, they both register correctly"
msgstr "geometry_columnsでは、両方とも正しく登録されています。"

#. Tag: programlisting
#: using_postgis_dataman.xml:690
#, fuzzy, no-c-format
msgid ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"
msgstr ""
"SELECT f_table_name, f_geometry_column, srid, type \n"
"        FROM geometry_columns \n"
"        WHERE f_table_name = 'pois_ny';"

#. Tag: screen
#: using_postgis_dataman.xml:691
#, no-c-format
msgid ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"

#. Tag: para
#: using_postgis_dataman.xml:692
#, no-c-format
msgid "However -- if we were to create a view like this"
msgstr "しかし、次のようにビューを作ろうとします。"

#. Tag: programlisting
#: using_postgis_dataman.xml:693
#, fuzzy, no-c-format
msgid ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"CREATE VIEW vw_pois_ny_parks AS \n"
"SELECT * \n"
"  FROM pois_ny \n"
"  WHERE cat='park';\n"
"  \n"
"SELECT f_table_name, f_geometry_column, srid, type \n"
"        FROM geometry_columns \n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: para
#: using_postgis_dataman.xml:694
#, no-c-format
msgid ""
"The typmod based geom view column registers correctly, but the constraint "
"based one does not."
msgstr ""
"型修飾子によるgeomのビューカラムは正しく登録されますが、制約に基づくものは正"
"しく登録されません。"

#. Tag: screen
#: using_postgis_dataman.xml:696
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"
msgstr ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"

#. Tag: para
#: using_postgis_dataman.xml:698
#, no-c-format
msgid ""
"This may change in future versions of PostGIS, but for now To force the "
"constraint based view column to register correctly, we need to do this:"
msgstr ""
"これは、将来的にPostGISの版で変更されるかもしれませんが、今のところは、制約に"
"基づくビューカラムを正しく登録させるには、次のようにします。"

#. Tag: programlisting
#: using_postgis_dataman.xml:700
#, fuzzy, no-c-format
msgid ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT gid, poi_name, cat\n"
"  , geom\n"
"  , geom_2160::geometry(POINT,2160) As geom_2160\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS \n"
"SELECT gid, poi_name, cat\n"
"  , geom\n"
"  , geom_2160::geometry(POINT,2160) As geom_2160 \n"
"  FROM pois_ny \n"
"  WHERE cat='park';\n"
"SELECT f_table_name, f_geometry_column, srid, type \n"
"        FROM geometry_columns \n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: screen
#: using_postgis_dataman.xml:701
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"

#. Tag: title
#: using_postgis_dataman.xml:705
#, no-c-format
msgid "Ensuring OpenGIS compliancy of geometries"
msgstr "ジオメトリのOpenGIS準拠を確実にする"

#. Tag: para
#: using_postgis_dataman.xml:707
#, no-c-format
msgid ""
"PostGIS is compliant with the Open Geospatial Consortium’s (OGC) OpenGIS "
"Specifications. As such, many PostGIS methods require, or more accurately, "
"assume that geometries that are operated on are both simple and valid. For "
"example, it does not make sense to calculate the area of a polygon that has "
"a hole defined outside of the polygon, or to construct a polygon from a non-"
"simple boundary line."
msgstr ""
"PostGISはOpen Geospatial Consortium (OGC)のOpenGIS仕様に準拠しています。多く"
"のPostGISメソッドは、操作対象のジオメトリが単純かつ妥当であることが求められま"
"す (正確に言うとそう仮定します)。たとえば、ポリゴンの外に穴があるようなものの"
"面積を計算したり、単純でない境界線を持つポリゴンを作ったりするのは、意味があ"
"りません。"

#. Tag: para
#: using_postgis_dataman.xml:714
#, no-c-format
msgid ""
"According to the OGC Specifications, a <emphasis>simple</emphasis> geometry "
"is one that has no anomalous geometric points, such as self intersection or "
"self tangency and primarily refers to 0 or 1-dimensional geometries (i.e. "
"<varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). Geometry validity, on "
"the other hand, primarily refers to 2-dimensional geometries (i.e. "
"<varname>[MULTI]POLYGON)</varname> and defines the set of assertions that "
"characterizes a valid polygon. The description of each geometric class "
"includes specific conditions that further detail geometric simplicity and "
"validity."
msgstr ""
"OGS仕様に沿うと、<emphasis>単純な</emphasis>ジオメトリとは、自己インタセクト"
"や自己接触のような、異常な幾何点を持たないことです。主に0次元または1次元のジ"
"オメトリ (<varname>[MULTI]POINT, [MULTI]LINESTRING</varname>))に適用します。 "
"他方、ジオメトリの妥当性は、主に2次元ジオメトリ (<varname>[MULTI]POLYGON</"
"varname>)に適用し、妥当なポリゴンを特徴づける位置指定子の集合を定義します。"
"個々のジオメトリクラスには、単純性と妥当性をさらに詳細に述べる特定の条件があ"
"ります。"

#. Tag: para
#: using_postgis_dataman.xml:724
#, no-c-format
msgid ""
"A <varname>POINT</varname> is inheritably <emphasis>simple</emphasis> as a 0-"
"dimensional geometry object."
msgstr ""
"<varname>POINT</varname>は0次元ジオメトリオブジェクトとして常に<emphasis>単純"
"</emphasis>です。"

#. Tag: para
#: using_postgis_dataman.xml:727
#, no-c-format
msgid ""
"<varname>MULTIPOINT</varname>s are <emphasis>simple</emphasis> if no two "
"coordinates (<varname>POINT</varname>s) are equal (have identical coordinate "
"values)."
msgstr ""
"<varname>MULTIPOINT</varname>は、二つの座標値 (<varname>POINT</varname>)が同"
"じでないなら<emphasis>単純</emphasis>です。"

#. Tag: para
#: using_postgis_dataman.xml:731
#, no-c-format
msgid ""
"A <varname>LINESTRING</varname> is <emphasis>simple</emphasis> if it does "
"not pass through the same <varname>POINT</varname> twice (except for the "
"endpoints, in which case it is referred to as a linear ring and additionally "
"considered closed)."
msgstr ""
"<varname>LINESTRING</varname>は、2度同じ<varname>POINT</varname>を通らない "
"(終点は除きます。この場合は線型環と呼ばれ、さらに言うと閉じていると思われま"
"す)なら<emphasis>単純</emphasis>です。"

#. Tag: emphasis
#: using_postgis_dataman.xml:746
#, no-c-format
msgid "<emphasis>(a)</emphasis>"
msgstr "<emphasis>(a)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:756
#, no-c-format
msgid "<emphasis>(b)</emphasis>"
msgstr "<emphasis>(b)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:768
#, no-c-format
msgid "<emphasis>(c)</emphasis>"
msgstr "<emphasis>(c)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:778
#, no-c-format
msgid "<emphasis>(d)</emphasis>"
msgstr "<emphasis>(d)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:788
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(a)</emphasis> and <emphasis role=\"bold\">(c)</"
"emphasis> are simple <varname>LINESTRING</varname>s, <emphasis role=\"bold"
"\">(b)</emphasis> and <emphasis role=\"bold\">(d)</emphasis> are not."
msgstr ""
"<emphasis role=\"bold\">(a)</emphasis>と<emphasis role=\"bold\">(c)</"
"emphasis>は単純な<varname>LINESTRING</varname>です。<emphasis role=\"bold"
"\">(b)</emphasis>と<emphasis role=\"bold\">(d)</emphasis>は単純ではありませ"
"ん。"

#. Tag: para
#: using_postgis_dataman.xml:797
#, no-c-format
msgid ""
"A <varname>MULTILINESTRING</varname> is <emphasis>simple</emphasis> only if "
"all of its elements are simple and the only intersection between any two "
"elements occurs at <varname>POINT</varname>s that are on the boundaries of "
"both elements."
msgstr ""
"<varname>MULTILINESTRING</varname>は、 全ての要素が単純で、かつ任意の2要素の"
"インタセクトが要素の境界である<varname>POINT</varname>でだけ発生する場合に"
"限って<emphasis>単純</emphasis>です。"

#. Tag: emphasis
#: using_postgis_dataman.xml:812
#, no-c-format
msgid "<emphasis>(e)</emphasis>"
msgstr "<emphasis>(e)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:822
#, no-c-format
msgid "<emphasis>(f)</emphasis>"
msgstr "<emphasis>(f)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:832
#, no-c-format
msgid "<emphasis>(g)</emphasis>"
msgstr "<emphasis>(g)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:842
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(e)</emphasis> and <emphasis role=\"bold\">(f)</"
"emphasis> are simple <varname>MULTILINESTRING</varname>s, <emphasis role="
"\"bold\">(g)</emphasis> is not."
msgstr ""
"<emphasis role=\"bold\">(e)</emphasis>と<emphasis role=\"bold\">(f)</"
"emphasis>は単純な<varname>MULTILINESTRING</varname>です。<emphasis role="
"\"bold\">(g)</emphasis>は単純ではありません。"

#. Tag: para
#: using_postgis_dataman.xml:851
#, no-c-format
msgid ""
"By definition, a <varname>POLYGON</varname> is always <emphasis>simple</"
"emphasis>. It is <emphasis>valid</emphasis> if no two rings in the boundary "
"(made up of an exterior ring and interior rings) cross. The boundary of a "
"<varname>POLYGON</varname> may intersect at a <varname>POINT</varname> but "
"only as a tangent (i.e. not on a line). A <varname>POLYGON</varname> may not "
"have cut lines or spikes and the interior rings must be contained entirely "
"within the exterior ring."
msgstr ""
"定義から<varname>POLYGON</varname>は常に単純です。バウンダリ内の環 (外環と内"
"環からなる)のうち二つがクロスしていないなら<emphasis>妥当</emphasis>です。"
"<varname>POLYGON</varname>の境界は、<varname>POINT</varname>とインタセクトす"
"るかも知れませんが、接点にしかなりません (すなわち線上にない)。"
"<varname>POLYGON</varname>はカットラインまたはスパイクを持たなくても良く、内"
"環は外環の中に完全に含まれていなければなりません。"

#. Tag: emphasis
#: using_postgis_dataman.xml:869
#, no-c-format
msgid "<emphasis>(h)</emphasis>"
msgstr "<emphasis>(h)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:879
#, no-c-format
msgid "<emphasis>(i)</emphasis>"
msgstr "<emphasis>(i)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:889
#, no-c-format
msgid "<emphasis>(j)</emphasis>"
msgstr "<emphasis>(j)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:901
#, no-c-format
msgid "<emphasis>(k)</emphasis>"
msgstr "<emphasis>(k)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:911
#, no-c-format
msgid "<emphasis>(l)</emphasis>"
msgstr "<emphasis>(l)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:921
#, no-c-format
msgid "<emphasis>(m)</emphasis>"
msgstr "<emphasis>(m)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:930
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(h)</emphasis> and <emphasis role=\"bold\">(i)</"
"emphasis> are valid <varname>POLYGON</varname>s, <emphasis role=\"bold\">(j-"
"m)</emphasis> cannot be represented as single <varname>POLYGON</varname>s, "
"but <emphasis role=\"bold\">(j)</emphasis> and <emphasis role=\"bold\">(m)</"
"emphasis> could be represented as a valid <varname>MULTIPOLYGON</varname>."
msgstr ""
"<emphasis role=\"bold\">(h)</emphasis>と<emphasis role=\"bold\">(i)</"
"emphasis>は妥当な<varname>POLYGON</varname>です。<emphasis role=\"bold\">(jか"
"らm)</emphasis>は単一の<varname>POLYGON</varname>としては表現できませんが、"
"<emphasis role=\"bold\">(j)</emphasis>と<emphasis role=\"bold\">(m)</"
"emphasis>は妥当な<varname>MULTIPOLYGON</varname>として表現できます。"

#. Tag: para
#: using_postgis_dataman.xml:942
#, no-c-format
msgid ""
"A <varname>MULTIPOLYGON</varname> is <emphasis>valid</emphasis> if and only "
"if all of its elements are valid and the interiors of no two elements "
"intersect. The boundaries of any two elements may touch, but only at a "
"finite number of <varname>POINT</varname>s."
msgstr ""
"<varname>MULTIPOLYGON</varname>は、全ての要素が妥当で、二つのポリゴン要素につ"
"いて内側がインタセクトしていない場合は<emphasis>妥当</emphasis>です。ポリゴン"
"要素の任意の二つの境界は接触してもよいですが、有限な数の<varname>POINT</"
"varname>でなければなりません。"

#. Tag: emphasis
#: using_postgis_dataman.xml:957
#, no-c-format
msgid "<emphasis>(n)</emphasis>"
msgstr "<emphasis>(n)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:967
#, no-c-format
msgid "<emphasis>(o)</emphasis>"
msgstr "<emphasis>(o)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:977
#, no-c-format
msgid "<emphasis>(p)</emphasis>"
msgstr "<emphasis>(p)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:986
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(n)</emphasis> and <emphasis role=\"bold\">(o)</"
"emphasis> are not valid <varname>MULTIPOLYGON</varname>s. <emphasis role="
"\"bold\">(p)</emphasis>, however, is valid."
msgstr ""
"<emphasis role=\"bold\">(n)</emphasis>と<emphasis role=\"bold\">(o)</"
"emphasis>は妥当でない<varname>MULTIPOLYGON</varname>です。<emphasis role="
"\"bold\">(p)</emphasis>は妥当です。"

#. Tag: para
#: using_postgis_dataman.xml:995
#, no-c-format
msgid ""
"Most of the functions implemented by the GEOS library rely on the assumption "
"that your geometries are valid as specified by the OpenGIS Simple Feature "
"Specification. To check simplicity or validity of geometries you can use the "
"<link linkend=\"ST_IsSimple\">ST_IsSimple()</link> and <link linkend="
"\"ST_IsValid\">ST_IsValid()</link>"
msgstr ""
"GEOSライブラリを使って実装されている関数のほとんどは、ジオメトリがOpenGISシン"
"プルフィーチャー仕様で定義されているように妥当であると仮定しています。ジオメ"
"トリが単純であるか、また妥当であるか、のチェックとして<link linkend="
"\"ST_IsSimple\">ST_IsSimple()</link>と<link linkend=\"ST_IsValid"
"\">ST_IsValid()</link>が使えます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1001
#, no-c-format
msgid ""
"-- Typically, it doesn't make sense to check\n"
"-- for validity on linear features since it will always return TRUE.\n"
"-- But in this example, PostGIS extends the definition of the OGC IsValid\n"
"-- by returning false if a LineString has less than 2 *distinct* vertices.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"
msgstr ""
"-- 一般的に、線フィーチャーの妥当性のチェックは\n"
"-- 常にTRUEを返すので意味がありません\n"
"-- しかし、この例では、PostGISがOGCのIsValidの定義を拡張して\n"
"-- *一意な頂点*が2より少ないラインストリングについてFALSEを\n"
"-- 返すようにしています\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"

#. Tag: para
#: using_postgis_dataman.xml:1003
#, no-c-format
msgid ""
"By default, PostGIS does not apply this validity check on geometry input, "
"because testing for validity needs lots of CPU time for complex geometries, "
"especially polygons. If you do not trust your data sources, you can manually "
"enforce such a check to your tables by adding a check constraint:"
msgstr ""
"デフォルトでは、PostGISはジオメトリ入力に関するこの妥当性チェックを適用しませ"
"ん。複雑なジオメトリの妥当性のチェックはCPU時間を多く必要とするためです。デー"
"タソースが信用できない場合は、手動でこのチェックを強制するための制約を付ける"
"ことができます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1009
#, no-c-format
msgid ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"
msgstr ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"

#. Tag: para
#: using_postgis_dataman.xml:1011
#, no-c-format
msgid ""
"If you encounter any strange error messages such as \"GEOS Intersection() "
"threw an error!\" or \"JTS Intersection() threw an error!\" when calling "
"PostGIS functions with valid input geometries, you likely found an error in "
"either PostGIS or one of the libraries it uses, and you should contact the "
"PostGIS developers. The same is true if a PostGIS function returns an "
"invalid geometry for valid input."
msgstr ""
"妥当な入力ジオメトリでPostGIS関数を呼んだのに「GEOS Intersection()がエラーを"
"投げました!」や「JTS Intersection()がエラーを投げました!」というようなメッ"
"セージに遭遇したら、それはたぶん、PostGISまたは使用しているライブラリの中のエ"
"ラーを発見しました。PostGIS開発者に連絡するべきです。PostGIS関数が妥当である"
"入力ジオメトリから妥当でないジオメトリが返る場合も同じです。"

#. Tag: para
#: using_postgis_dataman.xml:1019
#, no-c-format
msgid ""
"Strictly compliant OGC geometries cannot have Z or M values. The <link "
"linkend=\"ST_IsValid\">ST_IsValid()</link> function won't consider higher "
"dimensioned geometries invalid! Invocations of <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> will add a constraint "
"checking geometry dimensions, so it is enough to specify 2 there."
msgstr ""
"厳格にOGCジオメトリに準拠すると、Z値やM値を持てません。<link linkend="
"\"ST_IsValid\">ST_IsValid()</link>は高次を考慮に入れません。<link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link>を実行するとジオメトリの次元"
"をチェックする制約が加わるので、そこで2を指定すれば十分です。"

#. Tag: title
#: using_postgis_dataman.xml:1029
#, no-c-format
msgid "Dimensionally Extended 9 Intersection Model (DE-9IM)"
msgstr ""
"ここで、Dimensionally Extended 9 Intersection Modelまたは略してDE-9IMを見てみ"
"ましょう。"

#. Tag: para
#: using_postgis_dataman.xml:1031
#, no-c-format
msgid ""
"It is sometimes the case that the typical spatial predicates (<xref linkend="
"\"ST_Contains\"/>, <xref linkend=\"ST_Crosses\"/>, <xref linkend="
"\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>, ...) are insufficient "
"in and of themselves to adequately provide that desired spatial filter."
msgstr ""
"代表的な空間述語 (<xref linkend=\"ST_Contains\"/>, <xref linkend=\"ST_Crosses"
"\"/>, <xref linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>…)は、"
"求める空間フィルタを十分に提供しきれないことがあります。"

#. Tag: para
#: using_postgis_dataman.xml:1043
#, no-c-format
msgid ""
"For example, consider a linear dataset representing a road network. It may "
"be the task of a GIS analyst to identify all road segments that cross each "
"other, not at a point, but on a line, perhaps invalidating some business "
"rule. In this case, <xref linkend=\"ST_Crosses\"/> does not adequately "
"provide the necessary spatial filter since, for linear features, it returns "
"<varname>true</varname> only where they cross at a point."
msgstr ""
"たとえば、道路網を表現する線型のデータセットがあるとします。ビジネスルールを"
"無視しているかも知れませんが、点で交差するだけでなく線上で交差する道路区間を"
"全て判別することがGIS解析者の仕事となるかも知れません。この場合、 <xref "
"linkend=\"ST_Crosses\"/>では重要な空間フィルタとして十分ではありません。線型"
"のフィーチャーでは、点でクロス (訳注: インタセクトより厳しい条件です)している"
"場合のみ<varname>true</varname>が返ります。"

#. Tag: para
#: using_postgis_dataman.xml:1050
#, no-c-format
msgid ""
"One two-step solution might be to first perform the actual intersection "
"(<xref linkend=\"ST_Intersection\"/>) of pairs of road segments that "
"spatially intersect (<xref linkend=\"ST_Intersects\"/>), and then compare "
"the intersection's <xref linkend=\"ST_GeometryType\"/> with "
"'<varname>LINESTRING</varname>' (properly dealing with cases that return "
"<varname>GEOMETRYCOLLECTION</varname>s of <varname>[MULTI]POINT</varname>s, "
"<varname>[MULTI]LINESTRING</varname>s, etc.)."
msgstr ""
"空間的にインタセクトしている (<xref linkend=\"ST_Intersects\"/>)と判別された"
"二つの区間の組み合わせについて、実際のインタセクト (<xref linkend="
"\"ST_Intersection\"/>)を取り、 インタセクトの<xref linkend=\"ST_GeometryType"
"\"/>が''<varname>LINESTRING</varname>'であるかを見る (<varname>[MULTI]POINT</"
"varname>や<varname>[MULTI]LINESTRING</varname>等からなる"
"<varname>GEOMETRYCOLLECTION</varname>が帰ってくる場合にしっかり対応するた"
"め)、という2段階の方法で解くことはできます。"

#. Tag: para
#: using_postgis_dataman.xml:1058
#, no-c-format
msgid "A more elegant / faster solution may indeed be desirable."
msgstr "よりエレガントかつ速い解法が本当に望ましいでしょう。"

#. Tag: para
#: using_postgis_dataman.xml:1072
#, no-c-format
msgid ""
"A second [theoretical] example may be that of a GIS analyst trying to locate "
"all wharfs or docks that intersect a lake's boundary on a line and where "
"only one end of the wharf is up on shore. In other words, where a wharf is "
"within, but not completely within a lake, intersecting the boundary of a "
"lake on a line, and where the wharf's endpoints are both completely within "
"and on the boundary of the lake. The analyst may need to use a combination "
"of spatial predicates to isolate the sought after features:"
msgstr ""
"二つ目の[理論的な]例として、GIS解析者が全ての湖の境界に線でインタセクトする波"
"止場やドックの全ての位置を特定しようとするとします。ここで、波止場の一端だけ"
"陸にあるとします。言いかえると、波止場が湖の中にあるが完全に中に入りきっては"
"いなくて、湖と線でインタセクトして、波止場の一方の端が完全に湖に入っていて、"
"かつもう一方の端点が境界線上にあります。解析者は空間述語の組み合わせで、非常"
"に望まれるフィーチャーを引き出す必要があるかも知れません。"

#. Tag: para
#: using_postgis_dataman.xml:1083
#, no-c-format
msgid "(lake, wharf) = TRUE"
msgstr "(lake, wharf) = TRUE"

#. Tag: para
#: using_postgis_dataman.xml:1087
#, no-c-format
msgid "(lake, wharf) = FALSE"
msgstr "(lake, wharf) = FALSE"

#. Tag: para
#: using_postgis_dataman.xml:1091
#, no-c-format
msgid "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"
msgstr "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"

#. Tag: para
#: using_postgis_dataman.xml:1096
#, no-c-format
msgid ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"
msgstr ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"

#. Tag: para
#: using_postgis_dataman.xml:1099
#, no-c-format
msgid "... (needless to say, this could get quite complicated)"
msgstr "…(複雑なので以下略)"

#. Tag: para
#: using_postgis_dataman.xml:1108
#, no-c-format
msgid ""
"So enters the Dimensionally Extended 9 Intersection Model, or DE-9IM for "
"short."
msgstr ""
"ここで、Dimensionally Extended 9 Intersection Mode、略してDE-9IMを見てみま"
"しょう。"

#. Tag: title
#: using_postgis_dataman.xml:1112
#, no-c-format
msgid "Theory"
msgstr "理論"

#. Tag: para
#: using_postgis_dataman.xml:1114
#, no-c-format
msgid ""
"According to the <ulink url=\"http://www.opengeospatial.org/standards/sfs"
"\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, "
"\"the basic approach to comparing two geometries is to make pair-wise tests "
"of the intersections between the Interiors, Boundaries and Exteriors of the "
"two geometries and to classify the relationship between the two geometries "
"based on the entries in the resulting 'intersection' matrix.\""
msgstr ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink>によると「二つのジオメト"
"リの比較の基本的なアプローチは、二つのジオメトリの内部、境界、外部のインタセ"
"クションの比較と、『インタセクション行列』の要素に基づく2ジオメトリの関係の分"
"類です」。"

#. Tag: glossterm
#: using_postgis_dataman.xml:1125
#, no-c-format
msgid "<glossterm>Boundary</glossterm>"
msgstr "<glossterm>境界 (Boundary)</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1128
#, no-c-format
msgid ""
"The boundary of a geometry is the set of geometries of the next lower "
"dimension. For <varname>POINT</varname>s, which have a dimension of 0, the "
"boundary is the empty set. The boundary of a <varname>LINESTRING</varname> "
"are the two endpoints. For <varname>POLYGON</varname>s, the boundary is the "
"linework that make up the exterior and interior rings."
msgstr ""
"ジオメトリの境界は一つ低い次元のジオメトリの集合です。0次元の<varname>POINT</"
"varname>の境界は空集合です。<varname>LINESTRING</varname>の境界は二つの端点で"
"す。 <varname>POLYGON</varname>の境界は外環と内環を形成する線です。"

#. Tag: glossterm
#: using_postgis_dataman.xml:1139
#, no-c-format
msgid "<glossterm>Interior</glossterm>"
msgstr "<glossterm>内部 (Interior)</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1142
#, no-c-format
msgid ""
"The interior of a geometry are those points of a geometry that are left when "
"the boundary is removed. For <varname>POINT</varname>s, the interior is the "
"<varname>POINT</varname> itself. The interior of a <varname>LINESTRING</"
"varname> are the set of real points between the endpoints. For "
"<varname>POLYGON</varname>s, the interior is the areal surface inside the "
"polygon."
msgstr ""
"ジオメトリの内部は境界を取り去った際に残るジオメトリです。<varname>POINT</"
"varname>の内部は<varname>POINT</varname>自身です。<varname>LINESTRING</"
"varname>の内部は二つの端点の間の実際の点の集合です。<varname>POLYGON</"
"varname>の内部はポリゴンの内側の範囲であるサーフェスです。"

#. Tag: glossterm
#: using_postgis_dataman.xml:1153
#, no-c-format
msgid "<glossterm>Exterior</glossterm>"
msgstr "<glossterm>外部 (Exterior)</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1156
#, no-c-format
msgid ""
"The exterior of a geometry is the universe, an areal surface, not on the "
"interior or boundary of the geometry."
msgstr "ジオメトリの外部は、内部と境界を除いた全領域のサーフェスです。"

#. Tag: para
#: using_postgis_dataman.xml:1163
#, no-c-format
msgid ""
"Given geometry <emphasis>a</emphasis>, where the <emphasis>I(a)</emphasis>, "
"<emphasis>B(a)</emphasis>, and <emphasis>E(a)</emphasis> are the "
"<emphasis>Interior</emphasis>, <emphasis>Boundary</emphasis>, and "
"<emphasis>Exterior</emphasis> of a, the mathematical representation of the "
"matrix is:"
msgstr ""
"ジオメトリ<emphasis>a</emphasis>があり、aの内部、境界、外部をそれぞれ"
"<emphasis>I(a)</emphasis>、<emphasis>B(a)</emphasis>、<emphasis>E(a)</"
"emphasis>とします。数学的な行列表現は次のようになります。"

#. Tag: emphasis
#: using_postgis_dataman.xml:1175 using_postgis_dataman.xml:1185
#: using_postgis_dataman.xml:1269 using_postgis_dataman.xml:1282
#, no-c-format
msgid "<emphasis role=\"bold\">Interior</emphasis>"
msgstr "<emphasis role=\"bold\">内部 (Interior)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1177 using_postgis_dataman.xml:1191
#: using_postgis_dataman.xml:1272 using_postgis_dataman.xml:1305
#, no-c-format
msgid "<emphasis role=\"bold\">Boundary</emphasis>"
msgstr "<emphasis role=\"bold\">境界 (Boundary)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1179 using_postgis_dataman.xml:1197
#: using_postgis_dataman.xml:1275 using_postgis_dataman.xml:1328
#, no-c-format
msgid "<emphasis role=\"bold\">Exterior</emphasis>"
msgstr "<emphasis role=\"bold\">外部 (Exterior)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1186
#, no-c-format
msgid "dim( I(a) ∩ I(b) )"
msgstr "dim( I(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1187
#, no-c-format
msgid "dim( I(a) ∩ B(b) )"
msgstr "dim( I(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1188
#, no-c-format
msgid "dim( I(a) ∩ E(b) )"
msgstr "dim( I(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1192
#, no-c-format
msgid "dim( B(a) ∩ I(b) )"
msgstr "dim( B(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1193
#, no-c-format
msgid "dim( B(a) ∩ B(b) )"
msgstr "dim( B(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1194
#, no-c-format
msgid "dim( B(a) ∩ E(b) )"
msgstr "dim( B(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1198
#, no-c-format
msgid "dim( E(a) ∩ I(b) )"
msgstr "dim( E(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1199
#, no-c-format
msgid "dim( E(a) ∩ B(b) )"
msgstr "dim( E(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1200
#, no-c-format
msgid "dim( E(a) ∩ E(b) )"
msgstr "dim( E(a) ∩ E(b) )"

#. Tag: para
#: using_postgis_dataman.xml:1207
#, no-c-format
msgid ""
"Where <emphasis>dim(a)</emphasis> is the dimension of <emphasis>a</emphasis> "
"as specified by <xref linkend=\"ST_Dimension\"/> but has the domain of "
"<literal>{0,1,2,T,F,*}</literal>"
msgstr ""
"ここで、<emphasis>dim(a)</emphasis>は<emphasis>a</emphasis>の次元で、<xref "
"linkend=\"ST_Dimension\"/>で規定されますが、{0,1,2,T,F,*}の値域を持ちます。"

#. Tag: para
#: using_postgis_dataman.xml:1214
#, no-c-format
msgid "<literal>0</literal> =&gt; point"
msgstr "<literal>0</literal> =&gt; 点"

#. Tag: para
#: using_postgis_dataman.xml:1218
#, no-c-format
msgid "<literal>1</literal> =&gt; line"
msgstr "<literal>1</literal> =&gt; 線"

#. Tag: para
#: using_postgis_dataman.xml:1222
#, no-c-format
msgid "<literal>2</literal> =&gt; area"
msgstr "<literal>2</literal> =&gt; 面"

#. Tag: para
#: using_postgis_dataman.xml:1226
#, no-c-format
msgid "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"
msgstr "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"

#. Tag: para
#: using_postgis_dataman.xml:1231
#, no-c-format
msgid "<literal>F</literal> =&gt; empty set"
msgstr "<literal>F</literal> =&gt; 空集合"

#. Tag: para
#: using_postgis_dataman.xml:1235
#, no-c-format
msgid "<literal>*</literal> =&gt; don't care"
msgstr "<literal>*</literal> =&gt; 何でも良い"

#. Tag: para
#: using_postgis_dataman.xml:1239
#, no-c-format
msgid "Visually, for two overlapping polygonal geometries, this looks like:"
msgstr ""
"二つのオーバラップするポリゴンについて可視化すると、次のようになります。"

#. Tag: para
#: using_postgis_dataman.xml:1286 using_postgis_dataman.xml:1298
#: using_postgis_dataman.xml:1332 using_postgis_dataman.xml:1344
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1292 using_postgis_dataman.xml:1309
#: using_postgis_dataman.xml:1321 using_postgis_dataman.xml:1338
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1315
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1356
#, no-c-format
msgid ""
"Read from left to right and from top to bottom, the dimensional matrix is "
"represented, '<emphasis role=\"bold\">212101212</emphasis>'."
msgstr ""
"左から右、上から下に読むと、次元行列は'<emphasis role=\"bold\">212101212</"
"emphasis>'と表現されます。"

#. Tag: para
#: using_postgis_dataman.xml:1359
#, no-c-format
msgid ""
"A relate matrix that would therefore represent our first example of two "
"lines that intersect on a line would be: '<emphasis role=\"bold\">1*1***1**</"
"emphasis>'"
msgstr ""
"一つ目の例である、2線が線上でインタセクトする場合の関係行列は'<emphasis role="
"\"bold\">1*1***1**</emphasis>'となります。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1363
#, fuzzy, no-c-format
msgid ""
"-- Identify road segments that cross on a line\n"
"SELECT a.id\n"
"FROM roads a, roads b\n"
"WHERE a.id != b.id\n"
"AND a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '1*1***1**');"
msgstr ""
"-- 線上でクロスする道路区間の判別\n"
"SELECT a.id\n"
"FROM roads a, roads b\n"
"WHERE a.id != b.id \n"
"AND a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '1*1***1**');"

#. Tag: para
#: using_postgis_dataman.xml:1365
#, no-c-format
msgid ""
"A relate matrix that represents the second example of wharfs partly on the "
"lake's shoreline would be '<emphasis role=\"bold\">102101FF2</emphasis>'"
msgstr ""
"二つ目の例である、一部が湖の水涯線上にある波止場についての関係行列"
"は'<emphasis role=\"bold\">102101FF2</emphasis>'となります。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1369
#, no-c-format
msgid ""
"-- Identify wharfs partly on a lake's shoreline\n"
"SELECT a.lake_id, b.wharf_id\n"
"FROM lakes a, wharfs b\n"
"WHERE a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '102101FF2');"
msgstr ""
"-- 一部が湖の水涯線上にある波止場の判別\n"
"SELECT a.lake_id, b.wharf_id\n"
"FROM lakes a, wharfs b\n"
"WHERE a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '102101FF2');"

#. Tag: para
#: using_postgis_dataman.xml:1371
#, no-c-format
msgid "For more information or reading, see:"
msgstr "詳細情報ついては、次のページをご覧ください。"

#. Tag: para
#: using_postgis_dataman.xml:1375
#, no-c-format
msgid ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink> (version 1.1, section "
"2.1.13.2)"
msgstr ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink> (1.1版, 2.1.13.2節)"

#. Tag: ulink
#: using_postgis_dataman.xml:1380
#, no-c-format
msgid "Dimensionally Extended Nine-Intersection Model (DE-9IM)"
msgstr ""

#. Tag: ulink
#: using_postgis_dataman.xml:1384
#, no-c-format
msgid "GeoTools: Point Set Theory and the DE-9IM Matrix"
msgstr "GeoTools: Point Set Theory and the DE-9IM Matrix"

#. Tag: para
#: using_postgis_dataman.xml:1387
#, no-c-format
msgid "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"
msgstr "Hui Xiongさんによる<emphasis>Encyclopedia of GIS</emphasis>"

#. Tag: title
#: using_postgis_dataman.xml:1397
#, no-c-format
msgid "Loading GIS (Vector) Data"
msgstr "GIS (ベクタ)データをロードする"

#. Tag: para
#: using_postgis_dataman.xml:1399
#, no-c-format
msgid ""
"Once you have created a spatial table, you are ready to upload GIS data to "
"the database. Currently, there are two ways to get data into a PostGIS/"
"PostgreSQL database: using formatted SQL statements or using the Shape file "
"loader/dumper."
msgstr ""
"空間テーブルを作成したら、これでGISデータをデータベースにアップロードする準備"
"ができたことになります。現在、PostGIS/PostgreSQLデータベースにデータをロード"
"するには、SQLステートメントを使う、またはシェープファイルのローダ/ダンパを使"
"う、二つの方法があります。"

#. Tag: title
#: using_postgis_dataman.xml:1405
#, no-c-format
msgid "Loading Data Using SQL"
msgstr "SQLを使ってロードする"

#. Tag: para
#: using_postgis_dataman.xml:1407
#, no-c-format
msgid ""
"If you can convert your data to a text representation, then using formatted "
"SQL might be the easiest way to get your data into PostGIS. As with Oracle "
"and other SQL databases, data can be bulk loaded by piping a large text file "
"full of SQL \"INSERT\" statements into the SQL terminal monitor."
msgstr ""
"データをテキスト表現に変換できるなら、フォーマットされたSQLを使うのがデータを"
"PostGISに入れる最も簡単な方法です。Oracleや他のSQLデータベースを使うように、"
"SQL端末モニタにSQLの\"INSERT\"ステートメントで一杯になった大きなテキストファ"
"イルをパイプで送ることで、大量のデータをロードできます。"

#. Tag: para
#: using_postgis_dataman.xml:1413
#, no-c-format
msgid ""
"A data upload file (<filename>roads.sql</filename> for example) might look "
"like this:"
msgstr ""
"データアップロードファイル (たとえば<filename>roads.sql</filename>)は次のよう"
"になるでしょう。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1416
#, no-c-format
msgid ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 "
"243242)',-1),'Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 "
"244817)',-1),'Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 "
"229814)',-1),'Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 "
"259122)',-1),'Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 "
"228134)',-1),'Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 "
"268322)',-1),'Dave Cres');\n"
"COMMIT;"
msgstr ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 "
"243242)',-1),'Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 "
"244817)',-1),'Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 "
"229814)',-1),'Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 "
"259122)',-1),'Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 "
"228134)',-1),'Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 "
"268322)',-1),'Dave Cres');\n"
"COMMIT;"

#. Tag: para
#: using_postgis_dataman.xml:1418
#, no-c-format
msgid ""
"The data file can be piped into PostgreSQL very easily using the \"psql\" "
"SQL terminal monitor:"
msgstr ""
"データファイルは、次に示す\"psql\"というSQL端末モニタを使って、簡単に"
"PostgreSQLにパイプで送ることができます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1421
#, no-c-format
msgid "psql -d [database] -f roads.sql"
msgstr "psql -d [データベース名] -f roads.sql"

#. Tag: title
#: using_postgis_dataman.xml:1425
#, no-c-format
msgid "shp2pgsql: Using the ESRI Shapefile Loader"
msgstr "shp2pgsql: ESRIシェープファイルローダを使う"

#. Tag: para
#: using_postgis_dataman.xml:1427
#, no-c-format
msgid ""
"The <filename>shp2pgsql</filename> data loader converts ESRI Shape files "
"into SQL suitable for insertion into a PostGIS/PostgreSQL database either in "
"geometry or geography format. The loader has several operating modes "
"distinguished by command line flags:"
msgstr ""
"<filename>shp2pgsql</filename>データローダは、ESRIシェープファイルをPostGIS/"
"PostgreSQLデータベースに、ジオメトリまたはジオグラフィとして挿入するための適"
"切なSQLに変換します。ローダには、次に示すコマンドラインフラグによって区別され"
"る、いくつかの操作モードがあります。"

#. Tag: para
#: using_postgis_dataman.xml:1432
#, no-c-format
msgid ""
"In addition to the shp2pgsql command-line loader, there is an "
"<filename>shp2pgsql-gui</filename> graphical interface with most of the "
"options as the command-line loader, but may be easier to use for one-off non-"
"scripted loading or if you are new to PostGIS. It can also be configured as "
"a plugin to PgAdminIII."
msgstr ""
"また、コマンドラインローダのほとんどのオプションに対応する"
"<filename>shp2pgsql-gui</filename>グラフィカルユーザインタフェースがありま"
"す。一度限りのロードしか行わずスクリプト化しない場合やPostGISに不慣れな方に"
"とって便利になるかもしれません。これはpgAdminIIIのプラグインとして構築するこ"
"ともできます。"

#. Tag: term
#: using_postgis_dataman.xml:1439
#, no-c-format
msgid "(c|a|d|p) These are mutually exclusive options:"
msgstr "(c|a|d|p) 相互に排他的なオプションです"

#. Tag: term
#: using_postgis_dataman.xml:1444
#, no-c-format
msgid "<term>-c</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1446
#, no-c-format
msgid ""
"Creates a new table and populates it from the shapefile. <emphasis>This is "
"the default mode.</emphasis>"
msgstr ""
"新しいテーブルの作成とシェープファイルからのデータの読み込みを行います。"
"<emphasis>これがデフォルトモードです</emphasis>。"

#. Tag: term
#: using_postgis_dataman.xml:1454
#, no-c-format
msgid "<term>-a</term>"
msgstr "<term>-a</term>"

#. Tag: para
#: using_postgis_dataman.xml:1456
#, no-c-format
msgid ""
"Appends data from the Shape file into the database table. Note that to use "
"this option to load multiple files, the files must have the same attributes "
"and same data types."
msgstr ""
"シェープファイルからデータベーステーブルにデータを追加します。複数のファイル"
"をロードするためにこのオプションを使う場合は、これらのファイルは同じ属性と同"
"じデータ型を持つ必要があります。"

#. Tag: term
#: using_postgis_dataman.xml:1465 using_postgis_dataman.xml:1854
#, no-c-format
msgid "<term>-d</term>"
msgstr "<term>-d</term>"

#. Tag: para
#: using_postgis_dataman.xml:1467
#, no-c-format
msgid ""
"Drops the database table before creating a new table with the data in the "
"Shape file."
msgstr ""
"シェープファイルにあるデータを持つ新しいテーブルを作成する前にデータベース"
"テーブルを削除します。"

#. Tag: term
#: using_postgis_dataman.xml:1475
#, no-c-format
msgid "<term>-p</term>"
msgstr "<term>-p</term>"

#. Tag: para
#: using_postgis_dataman.xml:1477
#, no-c-format
msgid ""
"Only produces the table creation SQL code, without adding any actual data. "
"This can be used if you need to completely separate the table creation and "
"data loading steps."
msgstr ""
"テーブル作成のSQLコードを生成するだけで、実際のデータは追加しません。このモー"
"ドは、テーブル作成とデータロードとを完全に分けたい場合に使用します。"

#. Tag: term
#: using_postgis_dataman.xml:1490
#, no-c-format
msgid "<term>-?</term>"
msgstr "<term>-?</term>"

#. Tag: para
#: using_postgis_dataman.xml:1492
#, no-c-format
msgid "Display help screen."
msgstr "ヘルプ画面を表示します。"

#. Tag: term
#: using_postgis_dataman.xml:1499
#, no-c-format
msgid "<term>-D</term>"
msgstr "<term>-D</term>"

#. Tag: para
#: using_postgis_dataman.xml:1501
#, no-c-format
msgid ""
"Use the PostgreSQL \"dump\" format for the output data. This can be combined "
"with -a, -c and -d. It is much faster to load than the default \"insert\" "
"SQL format. Use this for very large data sets."
msgstr ""
"出力データにPostgreSQLのダンプ書式を用います。このモードは-a, -c, -dと組み合"
"わせて利用します。デフォルトの\"insert\"によるSQL書式よりも、大変早くロードで"
"きます。大きなデータセットではこちらを使用して下さい。"

#. Tag: term
#: using_postgis_dataman.xml:1510
#, no-c-format
msgid "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"
msgstr "-s [&lt;FROM_SRID&gt;:]&lt;SRID&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1512
#, no-c-format
msgid ""
"Creates and populates the geometry tables with the specified SRID. "
"Optionally specifies that the input shapefile uses the given FROM_SRID, in "
"which case the geometries will be reprojected to the target SRID. FROM_SRID "
"cannot be specified with -D."
msgstr ""
"指定したSRIDでジオメトリデーブルの作成とデータの読み込みを行います。 入力"
"シェープファイルが使っているFROM_SRIDの指定が可能で、この場合は対象SRIDに投影"
"変換を行います。FROM_SRIDは-Dと一緒には指定できません。"

#. Tag: term
#: using_postgis_dataman.xml:1523
#, no-c-format
msgid "<term>-k</term>"
msgstr "<term>-k</term>"

#. Tag: para
#: using_postgis_dataman.xml:1525
#, no-c-format
msgid ""
"Keep identifiers' case (column, schema and attributes). Note that attributes "
"in Shapefile are all UPPERCASE."
msgstr ""
"識別子 (カラム、スキーマおよび属性)の大文字小文字を保持します。シェープファイ"
"ルの属性は全て大文字であることに注意して下さい。"

#. Tag: term
#: using_postgis_dataman.xml:1533
#, no-c-format
msgid "<term>-i</term>"
msgstr "<term>-i</term>"

#. Tag: para
#: using_postgis_dataman.xml:1535
#, no-c-format
msgid ""
"Coerce all integers to standard 32-bit integers, do not create 64-bit "
"bigints, even if the DBF header signature appears to warrant it."
msgstr ""
"全ての整数を標準の32ビット整数に強制します。DBFヘッダではそれが正当であったと"
"しても、64ビットのbigintを生成しません。"

#. Tag: term
#: using_postgis_dataman.xml:1543
#, no-c-format
msgid "<term>-I</term>"
msgstr "<term>-I</term>"

#. Tag: para
#: using_postgis_dataman.xml:1545
#, no-c-format
msgid "Create a GiST index on the geometry column."
msgstr "ジオメトリカラムにGiSTインデクスを生成します。"

#. Tag: term
#: using_postgis_dataman.xml:1552
#, no-c-format
msgid "<term>-m</term>"
msgstr "<term>-m</term>"

#. Tag: para
#: using_postgis_dataman.xml:1554
#, no-c-format
msgid ""
"-m <filename>a_file_name</filename> Specify a file containing a set of "
"mappings of (long) column names to 10 character DBF column names. The "
"content of the file is one or more lines of two names separated by white "
"space and no trailing or leading space. For example:"
msgstr ""
"-m <filename>a_file_name</filename>で、長いカラム名を10文字のDBFカラム名に対"
"応付けるファイルを指定します。ファイルは、1以上の行を持ちます。各行は空白区切"
"りで二つの名前を持ち、行頭行末に空白を入れません。例を次に示します。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1559
#, no-c-format
msgid ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"
msgstr ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"

#. Tag: term
#: using_postgis_dataman.xml:1565
#, no-c-format
msgid "<term>-S</term>"
msgstr "<term>-S</term>"

#. Tag: para
#: using_postgis_dataman.xml:1567
#, no-c-format
msgid ""
"Generate simple geometries instead of MULTI geometries. Will only succeed if "
"all the geometries are actually single (I.E. a MULTIPOLYGON with a single "
"shell, or or a MULTIPOINT with a single vertex)."
msgstr ""
"マルチ系ジオメトリの替りに単一ジオメトリを生成します。全てのジオメトリが実際"
"に単一である (たとえば単一の外環でなるMULTIPOLYGONや単一の頂点でなる"
"MULTIPOINT)場合にのみ成功します。"

#. Tag: term
#: using_postgis_dataman.xml:1576
#, no-c-format
msgid "-t &lt;dimensionality&gt;"
msgstr "-t &lt;次元&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1578
#, no-c-format
msgid ""
"Force the output geometry to have the specified dimensionality. Use the "
"following strings to indicate the dimensionality: 2D, 3DZ, 3DM, 4D."
msgstr ""
"出力ジオメトリが特定の次元を持つよう強制します。次元は、2D, 3DZ, 3DM, 4Dの文"
"字列を使います。"

#. Tag: para
#: using_postgis_dataman.xml:1582
#, no-c-format
msgid ""
"If the input has fewer dimensions that specified, the output will have those "
"dimensions filled in with zeroes. If the input has more dimensions that "
"specified, the unwanted dimensions will be stripped."
msgstr ""
"入力の次元が出力より小さい場合には、出力では0が入ります。入力の次元が大きい場"
"合には、外されます。"

#. Tag: term
#: using_postgis_dataman.xml:1591
#, no-c-format
msgid "<term>-w</term>"
msgstr "<term>-w</term>"

#. Tag: para
#: using_postgis_dataman.xml:1593
#, no-c-format
msgid ""
"Output WKT format, instead of WKB. Note that this can introduce coordinate "
"drifts due to loss of precision."
msgstr ""
"出力書式をWKBでなくWKTにします。精度が低下して、座標変動が発生しうることに注"
"意が必要です。"

#. Tag: term
#: using_postgis_dataman.xml:1601
#, no-c-format
msgid "<term>-e</term>"
msgstr "<term>-e</term>"

#. Tag: para
#: using_postgis_dataman.xml:1603
#, no-c-format
msgid ""
"Execute each statement on its own, without using a transaction. This allows "
"loading of the majority of good data when there are some bad geometries that "
"generate errors. Note that this cannot be used with the -D flag as the \"dump"
"\" format always uses a transaction."
msgstr ""
"トランザクションを使わずに、ステートメントごとに実行するようにします。エラー"
"の元となる不良なジオメトリがいくつか含んでいる時に、大半の良好なデータのロー"
"ドが可能にするものです。ダンプ書式ではトランザクションを常に使うので、-Dフラ"
"グを指定している場合には使えません。"

#. Tag: term
#: using_postgis_dataman.xml:1613
#, no-c-format
msgid "-W &lt;encoding&gt;"
msgstr "-W &lt;エンコーディング&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1615
#, no-c-format
msgid ""
"Specify encoding of the input data (dbf file). When used, all attributes of "
"the dbf are converted from the specified encoding to UTF8. The resulting SQL "
"output will contain a <code>SET CLIENT_ENCODING to UTF8</code> command, so "
"that the backend will be able to reconvert from UTF8 to whatever encoding "
"the database is configured to use internally."
msgstr ""
"入力データ (dbfファイル)のエンコーディングを指定します。全てのdbfの属性は指定"
"されたエンコーディングからUTF8に変換されます。SQL出力結果には <code>SET "
"CLIENT_ENCODING to UTF8</code>が含まれるようになり、バックエンドはUTF-8から"
"データベースが内部利用のために設定したエンコーディングに再変換できます。"

#. Tag: term
#: using_postgis_dataman.xml:1625
#, no-c-format
msgid "-N &lt;policy&gt;"
msgstr "-N &lt;方針&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1627
#, no-c-format
msgid "NULL geometries handling policy (insert*,skip,abort)"
msgstr ""
"NULLジオメトリ操作方針(insert*=挿入, skip=スキップ, abort=強制終了)を選択しま"
"す。"

#. Tag: term
#: using_postgis_dataman.xml:1633
#, no-c-format
msgid "<term>-n</term>"
msgstr "<term>-n</term>"

#. Tag: para
#: using_postgis_dataman.xml:1635
#, no-c-format
msgid ""
"-n Only import DBF file. If your data has no corresponding shapefile, it "
"will automatically switch to this mode and load just the dbf. So setting "
"this flag is only needed if you have a full shapefile set, and you only want "
"the attribute data and no geometry."
msgstr ""
"DBFファイルのみインポートします。対応するシェープファイルを持っていない場"
"合、 自動的にこのモードになり、DBFファイルのみロードします。 このフラグは、完"
"全なシェープファイル群を持っていて、属性データだけが欲しくてジオメトリが欲し"
"くない時のみ使用します。"

#. Tag: term
#: using_postgis_dataman.xml:1643
#, no-c-format
msgid "<term>-G</term>"
msgstr "<term>-G</term>"

#. Tag: para
#: using_postgis_dataman.xml:1645
#, no-c-format
msgid ""
"Use geography type instead of geometry (requires lon/lat data) in WGS84 long "
"lat (SRID=4326)"
msgstr ""
"ジオメトリ型のかわりに、ジオグラフィ型で、WGS84経度緯度 (SRID=4326)を使用しま"
"す (経度緯度データが必要です)。"

#. Tag: term
#: using_postgis_dataman.xml:1651
#, no-c-format
msgid "-T &lt;tablespace&gt;"
msgstr "-T &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1653
#, no-c-format
msgid ""
"Specify the tablespace for the new table. Indexes will still use the default "
"tablespace unless the -X parameter is also used. The PostgreSQL "
"documentation has a good description on when to use custom tablespaces."
msgstr ""
"新しいテーブルのテーブル空間を指定します。 -Xパラメータが使われない場合には、"
"インデクスはデフォルトのテーブル空間を使用します。PostgreSQL文書には、テーブ"
"ル空間を用いるべき時に関する良い文書があります。"

#. Tag: term
#: using_postgis_dataman.xml:1661
#, no-c-format
msgid "-X &lt;tablespace&gt;"
msgstr "-X &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1663
#, no-c-format
msgid ""
"Specify the tablespace for the new table's indexes. This applies to the "
"primary key index, and the GIST spatial index if -I is also used."
msgstr ""
"新しいテーブルのインデクスで使われるテーブル空間を指定します。 主キーインデク"
"スに適用され、-Iが合わせて使われている場合にはGiST空間インデクスにも適用され"
"ます。"

#. Tag: para
#: using_postgis_dataman.xml:1671
#, no-c-format
msgid ""
"An example session using the loader to create an input file and uploading it "
"might look like this:"
msgstr ""
"ローダを使って入力ファイルを生成してアップロードするセッション例は次の通りで"
"す。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1676
#, no-c-format
msgid ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"
msgstr ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"

#. Tag: para
#: using_postgis_dataman.xml:1678
#, no-c-format
msgid "A conversion and upload can be done all in one step using UNIX pipes:"
msgstr "変換とアップロードはUNIXのパイプを使うと一回で実行できます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1682
#, no-c-format
msgid "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"
msgstr "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"

#. Tag: title
#: using_postgis_dataman.xml:1687
#, no-c-format
msgid "Retrieving GIS Data"
msgstr "GISデータを検索する"

#. Tag: para
#: using_postgis_dataman.xml:1689
#, no-c-format
msgid ""
"Data can be extracted from the database using either SQL or the Shape file "
"loader/dumper. In the section on SQL we will discuss some of the operators "
"available to do comparisons and queries on spatial tables."
msgstr ""
"データは、SQLまたはシェープファイルローダ/ダンパを使ってデータベースから抜き"
"出すことができます。SQLに関する節において、空間テーブルでの比較とクエリを行う"
"ために用いることができる演算子のいくつかを議論します。"

#. Tag: title
#: using_postgis_dataman.xml:1695
#, no-c-format
msgid "Using SQL to Retrieve Data"
msgstr "SQLを使ってデータを検索する"

#. Tag: para
#: using_postgis_dataman.xml:1697
#, no-c-format
msgid ""
"The most straightforward means of pulling data out of the database is to use "
"a SQL select query to reduce the number of RECORDS and COLUMNS returned and "
"dump the resulting columns into a parsable text file:"
msgstr ""
"データベースからデータを引き出す最も直接的な手段は、次のように、SQLのSELECTク"
"エリを使って返ってくるレコードとカラムの数を減らし、結果のカラムを可読テキス"
"トファイルにダンプするやり方です。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1702
#, no-c-format
msgid ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"
msgstr ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"

#. Tag: para
#: using_postgis_dataman.xml:1704
#, no-c-format
msgid ""
"However, there will be times when some kind of restriction is necessary to "
"cut down the number of fields returned. In the case of attribute-based "
"restrictions, just use the same SQL syntax as normal with a non-spatial "
"table. In the case of spatial restrictions, the following operators are "
"available/useful:"
msgstr ""
"しかし、返ってくる結果の数を削るために、なんらかの制限をかけることが重要とな"
"るときがあるでしょう。属性ベースの制限の場合、非空間テーブルで使う通常の文法"
"と同じSQLを使うだけです。空間ベースの制限の場合、次の演算子が使用可能であり、"
"便利です。"

#. Tag: term
#: using_postgis_dataman.xml:1712
#, no-c-format
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#. Tag: para
#: using_postgis_dataman.xml:1715
#, no-c-format
msgid ""
"This operator tells whether the bounding box of one geometry intersects the "
"bounding box of another."
msgstr ""
"この演算子で、一つのジオメトリのバウンディングボックスが他のバウンディング"
"ボックスとインタセクトするかを問い合わせることができます。"

#. Tag: term
#: using_postgis_dataman.xml:1721
#, no-c-format
msgid "ST_OrderingEquals"
msgstr "ST_OrderingEquals"

#. Tag: para
#: using_postgis_dataman.xml:1724
#, no-c-format
msgid ""
"This tests whether two geometries are geometrically identical. For example, "
"if 'POLYGON((0 0,1 1,1 0,0 0))' is the same as 'POLYGON((0 0,1 1,1 0,0 "
"0))' (it is)."
msgstr ""
"この関数で、二つのジオメトリが幾何的に同一であるかを見ることができます。たと"
"えば、'POLYGON((0 0,1 1,1 0,0 0))' は 'POLYGON((0 0,1 1,1 0,0 0))' と同じかを"
"見ることができます (これは同じとなります)。"

#. Tag: term
#: using_postgis_dataman.xml:1731
#, no-c-format
msgid "<term>=</term>"
msgstr "<term>=</term>"

#. Tag: para
#: using_postgis_dataman.xml:1734
#, no-c-format
msgid ""
"This operator is a little more naive, it only tests whether the bounding "
"boxes of two geometries are the same."
msgstr ""
"この演算子は他より若干素朴なもので、二つのジオメトリのバウンディングボックス"
"が同じかを見るだけです。"

#. Tag: para
#: using_postgis_dataman.xml:1740
#, no-c-format
msgid ""
"Next, you can use these operators in queries. Note that when specifying "
"geometries and boxes on the SQL command line, you must explicitly turn the "
"string representations into geometries by using the \"ST_GeomFromText()\" "
"function. The 312 is a fictitious spatial reference system that matches our "
"data. So, for example:"
msgstr ""
"次に、これらの演算子をクエリで使うことができます。SQLコマンドラインからジオメ"
"トリとボックスの指定を行うときは、\"ST_GeomFromText()\"関数で、明示的に文字列"
"表現をジオメトリに変換しなければならないことに注意して下さい。 たとえば、次の"
"ようになります (312は架空の空間参照系番号で、ここでのデータに合致していま"
"す)。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1746
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE ST_OrderingEquals(roads_geom , ST_GeomFromText('LINESTRING(191232 "
"243118,191108 243242)',312) ) ;"
msgstr ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE ST_OrderingEquals(roads_geom , ST_GeomFromText('LINESTRING(191232 "
"243118,191108 243242)',312) ) ;"

#. Tag: para
#: using_postgis_dataman.xml:1748
#, no-c-format
msgid ""
"The above query would return the single record from the \"ROADS_GEOM\" table "
"in which the geometry was equal to that value."
msgstr ""
"上のクエリは\"ROADS_GEOM\"テーブルから、その値と等価である単一のレコードを返"
"します。"

#. Tag: para
#: using_postgis_dataman.xml:1751
#, no-c-format
msgid ""
"When using the \"&amp;&amp;\" operator, you can specify either a BOX3D as "
"the comparison feature or a GEOMETRY. When you specify a GEOMETRY, however, "
"its bounding box will be used for the comparison."
msgstr ""
"\"&amp;&amp;\"演算子を使うとき、比較フィーチャーをBOX3DかGEOMETRYかに指定する"
"ことができます。ただし、GEOMETRYを指定すると、それのバウンディングボックスが"
"比較に使われます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1756
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))',312);"
msgstr ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))',312);"

#. Tag: para
#: using_postgis_dataman.xml:1758
#, no-c-format
msgid ""
"The above query will use the bounding box of the polygon for comparison "
"purposes."
msgstr ""
"上のクエリでは、比較するためにポリゴンのバウンディングボックスを用いていま"
"す。"

#. Tag: para
#: using_postgis_dataman.xml:1761
#, no-c-format
msgid ""
"The most common spatial query will probably be a \"frame-based\" query, used "
"by client software, like data browsers and web mappers, to grab a \"map frame"
"\" worth of data for display. Using a \"BOX3D\" object for the frame, such a "
"query looks like this:"
msgstr ""
"最も一般的な空間クエリは「フレームベース」のクエリでしょう。これは、表示する"
"ためのデータの価値のある「マップフレーム」を取得するために、データブラウザや"
"ウェブマッパのようなクライアントソフトウェアに使われます。このフレームで"
"\"BOX3D\"オブジェクトを使う場合は、次のようなクエリになります。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1766
#, no-c-format
msgid ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"
msgstr ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"

#. Tag: para
#: using_postgis_dataman.xml:1768
#, no-c-format
msgid ""
"Note the use of the SRID 312, to specify the projection of the envelope."
msgstr ""
"エンベロープの投影を指定するためにSRID 312を使っていることに注意して下さい。"

#. Tag: title
#: using_postgis_dataman.xml:1772
#, no-c-format
msgid "Using the Dumper"
msgstr "ダンパを使う"

#. Tag: para
#: using_postgis_dataman.xml:1774
#, no-c-format
msgid ""
"The <filename>pgsql2shp</filename> table dumper connects directly to the "
"database and converts a table (possibly defined by a query) into a shape "
"file. The basic syntax is:"
msgstr ""
"<filename>pgsql2shp</filename>テーブルダンパは、データベースに直接接続して、"
"テーブル (あるいはクエリによって定義されたもの)をシェープファイルに変換するも"
"のです。基本的な文法は次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1778
#, no-c-format
msgid ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"
msgstr ""
"pgsql2shp [&lt;オプション&gt;] &lt;database&gt; [&lt;スキーマ&gt;.]&lt;"
"table&gt;"

#. Tag: programlisting
#: using_postgis_dataman.xml:1780
#, no-c-format
msgid "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"
msgstr "pgsql2shp [&lt;オプション&gt;] &lt;データベース&gt; &lt;クエリ&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1782
#, no-c-format
msgid "The commandline options are:"
msgstr "コマンドラインオプションは次の通りです。"

#. Tag: term
#: using_postgis_dataman.xml:1786
#, no-c-format
msgid "-f &lt;filename&gt;"
msgstr "-f &lt;ファイル名&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1789
#, no-c-format
msgid "Write the output to a particular filename."
msgstr "特定のファイル名に出力を書きこみます。"

#. Tag: term
#: using_postgis_dataman.xml:1794
#, no-c-format
msgid "-h &lt;host&gt;"
msgstr "-h &lt;ホスト&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1797
#, no-c-format
msgid "The database host to connect to."
msgstr "接続先データベースのホスト名。"

#. Tag: term
#: using_postgis_dataman.xml:1802
#, no-c-format
msgid "-p &lt;port&gt;"
msgstr "-p &lt;ポート&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1805
#, no-c-format
msgid "The port to connect to on the database host."
msgstr "接続先データベースのポート。"

#. Tag: term
#: using_postgis_dataman.xml:1810
#, no-c-format
msgid "-P &lt;password&gt;"
msgstr "-P &lt;パスワード&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1813
#, no-c-format
msgid "The password to use when connecting to the database."
msgstr "データベースに接続するためのパスワード。"

#. Tag: term
#: using_postgis_dataman.xml:1818
#, no-c-format
msgid "-u &lt;user&gt;"
msgstr "-u &lt;ユーザ名&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1821
#, no-c-format
msgid "The username to use when connecting to the database."
msgstr "データベースに接続する際のユーザ名。"

#. Tag: term
#: using_postgis_dataman.xml:1826
#, no-c-format
msgid "-g &lt;geometry column&gt;"
msgstr "-g &lt;ジオメトリカラム&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1829
#, no-c-format
msgid ""
"In the case of tables with multiple geometry columns, the geometry column to "
"use when writing the shape file."
msgstr ""
"複数のジオメトリカラムを持つテーブルの場合の、シェープファイルの出力に使用す"
"るジオメトリカラム。"

#. Tag: term
#: using_postgis_dataman.xml:1835
#, no-c-format
msgid "<term>-b</term>"
msgstr "<term>-b</term>"

#. Tag: para
#: using_postgis_dataman.xml:1838
#, no-c-format
msgid ""
"Use a binary cursor. This will make the operation faster, but will not work "
"if any NON-geometry attribute in the table lacks a cast to text."
msgstr ""
"バイナリカーソルを使います。これは、実行時間を短くしますが、テーブルの非ジオ"
"メトリ属性がテキストへのキャストを持っていない場合には、動作しません。"

#. Tag: term
#: using_postgis_dataman.xml:1845
#, no-c-format
msgid "<term>-r</term>"
msgstr "<term>-r</term>"

#. Tag: para
#: using_postgis_dataman.xml:1848
#, no-c-format
msgid ""
"Raw mode. Do not drop the <varname>gid</varname> field, or escape column "
"names."
msgstr ""
"Rawモード。<varname>gid</varname>フィールドを落としたり、カラム名をエスケープ"
"してはいけません。"

#. Tag: para
#: using_postgis_dataman.xml:1857
#, no-c-format
msgid ""
"For backward compatibility: write a 3-dimensional shape file when dumping "
"from old (pre-1.0.0) postgis databases (the default is to write a 2-"
"dimensional shape file in that case). Starting from postgis-1.0.0+, "
"dimensions are fully encoded."
msgstr ""
"後方互換: 古い (1.0.0より前)のPostGISデータベースからダンプする際に3次元の"
"シェープファイルを出力します (デフォルトでは2次元になります)。 PostGIS 1.0.0"
"以上では、次元は完全に反映されます。"

#. Tag: term
#: using_postgis_dataman.xml:1865
#, no-c-format
msgid "-m <varname>filename</varname>"
msgstr "-m <varname>ファイル名</varname>"

#. Tag: para
#: using_postgis_dataman.xml:1867
#, no-c-format
msgid ""
"Remap identifiers to ten character names. The content of the file is lines "
"of two symbols separated by a single white space and no trailing or leading "
"space: VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."
msgstr ""
"識別名を10文字名に再割り当てします。 ファイルの中身は、一つの空白で区切られ、"
"前と後に空白が無い二つのシンボルの行からなります。VERYLONGSYMBOL SHORTONE "
"ANOTHERVERYLONGSYMBOL SHORTER等となります。"

#. Tag: title
#: using_postgis_dataman.xml:1880
#, no-c-format
msgid "Building Indexes"
msgstr "インデクスを構築する"

#. Tag: para
#: using_postgis_dataman.xml:1882
#, no-c-format
msgid ""
"Indexes are what make using a spatial database for large data sets possible. "
"Without indexing, any search for a feature would require a \"sequential scan"
"\" of every record in the database. Indexing speeds up searching by "
"organizing the data into a search tree which can be quickly traversed to "
"find a particular record. PostgreSQL supports three kinds of indexes by "
"default: B-Tree indexes, R-Tree indexes, and GiST indexes."
msgstr ""
"インデクスは大きなデータセットを持つ空間データベースの利用を可能にするもので"
"す。インデクスなしでは、フィーチャーの検索でデータベースの全レコードを「シー"
"ケンシャルスキャン」する必要があります。インデクスをつけることで、データを検"
"索木に組織化して、特定のレコードを発見するための検索をより早くすることができ"
"ます。 PostgreSQLは、B木、R木、GiSTの3種類のインデクスをデフォルトでサポート"
"しています。"

#. Tag: para
#: using_postgis_dataman.xml:1892
#, no-c-format
msgid ""
"B-Trees are used for data which can be sorted along one axis; for example, "
"numbers, letters, dates. GIS data cannot be rationally sorted along one axis "
"(which is greater, (0,0) or (0,1) or (1,0)?) so B-Tree indexing is of no use "
"for us."
msgstr ""
"B木は、数字、文字、日付といった、一つの軸に沿ってソートできるデータに使用しま"
"す。 GISデータは合理的に一つの軸に沿ったソートはできません ((0,0)と(0,1)と"
"(1,0)で大きいのはどれでしょう?)ので、B木インデクスは、ここでは使えません。"

#. Tag: para
#: using_postgis_dataman.xml:1899
#, no-c-format
msgid ""
"R-Trees break up data into rectangles, and sub-rectangles, and sub-sub "
"rectangles, etc. R-Trees are used by some spatial databases to index GIS "
"data, but the PostgreSQL R-Tree implementation is not as robust as the GiST "
"implementation."
msgstr ""
"R木はデータを長方形に分割して、さらにその長方形を小さい長方形に分割していった"
"ものです。R木はいくつかの空間データベースでGISデータのインデクスに使われます"
"が、PostgreSQLのR木実装は、GiST実装ほどにロバストではありません。"

#. Tag: para
#: using_postgis_dataman.xml:1906
#, no-c-format
msgid ""
"GiST (Generalized Search Trees) indexes break up data into \"things to one "
"side\", \"things which overlap\", \"things which are inside\" and can be "
"used on a wide range of data-types, including GIS data. PostGIS uses an R-"
"Tree index implemented on top of GiST to index GIS data."
msgstr ""
"GiST (Generalized Search Trees)インデクスはデータを「一方へのもの」 (訳注: "
"「左側にあるもの」「上側にあるもの」など)、「オーバラップするもの」、「中にあ"
"るもの」に分割して、GISデータを含む幅広いデータ型で使えるようにしたものです。"
"PostGISではGISデータにインデクスを付けるためにGiSTの上でR木インデクス実装を使"
"用しています。"

#. Tag: title
#: using_postgis_dataman.xml:1915
#, no-c-format
msgid "GiST Indexes"
msgstr "GiSTインデクス"

#. Tag: para
#: using_postgis_dataman.xml:1917
#, no-c-format
msgid ""
"GiST stands for \"Generalized Search Tree\" and is a generic form of "
"indexing. In addition to GIS indexing, GiST is used to speed up searches on "
"all kinds of irregular data structures (integer arrays, spectral data, etc) "
"which are not amenable to normal B-Tree indexing."
msgstr ""
"GiSTは「汎用的な検索木 (Generalized Search Tree)」の意味で、インデクスの一般"
"化された形式です。GISインデクスに加えて、GiSTは通常のB木インデクスに従わない"
"全ての種類の不規則なデータ構造 (整数配列, スペクトラルデータ等)の検索速度を向"
"上させるために使います。"

#. Tag: para
#: using_postgis_dataman.xml:1922
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields)."
msgstr ""
"ひとたびGISデータテーブルが数千行を超えたら、空間検索の速度向上のためインデク"
"スを構築したくなるでしょう (これは属性検索でない場合です。属性でしたら通常の"
"インデクスを属性フィールドに追加します)。"

#. Tag: para
#: using_postgis_dataman.xml:1927
#, no-c-format
msgid ""
"The syntax for building a GiST index on a \"geometry\" column is as follows:"
msgstr "GiSTインデクスをジオメトリカラムに追加するための文は次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1930
#, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"
msgstr ""
"CREATE INDEX [インデクス名] ON [テーブル名] USING GIST ( [ジオメトリカラム"
"名] );"

#. Tag: para
#: using_postgis_dataman.xml:1931
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get the an n-dimensional "
"index supported in PostGIS 2.0+ for the geometry type, you can create one "
"using this syntax"
msgstr ""
"上の書式では常に2次元インデクスを構築します。PostGIS 2.0以上で対応しているn次"
"元インデクスをジオメトリタイプで使うには、次の書式で生成できます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1932
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"
msgstr ""
"CREATE INDEX [インデクス名] ON [テーブル名] USING GIST ( [ジオメトリカラム"
"名] gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1934
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive exercise: on tables "
"of around 1 million rows, on a 300MHz Solaris machine, we have found "
"building a GiST index takes about 1 hour. After building an index, it is "
"important to force PostgreSQL to collect table statistics, which are used to "
"optimize query plans:"
msgstr ""
"空間インデクスの構築は、計算量を集中させて行われます。100万行のテーブルで、"
"300MHzのSolaris機ではGiSTインデクスの構築に概ね1時間かかりました。インデクス"
"を構築したあとは、クエリプランの最適化に使うため、次のようにPostgreSQLにテー"
"ブル統計情報の収集をさせることが重要です。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1940 using_postgis_dataman.xml:2023
#, no-c-format
msgid ""
"VACUUM ANALYZE [table_name] [(column_name)];\n"
"-- This is only needed for PostgreSQL 7.4 installations and below\n"
"SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);"
msgstr ""
"VACUUM ANALYZE [テーブル名] [(カラム名)];\n"
"-- 次のクエリはPostgreSQL 7.4以前でのみ必要です\n"
"SELECT UPDATE_GEOMETRY_STATS( [テーブル名], [(カラム名)] );"

#. Tag: para
#: using_postgis_dataman.xml:1942
#, no-c-format
msgid ""
"GiST indexes have two advantages over R-Tree indexes in PostgreSQL. Firstly, "
"GiST indexes are \"null safe\", meaning they can index columns which include "
"null values. Secondly, GiST indexes support the concept of \"lossiness\" "
"which is important when dealing with GIS objects larger than the PostgreSQL "
"8K page size. Lossiness allows PostgreSQL to store only the \"important\" "
"part of an object in an index -- in the case of GIS objects, just the "
"bounding box. GIS objects larger than 8K will cause R-Tree indexes to fail "
"in the process of being built."
msgstr ""
"GiSTインデクスはPostgreSQLのR木インデクスと比べて二つの利点を持っています。ま"
"ず、GiSTインデクスは「NULLセーフ」、すなわちNULL値を含むインデクスカラムで利"
"用できることです。次に、GiSTインデクスはGISオブジェクトがPostgreSQLで8Kのペー"
"ジサイズを超えるサイズを扱う際に重要な「不可逆」の概念を持っていることです。"
"不可逆にすることによって、PostgreSQLは、インデクスにおけるオブジェクトの「重"
"要な」部分、GISオブジェクトの場合にはバウンディングボックスになりますが、これ"
"のみを納めることができます。 R木インデクスで8Kを超えるGISオブジェクトのインデ"
"クスを構築しようとすると、失敗します。"

#. Tag: title
#: using_postgis_dataman.xml:1954
#, fuzzy, no-c-format
msgid "BRIN Indexes"
msgstr "GiSTインデクス"

#. Tag: para
#: using_postgis_dataman.xml:1956
#, no-c-format
msgid ""
"BRIN stands for \"Block Range Index\" and is a generic form of indexing that "
"has been introduced in PostgreSQL 9.5. BRIN is a lossy kind of index, and "
"its main usage is to provide a compromise for both read and write "
"performance. Its primary goal is to handle very large tables for which some "
"of the columns have some natural correlation with their physical location "
"within the table. In addition to GIS indexing, BRIN is used to speed up "
"searches on various kinds of regular or irregular data structures (integer, "
"arrays etc)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1965
#, fuzzy, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields). GiST indexes are really performant as long as their "
"size doesn't exceed the amount of RAM available for the database, and as "
"long as you can afford the storage size, and the penalty in write workload. "
"Otherwise, BRIN index can be considered as an alternative."
msgstr ""
"ひとたびGISデータテーブルが数千行を超えたら、空間検索の速度向上のためインデク"
"スを構築したくなるでしょう (これは属性検索でない場合です。属性でしたら通常の"
"インデクスを属性フィールドに追加します)。"

#. Tag: para
#: using_postgis_dataman.xml:1974
#, no-c-format
msgid ""
"The idea of a BRIN index is to store only the bouding box englobing all the "
"geometries contained in all the rows in a set of table blocks, called a "
"range. Obviously, this indexing method will only be efficient if the data is "
"physically ordered in a way where the resulting bouding boxes for block "
"ranges will be mutually exclusive. The resulting index will be really small, "
"but will be less efficient than a GiST index in many cases."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1982
#, no-c-format
msgid ""
"Building a BRIN index is way less intensive than building a GiST index. It's "
"quite common to build a BRIN index in more than ten time less than a GiST "
"index would have required. As a BRIN index only store one bouding box for "
"one to many table blocks, it's pretty common to consume up to a thousand "
"time less disk space for this kind of indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1988
#, no-c-format
msgid ""
"You can choose the number of blocks to summarize in a range. If you decrease "
"this number, the index will be bigger but will probably help to get better "
"performance."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1992
#, fuzzy, no-c-format
msgid ""
"The syntax for building a BRIN index on a \"geometry\" column is as follows:"
msgstr "GiSTインデクスをジオメトリカラムに追加するための文は次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1995
#, fuzzy, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] );"
msgstr ""
"CREATE INDEX [インデクス名] ON [テーブル名] USING GIST ( [ジオメトリカラム"
"名] );"

#. Tag: para
#: using_postgis_dataman.xml:1996
#, fuzzy, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get a 3d-dimensional "
"index, you can create one using this syntax"
msgstr ""
"上の書式では常に2次元インデクスを構築します。PostGIS 2.0以上で対応しているn次"
"元インデクスをジオメトリタイプで使うには、次の書式で生成できます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:1997
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_3d);"
msgstr ""
"CREATE INDEX [インデクス名] ON [テーブル名] USING GIST ( [ジオメトリカラム"
"名] gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1998
#, no-c-format
msgid "You can also get a 4d-dimensional index using the 4d operator class"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1999
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_4d);"
msgstr ""
"CREATE INDEX [インデクス名] ON [テーブル名] USING GIST ( [ジオメトリカラム"
"名] gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:2000
#, no-c-format
msgid ""
"These above syntaxes will use the default number or block in a range, which "
"is 128. To specify the number of blocks you want to summarise in a range, "
"you can create one using this syntax"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:2001
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] ) WITH "
"(pages_per_range = [number]);"
msgstr ""
"CREATE INDEX [インデクス名] ON [テーブル名] USING GIST ( [ジオメトリカラム"
"名] );"

#. Tag: para
#: using_postgis_dataman.xml:2002
#, no-c-format
msgid ""
"Also, keep in mind that a BRIN index will only store one index value for a "
"large number of rows. If your table stores geometries with a mixed number of "
"dimensions, it's likely that the resulting index will have poor performance. "
"You can avoid this drop of performance by choosing the operator class whith "
"the least number of dimensions of the stored geometries"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2010
#, fuzzy, no-c-format
msgid ""
"Also the \"geography\" datatype is supported for BRIN indexing. The syntax "
"for building a BRIN index on a \"geography\" column is as follows:"
msgstr "GiSTインデクスをジオメトリカラムに追加するための文は次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2013
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geographyfield] );"
msgstr ""
"CREATE INDEX [インデクス名] ON [テーブル名] USING GIST ( [ジオメトリカラム"
"名] );"

#. Tag: para
#: using_postgis_dataman.xml:2014
#, fuzzy, no-c-format
msgid ""
"The above syntax will always build a 2D-index for geospatial objects on the "
"spheroid."
msgstr ""
"上の書式では常に2次元インデクスを構築します。PostGIS 2.0以上で対応しているn次"
"元インデクスをジオメトリタイプで使うには、次の書式で生成できます。"

#. Tag: para
#: using_postgis_dataman.xml:2016
#, no-c-format
msgid ""
"Currently, just the \"inclusion support\" is considered here, meaning that "
"just <varname>&amp;&amp;</varname>, <varname>~</varname> and <varname>@</"
"varname> operators can be used for the 2D cases (both for \"geometry\" and "
"for \"geography\"), and just the <varname>&amp;&amp;&amp;</varname> operator "
"can be used for the 3D geometries. There is no support for kNN searches at "
"the moment."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2027
#, no-c-format
msgid "Using Indexes"
msgstr "インデクスを使う"

#. Tag: para
#: using_postgis_dataman.xml:2029
#, no-c-format
msgid ""
"Ordinarily, indexes invisibly speed up data access: once the index is built, "
"the query planner transparently decides when to use index information to "
"speed up a query plan. Unfortunately, the PostgreSQL query planner does not "
"optimize the use of GiST indexes well, so sometimes searches which should "
"use a spatial index instead default to a sequence scan of the whole table."
msgstr ""
"通常、インデクスは見えないところでデータアクセスの速度向上を行います。すなわ"
"ち、ひとたびインデクスが構築されたら、クエリプランナは透過的に、クエリプラン"
"の速度を向上させるためにインデクス情報を使うべき時を判断します。残念なこと"
"に、PostgreSQLクエリプランナは、GiSTインデクスの使用について十分に最適化でき"
"ず、時々、検索で空間インデクスを使用すべきなのに、テーブル全体を順に走査する"
"ことがあります。"

#. Tag: para
#: using_postgis_dataman.xml:2036
#, no-c-format
msgid ""
"If you find your spatial indexes are not being used (or your attribute "
"indexes, for that matter) there are a couple things you can do:"
msgstr ""
"空間インデクスが使用されていない (または属性インデクスがその問題のために使用"
"されていない)場合、次の二つのことができます。"

#. Tag: para
#: using_postgis_dataman.xml:2042
#, no-c-format
msgid ""
"Firstly, make sure statistics are gathered about the number and "
"distributions of values in a table, to provide the query planner with better "
"information to make decisions around index usage. For PostgreSQL 7.4 "
"installations and below this is done by running "
"<command>update_geometry_stats([table_name, column_name])</command> (compute "
"distribution) and <command>VACUUM ANALYZE [table_name] [column_name]</"
"command> (compute number of values). Starting with PostgreSQL 8.0 running "
"<command>VACUUM ANALYZE</command> will do both operations. You should "
"regularly vacuum your databases anyways -- many PostgreSQL DBAs have "
"<command>VACUUM</command> run as an off-peak cron job on a regular basis."
msgstr ""
"まず、クエリプランナにインデクス使用まわりの判断に利用するためのより良い情報"
"を提供するために、値の数量と分散に関する統計情報が収集されたかを確認してくだ"
"さい。PostgreSQL 7.4以前では、<command>update_geometry_stats([テーブル名], "
"[カラム名])</command> (分散計算)と<command>VACUUM ANALYZE [テーブル名] [カラ"
"ム名]</command> (値の数量の計算)とを実行します。PostgreSQL 8.0については、"
"<command>VACUUM ANALYZE</command>を実行することで同じ動作になります。常に定期"
"的なデータベースへのvacuumを実行すべきです。多くのPostgreSQLのデータベース"
"エージェントは、閑散時のcronジョブとして定期的に<command>VACUUM</command>を実"
"行します。"

#. Tag: para
#: using_postgis_dataman.xml:2056
#, no-c-format
msgid ""
"If vacuuming does not work, you can force the planner to use the index "
"information by using the <command>SET ENABLE_SEQSCAN=OFF</command> command. "
"You should only use this command sparingly, and only on spatially indexed "
"queries: generally speaking, the planner knows better than you do about when "
"to use normal B-Tree indexes. Once you have run your query, you should "
"consider setting <varname>ENABLE_SEQSCAN</varname> back on, so that other "
"queries will utilize the planner as normal."
msgstr ""
"vacuumが働かないなら、<command>SET ENABLE_SEQSCAN=OFF</command>コマンドで、プ"
"ランナにインデクス情報を強制的に使わせることができます。このコマンドは控え目"
"に実行すべきで、かつ、空間インデクスがあるクエリ上でのみ使うべきです。一般的"
"に言うと、通常のB木インデクスを使うべき時に関してあなたが知っていることより"
"も、プランナはより良く知っています。クエリを実行したら、"
"<varname>ENABLE_SEQSCAN</varname>設定を戻して、他のクエリでは通常通りプランナ"
"を使用することを考えるべきです。"

#. Tag: para
#: using_postgis_dataman.xml:2066
#, no-c-format
msgid ""
"As of version 0.6, it should not be necessary to force the planner to use "
"the index with <varname>ENABLE_SEQSCAN</varname>."
msgstr ""
"0.6版では、<varname>ENABLE_SEQSCAN</varname>でプランナにインデクスを強制的に"
"使わせることは重要ではありません。"

#. Tag: para
#: using_postgis_dataman.xml:2073
#, no-c-format
msgid ""
"If you find the planner wrong about the cost of sequential vs index scans "
"try reducing the value of random_page_cost in postgresql.conf or using SET "
"random_page_cost=#. Default value for the parameter is 4, try setting it to "
"1 or 2. Decrementing the value makes the planner more inclined of using "
"Index scans."
msgstr ""
"もし、順に走査する際のコストとインデクスを使う際のコストとを比較してプランナ"
"が間違っていることに気付いたら、postgresql.confでrandom_page_costの値を減らし"
"てみるか、\"SET random_page_cost=#\"を使ってみてください。このパラメータのデ"
"フォルト値は4ですが、それを1か2にしてみて下さい。値を減らすことで、プランナが"
"よりインデクススキャンを行う傾向になります。"

#. Tag: title
#: using_postgis_dataman.xml:2084
#, no-c-format
msgid "Complex Queries"
msgstr "複雑なクエリ"

#. Tag: para
#: using_postgis_dataman.xml:2086
#, fuzzy, no-c-format
msgid ""
"The <emphasis>raison d'etre</emphasis> of spatial database functionality is "
"performing queries inside the database which would ordinarily require "
"desktop GIS functionality. Using PostGIS effectively requires knowing what "
"spatial functions are available, and ensuring that appropriate indexes are "
"in place to provide good performance. The SRID of 312 used in these examples "
"is purely for demonstration. You should be using a REAL SRID listed in the "
"the spatial_ref_sys table and one that matches the projection of your data. "
"If your data has no spatial reference system specified, you should be "
"THINKING very thoughtfully why it doesn't and maybe it should."
msgstr ""
"空間データベース機能の<emphasis>レゾンデートル</emphasis>は、通常はデスクトッ"
"プGISに求める機能を、データベース内部のクエリで実現してすることです。PostGIS"
"を効果的に使用するには、どの空間機能が有効かを知り、また、良好なパフォーマン"
"スを提供する所に適切にインデクスがあることが保証されていることが求められま"
"す。なお、本例ではSRID 312を使っていますが、これは純粋に例として出しているだ"
"けです。spatial_ref_sysテーブルにあり、データの投影法に合致している、本当の"
"SRIDを使ってください。空間参照系を持たないデータについては、なぜ持っていない"
"のか、持つべきなのかも知れないのか、をじっくり*考えてください*。 たとえば分子"
"内部や火星旅行の到達位置といった、定義された空間参照系を持たない場合には、単"
"にSRIDを無視するか、一つ作成して<varname>spatial_ref_sys</varname>テーブルに"
"追加して下さい。"

#. Tag: para
#: using_postgis_dataman.xml:2094
#, no-c-format
msgid ""
"If your reason is because you are modeling something that doesn't have a "
"geographic spatial reference system defined such as the internals of a "
"molecule or the floorplan of a not yet built amusement park then that's "
"fine. If the location of the amusement park has been planned however, then "
"it would make sense to use a suitable planar coordinate system for that "
"location if nothing more than to ensure the amusement part is not "
"trespassing on already existing structures."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2098
#, no-c-format
msgid ""
"Even in the case where you are planning a Mars expedition to transport the "
"human race in the event of a nuclear holocaust and you want to map out the "
"Mars planet for rehabitation, you can use a non-earthly coordinate system "
"such as <ulink url=\"http://spatialreference.org/ref/iau2000/mars-2000/"
"\">Mars 2000</ulink> make one up and insert it in the "
"<varname>spatial_ref_sys</varname> table. Though this Mars coordinate system "
"is a non-planar one (it's in degrees spheroidal), you can use it with the "
"geography type to have your length and proximity measurements in meters "
"instead of degrees."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2104
#, no-c-format
msgid "Taking Advantage of Indexes"
msgstr "インデクスの利点を使う"

#. Tag: para
#: using_postgis_dataman.xml:2106
#, no-c-format
msgid ""
"When constructing a query it is important to remember that only the bounding-"
"box-based operators such as &amp;&amp; can take advantage of the GiST "
"spatial index. Functions such as <varname>ST_Distance()</varname> cannot use "
"the index to optimize their operation. For example, the following query "
"would be quite slow on a large table:"
msgstr ""
"クエリを作成するとき、&amp;&amp;のようなバウンディングボックスを基準とした演"
"算子によってのみGiST空間インデクスの利点が出てくることだけは覚えておくことが"
"重要です。<varname>ST_Distance()</varname>のような関数では演算の最適化を行う"
"ためにインデクスを使うことができません。たとえば、次のクエリでは、大きなテー"
"ブルでは本当に遅くなります。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2113
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) "
"&lt; 100"
msgstr ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) "
"&lt; 100"

#. Tag: para
#: using_postgis_dataman.xml:2115
#, no-c-format
msgid ""
"This query is selecting all the geometries in geom_table which are within "
"100 units of the point (100000, 200000). It will be slow because it is "
"calculating the distance between each point in the table and our specified "
"point, ie. one <varname>ST_Distance()</varname> calculation for each row in "
"the table. We can avoid this by using the &amp;&amp; operator to reduce the "
"number of distance calculations required:"
msgstr ""
"このクエリは、geom_tableにおける (100000, 200000)の点から距離が100単位以内に"
"ある全てのジオメトリを選択します。このクエリでは、テーブル内にあるそれぞれの"
"点と指定した点との距離を計算する、すなわち、それぞれの行で一つの"
"<varname>ST_Distance()</varname>計算を行うため、遅くなるのです。&amp;&amp;演"
"算子を使って、求められる距離計算の量を減らすことで回避できます。次のようにし"
"ます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2122
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, "
"200100,312), 100)"
msgstr ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, "
"200100,312), 100)"

#. Tag: para
#: using_postgis_dataman.xml:2124
#, no-c-format
msgid ""
"This query selects the same geometries, but it does it in a more efficient "
"way. Assuming there is a GiST index on the_geom, the query planner will "
"recognize that it can use the index to reduce the number of rows before "
"calculating the result of the <varname>ST_distance()</varname> function. "
"Notice that the <varname>ST_MakeEnvelope</varname> geometry which is used in "
"the &amp;&amp; operation is a 200 unit square box centered on the original "
"point - this is our \"query box\". The &amp;&amp; operator uses the index to "
"quickly reduce the result set down to only those geometries which have "
"bounding boxes that overlap the \"query box\". Assuming that our query box "
"is much smaller than the extents of the entire geometry table, this will "
"drastically reduce the number of distance calculations that need to be done."
msgstr ""
"このクエリは、同じジオメトリを選択しますが、より効果的な方法で行われます。"
"the_geomにGiSTインデクスがあると仮定すると、クエリプランナは"
"<varname>ST_distance()</varname>関数の結果を計算する前にインデクスを使って行"
"を減らせると認識します。 &amp;&amp;演算子で使われる<varname>ST_MakeEnvelope</"
"varname>ジオメトリが、元のポイントに中央寄せした200単位の正方形です。これは"
"「クエリボックス」です。&amp;&amp;演算子は、結果セットを「クエリボックス」に"
"オーバラップするバウンディングボックスを持つジオメトリだけに素早く減らすため"
"にインデクスを使います。「クエリボックス」がジオメトリテーブル全体の範囲より"
"十分に小さいと仮定すると、行われなければならない距離計算の量は劇的に減少しま"
"す。"

#. Tag: title
#: using_postgis_dataman.xml:2138
#, no-c-format
msgid "Change in Behavior"
msgstr "挙動の変更"

#. Tag: para
#: using_postgis_dataman.xml:2140
#, no-c-format
msgid ""
"As of PostGIS 1.3.0, most of the Geometry Relationship Functions, with the "
"notable exceptions of ST_Disjoint and ST_Relate, include implicit bounding "
"box overlap operators."
msgstr ""
"PostGIS 1.3.0では、ST_DisjointとST_Relateの注目すべき例外がありますが、ほとん"
"どのジオメトリ関係関数は暗黙的なバウンディングボックスオーバラップ演算子を含"
"んでいます。"

#. Tag: title
#: using_postgis_dataman.xml:2147
#, no-c-format
msgid "Examples of Spatial SQL"
msgstr "空間SQLの例"

#. Tag: para
#: using_postgis_dataman.xml:2149
#, no-c-format
msgid ""
"The examples in this section will make use of two tables, a table of linear "
"roads, and a table of polygonal municipality boundaries. The table "
"definitions for the <varname>bc_roads</varname> table is:"
msgstr ""
"本節の例では、線型の道、ポリゴンの自治体境界、の二つのテーブルを使います。"
"テーブルの定義をしまします。<varname>bc_roads</varname>については次の通りで"
"す。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2153
#, no-c-format
msgid ""
"Column      | Type              | Description\n"
"------------+-------------------+-------------------\n"
"gid         | integer           | Unique ID\n"
"name        | character varying | Road Name\n"
"the_geom    | geometry          | Location Geometry (Linestring)"
msgstr ""
"Column      | Type              | Description\n"
"------------+-------------------+-------------------\n"
"gid         | integer           | Unique ID\n"
"name        | character varying | Road Name\n"
"the_geom    | geometry          | Location Geometry (Linestring)"

#. Tag: para
#: using_postgis_dataman.xml:2155
#, no-c-format
msgid ""
"The table definition for the <varname>bc_municipality</varname> table is:"
msgstr ""
"<varname>bc_municipality</varname>テーブルの定義については次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2158
#, no-c-format
msgid ""
"Column     | Type              | Description\n"
"-----------+-------------------+-------------------\n"
"gid        | integer           | Unique ID\n"
"code       | integer           | Unique ID\n"
"name       | character varying | City / Town Name\n"
"the_geom   | geometry          | Location Geometry (Polygon)"
msgstr ""
"Column     | Type              | Description\n"
"-----------+-------------------+-------------------\n"
"gid        | integer           | Unique ID\n"
"code       | integer           | Unique ID\n"
"name       | character varying | City / Town Name\n"
"the_geom   | geometry          | Location Geometry (Polygon)"

#. Tag: para
#: using_postgis_dataman.xml:2163
#, no-c-format
msgid "What is the total length of all roads, expressed in kilometers?"
msgstr "道路の総延長はkm表記でいくらになるでしょう?"

#. Tag: para
#: using_postgis_dataman.xml:2168
#, no-c-format
msgid "You can answer this question with a very simple piece of SQL:"
msgstr "この問題は、次のようなとても単純なSQLで答えを得ることができます。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2171
#, no-c-format
msgid ""
"SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
"\n"
"km_roads\n"
"------------------\n"
"70842.1243039643\n"
"(1 row)"
msgstr ""
"SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
"\n"
"km_roads\n"
"------------------\n"
"70842.1243039643\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2177
#, no-c-format
msgid "How large is the city of Prince George, in hectares?"
msgstr "プリンスジョージ市の大きさはha表記でいくらになるでしょう?"

#. Tag: para
#: using_postgis_dataman.xml:2181
#, no-c-format
msgid ""
"This query combines an attribute condition (on the municipality name) with a "
"spatial calculation (of the area):"
msgstr ""
"このクエリでは、属性条件 (municipality name, 自治体名)に空間計算 (面積)を併用"
"しています。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2185
#, no-c-format
msgid ""
"SELECT\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM bc_municipality\n"
"WHERE name = 'PRINCE GEORGE';\n"
"\n"
"hectares\n"
"------------------\n"
"32657.9103824927\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM bc_municipality\n"
"WHERE name = 'PRINCE GEORGE';\n"
"\n"
"hectares\n"
"------------------\n"
"32657.9103824927\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2191
#, no-c-format
msgid "What is the largest municipality in the province, by area?"
msgstr "県内で最も大きな面積となる自治体はどこでしょう?"

#. Tag: para
#: using_postgis_dataman.xml:2196
#, no-c-format
msgid ""
"This query brings a spatial measurement into the query condition. There are "
"several ways of approaching this problem, but the most efficient is below:"
msgstr ""
"このクエリは、空間計測をクエリ条件に持ってきています。この問題へのアプローチ"
"の方法はいくつかありますが、最も効率的なのは次の通りです。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2200
#, no-c-format
msgid ""
"SELECT\n"
"  name,\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM\n"
"  bc_municipality\n"
"ORDER BY hectares DESC\n"
"LIMIT 1;\n"
"\n"
"name           | hectares\n"
"---------------+-----------------\n"
"TUMBLER RIDGE  | 155020.02556131\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  name,\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM\n"
"  bc_municipality\n"
"ORDER BY hectares DESC\n"
"LIMIT 1;\n"
"\n"
"name           | hectares\n"
"---------------+-----------------\n"
"TUMBLER RIDGE  | 155020.02556131\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2202
#, no-c-format
msgid ""
"Note that in order to answer this query we have to calculate the area of "
"every polygon. If we were doing this a lot it would make sense to add an "
"area column to the table that we could separately index for performance. By "
"ordering the results in a descending direction, and them using the "
"PostgreSQL \"LIMIT\" command we can easily pick off the largest value "
"without using an aggregate function like max()."
msgstr ""
"このクエリの答えを出すためには、全てのポリゴンの面積を求める必要があることに"
"注意して下さい。このクエリを多く実行する場合、性能向上のためにテーブルにarea"
"カラムを追加して、別のインデクスを追加することができるようにするのは、意義の"
"あることです。結果を距離について降順に並べ替え、PostgreSQLの\"LIMIT\"コマンド"
"を用いることで、max()のような集約関数を使わずに、簡単に最も大きい値を集約関数"
"を得ることができます。"

#. Tag: para
#: using_postgis_dataman.xml:2214
#, no-c-format
msgid "What is the length of roads fully contained within each municipality?"
msgstr "各自治体内に含まれる道路の総延長はいくらでしょう?"

#. Tag: para
#: using_postgis_dataman.xml:2219
#, no-c-format
msgid ""
"This is an example of a \"spatial join\", because we are bringing together "
"data from two tables (doing a join) but using a spatial interaction "
"condition (\"contained\") as the join condition rather than the usual "
"relational approach of joining on a common key:"
msgstr ""
"これは、二つのテーブルからデータを持ち込んで (結合して)いるので「空間結合」の"
"例です。しかし、結合の条件として共通キーの上で接続するという普通のリレーショ"
"ンのやり方でなく空間インタラクション条件 (「含む」)を使っています。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2225
#, no-c-format
msgid ""
"SELECT\n"
"  m.name,\n"
"  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  ST_Contains(m.the_geom,r.the_geom)\n"
"GROUP BY m.name\n"
"ORDER BY roads_km;\n"
"\n"
"name                        | roads_km\n"
"----------------------------+------------------\n"
"SURREY                      | 1539.47553551242\n"
"VANCOUVER                   | 1450.33093486576\n"
"LANGLEY DISTRICT            | 833.793392535662\n"
"BURNABY                     | 773.769091404338\n"
"PRINCE GEORGE               | 694.37554369147\n"
"..."
msgstr ""
"SELECT\n"
"  m.name,\n"
"  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  ST_Contains(m.the_geom,r.the_geom)\n"
"GROUP BY m.name\n"
"ORDER BY roads_km;\n"
"\n"
"name                        | roads_km\n"
"----------------------------+------------------\n"
"SURREY                      | 1539.47553551242\n"
"VANCOUVER                   | 1450.33093486576\n"
"LANGLEY DISTRICT            | 833.793392535662\n"
"BURNABY                     | 773.769091404338\n"
"PRINCE GEORGE               | 694.37554369147\n"
"..."

#. Tag: para
#: using_postgis_dataman.xml:2227
#, no-c-format
msgid ""
"This query takes a while, because every road in the table is summarized into "
"the final result (about 250K roads for our particular example table). For "
"smaller overlays (several thousand records on several hundred) the response "
"can be very fast."
msgstr ""
"このクエリは、テーブル内の全ての道路の合計を最終結果 (この例での話ですが約"
"250Kmの道です)にまとめられるので、少し時間がかかります。より小さいオーバレイ "
"(数百の道路で数千のレコード)の場合、応答はもっと早くなりえます。"

#. Tag: para
#: using_postgis_dataman.xml:2236
#, no-c-format
msgid "Create a new table with all the roads within the city of Prince George."
msgstr "プリンスジョージ市内の全ての道路からなるテーブルを作る"

#. Tag: para
#: using_postgis_dataman.xml:2241
#, no-c-format
msgid ""
"This is an example of an \"overlay\", which takes in two tables and outputs "
"a new table that consists of spatially clipped or cut resultants. Unlike the "
"\"spatial join\" demonstrated above, this query actually creates new "
"geometries. An overlay is like a turbo-charged spatial join, and is useful "
"for more exact analysis work:"
msgstr ""
"これは「オーバレイ」の例です。つまり、二つのテーブルを取得して、空間的に切り"
"取られた結果からなる新しいテーブルを出力します。上で示した「空間結合」と違"
"い、このクエリは実際に新しいジオメトリを生成します。生成されたオーバレイは"
"ターボのかかった空間結合みたいなもので、より確かな解析作業に便利です。"

#. Tag: programlisting
#: using_postgis_dataman.xml:2248
#, no-c-format
msgid ""
"CREATE TABLE pg_roads as\n"
"SELECT\n"
"  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
"  ST_Length(r.the_geom) AS rd_orig_length,\n"
"  r.*\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);"
msgstr ""
"CREATE TABLE pg_roads as\n"
"SELECT\n"
"  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
"  ST_Length(r.the_geom) AS rd_orig_length,\n"
"  r.*\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);"

#. Tag: para
#: using_postgis_dataman.xml:2254
#, no-c-format
msgid "What is the length in kilometers of \"Douglas St\" in Victoria?"
msgstr "ビクトリア州の「ダグラス通り」の長さはkm表記でいくらになるでしょう?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2259
#, no-c-format
msgid ""
"SELECT\n"
"  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
"FROM\n"
"  bc_roads r,\n"
"  bc_municipality m\n"
"WHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA'\n"
"        AND ST_Contains(m.the_geom, r.the_geom) ;\n"
"\n"
"kilometers\n"
"------------------\n"
"4.89151904172838\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
"FROM\n"
"  bc_roads r,\n"
"  bc_municipality m\n"
"WHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA'\n"
"        AND ST_Contains(m.the_geom, r.the_geom) ;\n"
"\n"
"kilometers\n"
"------------------\n"
"4.89151904172838\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2265
#, no-c-format
msgid "What is the largest municipality polygon that has a hole?"
msgstr "穴を持つ自治体ポリゴンのうち最も大きいのはどれでしょう?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2270
#, no-c-format
msgid ""
"SELECT gid, name, ST_Area(the_geom) AS area\n"
"FROM bc_municipality\n"
"WHERE ST_NRings(the_geom) &gt; 1\n"
"ORDER BY area DESC LIMIT 1;\n"
"\n"
"gid  | name         | area\n"
"-----+--------------+------------------\n"
"12   | SPALLUMCHEEN | 257374619.430216\n"
"(1 row)"
msgstr ""
"SELECT gid, name, ST_Area(the_geom) AS area\n"
"FROM bc_municipality\n"
"WHERE ST_NRings(the_geom) &gt; 1\n"
"ORDER BY area DESC LIMIT 1;\n"
"\n"
"gid  | name         | area\n"
"-----+--------------+------------------\n"
"12   | SPALLUMCHEEN | 257374619.430216\n"
"(1 row)"

#~ msgid ""
#~ "Examples of the text representations (EWKT) of the extended spatial "
#~ "objects of the features are as follows. The * ones are new in this "
#~ "version of PostGIS:"
#~ msgstr ""
#~ "フィーチャーの拡張空間オブジェクトのテキスト表現 (EKWT)の例は次の通りで"
#~ "す。"

#~ msgid ""
#~ "However they may be registered as a generic geometry column if the column "
#~ "was not defined as a specific type during creation."
#~ msgstr ""
#~ "しかし、 カラムが生成時に特定のタイプで定義されなかった場合には、一般的な"
#~ "ジオメトリカラムとして登録することがあります。"
