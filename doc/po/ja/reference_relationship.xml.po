# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Kayama Yoichi <yoichi.kayama@gmail.com>, 2019
# TERAMOTO Ikuhiro <yellow@affrc.go.jp>, 2021
# Sandro Santilli <strk@kbt.io>, 2022
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2022-11-27 05:42+0000\n"
"PO-Revision-Date: 2022-12-01 10:30+0000\n"
"Last-Translator: Teramoto Ikuhiro <yellow@affrc.go.jp>\n"
"Language-Team: Japanese <https://weblate.osgeo.org/projects/postgis/"
"reference_relationshipxml/ja/>\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14.1\n"

#. Tag: para
#: reference_relationship.xml:5
#, no-c-format
msgid "These functions determine spatial relationships between geometries."
msgstr "これらの関数は、ジオメトリ間の空間的な関係を判定します。"

#. Tag: title
#: reference_relationship.xml:8
#, no-c-format
msgid "Spatial Relationships"
msgstr "空間関係関数"

#. Tag: title
#: reference_relationship.xml:11
#, no-c-format
msgid "Topological Relationships"
msgstr "トポロジ関係関数"

#. Tag: refname
#: reference_relationship.xml:15
#, no-c-format
msgid "ST_3DIntersects"
msgstr "ST_3DIntersects"

#. Tag: refpurpose
#: reference_relationship.xml:17
#, no-c-format
msgid ""
"Tests if two geometries spatially intersect in 3D - only for points, "
"linestrings, polygons, polyhedral surface (area)"
msgstr ""
"二つのジオメトリが3次元空間において空間的にインタセクトするかどうかをテストし"
"ます。ポイント、ラインストリング、ポリゴン、多面体サーフェス (面)についてのみ"
"動作します。"

#. Tag: funcprototype
#: reference_relationship.xml:23
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_3DIntersects</function></funcdef> <paramdef> "
"<type>geometry</type> <parameter>geomA</parameter> </paramdef> <paramdef> "
"<type>geometry</type> <parameter>geomB</parameter> </paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_3DIntersects</function></funcdef> <paramdef> "
"<type>geometry</type> <parameter>geomA</parameter> </paramdef> <paramdef> "
"<type>geometry</type> <parameter>geomB</parameter> </paramdef>"

#. Tag: title
#: reference_relationship.xml:37 reference_relationship.xml:89
#: reference_relationship.xml:282 reference_relationship.xml:359
#: reference_relationship.xml:435 reference_relationship.xml:508
#: reference_relationship.xml:674 reference_relationship.xml:728
#: reference_relationship.xml:795 reference_relationship.xml:872
#: reference_relationship.xml:979 reference_relationship.xml:1022
#: reference_relationship.xml:1162 reference_relationship.xml:1314
#: reference_relationship.xml:1370 reference_relationship.xml:1515
#: reference_relationship.xml:1610 reference_relationship.xml:1671
#: reference_relationship.xml:1727 reference_relationship.xml:1792
#: reference_relationship.xml:1857
#, no-c-format
msgid "Description"
msgstr "説明"

#. Tag: para
#: reference_relationship.xml:38
#, no-c-format
msgid ""
"Overlaps, Touches, Within all imply spatial intersection. If any of the "
"aforementioned returns true, then the geometries also spatially intersect. "
"Disjoint implies false for spatial intersection."
msgstr ""
"オーバラップ、接触、包含は全て、ジオメトリがインタセクトしていることを意味し"
"ています。これらがTRUEを返す場合は、空間的にインタセクトしています。非接続"
"は、空間インタセクトについてFALSEとなります。"

#. Tag: para
#: reference_relationship.xml:42 reference_relationship.xml:554
#: reference_relationship.xml:817 reference_relationship.xml:1619
#: reference_relationship.xml:1679 reference_relationship.xml:1735
#, no-c-format
msgid "&index_aware;"
msgstr "&index_aware;"

#. Tag: para
#: reference_relationship.xml:44
#, no-c-format
msgid "Changed: 3.0.0 SFCGAL backend removed, GEOS backend supports TINs."
msgstr ""
"Changed: 3.0.0 SFCGALバックエンドが削除され、GEOSバックエンドではTINに対応し"
"ました。"

#. Tag: para
#: reference_relationship.xml:45 reference_relationship.xml:1327
#: reference_relationship.xml:1626 reference_relationship.xml:1681
#, no-c-format
msgid "Availability: 2.0.0"
msgstr "Availability: 2.0.0"

#. Tag: para
#: reference_relationship.xml:47 reference_relationship.xml:1621
#: reference_relationship.xml:1682
#, no-c-format
msgid "&Z_support;"
msgstr "&Z_support;"

#. Tag: para
#: reference_relationship.xml:49 reference_relationship.xml:1623
#: reference_relationship.xml:1684
#, no-c-format
msgid "&P_support;"
msgstr "&P_support;"

#. Tag: para
#: reference_relationship.xml:50 reference_relationship.xml:838
#, no-c-format
msgid "&T_support;"
msgstr "&T_support;"

#. Tag: para
#: reference_relationship.xml:51
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM IEC 13249-3: 5.1"
msgstr "&sqlmm_compliant; SQL-MM IEC 13249-3: 5.1"

#. Tag: title
#: reference_relationship.xml:54 reference_relationship.xml:841
#, no-c-format
msgid "Geometry Examples"
msgstr "ジオメトリの例"

#. Tag: programlisting
#: reference_relationship.xml:55
#, no-c-format
msgid ""
"SELECT ST_3DIntersects(pt, line), ST_Intersects(pt, line)\n"
"  FROM (SELECT 'POINT(0 0 2)'::geometry As pt, 'LINESTRING (0 0 1, 0 2 3)'::"
"geometry As line) As foo;\n"
" st_3dintersects | st_intersects\n"
"-----------------+---------------\n"
" f               | t\n"
"(1 row)"
msgstr ""
"SELECT ST_3DIntersects(pt, line), ST_Intersects(pt, line)\n"
"  FROM (SELECT 'POINT(0 0 2)'::geometry As pt, 'LINESTRING (0 0 1, 0 2 3)'::"
"geometry As line) As foo;\n"
" st_3dintersects | st_intersects\n"
"-----------------+---------------\n"
" f               | t\n"
"(1 row)"

#. Tag: title
#: reference_relationship.xml:58
#, no-c-format
msgid "TIN Examples"
msgstr "TINの例"

#. Tag: programlisting
#: reference_relationship.xml:59
#, no-c-format
msgid ""
"SELECT ST_3DIntersects('TIN(((0 0 0,1 0 0,0 1 0,0 0 0)))'::geometry, "
"'POINT(.1 .1 0)'::geometry);\n"
" st_3dintersects\n"
"-----------------\n"
" t"
msgstr ""
"SELECT ST_3DIntersects('TIN(((0 0 0,1 0 0,0 1 0,0 0 0)))'::geometry, "
"'POINT(.1 .1 0)'::geometry);\n"
" st_3dintersects\n"
"-----------------\n"
" t"

#. Tag: title
#: reference_relationship.xml:62 reference_relationship.xml:255
#: reference_relationship.xml:322 reference_relationship.xml:399
#: reference_relationship.xml:483 reference_relationship.xml:646
#: reference_relationship.xml:705 reference_relationship.xml:754
#: reference_relationship.xml:849 reference_relationship.xml:956
#: reference_relationship.xml:999 reference_relationship.xml:1121
#: reference_relationship.xml:1282 reference_relationship.xml:1342
#: reference_relationship.xml:1575 reference_relationship.xml:1636
#: reference_relationship.xml:1694 reference_relationship.xml:1746
#: reference_relationship.xml:1831 reference_relationship.xml:1878
#, no-c-format
msgid "See Also"
msgstr "関連情報"

#. Tag: refname
#: reference_relationship.xml:69
#, no-c-format
msgid "ST_Contains"
msgstr "ST_Contains"

#. Tag: refpurpose
#: reference_relationship.xml:71
#, no-c-format
msgid ""
"Tests if every point of B lies in A, and their interiors have a point in "
"common"
msgstr ""
"Bの全てのポイントがA内にあり、かつ、双方の内部に共有点が存在するかどうかをテ"
"ストします。"

#. Tag: funcprototype
#: reference_relationship.xml:76
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Contains</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Contains</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:91
#, no-c-format
msgid ""
"Returns TRUE if geometry A contains geometry B. A contains B if and only if "
"all points of B lie inside (i.e. in the interior or boundary of) A (or "
"equivalently, no points of B lie in the exterior of A), and the interiors of "
"A and B have at least one point in common."
msgstr ""
"ジオメトリAがジオメトリBを含む場合にはTRUEを返します。AがBを含むというのは、B"
"のポイントの全てがAの内側 (つまりAの内部または境界)にあり (Aの外部にBのポイン"
"トが全くないとも言えます)、かつBの内部の少なくとも一つのポイントがAの内部にあ"
"る場合に限ります。"

#. Tag: para
#: reference_relationship.xml:97
#, no-c-format
msgid ""
"The contains relationship is reflexive: every geometry contains itself. (In "
"contrast, in the <xref linkend=\"ST_ContainsProperly\"/> predicate a "
"geometry does <emphasis>not</emphasis> properly contain itself.) The "
"relationship is antisymmetric: if <code>ST_Contains(A,B) = true</code> and "
"<code>ST_Contains(B,A) = true</code>, then the two geometries must be "
"topologically equal (<code>ST_Equals(A,B) = true</code>)."
msgstr ""
"包含関係は反射関係です。あらゆるジオメトリは自己を包含します (対照的に<xref "
"linkend=\"ST_ContainsProperly\"/>述語内ではジオメトリは確実な包含には"
"<emphasis>なりません</emphasis>)。また、包含関係は非対称です。"
"<code>ST_Contains(A,B) = true</code>かつ<code>ST_Contains(B,A) = true</code>"
"の場合には、二つのジオメトリはトポロジ的に等価です (<code>ST_Equals(A,B) = "
"true</code>)。"

#. Tag: para
#: reference_relationship.xml:104
#, no-c-format
msgid ""
"ST_Contains is the converse of <xref linkend=\"ST_Within\"/>. So, "
"<code>ST_Contains(A,B) = ST_Within(B,A)</code>."
msgstr ""
"ST_Containsは<xref linkend=\"ST_Within\"/>の反対です。<code>ST_Contains(A,B) "
"= ST_Within(B,A)</code>となります。"

#. Tag: para
#: reference_relationship.xml:107
#, no-c-format
msgid ""
"Because the interiors must have a common point, a subtlety of the definition "
"is that polygons and lines do <emphasis>not</emphasis> contain lines and "
"points lying fully in their boundary. For further details see <ulink "
"url=\"http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-"
"spatial.html\">Subtleties of OGC Covers, Contains, Within</ulink>. The <xref "
"linkend=\"ST_Covers\"/> predicate provides a more inclusive relationship."
msgstr ""
"内部が必ず共通の点を持たなければならないので、定義の微妙な点は、ポリゴンとラ"
"インが境界であるラインとポイントを<emphasis>含まない</emphasis>ことです。詳細"
"については、<ulink url=\"http://lin-ear-th-inking.blogspot.com/2007/06/"
"subtleties-of-ogc-covers-spatial.html\">Subtleties of OGC Covers, Contains, "
"Within</ulink>をご覧下さい。<xref linkend=\"ST_Covers\"/>述語は、より包括的な"
"関係を提供します。"

#. Tag: para
#: reference_relationship.xml:113
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_Contains</"
"function>."
msgstr ""
"&index_aware; インデックスの使用を避けるには<function>_ST_Contains</function>"
"関数を使います。"

#. Tag: para
#: reference_relationship.xml:116 reference_relationship.xml:384
#: reference_relationship.xml:462 reference_relationship.xml:683
#: reference_relationship.xml:1035 reference_relationship.xml:1240
#: reference_relationship.xml:1325 reference_relationship.xml:1542
#, no-c-format
msgid "Performed by the GEOS module"
msgstr "GEOSモジュールで実現しています。"

#. Tag: para
#: reference_relationship.xml:117 reference_relationship.xml:821
#, no-c-format
msgid ""
"Enhanced: 2.3.0 Enhancement to PIP short-circuit extended to support "
"MultiPoints with few points. Prior versions only supported point in polygon."
msgstr ""
"Enhanced: 2.3.0 PIP short-circuit (ポリゴンとポイントに限定した高速判定)を少"
"ないポイントからなるマルチポイントに対応することができるよう拡張しました。以"
"前の版ではポリゴンとポイントの組み合わせにだけ対応していました。"

#. Tag: para
#: reference_relationship.xml:120 reference_relationship.xml:307
#: reference_relationship.xml:378 reference_relationship.xml:455
#: reference_relationship.xml:557 reference_relationship.xml:680
#: reference_relationship.xml:739 reference_relationship.xml:1038
#: reference_relationship.xml:1243 reference_relationship.xml:1409
#: reference_relationship.xml:1547
#, no-c-format
msgid ""
"Enhanced: 3.0.0 enabled support for <varname>GEOMETRYCOLLECTION</varname>"
msgstr ""
"Enhanced: 3.0.0 <varname>GEOMETRYCOLLECTION</varname>への対応が可能となりまし"
"た"

#. Tag: para
#: reference_relationship.xml:124 reference_relationship.xml:311
#: reference_relationship.xml:382 reference_relationship.xml:459
#: reference_relationship.xml:1551
#, no-c-format
msgid ""
"Do not use this function with invalid geometries. You will get unexpected "
"results."
msgstr ""
"この関数を不正なジオメトリで呼ばないでください。予期しない結果が返されます。"

#. Tag: para
#: reference_relationship.xml:127 reference_relationship.xml:387
#: reference_relationship.xml:468 reference_relationship.xml:691
#: reference_relationship.xml:829 reference_relationship.xml:1041
#: reference_relationship.xml:1554
#, no-c-format
msgid ""
"NOTE: this is the \"allowable\" version that returns a boolean, not an "
"integer."
msgstr "ご注意: これは論理値を返して整数を返さないのが「許される」版です。"

#. Tag: para
#: reference_relationship.xml:130
#, no-c-format
msgid ""
"&sfs_compliant; s2.1.1.2 // s2.1.13.3 - same as within(geometry B, geometry "
"A)"
msgstr ""
"&sfs_compliant; s2.1.1.2 // s2.1.13.3 - within(geometry B, geometry A)と同じ"

#. Tag: para
#: reference_relationship.xml:132
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.31"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.31"

#. Tag: title
#: reference_relationship.xml:137 reference_relationship.xml:317
#: reference_relationship.xml:394 reference_relationship.xml:475
#: reference_relationship.xml:565 reference_relationship.xml:699
#: reference_relationship.xml:748 reference_relationship.xml:908
#: reference_relationship.xml:994 reference_relationship.xml:1049
#: reference_relationship.xml:1250 reference_relationship.xml:1332
#: reference_relationship.xml:1417 reference_relationship.xml:1564
#: reference_relationship.xml:1630 reference_relationship.xml:1689
#: reference_relationship.xml:1741 reference_relationship.xml:1826
#: reference_relationship.xml:1871
#, no-c-format
msgid "Examples"
msgstr "例"

#. Tag: para
#: reference_relationship.xml:139
#, no-c-format
msgid ""
"<function>ST_Contains</function> returns <varname>TRUE</varname> in the "
"following situations:"
msgstr ""
"次に示す図全てで、<function>ST_Contains</function>は<varname>TRUE</varname>を"
"返します。"

#. Tag: para
#: reference_relationship.xml:151
#, no-c-format
msgid "<varname>LINESTRING</varname> / <varname>MULTIPOINT</varname>"
msgstr "<varname>LINESTRING</varname> / <varname>MULTIPOINT</varname>"

#. Tag: para
#: reference_relationship.xml:161 reference_relationship.xml:1481
#, no-c-format
msgid "<varname>POLYGON</varname> / <varname>POINT</varname>"
msgstr "<varname>POLYGON</varname> / <varname>POINT</varname>"

#. Tag: para
#: reference_relationship.xml:172 reference_relationship.xml:212
#: reference_relationship.xml:243 reference_relationship.xml:1450
#, no-c-format
msgid "<varname>POLYGON</varname> / <varname>LINESTRING</varname>"
msgstr "<varname>POLYGON</varname> / <varname>LINESTRING</varname>"

#. Tag: para
#: reference_relationship.xml:182 reference_relationship.xml:1078
#: reference_relationship.xml:1430 reference_relationship.xml:1440
#, no-c-format
msgid "<varname>POLYGON</varname> / <varname>POLYGON</varname>"
msgstr "<varname>POLYGON</varname> / <varname>POLYGON</varname>"

#. Tag: para
#: reference_relationship.xml:190
#, no-c-format
msgid ""
"<function>ST_Contains</function> returns <varname>FALSE</varname> in the "
"following situations:"
msgstr ""
"次に示す状況では<function>ST_Contains</function>は<varname>FALSE</varname>を"
"返します。"

#. Tag: para
#: reference_relationship.xml:202
#, no-c-format
msgid "<varname>POLYGON</varname> / <varname>MULTIPOINT</varname>"
msgstr "<varname>POLYGON</varname> / <varname>MULTIPOINT</varname>"

#. Tag: para
#: reference_relationship.xml:220
#, no-c-format
msgid ""
"Due to the interior intersection condition <function>ST_Contains</function> "
"returns <varname>FALSE</varname> in the following situations (whereas "
"<function>ST_Covers</function> returns <varname>TRUE</varname>):"
msgstr ""
"次に示す状況にあっては、内部のインタセクトの状態のために "
"(<function>ST_Covers</function>だと<varname>TRUE</varname>を返すの"
"に)<function>ST_Contains</function>は<varname>FALSE</varname>を返します。"

#. Tag: para
#: reference_relationship.xml:233
#, no-c-format
msgid "<varname>LINESTRING</varname> / <varname>POINT</varname>"
msgstr "<varname>LINESTRING</varname> / <varname>POINT</varname>"

#. Tag: programlisting
#: reference_relationship.xml:251
#, no-c-format
msgid ""
"-- A circle within a circle\n"
"SELECT ST_Contains(smallc, bigc) As smallcontainsbig,\n"
"     ST_Contains(bigc,smallc) As bigcontainssmall,\n"
"     ST_Contains(bigc, ST_Union(smallc, bigc)) as bigcontainsunion,\n"
"     ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
"     ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"     ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"       ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"\n"
"-- Result\n"
"  smallcontainsbig | bigcontainssmall | bigcontainsunion | bigisunion | "
"bigcoversexterior | bigcontainsexterior\n"
"------------------+------------------+------------------+------------"
"+-------------------+---------------------\n"
" f                | t                | t                | t          | "
"t        | f\n"
"\n"
"-- Example demonstrating difference between contains and contains properly\n"
"SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
"acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
"   ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
"ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
"FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
"       ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
"       ( ST_Point(1,1) )\n"
"    ) As foo(geomA);\n"
"\n"
"  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba\n"
"--------------+------------+----------------+-------------"
"+-----------------\n"
"ST_Polygon    | t          | f              | f           | f\n"
"ST_LineString | t          | f              | f           | f\n"
"ST_Point      | t          | t              | f           | f"
msgstr ""
"-- 円内の円\n"
"SELECT ST_Contains(smallc, bigc) As smallcontainsbig,\n"
"     ST_Contains(bigc,smallc) As bigcontainssmall,\n"
"     ST_Contains(bigc, ST_Union(smallc, bigc)) as bigcontainsunion,\n"
"     ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
"     ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"     ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"       ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"\n"
"-- 結果\n"
"  smallcontainsbig | bigcontainssmall | bigcontainsunion | bigisunion | "
"bigcoversexterior | bigcontainsexterior\n"
"------------------+------------------+------------------+------------"
"+-------------------+---------------------\n"
" f                | t                | t                | t          | "
"t        | f\n"
"\n"
"-- ST_ContainsとST_ContainsProperlyとの違いを示す例\n"
"SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
"acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
"   ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
"ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
"FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
"       ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
"       ( ST_Point(1,1) )\n"
"    ) As foo(geomA);\n"
"\n"
"  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba\n"
"--------------+------------+----------------+-------------"
"+-----------------\n"
"ST_Polygon    | t          | f              | f           | f\n"
"ST_LineString | t          | f              | f           | f\n"
"ST_Point      | t          | t              | f           | f"

#. Tag: para
#: reference_relationship.xml:256
#, no-c-format
msgid ""
", <xref linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, "
"<xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, "
"<xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:262
#, no-c-format
msgid "ST_ContainsProperly"
msgstr "ST_ContainsProperly"

#. Tag: refpurpose
#: reference_relationship.xml:264
#, no-c-format
msgid "Tests if every point of B lies in the interior of A"
msgstr "Bの全てのポイントがAの内部にあるかをテストします。"

#. Tag: funcprototype
#: reference_relationship.xml:269
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_ContainsProperly</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_ContainsProperly</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:284
#, no-c-format
msgid ""
"Returns <varname>true</varname> if every point of B lies inside A (or "
"equivalently, no point of B lies in the the boundary or exterior of A)."
msgstr ""
"Bの全てのポイントがAの内側にある (もしくは、Aの外部にも境界にもBのポイントが"
"無い)場合に<varname>TRUE</varname>を返します。"

#. Tag: para
#: reference_relationship.xml:287
#, no-c-format
msgid "A does not properly contain itself, but does contain itself."
msgstr "Aは自身を正しく含むことはありませんが、自身を含みます。"

#. Tag: para
#: reference_relationship.xml:288
#, no-c-format
msgid ""
"Every point of the other geometry is a point of this geometry's interior. "
"The DE-9IM Intersection Matrix for the two geometries matches [T**FF*FF*] "
"used in <xref linkend=\"ST_Relate\"/>"
msgstr ""
"他のジオメトリの全てのポイントは、このジオメトリの内部のポイントです。 <xref "
"linkend=\"ST_Relate\"/>で使われるDE-9IMでは[T**FF*FF*]に合致します。"

#. Tag: para
#: reference_relationship.xml:291
#, no-c-format
msgid ""
"A use for this predicate is computing the intersections of a set of "
"geometries with a large polygonal geometry. Since intersection is a fairly "
"slow operation, it can be more efficient to use containsProperly to filter "
"out test geometries which lie fully inside the area. In these cases the "
"intersection is known a priori to be exactly the original test geometry."
msgstr ""
"大きいポリゴンジオメトリでのジオメトリの集合のインタセクションを計算する際に"
"この述語を使います。インタセクションはかなり遅いので、ContainsProperlyを使っ"
"て、対象ジオメトリのうち全体が領域内にあるものを抜き出すことができ、効率的に"
"なります。これらの場面では、インタセクションは確実に元の対象ジオメトリである"
"ことが直感的に分かります。"

#. Tag: para
#: reference_relationship.xml:296
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function "
"<function>_ST_ContainsProperly</function>."
msgstr ""
"&index_aware; インデックスの使用を避けるには<function>_ST_ContainsProperly</"
"function>関数を使います。"

#. Tag: para
#: reference_relationship.xml:300
#, no-c-format
msgid ""
"The advantage of this predicate over <xref linkend=\"ST_Contains\"/> and "
"<xref linkend=\"ST_Intersects\"/> is that it can be computed more "
"efficiently, with no need to compute topology at individual points."
msgstr ""
"この関数は、個々のポイントでトポロジを計算する必要が無く、より効率的に計算で"
"きる点で、<xref linkend=\"ST_Contains\"/>と<xref linkend=\"ST_Intersects\"/>"
"より優れています。"

#. Tag: para
#: reference_relationship.xml:303
#, no-c-format
msgid "Performed by the GEOS module."
msgstr "GEOSモジュールで実現しています。"

#. Tag: para
#: reference_relationship.xml:304
#, no-c-format
msgid "Availability: 1.4.0"
msgstr "Availability: 1.4.0"

#. Tag: programlisting
#: reference_relationship.xml:318
#, no-c-format
msgid ""
"--a circle within a circle\n"
"  SELECT ST_ContainsProperly(smallc, bigc) As smallcontainspropbig,\n"
"  ST_ContainsProperly(bigc,smallc) As bigcontainspropsmall,\n"
"  ST_ContainsProperly(bigc, ST_Union(smallc, bigc)) as "
"bigcontainspropunion,\n"
"  ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
"  ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"  ST_ContainsProperly(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"  FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  --Result\n"
"  smallcontainspropbig | bigcontainspropsmall | bigcontainspropunion | "
"bigisunion | bigcoversexterior | bigcontainsexterior\n"
"------------------+------------------+------------------+------------"
"+-------------------+---------------------\n"
" f                     | t                    | f                    | "
"t          | t                 | f\n"
"\n"
" --example demonstrating difference between contains and contains properly\n"
" SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
"acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
" ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
"ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
" FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
"      ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
"      ( ST_Point(1,1) )\n"
"  ) As foo(geomA);\n"
"\n"
"  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba\n"
"--------------+------------+----------------+-------------"
"+-----------------\n"
"ST_Polygon    | t          | f              | f           | f\n"
"ST_LineString | t          | f              | f           | f\n"
"ST_Point      | t          | t              | f           | f"
msgstr ""
"-- 円内の円\n"
"  SELECT ST_ContainsProperly(smallc, bigc) As smallcontainspropbig,\n"
"  ST_ContainsProperly(bigc,smallc) As bigcontainspropsmall,\n"
"  ST_ContainsProperly(bigc, ST_Union(smallc, bigc)) as "
"bigcontainspropunion,\n"
"  ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
"  ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"  ST_ContainsProperly(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"  FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  -- 結果\n"
"  smallcontainspropbig | bigcontainspropsmall | bigcontainspropunion | "
"bigisunion | bigcoversexterior | bigcontainsexterior\n"
"------------------+------------------+------------------+------------"
"+-------------------+---------------------\n"
" f                     | t                    | f                    | "
"t          | t                 | f\n"
"\n"
" -- ST_ContainsとST_ContainsProperlyとの違いを示す例\n"
" SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
"acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
" ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
"ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
" FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
"      ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
"      ( ST_Point(1,1) )\n"
"  ) As foo(geomA);\n"
"\n"
"  geomtype    | acontainsa | acontainspropa | acontainsba | acontainspropba\n"
"--------------+------------+----------------+-------------"
"+-----------------\n"
"ST_Polygon    | t          | f              | f           | f\n"
"ST_LineString | t          | f              | f           | f\n"
"ST_Point      | t          | t              | f           | f"

#. Tag: para
#: reference_relationship.xml:323
#, no-c-format
msgid ""
", <xref linkend=\"ST_Boundary\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref "
"linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Relate\"/>, <xref "
"linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_Boundary\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref "
"linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Relate\"/>, <xref "
"linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:329
#, no-c-format
msgid "ST_CoveredBy"
msgstr "ST_CoveredBy"

#. Tag: refpurpose
#: reference_relationship.xml:331
#, no-c-format
msgid "Tests if every point of A lies in B"
msgstr "Aの全てのポイントがB内にあるかをテストします。"

#. Tag: funcsynopsis
#: reference_relationship.xml:335
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_CoveredBy</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>boolean <function>ST_CoveredBy</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geogA</"
"parameter></paramdef> <paramdef><type>geography </type> <parameter>geogB</"
"parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_CoveredBy</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>boolean <function>ST_CoveredBy</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geogA</"
"parameter></paramdef> <paramdef><type>geography </type> <parameter>geogB</"
"parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:361
#, no-c-format
msgid ""
"Returns <varname>true</varname> if every point in Geometry/Geography A lies "
"inside (i.e. intersects the interior or boundary of) Geometry/Geography B. "
"Equivalently, tests that no point of A lies outside (in the exterior of) B."
msgstr ""
"ジオメトリ/ジオグラフィAの全ての点がジオメトリ/ジオグラフィBの内側にある (つ"
"まりBの境界か内部とインタセクトする)場合に<varname>TRUE</varname>を返します。"
"AにBの外側にある (Bの外部にある)点が無いかどうかをテストする、と言い換えられ"
"ます。"

#. Tag: para
#: reference_relationship.xml:367
#, no-c-format
msgid ""
"ST_CoveredBy is the converse of <xref linkend=\"ST_Covers\"/>. So, "
"<code>ST_CoveredBy(A,B) = ST_Covers(B,A)</code>."
msgstr ""
"ST_CoveredByは<xref linkend=\"ST_Covers\"/>の反対です。<code>ST_CoveredBy(A,"
"B) = ST_Covers(B,A)</code>となります。"

#. Tag: para
#: reference_relationship.xml:370
#, no-c-format
msgid ""
"Generally this function should be used instead of <xref "
"linkend=\"ST_Within\"/>, since it has a simpler definition which does not "
"have the quirk that \"boundaries are not within their geometry\"."
msgstr ""
"一般に、この関数は<xref linkend=\"ST_Within\"/>の代わりに使います。「境界がジ"
"オメトリの内側に無い」という奇妙な言葉が定義に含まれないためです。"

#. Tag: para
#: reference_relationship.xml:374
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_CoveredBy</"
"function>."
msgstr ""
"&index_aware; インデックスの使用を避けるには<function>_ST_CoveredBy</"
"function>関数を使います。"

#. Tag: para
#: reference_relationship.xml:385 reference_relationship.xml:466
#, no-c-format
msgid "Availability: 1.2.2"
msgstr "Availability: 1.2.2"

#. Tag: para
#: reference_relationship.xml:390 reference_relationship.xml:471
#, no-c-format
msgid "Not an OGC standard, but Oracle has it too."
msgstr "これはOGC標準と違いますがOracleは持っています。"

#. Tag: programlisting
#: reference_relationship.xml:395
#, no-c-format
msgid ""
"--a circle coveredby a circle\n"
"SELECT ST_CoveredBy(smallc,smallc) As smallinsmall,\n"
"  ST_CoveredBy(smallc, bigc) As smallcoveredbybig,\n"
"  ST_CoveredBy(ST_ExteriorRing(bigc), bigc) As exteriorcoveredbybig,\n"
"  ST_Within(ST_ExteriorRing(bigc),bigc) As exeriorwithinbig\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  --Result\n"
" smallinsmall | smallcoveredbybig | exteriorcoveredbybig | exeriorwithinbig\n"
"--------------+-------------------+----------------------"
"+------------------\n"
" t            | t                 | t                    | f\n"
"(1 row)"
msgstr ""
"-- 円に覆われる円\n"
"SELECT ST_CoveredBy(smallc,smallc) As smallinsmall,\n"
"  ST_CoveredBy(smallc, bigc) As smallcoveredbybig,\n"
"  ST_CoveredBy(ST_ExteriorRing(bigc), bigc) As exteriorcoveredbybig,\n"
"  ST_Within(ST_ExteriorRing(bigc),bigc) As exeriorwithinbig\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  -- 結果\n"
" smallinsmall | smallcoveredbybig | exteriorcoveredbybig | exeriorwithinbig\n"
"--------------+-------------------+----------------------"
"+------------------\n"
" t            | t                 | t                    | f\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:400
#, no-c-format
msgid ""
", <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_ExteriorRing\"/>, <xref "
"linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_ExteriorRing\"/>, <xref "
"linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:406
#, no-c-format
msgid "ST_Covers"
msgstr "ST_Covers"

#. Tag: refpurpose
#: reference_relationship.xml:408
#, no-c-format
msgid "Tests if every point of B lies in A"
msgstr "Bの全ての点がA内にあるかをテストします。"

#. Tag: funcsynopsis
#: reference_relationship.xml:412
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_Covers</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>boolean <function>ST_Covers</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geogpolyA</"
"parameter></paramdef> <paramdef><type>geography </type> "
"<parameter>geogpointB</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_Covers</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>boolean <function>ST_Covers</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geogpolyA</"
"parameter></paramdef> <paramdef><type>geography </type> "
"<parameter>geogpointB</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:437
#, no-c-format
msgid ""
"Returns <varname>true</varname> if every point in Geometry/Geography B lies "
"inside (i.e. intersects the interior or boundary of) Geometry/Geography A. "
"Equivalently, tests that no point of B lies outside (in the exterior of) A."
msgstr ""
"ジオメトリ/ジオグラフィBの全てのポイントがジオメトリ/ジオグラフィAの内側にあ"
"る (内部または境界とインタセクトする)場合に<varname>TRUE</varname>を返しま"
"す。Aの外部にBの点が無いことと等価です。"

#. Tag: para
#: reference_relationship.xml:443
#, no-c-format
msgid ""
"ST_Covers is the converse of <xref linkend=\"ST_CoveredBy\"/>. So, "
"<code>ST_Covers(A,B) = ST_CoveredBy(B,A)</code>."
msgstr ""
"ST_Covers は<xref linkend=\"ST_CoveredBy\"/>の逆です。<code>ST_Covers(A,B) = "
"ST_CoveredBy(B,A)</code>となります。"

#. Tag: para
#: reference_relationship.xml:446
#, no-c-format
msgid ""
"Generally this function should be used instead of <xref "
"linkend=\"ST_Contains\"/>, since it has a simpler definition which does not "
"have the quirk that \"geometries do not contain their boundary\"."
msgstr ""
"一般に、この関数は<xref linkend=\"ST_Contains\"/>の代わりに使われるべきもので"
"す。定義が「ジオメトリがその境界を含まない」という奇妙なものになっていないか"
"らです。"

#. Tag: para
#: reference_relationship.xml:451
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_Covers</"
"function>."
msgstr ""
"&index_aware; インデックスの使用を避けるには<function>_ST_Covers</function>関"
"数を使います。"

#. Tag: para
#: reference_relationship.xml:463
#, no-c-format
msgid ""
"Enhanced: 2.4.0 Support for polygon in polygon and line in polygon added for "
"geography type"
msgstr ""
"Enhanced: 2.4.0 ジオグラフィ型を使う形式においてポリゴンの中のポリゴンとポリ"
"ゴンの中のラインストリングへの対応を追加"

#. Tag: para
#: reference_relationship.xml:464 reference_relationship.xml:1544
#, no-c-format
msgid ""
"Enhanced: 2.3.0 Enhancement to PIP short-circuit for geometry extended to "
"support MultiPoints with few points. Prior versions only supported point in "
"polygon."
msgstr ""
"Enhanced: 2.3.0 ジオメトリについて、PIP short-circuit (ポリゴンとポイントに限"
"定した高速判定)を少ないポイントからなるマルチポイントに対応することができるよ"
"う拡張しました。以前の版ではポリゴンとポイントの組み合わせにだけ対応していま"
"した。"

#. Tag: para
#: reference_relationship.xml:465
#, no-c-format
msgid "Availability: 1.5 - support for geography was introduced."
msgstr "Availability: 1.5 - ジオグラフィ対応が導入されました。"

#. Tag: para
#: reference_relationship.xml:476
#, no-c-format
msgid "Geometry example"
msgstr "ジオメトリの例"

#. Tag: programlisting
#: reference_relationship.xml:477
#, no-c-format
msgid ""
"--a circle covering a circle\n"
"SELECT ST_Covers(smallc,smallc) As smallinsmall,\n"
"  ST_Covers(smallc, bigc) As smallcoversbig,\n"
"  ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"  ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  --Result\n"
" smallinsmall | smallcoversbig | bigcoversexterior | bigcontainsexterior\n"
"--------------+----------------+-------------------+---------------------\n"
" t            | f              | t                 | f\n"
"(1 row)"
msgstr ""
"-- 円を覆う円\n"
"SELECT ST_Covers(smallc,smallc) As smallinsmall,\n"
"  ST_Covers(smallc, bigc) As smallcoversbig,\n"
"  ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
"  ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
"FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
"  -- 結果\n"
" smallinsmall | smallcoversbig | bigcoversexterior | bigcontainsexterior\n"
"--------------+----------------+-------------------+---------------------\n"
" t            | f              | t                 | f\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:478
#, no-c-format
msgid "Geeography Example"
msgstr "ジオグラフィの例"

#. Tag: programlisting
#: reference_relationship.xml:479
#, no-c-format
msgid ""
"-- a point with a 300 meter buffer compared to a point, a point and its 10 "
"meter buffer\n"
"SELECT ST_Covers(geog_poly, geog_pt) As poly_covers_pt,\n"
"  ST_Covers(ST_Buffer(geog_pt,10), geog_pt) As buff_10m_covers_cent\n"
"  FROM (SELECT ST_Buffer(ST_GeogFromText('SRID=4326;POINT(-99.327 "
"31.4821)'), 300) As geog_poly,\n"
"        ST_GeogFromText('SRID=4326;POINT(-99.33 31.483)') As geog_pt ) As "
"foo;\n"
"\n"
" poly_covers_pt | buff_10m_covers_cent\n"
"----------------+------------------\n"
" f              | t"
msgstr ""
"-- 300mバッファを持つポイントとポイントとの比較と、10メートルバッファを持つポ"
"イントとポイントとの比較\n"
"SELECT ST_Covers(geog_poly, geog_pt) As poly_covers_pt,\n"
"  ST_Covers(ST_Buffer(geog_pt,10), geog_pt) As buff_10m_covers_cent\n"
"  FROM (SELECT ST_Buffer(ST_GeogFromText('SRID=4326;POINT(-99.327 "
"31.4821)'), 300) As geog_poly,\n"
"        ST_GeogFromText('SRID=4326;POINT(-99.33 31.483)') As geog_pt ) As "
"foo;\n"
"\n"
" poly_covers_pt | buff_10m_covers_cent\n"
"----------------+------------------\n"
" f              | t"

#. Tag: para
#: reference_relationship.xml:484
#, no-c-format
msgid ", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Within\"/>"
msgstr ", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:490
#, no-c-format
msgid "ST_Crosses"
msgstr "ST_Crosses"

#. Tag: refpurpose
#: reference_relationship.xml:492
#, no-c-format
msgid ""
"Tests if two geometries have some, but not all, interior points in common"
msgstr ""
"二つのジオメトリが内部に共有ポイントを持ち、かつそれだけにならないようになっ"
"ているかテストします。"

#. Tag: funcprototype
#: reference_relationship.xml:497
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Crosses</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Crosses</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:510
#, no-c-format
msgid ""
"Compares two geometry objects and returns <varname>true</varname> if their "
"intersection \"spatially cross\", that is, the geometries have some, but not "
"all interior points in common. The intersection of the interiors of the "
"geometries must be non-empty and must have dimension less than the maximum "
"dimension of the two input geometries. Additionally, the intersection of the "
"two geometries must not equal either of the source geometries. Otherwise, it "
"returns <varname>false</varname>."
msgstr ""
"二つのジオメトリを比較して、共有部が「空間的にクロスしている」場合には"
"<varname>true</varname>を返します。二つのジオメトリの内部の全部でない一部が共"
"有されている、という意味です。二つのジオメトリの内部の共有部は空であってはな"
"らず、二つの入力ジオメトリの最大次元より小さい次元でなければなりません。さら"
"に、二つのジオメトリの共有部は入力ジオメトリの一方とでも同じであってなりませ"
"ん。これらの条件に合わない場合には <varname>false</varname>を返します。"

#. Tag: para
#: reference_relationship.xml:519
#, no-c-format
msgid "In mathematical terms, this is:"
msgstr "数学的に述べると、次のようになります。"

#. Tag: para
#: reference_relationship.xml:529
#, no-c-format
msgid "Geometries cross if their DE-9IM Intersection Matrix matches:"
msgstr ""
"DE-9IMインタセクション行列が次の通り合致するとジオメトリはクロスしています。"

#. Tag: para
#: reference_relationship.xml:533
#, no-c-format
msgid ""
"<code>T*T******</code> for Point/Line, Point/Area, and Line/Area situations"
msgstr "Point/Line, Point/Area, Line/Areaの場合には<code>T*T******</code>"

#. Tag: para
#: reference_relationship.xml:537
#, no-c-format
msgid ""
"<code>T*****T**</code> for Line/Point, Area/Point, and Area/Line situations"
msgstr "Line/Point, Area/Point, Area/Lineの場合には<code>T*****T**</code>"

#. Tag: para
#: reference_relationship.xml:541
#, no-c-format
msgid "<code>0********</code> for Line/Line situations"
msgstr "Line/Lineの場合には<code>0********</code>"

#. Tag: para
#: reference_relationship.xml:545
#, no-c-format
msgid ""
"For Point/Point and Area/Area situations this predicate returns "
"<varname>false</varname>."
msgstr ""
"Point/PointとArea/Areaの場合には、この述語は<varname>FALSE</varname>を返しま"
"す。"

#. Tag: para
#: reference_relationship.xml:548
#, no-c-format
msgid ""
"The OpenGIS Simple Features Specification defines this predicate only for "
"Point/Line, Point/Area, Line/Line, and Line/Area situations. JTS / GEOS "
"extends the definition to apply to Line/Point, Area/Point and Area/Line "
"situations as well. This makes the relation symmetric."
msgstr ""
"OpenGIS Simple Feature Specificationでは、この述語はPoint/Line, Point/Area, "
"Line/Line, Line/Areaの場合についてのみ定義されています。JTS/GEOSでは、Line/"
"Point, Area/Point, Area/Lineについて拡張しています。これによって関係が対称に"
"なっています。"

#. Tag: para
#: reference_relationship.xml:560
#, no-c-format
msgid "&sfs_compliant; s2.1.13.3"
msgstr "&sfs_compliant; s2.1.13.3"

#. Tag: para
#: reference_relationship.xml:561
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.29"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.29"

#. Tag: para
#: reference_relationship.xml:567
#, no-c-format
msgid "The following situations all return <varname>true</varname>."
msgstr "次の場合には全て<varname>TRUE</varname>を返します。"

#. Tag: para
#: reference_relationship.xml:579
#, no-c-format
msgid "<varname>MULTIPOINT</varname> / <varname>LINESTRING</varname>"
msgstr "<varname>MULTIPOINT</varname> / <varname>LINESTRING</varname>"

#. Tag: para
#: reference_relationship.xml:589
#, no-c-format
msgid "<varname>MULTIPOINT</varname> / <varname>POLYGON</varname>"
msgstr "<varname>MULTIPOINT</varname> / <varname>POLYGON</varname>"

#. Tag: para
#: reference_relationship.xml:601
#, no-c-format
msgid "<varname>LINESTRING</varname> / <varname>POLYGON</varname>"
msgstr "<varname>LINESTRING</varname> / <varname>POLYGON</varname>"

#. Tag: para
#: reference_relationship.xml:611 reference_relationship.xml:1070
#: reference_relationship.xml:1461 reference_relationship.xml:1471
#, no-c-format
msgid "<varname>LINESTRING</varname> / <varname>LINESTRING</varname>"
msgstr "<varname>LINESTRING</varname> / <varname>LINESTRING</varname>"

#. Tag: para
#: reference_relationship.xml:619
#, no-c-format
msgid ""
"Consider a situation where a user has two tables: a table of roads and a "
"table of highways."
msgstr ""
"roads (道路)とhighways (高速道路)の2つのテーブルを持っている場面を考えます。"

#. Tag: programlisting
#: reference_relationship.xml:627
#, no-c-format
msgid ""
"CREATE TABLE roads (\n"
"  id serial NOT NULL,\n"
"  geom geometry,\n"
"  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
");"
msgstr ""
"CREATE TABLE roads (\n"
"  id serial NOT NULL,\n"
"  geom geometry,\n"
"  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
");"

#. Tag: programlisting
#: reference_relationship.xml:631
#, no-c-format
msgid ""
"CREATE TABLE highways (\n"
"  id serial NOT NULL,\n"
"  the_gem geometry,\n"
"  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
");"
msgstr ""
"CREATE TABLE highways (\n"
"  id serial NOT NULL,\n"
"  the_gem geometry,\n"
"  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
");"

#. Tag: para
#: reference_relationship.xml:638
#, no-c-format
msgid ""
"To determine a list of roads that cross a highway, use a query similiar to:"
msgstr ""
"次のようなクエリを使って、highwayとクロスするroadsのリストを決定します。"

#. Tag: programlisting
#: reference_relationship.xml:642
#, no-c-format
msgid ""
"SELECT roads.id\n"
"FROM roads, highways\n"
"WHERE ST_Crosses(roads.geom, highways.geom);"
msgstr ""
"SELECT roads.id\n"
"FROM roads, highways\n"
"WHERE ST_Crosses(roads.geom, highways.geom);"

#. Tag: para
#: reference_relationship.xml:648
#, no-c-format
msgid ", <xref linkend=\"ST_Overlaps\"/>"
msgstr ", <xref linkend=\"ST_Overlaps\"/>"

#. Tag: refname
#: reference_relationship.xml:654
#, no-c-format
msgid "ST_Disjoint"
msgstr "ST_Disjoint"

#. Tag: refpurpose
#: reference_relationship.xml:656
#, no-c-format
msgid "Tests if two geometries have no points in common"
msgstr "二つのジオメトリが共有点を持たないようになっているかテストします。"

#. Tag: funcprototype
#: reference_relationship.xml:660
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Disjoint</function></funcdef> <paramdef> "
"<type>geometry</type> <parameter>A</parameter> </paramdef> <paramdef> "
"<type>geometry</type> <parameter>B</parameter> </paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Disjoint</function></funcdef> <paramdef> "
"<type>geometry</type> <parameter>A</parameter> </paramdef> <paramdef> "
"<type>geometry</type> <parameter>B</parameter> </paramdef>"

#. Tag: para
#: reference_relationship.xml:675
#, no-c-format
msgid ""
"Overlaps, Touches, Within all imply geometries are not spatially disjoint. "
"If any of the aforementioned returns true, then the geometries are not "
"spatially disjoint. Disjoint implies false for spatial intersection."
msgstr ""
"オーバラップ、接触、包含は全て、ジオメトリが非接続でないことを意味していま"
"す。これらがTRUEを返す場合は、空間的に非接続ではありません。非接続は、空間イ"
"ンタセクトについてFALSEとなります。"

#. Tag: para
#: reference_relationship.xml:685
#, no-c-format
msgid ""
"This function call does not use indexes. A negated <xref "
"linkend=\"ST_Intersects\"/> predicate can be used as a more performant "
"alternative that uses indexes: <code>ST_Disjoint(A,B) = NOT ST_Intersects(A,"
"B)</code>"
msgstr ""
"この関数呼び出しはインデックスを使いません。<xref linkend=\"ST_Intersects\"/>"
"の否定には、インデックスを使用する、より効率の良い選択肢を使うことができます:"
" <code>ST_Disjoint(A,B) = NOT ST_Intersects(A,B)</code>"

#. Tag: para
#: reference_relationship.xml:694
#, no-c-format
msgid "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - a.Relate(b, 'FF*FF****')"
msgstr "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - a.Relate(b, 'FF*FF****')"

#. Tag: para
#: reference_relationship.xml:696
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.26"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.26"

#. Tag: programlisting
#: reference_relationship.xml:701
#, no-c-format
msgid ""
"SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
"geometry);\n"
" st_disjoint\n"
"---------------\n"
" t\n"
"(1 row)\n"
"SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
"geometry);\n"
" st_disjoint\n"
"---------------\n"
" f\n"
"(1 row)"
msgstr ""
"SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
"geometry);\n"
" st_disjoint\n"
"---------------\n"
" t\n"
"(1 row)\n"
"SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
"geometry);\n"
" st_disjoint\n"
"---------------\n"
" f\n"
"(1 row)"

#. Tag: refname
#: reference_relationship.xml:712
#, no-c-format
msgid "ST_Equals"
msgstr "ST_Equals"

#. Tag: refpurpose
#: reference_relationship.xml:714
#, no-c-format
msgid "Tests if two geometries include the same set of points"
msgstr "二つのジオメトリが同じ点集合になっているかテストします。"

#. Tag: funcprototype
#: reference_relationship.xml:719
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Equals</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Equals</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:730
#, no-c-format
msgid ""
"Returns <varname>true</varname> if the given geometries are \"spatially "
"equal\". Use this for a 'better' answer than '='. Note by spatially equal we "
"mean ST_Within(A,B) = true and ST_Within(B,A) = true and also mean ordering "
"of points can be different but represent the same geometry structure. To "
"verify the order of points is consistent, use ST_OrderingEquals (it must be "
"noted ST_OrderingEquals is a little more stringent than simply verifying "
"order of points are the same)."
msgstr ""
"与えられたジオメトリ表現が「空間的に同じ」場合には<varname>TRUE</varname>を返"
"します。'='よりも「よりよい」答を得るために使います。空間的に同じということ"
"は、ST_Within(A,B) = trueかつST_Within(B,A) = trueとなります。また、ポイント"
"の順序が違っても同じジオメトリ構造ならtrueとなります。構成ポイントの順序の確"
"認にはST_OrderingEqualsを使用します (ST_OrderingEqualsはポイントのオーダが同"
"じかを確認するよりも若干厳しくなります)。"

#. Tag: para
#: reference_relationship.xml:742
#, no-c-format
msgid "&sfs_compliant; s2.1.1.2"
msgstr "&sfs_compliant; s2.1.1.2"

#. Tag: para
#: reference_relationship.xml:743
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.24"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.24"

#. Tag: para
#: reference_relationship.xml:744
#, no-c-format
msgid ""
"Changed: 2.2.0 Returns true even for invalid geometries if they are binary "
"equal"
msgstr ""
"Changed: 2.2.0 この関数は、どちらのジオメトリも不正であっても、バイナリで同じ"
"場合ならTRUEを返します。"

#. Tag: programlisting
#: reference_relationship.xml:750
#, no-c-format
msgid ""
"SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_equals\n"
"-----------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT ST_Equals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_equals\n"
"-----------\n"
" t\n"
"(1 row)"
msgstr ""
"SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_equals\n"
"-----------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT ST_Equals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_equals\n"
"-----------\n"
" t\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:756
#, no-c-format
msgid ""
", <xref linkend=\"ST_OrderingEquals\"/>, <xref linkend=\"ST_Reverse\"/>, "
"<xref linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_OrderingEquals\"/>, <xref linkend=\"ST_Reverse\"/>, "
"<xref linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:764
#, no-c-format
msgid "ST_Intersects"
msgstr "ST_Intersects"

#. Tag: refpurpose
#: reference_relationship.xml:766
#, no-c-format
msgid ""
"Tests if two geometries intersect (they have at least one point in common)"
msgstr ""
"二つのジオメトリがインタセクトしている (少なくとも一つの共有点がある)かどうか"
"テストします。"

#. Tag: funcsynopsis
#: reference_relationship.xml:769
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_Intersects</function></"
"funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
"paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
"paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
"<function>ST_Intersects</function></funcdef> <paramdef> <type>geography</"
"type> <parameter>geogA</parameter> </paramdef> <paramdef> <type>geography</"
"type> <parameter>geogB</parameter> </paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_Intersects</function></"
"funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
"paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
"paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
"<function>ST_Intersects</function></funcdef> <paramdef> <type>geography</"
"type> <parameter>geogA</parameter> </paramdef> <paramdef> <type>geography</"
"type> <parameter>geogB</parameter> </paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:796
#, no-c-format
msgid ""
"Compares two geometries and returns <varname>true</varname> if they "
"intersect. Geometries intersect if they have any point in common."
msgstr ""
"二つのジオメトリを比較して、インタセクトしている場合には<varname>TRUE</"
"varname>を返します。ジオメトリが共有部分を持っている場合にはインタセクトして"
"いることになります。"

#. Tag: para
#: reference_relationship.xml:800
#, no-c-format
msgid ""
"For geography, a distance tolerance of 0.00001 meters is used (so points "
"that are very close are considered to intersect)."
msgstr ""
"ジオグラフィに対しては、0.00001メートルの距離許容値が使われます (このため非常"
"に近いポイントはインタセクトしているとみなされます)。"

#. Tag: para
#: reference_relationship.xml:804
#, no-c-format
msgid ""
"Geometries intersect if their DE-9IM Intersection Matrix matches one of:"
msgstr ""
"DE-9IMインタセクション行列が次の通り合致するとジオメトリはインタセクトしてい"
"ます。"

#. Tag: code
#: reference_relationship.xml:808
#, no-c-format
msgid "T********"
msgstr "T********"

#. Tag: code
#: reference_relationship.xml:809
#, no-c-format
msgid "*T*******"
msgstr "*T*******"

#. Tag: code
#: reference_relationship.xml:810
#, no-c-format
msgid "***T*****"
msgstr "***T*****"

#. Tag: code
#: reference_relationship.xml:811
#, no-c-format
msgid "****T****"
msgstr "****T****"

#. Tag: para
#: reference_relationship.xml:814
#, no-c-format
msgid ""
"Spatial intersection is implied by all the other spatial relationship tests, "
"except <xref linkend=\"ST_Disjoint\"/>, which tests that geometries do NOT "
"intersect."
msgstr ""
"空間的なインタセクションは全ての他の空間関係テスト関数に含まれます。例外は"
"<xref linkend=\"ST_Disjoint\"/>で、全てのジオメトリがインタセクトしていないか"
"どうかをテストすることになります。"

#. Tag: para
#: reference_relationship.xml:819
#, no-c-format
msgid ""
"Changed: 3.0.0 SFCGAL version removed and native support for 2D TINS added."
msgstr ""
"Changed: 3.0.0 SFCGAL版を削除し、2次元TINのネイティブ対応を追加しました。"

#. Tag: para
#: reference_relationship.xml:820
#, no-c-format
msgid "Enhanced: 2.5.0 Supports GEOMETRYCOLLECTION."
msgstr "Enhanced: 2.5.0 ジオメトリコレクションに対応しました。"

#. Tag: para
#: reference_relationship.xml:822
#, no-c-format
msgid "Performed by the GEOS module (for geometry), geography is native"
msgstr ""
"ジオメトリについては、GEOSモジュールで実現しています。ジオグラフィについては"
"ネイティブです。"

#. Tag: para
#: reference_relationship.xml:823
#, no-c-format
msgid "Availability: 1.5 support for geography was introduced."
msgstr "Availability: 1.5 ジオグラフィ対応が導入されました。"

#. Tag: para
#: reference_relationship.xml:825
#, no-c-format
msgid ""
"For geography, this function has a distance tolerance of about 0.00001 "
"meters and uses the sphere rather than spheroid calculation."
msgstr ""
"ジオグラフィでは、この関数は0.00001メートルの距離許容を持ち、回転楕円体計算で"
"なく球面を使います。"

#. Tag: para
#: reference_relationship.xml:832
#, no-c-format
msgid ""
"&sfs_compliant; s2.1.1.2 //s2.1.13.3 - ST_Intersects(g1, g2 ) --&gt; Not "
"(ST_Disjoint(g1, g2 ))"
msgstr ""
"&sfs_compliant; s2.1.1.2 //s2.1.13.3 - ST_Intersects(g1, g2 ) --&gt; Not "
"(ST_Disjoint(g1, g2 ))"

#. Tag: para
#: reference_relationship.xml:835
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.27"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.27"

#. Tag: para
#: reference_relationship.xml:836
#, no-c-format
msgid "&curve_support;"
msgstr "&curve_support;"

#. Tag: programlisting
#: reference_relationship.xml:842
#, no-c-format
msgid ""
"SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
"geometry);\n"
" st_intersects\n"
"---------------\n"
" f\n"
"(1 row)\n"
"SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
"geometry);\n"
" st_intersects\n"
"---------------\n"
" t\n"
"(1 row)\n"
"\n"
"-- Look up in table. Make sure table has a GiST index on geometry column for "
"faster lookup.\n"
"SELECT id, name FROM cities WHERE ST_Intersects(geom, 'SRID=4326;POLYGON((28 "
"53,27.707 52.293,27 52,26.293 52.293,26 53,26.293 53.707,27 54,27.707 "
"53.707,28 53))');\n"
" id | name\n"
"----+-------\n"
"  2 | Minsk\n"
"(1 row)"
msgstr ""
"SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
"geometry);\n"
" st_intersects\n"
"---------------\n"
" f\n"
"(1 row)\n"
"SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
"geometry);\n"
" st_intersects\n"
"---------------\n"
" t\n"
"(1 row)\n"
"\n"
"-- テーブルで検索を行いますテーブルのジオメトリカラムに高速検索のためGiSTイン"
"デックスを貼っています。\n"
"SELECT id, name FROM cities WHERE ST_Intersects(geom, 'SRID=4326;POLYGON((28 "
"53,27.707 52.293,27 52,26.293 52.293,26 53,26.293 53.707,27 54,27.707 "
"53.707,28 53))');\n"
" id | name\n"
"----+-------\n"
"  2 | Minsk\n"
"(1 row)"

#. Tag: title
#: reference_relationship.xml:845
#, no-c-format
msgid "Geography Examples"
msgstr "ジオグラフィの例"

#. Tag: programlisting
#: reference_relationship.xml:846
#, no-c-format
msgid ""
"SELECT ST_Intersects(\n"
"    'SRID=4326;LINESTRING(-43.23456 72.4567,-43.23456 72.4568)'::geography,\n"
"    'SRID=4326;POINT(-43.23456 72.4567772)'::geography\n"
"    );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"
msgstr ""
"SELECT ST_Intersects(\n"
"    'SRID=4326;LINESTRING(-43.23456 72.4567,-43.23456 72.4568)'::geography,\n"
"    'SRID=4326;POINT(-43.23456 72.4567772)'::geography\n"
"    );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: para
#: reference_relationship.xml:850
#, no-c-format
msgid ", <xref linkend=\"ST_3DIntersects\"/>, <xref linkend=\"ST_Disjoint\"/>"
msgstr ", <xref linkend=\"ST_3DIntersects\"/>, <xref linkend=\"ST_Disjoint\"/>"

#. Tag: refname
#: reference_relationship.xml:856
#, no-c-format
msgid "ST_LineCrossingDirection"
msgstr "ST_LineCrossingDirection"

#. Tag: refpurpose
#: reference_relationship.xml:858
#, no-c-format
msgid "Returns a number indicating the crossing behavior of two LineStrings"
msgstr "二つのラインストリングがどのように交差しているかを示す数字を返します。"

#. Tag: funcprototype
#: reference_relationship.xml:863
#, no-c-format
msgid ""
"<funcdef>integer <function>ST_LineCrossingDirection</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>linestringA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>linestringB</"
"parameter></paramdef>"
msgstr ""
"<funcdef>integer <function>ST_LineCrossingDirection</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>linestringA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>linestringB</"
"parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:874
#, no-c-format
msgid ""
"Given two linestrings returns an integer between -3 and 3 indicating what "
"kind of crossing behavior exists between them. 0 indicates no crossing. This "
"is only supported for <varname>LINESTRING</varname>s."
msgstr ""
"二つのラインストリングを与えると、-3から3までの整数が返ります。この整数は、ど"
"のようにクロスしているかを示すもので、0は交差無しを意味します。この関数は"
"<varname>LINESTRING</varname>にのみ対応しています。"

#. Tag: para
#: reference_relationship.xml:879
#, no-c-format
msgid "The crossing number has the following meaning:"
msgstr "交差の番号は次の通りです。"

#. Tag: para
#: reference_relationship.xml:882
#, no-c-format
msgid "0: LINE NO CROSS"
msgstr "0: クロスが無い"

#. Tag: para
#: reference_relationship.xml:885
#, no-c-format
msgid "-1: LINE CROSS LEFT"
msgstr "-1: 左クロス"

#. Tag: para
#: reference_relationship.xml:888
#, no-c-format
msgid "1: LINE CROSS RIGHT"
msgstr "1: 右クロス"

#. Tag: para
#: reference_relationship.xml:891
#, no-c-format
msgid "-2: LINE MULTICROSS END LEFT"
msgstr "-2: 複数クロスで最後が左"

#. Tag: para
#: reference_relationship.xml:894
#, no-c-format
msgid "2: LINE MULTICROSS END RIGHT"
msgstr "2: 複数クロスで最後が右"

#. Tag: para
#: reference_relationship.xml:897
#, no-c-format
msgid "-3: LINE MULTICROSS END SAME FIRST LEFT"
msgstr "-3: 複数クロスで開始終了ともに左"

#. Tag: para
#: reference_relationship.xml:900
#, no-c-format
msgid "3: LINE MULTICROSS END SAME FIRST RIGHT"
msgstr "3: 複数クロスで開始終了ともに右"

#. Tag: para
#: reference_relationship.xml:904
#, no-c-format
msgid "Availability: 1.4"
msgstr "Availability: 1.4"

#. Tag: para
#: reference_relationship.xml:910
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Example:</emphasis> LINE CROSS LEFT and LINE CROSS "
"RIGHT"
msgstr "<emphasis role=\"bold\">例:</emphasis> 左クロスと右クロス"

#. Tag: para
#: reference_relationship.xml:918 reference_relationship.xml:931
#: reference_relationship.xml:944
#, no-c-format
msgid "Blue: Line A; Green: Line B"
msgstr "青: ライン A、緑: ライン B"

#. Tag: programlisting
#: reference_relationship.xml:921
#, no-c-format
msgid ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
"  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
"  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"        -1 |         1"
msgstr ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
"  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
"  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"        -1 |         1"

#. Tag: para
#: reference_relationship.xml:923
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Example:</emphasis> LINE MULTICROSS END SAME FIRST "
"LEFT and LINE MULTICROSS END SAME FIRST RIGHT"
msgstr ""
"<emphasis role=\"bold\">例:</emphasis> 複数回クロスで開始終了ともに左と、複数"
"回クロスで開始終了ともに右"

#. Tag: programlisting
#: reference_relationship.xml:934
#, no-c-format
msgid ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
" ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
" ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"         3 |        -3"
msgstr ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
" ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
" ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"         3 |        -3"

#. Tag: para
#: reference_relationship.xml:936
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Example:</emphasis> LINE MULTICROSS END LEFT and "
"LINE MULTICROSS END RIGHT"
msgstr ""
"<emphasis role=\"bold\">例:</emphasis> 複数回クロスで最後が左と複数回クロスで"
"最後が右"

#. Tag: programlisting
#: reference_relationship.xml:947
#, no-c-format
msgid ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
"  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
"  ST_GeomFromText('LINESTRING(5 90, 71 74, 20 140, 171 154)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"        -2 |         2"
msgstr ""
"SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
"       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
"FROM (SELECT\n"
"  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
"  ST_GeomFromText('LINESTRING(5 90, 71 74, 20 140, 171 154)') As lineB\n"
"  ) As foo;\n"
"\n"
" A_cross_B | B_cross_A\n"
"-----------+-----------\n"
"        -2 |         2"

#. Tag: para
#: reference_relationship.xml:949
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Example:</emphasis> Finds all streets that cross"
msgstr "<emphasis role=\"bold\">例:</emphasis> 全てのクロスするストリートを見つける"

#. Tag: programlisting
#: reference_relationship.xml:952
#, no-c-format
msgid ""
"SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.geom, s2.geom)\n"
"  FROM streets s1 CROSS JOIN streets s2\n"
"         ON (s1.gid != s2.gid AND s1.geom &amp;&amp; s2.geom )\n"
"WHERE ST_LineCrossingDirection(s1.geom, s2.geom) > 0;"
msgstr ""
"SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.geom, s2.geom)\n"
"  FROM streets s1 CROSS JOIN streets s2\n"
"         ON (s1.gid != s2.gid AND s1.geom &amp;&amp; s2.geom )\n"
"WHERE ST_LineCrossingDirection(s1.geom, s2.geom) > 0;"

#. Tag: refname
#: reference_relationship.xml:963
#, no-c-format
msgid "ST_OrderingEquals"
msgstr "ST_OrderingEquals"

#. Tag: refpurpose
#: reference_relationship.xml:965
#, no-c-format
msgid ""
"Tests if two geometries represent the same geometry and have points in the "
"same directional order"
msgstr ""
"二つのジオメトリが同じジオメトリを表現し、かつ点の並び順が同じかどうかをテス"
"トします。"

#. Tag: funcprototype
#: reference_relationship.xml:970
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_OrderingEquals</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_OrderingEquals</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:981
#, no-c-format
msgid ""
"ST_OrderingEquals compares two geometries and returns t (TRUE) if the "
"geometries are equal and the coordinates are in the same order; otherwise it "
"returns f (FALSE)."
msgstr ""
"ST_OrderingEqualsは、二つのジオメトリを比較して、ジオメトリが同じで、座標値が"
"同じ順序である場合には、t (TRUE)を返し、それ以外の場合には、f (FALSE)を返しま"
"す。"

#. Tag: para
#: reference_relationship.xml:986
#, no-c-format
msgid ""
"This function is implemented as per the ArcSDE SQL specification rather than "
"SQL-MM. http://edndoc.esri.com/arcsde/9.1/sql_api/sqlapi3."
"htm#ST_OrderingEquals"
msgstr ""
"この関数は、SQL-MM仕様ではなくArcSDE SQL仕様に従って実装しています。http://"
"edndoc.esri.com/arcsde/9.1/sql_api/sqlapi3.htm#ST_OrderingEqualsをご覧くださ"
"い。"

#. Tag: para
#: reference_relationship.xml:990
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.43"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.43"

#. Tag: programlisting
#: reference_relationship.xml:996
#, no-c-format
msgid ""
"SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT ST_OrderingEquals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 "
"10)')),\n"
"    ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" f\n"
"(1 row)"
msgstr ""
"SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
"    ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT ST_OrderingEquals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 "
"10)')),\n"
"    ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
" st_orderingequals\n"
"-----------\n"
" f\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:1000
#, no-c-format
msgid ", <xref linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Reverse\"/>"
msgstr ", <xref linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Reverse\"/>"

#. Tag: refname
#: reference_relationship.xml:1006
#, no-c-format
msgid "ST_Overlaps"
msgstr "ST_Overlaps"

#. Tag: refpurpose
#: reference_relationship.xml:1008
#, no-c-format
msgid ""
"Tests if two geometries have the same dimension and intersect, but each has "
"at least one point not in the other"
msgstr ""
"二つのジオメトリが同じ次元を持ち、インタセクトして、かつ相手と重ならない点少"
"なくとも一つあるかをテストします。"

#. Tag: funcprototype
#: reference_relationship.xml:1013
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Overlaps</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Overlaps</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1024
#, no-c-format
msgid ""
"Returns TRUE if geometry A and B \"spatially overlap\". Two geometries "
"overlap if they have the same dimension, their interiors intersect in that "
"dimension. and each has at least one point inside the other (or "
"equivalently, neither one covers the other). The overlaps relationship is "
"symmetric and irreflexive."
msgstr ""
"ジオメトリAとBが「空間的にオーバラップする」場合にTRUEを返します。ジオメトリ"
"が同じ次元で、内部のインタセクションも同じ次元で、少なくとも一つの点がもう一"
"方の外側にある (一方がもう一方を覆っている状態でないのと等価です)と、二つのジ"
"オメトリがオーバラップしていると言います。オーバラップの関係は、対称性があ"
"り、無反射性があります。"

#. Tag: para
#: reference_relationship.xml:1032
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_Overlaps</"
"function>."
msgstr ""
"&index_aware; インデックスの使用を避けるには<function>_ST_Overlaps</function>"
"関数を使います。"

#. Tag: para
#: reference_relationship.xml:1044 reference_relationship.xml:1238
#: reference_relationship.xml:1412
#, no-c-format
msgid "&sfs_compliant; s2.1.1.2 // s2.1.13.3"
msgstr "&sfs_compliant; s2.1.1.2 // s2.1.13.3"

#. Tag: para
#: reference_relationship.xml:1045
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.32"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.32"

#. Tag: para
#: reference_relationship.xml:1050
#, no-c-format
msgid ""
"<function>ST_Overlaps</function> returns <varname>TRUE</varname> in the "
"following situations:"
msgstr ""
"次に示す図全てで、<function>ST_Overlaps</function>は<varname>TRUE</varname>を"
"返します。"

#. Tag: para
#: reference_relationship.xml:1061
#, no-c-format
msgid "<varname>MULTIPOINT</varname> / <varname>MULTIPOINT</varname>"
msgstr "<varname>MULTIPOINT</varname> / <varname>MULTIPOINT</varname>"

#. Tag: para
#: reference_relationship.xml:1093
#, no-c-format
msgid ""
"A Point on a LineString is contained, but since it has lower dimension it "
"does not overlap or cross."
msgstr ""
"ラインストリング上のポイントが含まますが、次元が低いのでオーバラップにもクロ"
"スにもなりません。"

#. Tag: programlisting
#: reference_relationship.xml:1095
#, no-c-format
msgid ""
"SELECT ST_Overlaps(a,b) AS overlaps,       ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,  ST_Contains(b,a) AS b_contains_a\n"
"FROM (SELECT ST_GeomFromText('POINT (100 100)') As a,\n"
"             ST_GeomFromText('LINESTRING (30 50, 40 160, 160 40, 180 160)')  "
"AS b) AS t\n"
"\n"
"overlaps | crosses | intersects | b_contains_a\n"
"---------+----------------------+--------------\n"
"f        | f       | t          | t"
msgstr ""
"SELECT ST_Overlaps(a,b) AS overlaps,       ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,  ST_Contains(b,a) AS b_contains_a\n"
"FROM (SELECT ST_GeomFromText('POINT (100 100)') As a,\n"
"             ST_GeomFromText('LINESTRING (30 50, 40 160, 160 40, 180 160)')  "
"AS b) AS t\n"
"\n"
"overlaps | crosses | intersects | b_contains_a\n"
"---------+----------------------+--------------\n"
"f        | f       | t          | t"

#. Tag: para
#: reference_relationship.xml:1103
#, no-c-format
msgid ""
"A LineString that partly covers a Polygon intersects and crosses, but does "
"not overlap since it has different dimension."
msgstr ""
"部分的にポリゴンを覆うラインストリングはインタセクトもクロスもしますが、異な"
"り次元なのでオーバラップしません。"

#. Tag: programlisting
#: reference_relationship.xml:1105
#, no-c-format
msgid ""
"SELECT ST_Overlaps(a,b) AS overlaps,        ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,   ST_Contains(a,b) AS contains\n"
"FROM (SELECT ST_GeomFromText('POLYGON ((40 170, 90 30, 180 100, 40 170))') "
"AS a,\n"
"             ST_GeomFromText('LINESTRING(10 10, 190 190)') AS b) AS t;\n"
"\n"
" overlap | crosses | intersects | contains\n"
"---------+---------+------------+--------------\n"
" f       | t       | t          | f"
msgstr ""
"SELECT ST_Overlaps(a,b) AS overlaps,        ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,   ST_Contains(a,b) AS contains\n"
"FROM (SELECT ST_GeomFromText('POLYGON ((40 170, 90 30, 180 100, 40 170))') "
"AS a,\n"
"             ST_GeomFromText('LINESTRING(10 10, 190 190)') AS b) AS t;\n"
"\n"
" overlap | crosses | intersects | contains\n"
"---------+---------+------------+--------------\n"
" f       | t       | t          | f"

#. Tag: para
#: reference_relationship.xml:1113
#, no-c-format
msgid ""
"Two Polygons that intersect but with neither contained by the other overlap, "
"but do not cross because their intersection has the same dimension."
msgstr ""
"二つのポリゴンがインタセクトするものの一方が他方のオーバラップを含んでいませ"
"んが、インタセクトが同じ次元なのでクロスしません。"

#. Tag: programlisting
#: reference_relationship.xml:1115
#, no-c-format
msgid ""
"SELECT ST_Overlaps(a,b) AS overlaps,       ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,  ST_Contains(b, a) AS "
"b_contains_a,\n"
"       ST_Dimension(a) AS dim_a, ST_Dimension(b) AS dim_b,\n"
"       ST_Dimension(ST_Intersection(a,b)) AS dim_int\n"
"FROM (SELECT ST_GeomFromText('POLYGON ((40 170, 90 30, 180 100, 40 170))') "
"AS a,\n"
"             ST_GeomFromText('POLYGON ((110 180, 20 60, 130 90, 110 180))') "
"AS b) As t;\n"
"\n"
" overlaps | crosses | intersects | b_contains_a | dim_a | dim_b | dim_int\n"
"----------+---------+------------+--------------+-------+-------"
"+-----------\n"
" t        | f       | t          | f            |     2 |     2 |       2"
msgstr ""
"SELECT ST_Overlaps(a,b) AS overlaps,       ST_Crosses(a,b) AS crosses,\n"
"       ST_Intersects(a, b) AS intersects,  ST_Contains(b, a) AS "
"b_contains_a,\n"
"       ST_Dimension(a) AS dim_a, ST_Dimension(b) AS dim_b,\n"
"       ST_Dimension(ST_Intersection(a,b)) AS dim_int\n"
"FROM (SELECT ST_GeomFromText('POLYGON ((40 170, 90 30, 180 100, 40 170))') "
"AS a,\n"
"             ST_GeomFromText('POLYGON ((110 180, 20 60, 130 90, 110 180))') "
"AS b) As t;\n"
"\n"
" overlaps | crosses | intersects | b_contains_a | dim_a | dim_b | dim_int\n"
"----------+---------+------------+--------------+-------+-------"
"+-----------\n"
" t        | f       | t          | f            |     2 |     2 |       2"

#. Tag: para
#: reference_relationship.xml:1123
#, no-c-format
msgid ""
", <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Dimension\"/>, <xref "
"linkend=\"ST_Intersects\"/>"
msgstr ""
", <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Dimension\"/>, <xref "
"linkend=\"ST_Intersects\"/>"

#. Tag: refname
#: reference_relationship.xml:1129
#, no-c-format
msgid "ST_Relate"
msgstr "ST_Relate"

#. Tag: refpurpose
#: reference_relationship.xml:1131
#, no-c-format
msgid ""
"Tests if two geometries have a topological relationship matching an "
"Intersection Matrix pattern, or computes their Intersection Matrix"
msgstr ""
"二つのジオメトリが与えられた交差行列パターンに合致するトポロジ関係があるかど"
"うかを見るか、交差行列を計算するかします。"

#. Tag: funcsynopsis
#: reference_relationship.xml:1138
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_Relate</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
"<paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>text "
"<function>ST_Relate</function></funcdef> <paramdef><type>geometry </type> "
"<parameter>geomA</parameter></paramdef> <paramdef><type>geometry </type> "
"<parameter>geomB</parameter></paramdef> </funcprototype> <funcprototype> "
"<funcdef>text <function>ST_Relate</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
"<paramdef><type>integer </type> <parameter>boundaryNodeRule</parameter></"
"paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_Relate</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
"<paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>text "
"<function>ST_Relate</function></funcdef> <paramdef><type>geometry </type> "
"<parameter>geomA</parameter></paramdef> <paramdef><type>geometry </type> "
"<parameter>geomB</parameter></paramdef> </funcprototype> <funcprototype> "
"<funcdef>text <function>ST_Relate</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
"<paramdef><type>integer </type> <parameter>boundaryNodeRule</parameter></"
"paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:1164
#, no-c-format
msgid ""
"These functions allow testing and evaluating the spatial (topological) "
"relationship between two geometries, as defined by the <ulink url=\"http://"
"en.wikipedia.org/wiki/DE-9IM\">Dimensionally Extended 9-Intersection Model</"
"ulink> (DE-9IM)."
msgstr ""
"これらの関数で、二つのジオメトリに対する<ulink url=\"http://en.wikipedia.org/"
"wiki/DE-9IM\">Dimensionally Extended 9-Intersection Model</ulink> (DE-9IM)で"
"定義される空間 (トポロジ)関係のテストと評価が可能になります。"

#. Tag: para
#: reference_relationship.xml:1168
#, no-c-format
msgid ""
"The DE-9IM is specified as a 9-element matrix indicating the dimension of "
"the intersections between the Interior, Boundary and Exterior of two "
"geometries. It is represented by a 9-character text string using the symbols "
"'F', '0', '1', '2' (e.g. <code>'FF1FF0102'</code>)."
msgstr ""
"DE-9IMは9要素の行列で、二つのジオメトリの内部、境界、外部のインタセクションの"
"次元を示しています。'F', '0', '1', '2'の文字による9文字の文字列で表現します "
"(例えば <code>'FF1FF0102'</code>)。"

#. Tag: para
#: reference_relationship.xml:1174
#, no-c-format
msgid ""
"A specific kind of spatial relationship can be tested by matching the "
"intersection matrix to an <emphasis>intersection matrix pattern</emphasis>. "
"Patterns can include the additional symbols 'T' (meaning \"intersection is "
"non-empty\") and '*' (meaning \"any value\"). Common spatial relationships "
"are provided by the named functions <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, <xref "
"linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Disjoint\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref "
"linkend=\"ST_Touches\"/>, and <xref linkend=\"ST_Within\"/>. Using an "
"explicit pattern allows testing multiple conditions of intersects, crosses, "
"etc in one step. It also allows testing spatial relationships which do not "
"have a named spatial relationship function. For example, the relationship "
"\"Interior-Intersects\" has the DE-9IM pattern <code>T********</code>, which "
"is not evaluated by any named predicate."
msgstr ""
"<emphasis>intersection matrix pattern</emphasis>で、特定の種類の空間関係のテ"
"ストができます。パターンでは追加の文字 'T' (「インタセクションが空でない」と"
"いう意味)と '*' (「値はなんでもいい」という意味)を使うことができます。一般的"
"な空間関係については、名前の付いた関数<xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, <xref "
"linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Disjoint\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref "
"linkend=\"ST_Touches\"/>, <xref linkend=\"ST_Within\"/>として提供されます。明"
"示的なパターンを使うことで、インタセクト、クロス等の複数のテストを一回ででき"
"るようになります。また、名前のある空間関係関数を持たない空間関係のテストも可"
"能になります。たとえば、「内部インタセクション」という空間関係は、名前の付い"
"た空間関係関数では評価できませんが、<code>T********</code>のDE-9IMで評価でき"
"ます。"

#. Tag: para
#: reference_relationship.xml:1190 reference_relationship.xml:1322
#, no-c-format
msgid "For more information refer to <xref linkend=\"eval_spatial_rel\"/>."
msgstr "詳細情報については<xref linkend=\"eval_spatial_rel\"/>をご覧下さい。"

#. Tag: para
#: reference_relationship.xml:1194
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Variant 1:</emphasis> Tests if two geometries are "
"spatially related according to the given <varname>intersectionMatrixPattern</"
"varname>."
msgstr ""
"<emphasis role=\"bold\">一つ目の形式:</emphasis> 二つのジオメトリが、与えられ"
"た<varname>intersectionMatrixPattern</varname>による空間関係に合うかどうかを"
"見ます。"

#. Tag: para
#: reference_relationship.xml:1198
#, no-c-format
msgid ""
"Unlike most of the named spatial relationship predicates, this does NOT "
"automatically include an index call. The reason is that some relationships "
"are true for geometries which do NOT intersect (e.g. Disjoint). If you are "
"using a relationship pattern that requires intersection, then include the "
"&amp;&amp; index call."
msgstr ""
"他の名前の付いた空間関係述語の多くと異なり、この関数は自動ではインデックスの"
"呼び出しを*行いません*。インタセクト*しない*ジオメトリでTRUEになる関係がある"
"ためです。インタセクションが求められる関係パターンを使用している場合には、関"
"数呼び出しに&amp;&amp;を取り入れてください。"

#. Tag: para
#: reference_relationship.xml:1206
#, no-c-format
msgid ""
"It is better to use a named relationship function if available, since they "
"automatically use a spatial index where one exists. Also, they may implement "
"performance optimizations which are not available with full relate evalation."
msgstr ""
"存在するなら、名前の追加空間関係関数を使う方が良いです。空間インデックスが存"
"在するなら自動で使用してくれるからです。また、完全な関係評価では有効にならな"
"い能率最適化が実装されていることがあります。"

#. Tag: para
#: reference_relationship.xml:1212
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Variant 2:</emphasis> Returns the DE-9IM matrix "
"string for the spatial relationship between the two input geometries. The "
"matrix string can be tested for matching a DE-9IM pattern using <xref "
"linkend=\"ST_RelateMatch\"/>."
msgstr ""
"<emphasis role=\"bold\">二つ目の形式:</emphasis> 二つのジオメトリの空間関係の"
"DE-9IM行列文字列を返します。行列文字列は、<xref linkend=\"ST_RelateMatch\"/>"
"を使ったDE-9IMパターンと合致するかテストさせることができます。"

#. Tag: para
#: reference_relationship.xml:1217
#, no-c-format
msgid ""
"<emphasis role=\"bold\">Variant 3:</emphasis> Like variant 2, but allows "
"specifying a <emphasis role=\"bold\">Boundary Node Rule</emphasis>. A "
"boundary node rule allows finer control over whether the endpoints of "
"MultiLineStrings are considered to lie in the DE-9IM Interior or Boundary. "
"The <varname>boundaryNodeRule</varname> values are:"
msgstr ""
"<emphasis role=\"bold\">三つ目の形式:</emphasis> 二つ目の形式と同じですが、"
"<emphasis role=\"bold\">境界ノード規則</emphasis>の指定ができる点が異なりま"
"す。この規則によって、マルチラインストリングの端点がDE-9IMの内部または境界上"
"にあると判定されるかどうかを細かく制御できます。<varname>boundaryNodeRule</"
"varname>の値は次の通りです。"

#. Tag: para
#: reference_relationship.xml:1224
#, fuzzy, no-c-format
msgid ""
"<code>1</code>: <emphasis role=\"bold\">OGC-Mod2</emphasis> - line endpoints "
"are in the Boundary if they occur an odd number of times. This is the rule "
"defined by the OGC SFS standard, and is the default for <function>ST_Relate</"
"function>."
msgstr ""
"<code>1</code>: <emphasis role=\"bold\">OGC-Mod2</emphasis> - 線の端点が奇数"
"番目なら境界上にあるとみなします。これはOGC SFS標準で定義された規則で、"
"<function>ST_Relate</function>のデフォルトです。"

#. Tag: para
#: reference_relationship.xml:1227
#, no-c-format
msgid ""
"<code>2</code>: <emphasis role=\"bold\">Endpoint</emphasis> - all endpoints "
"are in the Boundary."
msgstr ""
"<code>2</code>: <emphasis role=\"bold\">Endpoint</emphasis> - 全ての端点は境"
"界上にあります。"

#. Tag: para
#: reference_relationship.xml:1229
#, fuzzy, no-c-format
msgid ""
"<code>3</code>: <emphasis role=\"bold\">MultivalentEndpoint</emphasis> - "
"endpoints are in the Boundary if they occur more than once. In other words, "
"the boundary is all the \"attached\" or \"inner\" endpoints (but not the "
"\"unattached/outer\" ones)."
msgstr ""
"<code>3</code>: <emphasis role=\"bold\">MultivalentEndpoint</emphasis> - 線の"
"端点が境界線上にあるのが2回目以降の場合には、境界にあるとします。言い換える"
"と、境界は「取り付けられた」または「内部の」端点 (「取り付けられてない」「外"
"部の」端点ではない)です。"

#. Tag: para
#: reference_relationship.xml:1232
#, fuzzy, no-c-format
msgid ""
"<code>4</code>: <emphasis role=\"bold\">MonovalentEndpoint</emphasis> - "
"endpoints are in the Boundary if they occur only once. In other words, the "
"boundary is all the \"unattached\" or \"outer\" endpoints."
msgstr ""
"<code>4</code>: <emphasis role=\"bold\">MonovalentEndpoint</emphasis> - 線の"
"端点が境界線上にあるのが1回目の場合に限って、境界にあるとします。言い換えると"
"「属していない」または「外部」の端点です。"

#. Tag: para
#: reference_relationship.xml:1237
#, no-c-format
msgid "This function is not in the OGC spec, but is implied. see s2.1.13.2"
msgstr "OGC仕様にはありませんが実装しました。s2.1.13.2をご覧下さい。"

#. Tag: para
#: reference_relationship.xml:1239
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.25"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.25"

#. Tag: para
#: reference_relationship.xml:1241
#, no-c-format
msgid "Enhanced: 2.0.0 - added support for specifying boundary node rule."
msgstr "Enhanced: 2.0.0 - 境界ノード規則が追加されました。"

#. Tag: para
#: reference_relationship.xml:1252
#, no-c-format
msgid "Using the boolean-valued function to test spatial relationships."
msgstr "真偽値関数を使って空間関係を見ます。"

#. Tag: programlisting
#: reference_relationship.xml:1253
#, no-c-format
msgid ""
"SELECT ST_Relate('POINT(1 2)', ST_Buffer( 'POINT(1 2)', 2), '0FFFFF212');\n"
"st_relate\n"
"-----------\n"
"t\n"
"\n"
"SELECT ST_Relate(POINT(1 2)', ST_Buffer( 'POINT(1 2)', 2), '*FF*FF212');\n"
"st_relate\n"
"-----------\n"
"t"
msgstr ""
"SELECT ST_Relate('POINT(1 2)', ST_Buffer( 'POINT(1 2)', 2), '0FFFFF212');\n"
"st_relate\n"
"-----------\n"
"t\n"
"\n"
"SELECT ST_Relate(POINT(1 2)', ST_Buffer( 'POINT(1 2)', 2), '*FF*FF212');\n"
"st_relate\n"
"-----------\n"
"t"

#. Tag: para
#: reference_relationship.xml:1255
#, no-c-format
msgid ""
"Testing a custom spatial relationship pattern as a query condition, with "
"<code>&amp;&amp;</code> to enable using a spatial index."
msgstr ""
"独自の空間関係パターンを問い合わせ条件としてテストします。空間インデックスの"
"使用を有効にするために<code>&amp;&amp;</code>を使っています。"

#. Tag: programlisting
#: reference_relationship.xml:1257
#, no-c-format
msgid ""
"-- Find compounds that properly intersect (not just touch) a poly (Interior "
"Intersects)\n"
"\n"
"SELECT c.* , p.name As poly_name\n"
"    FROM polys AS p\n"
"    INNER JOIN compounds As c\n"
"          ON c.geom &amp;&amp; p.geom\n"
"             AND ST_Relate(p.geom, c.geom,'T********');"
msgstr ""
"-- poly (内部でインタセクト)と完全にインタセクトしている (接触ではない)区域の"
"探索\n"
"\n"
"SELECT c.* , p.name As poly_name\n"
"    FROM polys AS p\n"
"    INNER JOIN compounds As c\n"
"          ON c.geom &amp;&amp; p.geom\n"
"             AND ST_Relate(p.geom, c.geom,'T********');"

#. Tag: para
#: reference_relationship.xml:1259
#, no-c-format
msgid "Computing the intersection matrix for spatial relationships."
msgstr "空間関係交差行列を計算します。"

#. Tag: programlisting
#: reference_relationship.xml:1260
#, no-c-format
msgid ""
"SELECT ST_Relate( 'POINT(1 2)',\n"
"                  ST_Buffer( 'POINT(1 2)', 2));\n"
"-----------\n"
"0FFFFF212\n"
"\n"
"SELECT ST_Relate( 'LINESTRING(1 2, 3 4)',\n"
"                  'LINESTRING(5 6, 7 8)' );\n"
"-----------\n"
"FF1FF0102"
msgstr ""
"SELECT ST_Relate( 'POINT(1 2)',\n"
"                  ST_Buffer( 'POINT(1 2)', 2));\n"
"-----------\n"
"0FFFFF212\n"
"\n"
"SELECT ST_Relate( 'LINESTRING(1 2, 3 4)',\n"
"                  'LINESTRING(5 6, 7 8)' );\n"
"-----------\n"
"FF1FF0102"

#. Tag: para
#: reference_relationship.xml:1262
#, no-c-format
msgid ""
"Using different Boundary Node Rules to compute the spatial relationship "
"between a LineString and a MultiLineString with a duplicate endpoint "
"<code>(3 3)</code>:"
msgstr ""
"異なる境界ノード規則を使って、端点が重複するLINESTRINGとMULTILINESTRING間の空"
"間関係を計算します <code>(3 3)</code>:"

#. Tag: para
#: reference_relationship.xml:1266
#, no-c-format
msgid ""
"Using the <emphasis role=\"bold\">OGC-Mod2</emphasis> rule (1) the duplicate "
"endpoint is in the <emphasis role=\"bold\">interior</emphasis> of the "
"MultiLineString, so the DE-9IM matrix entry [aB:bI] is <code>0</code> and "
"[aB:bB] is <code>F</code>."
msgstr ""
"<emphasis role=\"bold\">OGC-Mod2</emphasis>規則 (1)を使うと、重複端点は"
"MULTILINESTRINGの<emphasis role=\"bold\">内部</emphasis>になり、DE-9IM行列の "
"[aB:bl]は<code>0</code>で、[aB:bB]は<code>F</code>です。"

#. Tag: para
#: reference_relationship.xml:1270
#, no-c-format
msgid ""
"Using the <emphasis role=\"bold\">Endpoint</emphasis> rule (2) the duplicate "
"endpoint is in the <emphasis role=\"bold\">boundary</emphasis> of the "
"MultiLineString, so the DE-9IM matrix entry [aB:bI] is <code>F</code> and "
"[aB:bB] is <code>0</code>."
msgstr ""
"<emphasis role=\"bold\">Endpoint</emphasis>規則 (2)を使うと、重複端点は"
"MULTILINESTRINGの<emphasis role=\"bold\">境界</emphasis>となり、DE-9IM行列の"
"[aB:bI]は<code>F</code>で、[aB:bB]は<code>0</code>です。"

#. Tag: programlisting
#: reference_relationship.xml:1275
#, no-c-format
msgid ""
"WITH data AS (SELECT\n"
"  'LINESTRING(1 1, 3 3)'::geometry AS a_line,\n"
"  'MULTILINESTRING((3 3, 3 5), (3 3, 5 3))':: geometry AS b_multiline\n"
")\n"
"SELECT ST_Relate( a_line, b_multiline, 1) AS bnr_mod2,\n"
"       ST_Relate( a_line, b_multiline, 2) AS bnr_endpoint\n"
"    FROM data;\n"
"\n"
" bnr_mod2  | bnr_endpoint\n"
"-----------+--------------\n"
" FF10F0102 | FF1F00102"
msgstr ""
"WITH data AS (SELECT\n"
"  'LINESTRING(1 1, 3 3)'::geometry AS a_line,\n"
"  'MULTILINESTRING((3 3, 3 5), (3 3, 5 3))':: geometry AS b_multiline\n"
")\n"
"SELECT ST_Relate( a_line, b_multiline, 1) AS bnr_mod2,\n"
"       ST_Relate( a_line, b_multiline, 2) AS bnr_endpoint\n"
"    FROM data;\n"
"\n"
" bnr_mod2  | bnr_endpoint\n"
"-----------+--------------\n"
" FF10F0102 | FF1F00102"

#. Tag: para
#: reference_relationship.xml:1284
#, no-c-format
msgid ""
", <xref linkend=\"ST_RelateMatch\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, <xref "
"linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Disjoint\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref "
"linkend=\"ST_Touches\"/>, <xref linkend=\"ST_Within\"/>"
msgstr ""
", <xref linkend=\"ST_RelateMatch\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, <xref "
"linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Disjoint\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref "
"linkend=\"ST_Touches\"/>, <xref linkend=\"ST_Within\"/>"

#. Tag: refname
#: reference_relationship.xml:1297
#, no-c-format
msgid "ST_RelateMatch"
msgstr "ST_RelateMatch"

#. Tag: refpurpose
#: reference_relationship.xml:1299
#, no-c-format
msgid ""
"Tests if a DE-9IM Intersection Matrix matches an Intersection Matrix pattern"
msgstr ""
"DE-9IMインタセクション行列がインタセクション行列パターンに合致するかどうかを"
"見ます。"

#. Tag: funcprototype
#: reference_relationship.xml:1305
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_RelateMatch</function></funcdef> "
"<paramdef><type>text </type> <parameter>intersectionMatrix</parameter></"
"paramdef> <paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
"parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_RelateMatch</function></funcdef> "
"<paramdef><type>text </type> <parameter>intersectionMatrix</parameter></"
"paramdef> <paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
"parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1316
#, no-c-format
msgid ""
"Tests if a <ulink url=\"http://en.wikipedia.org/wiki/DE-9IM\">Dimensionally "
"Extended 9-Intersection Model</ulink> (DE-9IM) <varname>intersectionMatrix</"
"varname> value satisfies an <varname>intersectionMatrixPattern</varname>. "
"Intersection matrix values can be computed by <xref linkend=\"ST_Relate\"/>."
msgstr ""
"<ulink url=\"http://en.wikipedia.org/wiki/DE-9IM\">Dimensionally Extended 9-"
"Intersection Model</ulink> (DE-9IM) <varname>intersectionMatrix</varname>の値"
"が <varname>intersectionMatrixPattern</varname>を満たすかどうかを見ます。交差"
"行列値は<xref linkend=\"ST_Relate\"/>で計算します。"

#. Tag: programlisting
#: reference_relationship.xml:1333
#, no-c-format
msgid ""
"SELECT ST_RelateMatch('101202FFF', 'TTTTTTFFF') ;\n"
"-- result --\n"
"t"
msgstr ""
"SELECT ST_RelateMatch('101202FFF', 'TTTTTTFFF') ;\n"
"-- 結果 --\n"
"t"

#. Tag: para
#: reference_relationship.xml:1334
#, no-c-format
msgid ""
"Patterns for common spatial relationships matched against intersection "
"matrix values, for a line in various positions relative to a polygon"
msgstr ""
"あるポリゴンとの様々な相対的な位置にあるラインを想定した交差行列値に合致する"
"一般的な空間関係のパターン"

#. Tag: programlisting
#: reference_relationship.xml:1337
#, no-c-format
msgid ""
"SELECT pat.name AS relationship, pat.val AS pattern,\n"
"       mat.name AS position, mat.val AS matrix,\n"
"       ST_RelateMatch(mat.val, pat.val) AS match\n"
"    FROM (VALUES ( 'Equality', 'T1FF1FFF1' ),\n"
"                 ( 'Overlaps', 'T*T***T**' ),\n"
"                 ( 'Within',   'T*F**F***' ),\n"
"                 ( 'Disjoint', 'FF*FF****' )) AS pat(name,val)\n"
"    CROSS JOIN\n"
"        (VALUES  ('non-intersecting', 'FF1FF0212'),\n"
"                 ('overlapping',      '1010F0212'),\n"
"                 ('inside',           '1FF0FF212')) AS mat(name,val);\n"
"\n"
" relationship |  pattern  |     position     |  matrix   | match\n"
"--------------+-----------+------------------+-----------+-------\n"
" Equality     | T1FF1FFF1 | non-intersecting | FF1FF0212 | f\n"
" Equality     | T1FF1FFF1 | overlapping      | 1010F0212 | f\n"
" Equality     | T1FF1FFF1 | inside           | 1FF0FF212 | f\n"
" Overlaps     | T*T***T** | non-intersecting | FF1FF0212 | f\n"
" Overlaps     | T*T***T** | overlapping      | 1010F0212 | t\n"
" Overlaps     | T*T***T** | inside           | 1FF0FF212 | f\n"
" Within       | T*F**F*** | non-intersecting | FF1FF0212 | f\n"
" Within       | T*F**F*** | overlapping      | 1010F0212 | f\n"
" Within       | T*F**F*** | inside           | 1FF0FF212 | t\n"
" Disjoint     | FF*FF**** | non-intersecting | FF1FF0212 | t\n"
" Disjoint     | FF*FF**** | overlapping      | 1010F0212 | f\n"
" Disjoint     | FF*FF**** | inside           | 1FF0FF212 | f"
msgstr ""
"SELECT pat.name AS relationship, pat.val AS pattern,\n"
"       mat.name AS position, mat.val AS matrix,\n"
"       ST_RelateMatch(mat.val, pat.val) AS match\n"
"    FROM (VALUES ( 'Equality', 'T1FF1FFF1' ),\n"
"                 ( 'Overlaps', 'T*T***T**' ),\n"
"                 ( 'Within',   'T*F**F***' ),\n"
"                 ( 'Disjoint', 'FF*FF****' )) AS pat(name,val)\n"
"    CROSS JOIN\n"
"        (VALUES  ('non-intersecting', 'FF1FF0212'),\n"
"                 ('overlapping',      '1010F0212'),\n"
"                 ('inside',           '1FF0FF212')) AS mat(name,val);\n"
"\n"
" relationship |  pattern  |     position     |  matrix   | match\n"
"--------------+-----------+------------------+-----------+-------\n"
" Equality     | T1FF1FFF1 | non-intersecting | FF1FF0212 | f\n"
" Equality     | T1FF1FFF1 | overlapping      | 1010F0212 | f\n"
" Equality     | T1FF1FFF1 | inside           | 1FF0FF212 | f\n"
" Overlaps     | T*T***T** | non-intersecting | FF1FF0212 | f\n"
" Overlaps     | T*T***T** | overlapping      | 1010F0212 | t\n"
" Overlaps     | T*T***T** | inside           | 1FF0FF212 | f\n"
" Within       | T*F**F*** | non-intersecting | FF1FF0212 | f\n"
" Within       | T*F**F*** | overlapping      | 1010F0212 | f\n"
" Within       | T*F**F*** | inside           | 1FF0FF212 | t\n"
" Disjoint     | FF*FF**** | non-intersecting | FF1FF0212 | t\n"
" Disjoint     | FF*FF**** | overlapping      | 1010F0212 | f\n"
" Disjoint     | FF*FF**** | inside           | 1FF0FF212 | f"

#. Tag: para
#: reference_relationship.xml:1343
#, no-c-format
msgid ", <xref linkend=\"ST_Relate\"/>"
msgstr ", <xref linkend=\"ST_Relate\"/>"

#. Tag: refname
#: reference_relationship.xml:1349
#, no-c-format
msgid "ST_Touches"
msgstr "ST_Touches"

#. Tag: refpurpose
#: reference_relationship.xml:1351
#, no-c-format
msgid ""
"Tests if two geometries have at least one point in common, but their "
"interiors do not intersect"
msgstr ""
"二つのジオメトリが少なくとも一つの共有点を持ち、かつ内部でインタセクトしてい"
"ないようになっているかテストします。"

#. Tag: funcprototype
#: reference_relationship.xml:1357
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Touches</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Touches</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1372
#, no-c-format
msgid ""
"Returns <varname>TRUE</varname> if A and B intersect, but their interiors do "
"not intersect. Equivalently, A and B have at least one point in common, and "
"the common points lie in at least one boundary. For Point/Point inputs the "
"relationship is always <varname>FALSE</varname>, since points do not have a "
"boundary."
msgstr ""
"AとBがインタセクトするがAの内部とBの内部がインタセクトしない場合には"
"<varname>TRUE</varname>を返します。AとBが少なくとも一つの共有点があり、共有点"
"が少なくとも一つの境界の上にあることと同じです。ポイント/ポイント入力では、ポ"
"イントは境界を持たないため、常に<varname>FALSE</varname>を返します。"

#. Tag: para
#: reference_relationship.xml:1378
#, no-c-format
msgid "In mathematical terms, this relationship is:"
msgstr "数学的に述べると、この関係は次のようになります。"

#. Tag: para
#: reference_relationship.xml:1388
#, no-c-format
msgid ""
"This relationship holds if the DE-9IM Intersection Matrix for the two "
"geometries matches one of:"
msgstr ""
"この関係は、二つのジオメトリのDE-9IM交差行列がどれか一つに合致すると、関係が"
"保持されていることになります。"

#. Tag: markup
#: reference_relationship.xml:1392
#, no-c-format
msgid "FT*******"
msgstr "FT*******"

#. Tag: markup
#: reference_relationship.xml:1396
#, no-c-format
msgid "F**T*****"
msgstr "F**T*****"

#. Tag: markup
#: reference_relationship.xml:1400
#, no-c-format
msgid "F***T****"
msgstr "F***T****"

#. Tag: para
#: reference_relationship.xml:1404
#, no-c-format
msgid ""
"&index_aware; To avoid using an index, use <function>_ST_Touches</function> "
"instead."
msgstr ""
"&index_aware; インデックスの使用を避けるには<function>_ST_Touches</function>"
"を代わりに使います。"

#. Tag: para
#: reference_relationship.xml:1413
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.28"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.28"

#. Tag: para
#: reference_relationship.xml:1419
#, no-c-format
msgid ""
"The <function>ST_Touches</function> predicate returns <varname>TRUE</"
"varname> in the following examples."
msgstr ""
"次の例では<function>ST_Touches</function>述語は<varname>TRUE</varname>を返し"
"ます。"

#. Tag: programlisting
#: reference_relationship.xml:1489
#, no-c-format
msgid ""
"SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(1 1)'::"
"geometry);\n"
" st_touches\n"
"------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(0 2)'::"
"geometry);\n"
" st_touches\n"
"------------\n"
" t\n"
"(1 row)"
msgstr ""
"SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(1 1)'::"
"geometry);\n"
" st_touches\n"
"------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(0 2)'::"
"geometry);\n"
" st_touches\n"
"------------\n"
" t\n"
"(1 row)"

#. Tag: refname
#: reference_relationship.xml:1495
#, no-c-format
msgid "ST_Within"
msgstr "ST_Within"

#. Tag: refpurpose
#: reference_relationship.xml:1497
#, no-c-format
msgid ""
"Tests if every point of A lies in B, and their interiors have a point in "
"common"
msgstr ""
"Aの全てのポイントがB内にあり、かつ両方の内部が共有点を持つかどうかをテストし"
"ます。"

#. Tag: funcprototype
#: reference_relationship.xml:1502
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_Within</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_Within</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1517
#, no-c-format
msgid ""
"Returns TRUE if geometry A is within geometry B. A is within B if and only "
"if all points of A lie inside (i.e. in the interior or boundary of) B (or "
"equivalently, no points of A lie in the exterior of B), and the interiors of "
"A and B have at least one point in common."
msgstr ""
"ジオメトリAがジオメトリB内にある場合にTRUEを返します。Aの全ての点がBの内側 "
"(内部または境界)にあり、Aの内部とBの内部に少なくとも一つの共有点がある場合に"
"限って、AはB内にあると言います。"

#. Tag: para
#: reference_relationship.xml:1522
#, no-c-format
msgid ""
"For this function to make sense, the source geometries must both be of the "
"same coordinate projection, having the same SRID."
msgstr ""
"渡すジオメトリが両方とも同じSRIDでなければ、この関数は意味がありません。"

#. Tag: para
#: reference_relationship.xml:1526
#, no-c-format
msgid ""
"The within relationship is reflexive: every geometry is within itself. The "
"relationship is antisymmetric: if <code>ST_Within(A,B) = true</code> and "
"<code>ST_Within(B,A) = true</code>, then the two geometries must be "
"topologically equal (<code>ST_Equals(A,B) = true</code>)."
msgstr ""
"内にある、という関係性には反射性があります。全てのジオメトリは、自分の内にあ"
"ると言えます。また、非対称性を持ちます。<code>ST_Within(A,B) = true</code>か"
"つ<code>ST_Within(B,A) = true</code>の場合には、二つのジオメトリは必ずトポロ"
"ジ的に等価 (<code>ST_Equals(A,B) = true</code>)になります。"

#. Tag: para
#: reference_relationship.xml:1530
#, no-c-format
msgid ""
"ST_Within is the converse of <xref linkend=\"ST_Contains\"/>. So, "
"<code>ST_Within(A,B) = ST_Contains(B,A)</code>."
msgstr ""
"ST_Withinは<xref linkend=\"ST_Contains\"/>の反対です。<code>ST_Within(A,B) = "
"ST_Contains(B,A)</code>となります。"

#. Tag: para
#: reference_relationship.xml:1533
#, no-c-format
msgid ""
"Because the interiors must have a common point, a subtlety of the definition "
"is that lines and points lying fully in the boundary of polygons or lines "
"are <emphasis>not</emphasis> within the geometry. For further details see "
"<ulink url=\"http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-"
"covers-spatial.html\">Subtleties of OGC Covers, Contains, Within</ulink>. "
"The <xref linkend=\"ST_CoveredBy\"/> predicate provides a more inclusive "
"relationship."
msgstr ""
"内部が必ず共有点を持つので、定義は、ポリゴンまたはラインの境界上にあるライン"
"またはポイントはジオメトリの内に<emphasis>ない</emphasis>という微妙なものにな"
"ります。詳細については、<ulink url=\"http://lin-ear-th-inking.blogspot."
"com/2007/06/subtleties-of-ogc-covers-spatial.html\">Subtleties of OGC "
"Covers, Contains, Within</ulink>をご覧下さい。<xref linkend=\"ST_CoveredBy\"/"
">述語はより包括的な関係を提供します。"

#. Tag: para
#: reference_relationship.xml:1539
#, no-c-format
msgid ""
"&index_aware; To avoid index use, use the function <function>_ST_Within</"
"function>."
msgstr ""
"&index_aware; インデックスの使用を避けるには<function>_ST_Within</function>関"
"数を使います。"

#. Tag: para
#: reference_relationship.xml:1557
#, no-c-format
msgid "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*F**F***')"
msgstr "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*F**F***')"

#. Tag: para
#: reference_relationship.xml:1560
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.30"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.30"

#. Tag: programlisting
#: reference_relationship.xml:1565
#, no-c-format
msgid ""
"--a circle within a circle\n"
"SELECT ST_Within(smallc,smallc) As smallinsmall,\n"
"  ST_Within(smallc, bigc) As smallinbig,\n"
"  ST_Within(bigc,smallc) As biginsmall,\n"
"  ST_Within(ST_Union(smallc, bigc), bigc) as unioninbig,\n"
"  ST_Within(bigc, ST_Union(smallc, bigc)) as biginunion,\n"
"  ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion\n"
"FROM\n"
"(\n"
"SELECT ST_Buffer(ST_GeomFromText('POINT(50 50)'), 20) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(50 50)'), 40) As bigc) As foo;\n"
"--Result\n"
" smallinsmall | smallinbig | biginsmall | unioninbig | biginunion | "
"bigisunion\n"
"--------------+------------+------------+------------+------------"
"+------------\n"
" t            | t          | f          | t          | t          | t\n"
"(1 row)"
msgstr ""
"-- 円内の円\n"
"SELECT ST_Within(smallc,smallc) As smallinsmall,\n"
"  ST_Within(smallc, bigc) As smallinbig,\n"
"  ST_Within(bigc,smallc) As biginsmall,\n"
"  ST_Within(ST_Union(smallc, bigc), bigc) as unioninbig,\n"
"  ST_Within(bigc, ST_Union(smallc, bigc)) as biginunion,\n"
"  ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion\n"
"FROM\n"
"(\n"
"SELECT ST_Buffer(ST_GeomFromText('POINT(50 50)'), 20) As smallc,\n"
"  ST_Buffer(ST_GeomFromText('POINT(50 50)'), 40) As bigc) As foo;\n"
"-- 結果\n"
" smallinsmall | smallinbig | biginsmall | unioninbig | biginunion | "
"bigisunion\n"
"--------------+------------+------------+------------+------------"
"+------------\n"
" t            | t          | f          | t          | t          | t\n"
"(1 row)"

#. Tag: para
#: reference_relationship.xml:1576
#, no-c-format
msgid ""
", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_IsValid\"/>"
msgstr ""
", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
"linkend=\"ST_IsValid\"/>"

#. Tag: title
#: reference_relationship.xml:1584
#, no-c-format
msgid "Distance Relationships"
msgstr "距離関係関数"

#. Tag: refname
#: reference_relationship.xml:1588
#, no-c-format
msgid "ST_3DDWithin"
msgstr "ST_3DDWithin"

#. Tag: refpurpose
#: reference_relationship.xml:1590
#, no-c-format
msgid "Tests if two 3D geometries are within a given 3D distance"
msgstr ""
"二つの3次元ジオメトリが与えらえれた3次元距離内にあるかどうかをテストします。"

#. Tag: funcprototype
#: reference_relationship.xml:1594
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_3DDWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance_of_srid</"
"parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_3DDWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance_of_srid</"
"parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1612
#, no-c-format
msgid ""
"Returns true if the 3D distance between two geometry values is no larger "
"than distance <varname>distance_of_srid</varname>. The distance is specified "
"in units defined by the spatial reference system of the geometries. For this "
"function to make sense the source geometries must be in the same coordinate "
"system (have the same SRID)."
msgstr ""
"二つのジオメトリ値の3次元距離が<varname>distance_of_srid</varname>以下なら"
"<varname>TRUE</varname>を返します。距離の単位はジオメトリの空間参照系の単位で"
"す。この関数から意味のある結果を得るには、引数に使うジオメトリを同じ空間系 "
"(同じSRIDを持つ)にしなければなりません。"

#. Tag: para
#: reference_relationship.xml:1624
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM ?"
msgstr "&sqlmm_compliant; SQL-MM ?"

#. Tag: programlisting
#: reference_relationship.xml:1632
#, no-c-format
msgid ""
"-- Geometry example - units in meters (SRID: 2163 US National Atlas Equal "
"area) (3D point and line compared 2D point and line)\n"
"-- Note: currently no vertical datum support so Z is not transformed and "
"assumed to be same units as final.\n"
"SELECT ST_3DDWithin(\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;POINT(-72.1235 42.3521 "
"4)'),2163),\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45 15, "
"-72.123 42.1546 20)'),2163),\n"
"      126.8\n"
"    ) As within_dist_3d,\n"
"ST_DWithin(\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;POINT(-72.1235 42.3521 "
"4)'),2163),\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45 15, "
"-72.123 42.1546 20)'),2163),\n"
"      126.8\n"
"    ) As within_dist_2d;\n"
"\n"
" within_dist_3d | within_dist_2d\n"
"----------------+----------------\n"
" f              | t"
msgstr ""
"-- ジオメトリの例 - 単位はメートル (SRID: 2163 米国ナショナルアトラス正積図"
"法)\n"
"-- (2次元のポイントとラインとに比較される3次元のポイントとライン)\n"
"-- ご注意: 現在垂直データムに対応しておらず、Z値は変換されず、同じ単位と仮定"
"されます。\n"
"SELECT ST_3DDWithin(\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;POINT(-72.1235 42.3521 "
"4)'),2163),\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45 15, "
"-72.123 42.1546 20)'),2163),\n"
"      126.8\n"
"    ) As within_dist_3d,\n"
"ST_DWithin(\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;POINT(-72.1235 42.3521 "
"4)'),2163),\n"
"      ST_Transform(ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45 15, "
"-72.123 42.1546 20)'),2163),\n"
"      126.8\n"
"    ) As within_dist_2d;\n"
"\n"
" within_dist_3d | within_dist_2d\n"
"----------------+----------------\n"
" f              | t"

#. Tag: para
#: reference_relationship.xml:1638
#, no-c-format
msgid ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DFullyWithin\"/>, <xref "
"linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_Distance\"/>, <xref "
"linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DFullyWithin\"/>, <xref "
"linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_Distance\"/>, <xref "
"linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_relationship.xml:1648
#, no-c-format
msgid "ST_3DDFullyWithin"
msgstr "ST_3DDFullyWithin"

#. Tag: refpurpose
#: reference_relationship.xml:1650
#, no-c-format
msgid "Tests if two 3D geometries are entirely within a given 3D distance"
msgstr ""
"二つの3次元ジオメトリが完全に与えらえれた3次元距離内にあるかどうかをテストし"
"ます。"

#. Tag: funcprototype
#: reference_relationship.xml:1655
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_3DDFullyWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance</parameter></"
"paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_3DDFullyWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance</parameter></"
"paramdef>"

#. Tag: para
#: reference_relationship.xml:1673
#, no-c-format
msgid ""
"Returns true if the 3D geometries are fully within the specified distance of "
"one another. The distance is specified in units defined by the spatial "
"reference system of the geometries. For this function to make sense, the "
"source geometries must both be of the same coordinate projection, having the "
"same SRID."
msgstr ""
"3次元ジオメトリが他のジオメトリとの距離が、完全に指定した範囲内ならtrueを返し"
"ます。距離の単位はジオメトリの空間参照系で定義されているものとされます。この"
"関数が意味を持つためには、与えられるジオメトリは両方とも同じ座標系で同じSRID"
"を持つ必要があります。"

#. Tag: programlisting
#: reference_relationship.xml:1690
#, no-c-format
msgid ""
"-- This compares the difference between fully within and distance within as "
"well\n"
"    -- as the distance fully within for the 2D footprint of the line/point "
"vs. the 3d fully within\n"
"    SELECT ST_3DDFullyWithin(geom_a, geom_b, 10) as D3DFullyWithin10, "
"ST_3DDWithin(geom_a, geom_b, 10) as D3DWithin10,\n"
"  ST_DFullyWithin(geom_a, geom_b, 20) as D2DFullyWithin20,\n"
"  ST_3DDFullyWithin(geom_a, geom_b, 20) as D3DFullyWithin20 from\n"
"    (select ST_GeomFromEWKT('POINT(1 1 2)') as geom_a,\n"
"    ST_GeomFromEWKT('LINESTRING(1 5 2, 2 7 20, 1 9 100, 14 12 3)') as "
"geom_b) t1;\n"
" d3dfullywithin10 | d3dwithin10 | d2dfullywithin20 | d3dfullywithin20\n"
"------------------+-------------+------------------+------------------\n"
" f                | t           | t                | f"
msgstr ""
"-- 完全な範囲内にあるかを見る関数と、範囲内にあるかを見るの比較と\n"
"    -- ライン/ポイントの2次元投影の完全な範囲内を見る関数と3次元のままで完全"
"に範囲内にあるかを見る関数の比較\n"
"    SELECT ST_3DDFullyWithin(geom_a, geom_b, 10) as D3DFullyWithin10, "
"ST_3DDWithin(geom_a, geom_b, 10) as D3DWithin10,\n"
"  ST_DFullyWithin(geom_a, geom_b, 20) as D2DFullyWithin20,\n"
"  ST_3DDFullyWithin(geom_a, geom_b, 20) as D3DFullyWithin20 from\n"
"    (select ST_GeomFromEWKT('POINT(1 1 2)') as geom_a,\n"
"    ST_GeomFromEWKT('LINESTRING(1 5 2, 2 7 20, 1 9 100, 14 12 3)') as "
"geom_b) t1;\n"
" d3dfullywithin10 | d3dwithin10 | d2dfullywithin20 | d3dfullywithin20\n"
"------------------+-------------+------------------+------------------\n"
" f                | t           | t                | f"

#. Tag: para
#: reference_relationship.xml:1696
#, no-c-format
msgid ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DFullyWithin\"/>, <xref "
"linkend=\"ST_3DMaxDistance\"/>"
msgstr ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DFullyWithin\"/>, <xref "
"linkend=\"ST_3DMaxDistance\"/>"

#. Tag: refname
#: reference_relationship.xml:1704
#, no-c-format
msgid "ST_DFullyWithin"
msgstr "ST_DFullyWithin"

#. Tag: refpurpose
#: reference_relationship.xml:1706
#, no-c-format
msgid "Tests if two geometries are entirely within a given distance"
msgstr ""
"二つのジオメトリが完全に与えらえれた距離内にあるかどうかをテストします。"

#. Tag: funcprototype
#: reference_relationship.xml:1711
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_DFullyWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance</parameter></"
"paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_DFullyWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance</parameter></"
"paramdef>"

#. Tag: para
#: reference_relationship.xml:1729
#, no-c-format
msgid ""
"Returns true if the geometries are entirely within the specified distance of "
"one another. The distance is specified in units defined by the spatial "
"reference system of the geometries. For this function to make sense, the "
"source geometries must both be of the same coordinate projection, having the "
"same SRID."
msgstr ""
"二つのジオメトリが互いに、完全に与えらえれた距離内にある場合にはTRUEを返しま"
"す。距離はジオメトリの空間参照系で定義されている単位になります。この関数が意"
"味のあるものにするためには、与えられるジオメトリは両方とも同じ座標系で同じ"
"SRIDを持つ必要があります。"

#. Tag: para
#: reference_relationship.xml:1737
#, no-c-format
msgid "Availability: 1.5.0"
msgstr "Availability: 1.5.0"

#. Tag: programlisting
#: reference_relationship.xml:1742
#, no-c-format
msgid ""
"postgis=# SELECT ST_DFullyWithin(geom_a, geom_b, 10) as DFullyWithin10, "
"ST_DWithin(geom_a, geom_b, 10) as DWithin10, ST_DFullyWithin(geom_a, geom_b, "
"20) as DFullyWithin20 from\n"
"    (select ST_GeomFromText('POINT(1 1)') as geom_a,"
"ST_GeomFromText('LINESTRING(1 5, 2 7, 1 9, 14 12)') as geom_b) t1;\n"
"\n"
"-----------------\n"
" DFullyWithin10 | DWithin10 | DFullyWithin20 |\n"
"---------------+----------+---------------+\n"
" f             | t        | t             |"
msgstr ""
"postgis=# SELECT ST_DFullyWithin(geom_a, geom_b, 10) as DFullyWithin10, "
"ST_DWithin(geom_a, geom_b, 10) as DWithin10, ST_DFullyWithin(geom_a, geom_b, "
"20) as DFullyWithin20 from\n"
"    (select ST_GeomFromText('POINT(1 1)') as geom_a,"
"ST_GeomFromText('LINESTRING(1 5, 2 7, 1 9, 14 12)') as geom_b) t1;\n"
"\n"
"-----------------\n"
" DFullyWithin10 | DWithin10 | DFullyWithin20 |\n"
"---------------+----------+---------------+\n"
" f             | t        | t             |"

#. Tag: para
#: reference_relationship.xml:1748
#, no-c-format
msgid ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_3DDWithin\"/>, <xref "
"linkend=\"ST_3DDFullyWithin\"/>"
msgstr ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_3DDWithin\"/>, <xref "
"linkend=\"ST_3DDFullyWithin\"/>"

#. Tag: refname
#: reference_relationship.xml:1755
#, no-c-format
msgid "ST_DWithin"
msgstr "ST_DWithin"

#. Tag: refpurpose
#: reference_relationship.xml:1757
#, no-c-format
msgid "Tests if two geometries are within a given distance"
msgstr "二つのジオメトリが与えらえれた距離内にあるかどうかをテストします。"

#. Tag: funcsynopsis
#: reference_relationship.xml:1761
#, no-c-format
msgid ""
"<funcprototype> <funcdef>boolean <function>ST_DWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance_of_srid</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
"<function>ST_DWithin</function></funcdef> <paramdef><type>geography </type> "
"<parameter>gg1</parameter></paramdef> <paramdef><type>geography </type> "
"<parameter>gg2</parameter></paramdef> <paramdef><type>double precision </"
"type> <parameter>distance_meters</parameter></paramdef> <paramdef "
"choice=\"opt\"><type>boolean </type> <parameter>use_spheroid = true</"
"parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>boolean <function>ST_DWithin</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>double precision </type> <parameter>distance_of_srid</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
"<function>ST_DWithin</function></funcdef> <paramdef><type>geography </type> "
"<parameter>gg1</parameter></paramdef> <paramdef><type>geography </type> "
"<parameter>gg2</parameter></paramdef> <paramdef><type>double precision </"
"type> <parameter>distance_meters</parameter></paramdef> <paramdef "
"choice=\"opt\"><type>boolean </type> <parameter>use_spheroid = true</"
"parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_relationship.xml:1794
#, no-c-format
msgid "Returns true if the geometries are within a given distance"
msgstr "ジオメトリが与えられた距離内にある場合にはTRUEを返します。"

#. Tag: para
#: reference_relationship.xml:1796
#, no-c-format
msgid ""
"For <type>geometry</type>: The distance is specified in units defined by the "
"spatial reference system of the geometries. For this function to make sense, "
"the source geometries must be in the same coordinate system (have the same "
"SRID)."
msgstr ""
"<type>geometry</type>: 距離の単位は空間参照系で定義される単位です。この関数が"
"意味のあるものにするためには、与えられるジオメトリは両方とも同じ座標系である "
"(同じSRIDを持つ)必要があります。"

#. Tag: para
#: reference_relationship.xml:1801
#, no-c-format
msgid ""
"For <type>geography</type>: units are in meters and distance measurement "
"defaults to <varname>use_spheroid</varname>=true. For faster evaluation use "
"<varname>use_spheroid</varname>=false to measure on the sphere."
msgstr ""
"<type>geography</type>: 単位はメートルで、距離の測定の既定値は"
"<varname>use_spheroid</varname>=trueです。より高速な評価のために、"
"<varname>use_spheroid</varname>=falseとして球面で測定します。"

#. Tag: para
#: reference_relationship.xml:1806
#, no-c-format
msgid "Use <xref linkend=\"ST_3DDWithin\"/> for 3D geometries."
msgstr "3次元ジオメトリでは<xref linkend=\"ST_3DDWithin\"/>を使います。"

#. Tag: para
#: reference_relationship.xml:1809
#, no-c-format
msgid ""
"This function call includes a bounding box comparison that makes use of any "
"indexes that are available on the geometries."
msgstr ""
"この関数の呼び出しによって、ジオメトリで使用可能なインデクスを使用したバウン"
"ディングボックスの比較が自動的に行われます。"

#. Tag: para
#: reference_relationship.xml:1814
#, no-c-format
msgid "&sfs_compliant;"
msgstr "&sfs_compliant;"

#. Tag: para
#: reference_relationship.xml:1815
#, no-c-format
msgid "Availability: 1.5.0 support for geography was introduced"
msgstr "Availability: 1.5.0 ジオグラフィが導入されました。"

#. Tag: para
#: reference_relationship.xml:1816
#, no-c-format
msgid ""
"Enhanced: 2.1.0 improved speed for geography. See <ulink url=\"http://blog."
"opengeo.org/2012/07/12/making-geography-faster/\">Making Geography faster</"
"ulink> for details."
msgstr ""
"Enhanced: 2.1.0で、ジオグラフィでの速度が向上しました。詳細については<ulink "
"url=\"http://blog.opengeo.org/2012/07/12/making-geography-faster/\">Making "
"Geography faster</ulink>を参照して下さい。"

#. Tag: para
#: reference_relationship.xml:1817
#, no-c-format
msgid "Enhanced: 2.1.0 support for curved geometries was introduced."
msgstr "Enhanced: 2.1.0 曲線ジオメトリ対応が導入されました。"

#. Tag: para
#: reference_relationship.xml:1819
#, no-c-format
msgid ""
"Prior to 1.3, <xref linkend=\"ST_Expand\"/> was commonly used in conjunction "
"with &amp;&amp; and ST_Distance to test for distance, and in pre-1.3.4 this "
"function used that logic. From 1.3.4, ST_DWithin uses a faster short-circuit "
"distance function."
msgstr ""
"1.3以前の<xref linkend=\"ST_Expand\"/>は、 距離をテストするために、&amp;&amp;"
"と、ST_Distanceとを一般的に併用していました。1.3.4より前では、この関数はその"
"ロジックを使っていました。1.3.4からST_DWithinは、より速いショートサーキットを"
"使った距離関数を使います。"

#. Tag: programlisting
#: reference_relationship.xml:1827
#, no-c-format
msgid ""
"-- Find the nearest hospital to each school\n"
"-- that is within 3000 units of the school.\n"
"--  We do an ST_DWithin search to utilize indexes to limit our search list\n"
"--  that the non-indexable ST_Distance needs to process\n"
"-- If the units of the spatial reference is meters then units would be "
"meters\n"
"SELECT DISTINCT ON (s.gid) s.gid, s.school_name, s.geom, h.hospital_name\n"
"  FROM schools s\n"
"    LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, 3000)\n"
"  ORDER BY s.gid, ST_Distance(s.geom, h.geom);\n"
"\n"
"-- The schools with no close hospitals\n"
"-- Find all schools with no hospital within 3000 units\n"
"-- away from the school.  Units is in units of spatial ref (e.g. meters, "
"feet, degrees)\n"
"SELECT s.gid, s.school_name\n"
"  FROM schools s\n"
"    LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, 3000)\n"
"  WHERE h.gid IS NULL;\n"
"\n"
"-- Find broadcasting towers that receiver with limited range can receive.\n"
"-- Data is geometry in Spherical Mercator (SRID=3857), ranges are "
"approximate.\n"
"\n"
"-- Create geometry index that will check proximity limit of user to tower\n"
"CREATE INDEX ON broadcasting_towers using gist (geom);\n"
"\n"
"-- Create geometry index that will check proximity limit of tower to user\n"
"CREATE INDEX ON broadcasting_towers using gist (ST_Expand(geom, "
"sending_range));\n"
"\n"
"-- Query towers that 4-kilometer receiver in Minsk Hackerspace can get\n"
"-- Note: two conditions, because shorter LEAST(b.sending_range, 4000) will "
"not use index.\n"
"SELECT b.tower_id, b.geom\n"
"  FROM broadcasting_towers b\n"
"  WHERE ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', 4000)\n"
"    AND ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', b."
"sending_range);"
msgstr ""
"-- 学校ごとに、3000単位以内の最も近い病院を見つけます。\n"
"-- ST_DWithinでインデックスを使用して検索リストの絞り込みを行い、\n"
"-- インデックスを使えないST_Distanceで処理します。\n"
"-- 空間参照系の単位がメートルならここで言う単位はメートルです。\n"
"SELECT DISTINCT ON (s.gid) s.gid, s.school_name, s.geom, h.hospital_name\n"
"  FROM schools s\n"
"    LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, 3000)\n"
"  ORDER BY s.gid, ST_Distance(s.geom, h.geom);\n"
"\n"
"-- 病院が近くにない学校\n"
"-- 3000単位以内に病院が無い学校を全て見つけます。\n"
"-- 単位は空間参照系の単位です (メートル、フィート、度など)\n"
"SELECT s.gid, s.school_name\n"
"  FROM schools s\n"
"    LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, 3000)\n"
"  WHERE h.gid IS NULL;\n"
"\n"
"\n"
"-- 受信可能距離の制限を持つ受信機が受信できる放送塔を見つけます。\n"
"-- データは球面メルカトル (SRID=3857)のジオメトリで、範囲は近似的なものとして"
"います。\n"
"\n"
"-- ユーザから見て塔が制限範囲内かをチェックするジオメトリインデックスの生"
"成。\n"
"CREATE INDEX ON broadcasting_towers using gist (geom);\n"
"\n"
"-- 塔から見てユーザが制限範囲内かをチェックするジオメトリインデックスの生"
"成。\n"
"CREATE INDEX ON broadcasting_towers using gist (ST_Expand(geom, "
"sending_range));\n"
"\n"
"-- ミンスクハケルスペイスにある受信機から4キロメートル以内にある塔の検索\n"
"-- ご注意: 二つの条件があります。より短い LEAST(b.sending_range, 4000) ではイ"
"ンデックスが使えません。\n"
"SELECT b.tower_id, b.geom\n"
"  FROM broadcasting_towers b\n"
"  WHERE ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', 4000)\n"
"    AND ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', b."
"sending_range);"

#. Tag: para
#: reference_relationship.xml:1833
#, no-c-format
msgid ", <xref linkend=\"ST_3DDWithin\"/>"
msgstr ", <xref linkend=\"ST_3DDWithin\"/>"

#. Tag: refname
#: reference_relationship.xml:1839
#, no-c-format
msgid "ST_PointInsideCircle"
msgstr "ST_PointInsideCircle"

#. Tag: refpurpose
#: reference_relationship.xml:1841
#, no-c-format
msgid ""
"Tests if a point geometry is inside a circle defined by a center and radius"
msgstr ""
"ポイントジオメトリが中心と半径で定められた円の内側にあるかをテストします。"

#. Tag: funcprototype
#: reference_relationship.xml:1846
#, no-c-format
msgid ""
"<funcdef>boolean <function>ST_PointInsideCircle</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>center_x</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>center_y</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>radius</parameter></paramdef>"
msgstr ""
"<funcdef>boolean <function>ST_PointInsideCircle</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_point</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>center_x</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>center_y</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>radius</parameter></paramdef>"

#. Tag: para
#: reference_relationship.xml:1859
#, no-c-format
msgid ""
"Returns true if the geometry is a point and is inside the circle with center "
"<varname>center_x</varname>,<varname>center_y</varname> and radius "
"<varname>radius</varname>."
msgstr ""
"ジオメトリが点であり、<varname>center_x</varname>,<varname>center_y</varname>"
"の中心点と<varname>radius</varname>の半径を持つ円の内側にある場合はTRUEを返し"
"ます。"

#. Tag: para
#: reference_relationship.xml:1863
#, no-c-format
msgid ""
"Does not use spatial indexes. Use <xref linkend=\"ST_DWithin\"/> instead."
msgstr ""
"この関数は空間インデックスを使用しません。代わりに<xref "
"linkend=\"ST_DWithin\"/>を使って下さい。"

#. Tag: para
#: reference_relationship.xml:1865
#, no-c-format
msgid "Availability: 1.2"
msgstr "Availability: 1.2"

#. Tag: para
#: reference_relationship.xml:1866
#, no-c-format
msgid "Changed: 2.2.0 In prior versions this was called ST_Point_Inside_Circle"
msgstr ""
"Changed: 2.2.0 前のバージョンではST_Point_Inside_Circleと呼ばれていました。"

#. Tag: programlisting
#: reference_relationship.xml:1873
#, no-c-format
msgid ""
"SELECT ST_PointInsideCircle(ST_Point(1,2), 0.5, 2, 3);\n"
" st_pointinsidecircle\n"
"------------------------\n"
" t"
msgstr ""
"SELECT ST_PointInsideCircle(ST_Point(1,2), 0.5, 2, 3);\n"
" st_pointinsidecircle\n"
"------------------------\n"
" t"

#, no-c-format
#~ msgid "This function call does not use indexes"
#~ msgstr "この関数はインデックスを使用しません。"

#, no-c-format
#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
#~ "       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
#~ "FROM (SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
#~ "  ST_GeomFromText('LINESTRING (171 154, 20 140, 71 74, 2.99 90.16)') As "
#~ "lineB\n"
#~ ") As foo;\n"
#~ "\n"
#~ " A_cross_B | B_cross_A\n"
#~ "-----------+-----------\n"
#~ "         2 |        -2"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(lineA, lineB) As A_cross_B,\n"
#~ "       ST_LineCrossingDirection(lineB, lineA) As B_cross_A\n"
#~ "FROM (SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As lineA,\n"
#~ "  ST_GeomFromText('LINESTRING (171 154, 20 140, 71 74, 2.99 90.16)') As "
#~ "lineB\n"
#~ ") As foo;\n"
#~ "\n"
#~ " A_cross_B | B_cross_A\n"
#~ "-----------+-----------\n"
#~ "         2 |        -2"

#, no-c-format
#~ msgid ""
#~ "A specific kind of spatial relationships is evaluated by comparing the "
#~ "intersection matrix to an <emphasis>intersection matrix pattern</"
#~ "emphasis>. A pattern can include the additional symbols 'T' and '*'. "
#~ "Common spatial relationships are provided by the named functions <xref "
#~ "linkend=\"ST_Contains\"/>, <xref linkend=\"ST_ContainsProperly\"/>, <xref "
#~ "linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref "
#~ "linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Disjoint\"/>, <xref "
#~ "linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Intersects\"/>, <xref "
#~ "linkend=\"ST_Overlaps\"/>, <xref linkend=\"ST_Touches\"/>, and <xref "
#~ "linkend=\"ST_Within\"/>. Using an explicit pattern allows testing "
#~ "multiple conditions of intersects, crosses, etc in one step. It also "
#~ "allows testing spatial relationships which do not have a named spatial "
#~ "relationship function. For example, the relationship \"Interior-"
#~ "Intersects\" has the DE-9IM pattern <code>T********</code>, which is not "
#~ "evaluated by any named predicate."
#~ msgstr ""
#~ "特定の種類の空間関係は、<emphasis>intersection matrix pattern</emphasis>と"
#~ "いう交差行列の比較によって評価されます。パターンには追加で文字'T'と'*'が使"
#~ "えます。一般の空間関係は名前付き関数で提供されています。名前付き関数には"
#~ "<xref linkend=\"ST_Contains\"/>, <xref linkend=\"ST_ContainsProperly\"/>, "
#~ "<xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref "
#~ "linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Disjoint\"/>, <xref "
#~ "linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Intersects\"/>, <xref "
#~ "linkend=\"ST_Overlaps\"/>, <xref linkend=\"ST_Touches\"/>, <xref "
#~ "linkend=\"ST_Within\"/>があります。明示的なパターンを使うと、インタセク"
#~ "ション、クロス等の複数の条件を一度にテストすることができます。また、名前付"
#~ "き空間関数を持たない空間関係のテストも可能です。たとえば、「内部-交差」の"
#~ "関係はDE-9IM パターン<code>T********</code>となり、名前付き述語の中には存"
#~ "在しません。"

#, no-c-format
#~ msgid ""
#~ "<emphasis role=\"bold\">Variant 3:</emphasis> Like variant 2, but allows "
#~ "specifying a <emphasis role=\"bold\">Boundary Node Rule</emphasis>. A "
#~ "boundary node rule allows finer control over whether geometry boundary "
#~ "points are considered to lie in the DE-9IM Interior or Boundary. The "
#~ "<varname>boundaryNodeRule</varname> code is: 1: OGC/MOD2, 2: Endpoint, 3: "
#~ "MultivalentEndpoint, 4: MonovalentEndpoint."
#~ msgstr ""
#~ "<emphasis role=\"bold\">三つ目の形式:</emphasis> 二つ目の形式と同じです"
#~ "が、<emphasis role=\"bold\">Boundary Node Rule</emphasis>の指定ができる点"
#~ "が異なります。Boundary Node Ruleによって、ジオメトリ境界のポイントがDE-9IM"
#~ "の内部または境界にあるかどうかをより良く制御することが可能です。"
#~ "<varname>boundaryNodeRule</varname>のコードは、1: OGC/MOD2, 2: Endpoint, "
#~ "3: MultivalentEndpoint, 4: MonovalentEndpoint です。"

#, no-c-format
#~ msgid ""
#~ "SELECT ST_Relate( 'POINT(1 2)',\n"
#~ "                  ST_Buffer( 'POINT(1 2)', 2));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "0FFFFF212\n"
#~ "\n"
#~ "SELECT ST_Relate( 'LINESTRING(1 2, 3 4)',\n"
#~ "                  'LINESTRING(5 6, 7 8)' );\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "FF1FF0102"
#~ msgstr ""
#~ "SELECT ST_Relate( 'POINT(1 2)',\n"
#~ "                  ST_Buffer( 'POINT(1 2)', 2));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "0FFFFF212\n"
#~ "\n"
#~ "SELECT ST_Relate( 'LINESTRING(1 2, 3 4)',\n"
#~ "                  'LINESTRING(5 6, 7 8)' );\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "FF1FF0102"

#, no-c-format
#~ msgid ""
#~ "Tests if two geometries spatially intersect in 3D - only for points, "
#~ "linestrings, polygons, polyhedral surface (area)."
#~ msgstr ""
#~ "二つのジオメトリが3次元で空間的にインタセクトするかをテストします。ポイン"
#~ "ト、ラインストリング、ポリゴン、多面体サーフェス (面)のみ有効です。"

#, no-c-format
#~ msgid ""
#~ "Tests if no points of B lie in the exterior of A, and A and B have at "
#~ "least one interior point in common."
#~ msgstr ""
#~ "Bの外部にAのポイントが無く、かつAとBが内部に少なくとも一つのポイントを共有"
#~ "する場合にはTRUEを返します。"

#, no-c-format
#~ msgid ""
#~ "Returns TRUE if geometry B is completely inside geometry A. A contains B "
#~ "if and only if no points of B lie in the exterior of A, and at least one "
#~ "point of the interior of B lies in the interior of A."
#~ msgstr ""
#~ "ジオメトリBが完全にジオメトリAの内部にある場合にはTRUEを返します。ジオメト"
#~ "リAがジオメトリBを含むのは、BのポイントがAの外部に無く、かつBの内部の少な"
#~ "くとも一つのポイントがAの内部にある場合に限ります。"

#, no-c-format
#~ msgid ""
#~ "A subtlety of the definition is that a geometry does not contain things "
#~ "in its boundary. Thus polygons and lines do <emphasis>not</emphasis> "
#~ "contain lines and points lying in their boundary. For further details see "
#~ "<ulink url=\"http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-"
#~ "ogc-covers-spatial.html\">Subtleties of OGC Covers, Contains, Within</"
#~ "ulink>. (The <xref linkend=\"ST_Covers\"/> predicate provides a more "
#~ "inclusive relationship.) However, a geometry does contain itself. (In "
#~ "contrast, in the <xref linkend=\"ST_ContainsProperly\"/> predicate a "
#~ "geometry does <emphasis>not</emphasis> properly contain itself.)"
#~ msgstr ""
#~ "この定義は、ジオメトリに境界が含まれていない点で微妙です。これは、ポリゴン"
#~ "とラインに境界であるラインとポイントを<emphasis>含まない</emphasis>ことを"
#~ "意味します。詳細については、<ulink url=\"http://lin-ear-th-inking."
#~ "blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html\">Subtleties "
#~ "of OGC Covers, Contains, Within</ulink>をご覧下さい (<xref "
#~ "linkend=\"ST_Covers\"/>は、より包括的な関係を提供します)。しかし、ジオメト"
#~ "リは自身を含みます (対して<xref linkend=\"ST_ContainsProperly\"/>ではジオ"
#~ "メトリは自身を<emphasis>正しく含むことにはなりません</emphasis>)。"

#, no-c-format
#~ msgid ""
#~ "ST_Contains is the inverse of <xref linkend=\"ST_Within\"/>. So, "
#~ "<code>ST_Contains(A,B) = ST_Within(B,A)</code>."
#~ msgstr ""
#~ "ST_Containsは<xref linkend=\"ST_Within\"/>の逆です。つまり"
#~ "<code>ST_Contains(A,B) = ST_Within(B,A)</code>となります。"

#, no-c-format
#~ msgid ""
#~ "The <function>ST_Contains</function> predicate returns <varname>FALSE</"
#~ "varname> in the following situations:"
#~ msgstr ""
#~ "次に示す図全てで、<function>ST_Contains</function>は<varname>FALSE</"
#~ "varname>を返します。"

#, no-c-format
#~ msgid ""
#~ "Tests if B intersects the interior of A but not the boundary or exterior."
#~ msgstr ""
#~ "BがAの内部にインタセクトするが境界または外部にインタセクトしないかどうかを"
#~ "テストします。"

#, no-c-format
#~ msgid ""
#~ "Returns true if B intersects the interior of A but not the boundary or "
#~ "exterior."
#~ msgstr ""
#~ "BがAの内部にインタセクトするが境界と外部にインタセクトしない場合にはTRUEを"
#~ "返します。"

#, no-c-format
#~ msgid ""
#~ "An example use case for this predicate is computing the intersections of "
#~ "a set of geometries with a large polygonal geometry. Since intersection "
#~ "is a fairly slow operation, it can be more efficient to use "
#~ "containsProperly to filter out test geometries which lie wholly inside "
#~ "the area. In these cases the intersection is known a priori to be exactly "
#~ "the original test geometry."
#~ msgstr ""
#~ "この述語の使用事例として、大きいポリゴンジオメトリでのジオメトリの集合のイ"
#~ "ンタセクションを計算することが挙げられます。インタセクションはかなり遅いの"
#~ "で、ContainsProperlyを使って、対象ジオメトリのうち全体が領域内にあるものを"
#~ "抜き出すことができ、効率的になります。これらの場面では、インタセクションは"
#~ "確実に元の対象ジオメトリであることが直感的に分かります。"

#, no-c-format
#~ msgid "Tests if no point in A is outside B"
#~ msgstr "AのポイントがBの外部に存在しないかどうかをテストします。"

#, no-c-format
#~ msgid ""
#~ "Returns <varname>true</varname> if no point in Geometry/Geography A lies "
#~ "outside Geometry/Geography B. Equivalently, tests if every point of "
#~ "geometry A is inside (i.e. intersects the interior or boundary of) "
#~ "geometry B."
#~ msgstr ""
#~ "ジオメトリ/ジオグラフィAのポイントがジオメトリ/ジオグラフィBの外側に存在し"
#~ "ない場合には<varname>TRUE</varname>を返します。ジオメトリAの全てのポイント"
#~ "がジオメトリBの内側にある (内部または境界とインタセクトする)かを見るのと同"
#~ "じです。"

#, no-c-format
#~ msgid "Tests if no point in B is outside A"
#~ msgstr "BのポイントがAの外部に存在しないかどうかをテストします。"

#, no-c-format
#~ msgid ""
#~ "Returns <varname>true</varname> if no point in Geometry/Geography B is "
#~ "outside Geometry/Geography A. Equivalently, tests if every point of "
#~ "geometry B is inside (i.e. intersects the interior or boundary of) "
#~ "geometry A."
#~ msgstr ""
#~ "ジオメトリ/ジオグラフィBのポイントがジオメトリ/ジオグラフィAの外側に存在し"
#~ "ない場合には<varname>TRUE</varname>を返します。ジオメトリBの全てのポイント"
#~ "がジオメトリAの内側にある (内部または境界とインタセクトする)かを見るのと同"
#~ "じです。"

#, no-c-format
#~ msgid ""
#~ "Tests if two geometries have some, but not all, interior points in common."
#~ msgstr ""
#~ "与えられたジオメトリが共通の内部の点を持ち、かつそうでない内部の点を持つ場"
#~ "合に、TRUEを返します。"

#, no-c-format
#~ msgid "Tests if two geometries are disjoint (they have no point in common)."
#~ msgstr ""
#~ "二つのジオメトリがインタセクトしていない (共有しているポイントが存在しな"
#~ "い)かどうかをテストします。"

#, no-c-format
#~ msgid "Tests if two geometries include the same set of points."
#~ msgstr ""
#~ "二つのジオメトリが同じポイントの集合でできているかどうかをテストします。"

#, no-c-format
#~ msgid ""
#~ "Tests if two geometries intersect (they have at least one point in "
#~ "common)."
#~ msgstr ""
#~ "二つのジオメトリがインタセクトしている (少なくとも一つのポイントを共有して"
#~ "いる)かどうかをテストします。"

#, no-c-format
#~ msgid ""
#~ "Returns a number indicating the crossing behavior of two LineStrings."
#~ msgstr ""
#~ "二つのラインストリングがどのように交差しているかを示す数字を返します。"

#, no-c-format
#~ msgid ""
#~ "Tests if two geometries represent the same geometry and have points in "
#~ "the same directional order."
#~ msgstr ""
#~ "二つのジオメトリが同じジオメトリを表現し、かつポイントの順序が同じかどうか"
#~ "をテストします。"

#, no-c-format
#~ msgid ""
#~ "Tests if two geometries intersect and have the same dimension, but are "
#~ "not completely contained by each other."
#~ msgstr ""
#~ "二つのジオメトリがインタセクトし、同じ次元で、一方に完全に含まれることが無"
#~ "いかどうかをテストします。"

#, no-c-format
#~ msgid ""
#~ "Returns TRUE if geometry A and B \"spatially overlap\". Two geometries "
#~ "overlap if they have the same dimension, each has at least one point not "
#~ "shared by the other (or equivalently neither covers the other), and the "
#~ "intersection of their interiors has the same dimension. The overlaps "
#~ "relationship is symmetrical."
#~ msgstr ""
#~ "AとBが「空間的にオーバラップする」とTRUEを返します。二つのジオメトリが同じ"
#~ "次元で、それぞれが少なくとも一つのポイントを他方と共有していなくて (他方を"
#~ "覆わなくて)、かつ内部のインタセクションが同じ次元になる場合には、ジオメト"
#~ "リはオーバラップしています。オーバラップは対称の関係になります。"

#, no-c-format
#~ msgid ""
#~ "Tests if two geometries have at least one point in common, but their "
#~ "interiors do not intersect."
#~ msgstr ""
#~ "二つのジオメトリが共通のポイントを少なくとも一つ持ち、かつ内部でインタセク"
#~ "トしないかどうかをテストします。"

#, no-c-format
#~ msgid ""
#~ "Tests if no points of A lie in the exterior of B, and A and B have at "
#~ "least one interior point in common."
#~ msgstr ""
#~ "Bの外部にAのポイントが無く、かつAとBが内部に少なくとも一つのポイントを共有"
#~ "するかどうかをテストします。"

#, no-c-format
#~ msgid ""
#~ "Returns TRUE if geometry A is completely inside geometry B. For this "
#~ "function to make sense, the source geometries must both be of the same "
#~ "coordinate projection, having the same SRID. It is a given that if "
#~ "ST_Within(A,B) is true and ST_Within(B,A) is true, then the two "
#~ "geometries are considered spatially equal."
#~ msgstr ""
#~ "ジオメトリAが完全にジオメトリBの内側にある場合にはTRUEを返します。この関数"
#~ "が意味を持つためには、与えられるジオメトリは両方とも同じ座標系で同じSRIDを"
#~ "持つ必要があります。ST_Within(A,B)がTRUEかつST_Within(B,A)がTRUEである場合"
#~ "には、二つのジオメトリは空間的に同じであると考えられます。"

#, no-c-format
#~ msgid ""
#~ "A subtlety of this definition is that the boundary of a geometry is not "
#~ "within the geometry. This means that lines and points lying in the "
#~ "boundary of a polygon or line are <emphasis>not</emphasis> within the "
#~ "geometry. For further details see <ulink url=\"http://lin-ear-th-inking."
#~ "blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html\">Subtleties "
#~ "of OGC Covers, Contains, Within</ulink>. (The <xref "
#~ "linkend=\"ST_CoveredBy\"/> predicate provides a more inclusive "
#~ "relationship)."
#~ msgstr ""
#~ "この定義の微妙な点は、ジオメトリの境界はジオメトリの内部に存在しないことで"
#~ "す。これは、ポリゴンやラインの境界にあるラインやポイントはジオメトリの内部"
#~ "に<emphasis>ありません</emphasis>。詳細情報については<ulink url=\"http://"
#~ "lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial."
#~ "html\">Subtleties of OGC Covers, Contains, Within</ulink>をご覧下さい "
#~ "(<xref linkend=\"ST_CoveredBy\"/>は、より包括的な関係を提供します)。"

#, no-c-format
#~ msgid ""
#~ "ST_Within is the inverse of <xref linkend=\"ST_Contains\"/>. So, "
#~ "<code>ST_Within(A,B) = ST_Contains(B,A)</code>."
#~ msgstr ""
#~ "ST_Withinは<xref linkend=\"ST_Contains\"/>の逆です。つまり"
#~ "<code>ST_Within(A,B) = ST_Contains(B,A)</code>となります。"

#, no-c-format
#~ msgid ""
#~ "Tests if a point geometry is inside a circle defined by a center and "
#~ "radius."
#~ msgstr ""
#~ "ポイントジオメトリが中心点と半径で定義された円の内側にあるかどうかを見ま"
#~ "す。"

#, no-c-format
#~ msgid "&sqlmm_compliant; SQL-MM 3: ?"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: ?"

#~ msgid ""
#~ "Returns true if two geometries spatially intersect in 3D - only for "
#~ "points, linestrings, polygons, polyhedral surface (area)."
#~ msgstr ""
#~ "ジオメトリが3次元で空間的にインタセクトする場合にはTRUEを返します。ポイン"
#~ "ト、ラインストリング、ポリゴン、多面体サーフェス (面)のみ有効です。"

#~ msgid "&sfcgal_enhanced;"
#~ msgstr "&sfcgal_enhanced;"

#~ msgid ""
#~ "Returns true if no points of B lie in the exterior of A, and A and B have "
#~ "at least one interior point in common."
#~ msgstr ""
#~ "Aの外部にBのポイントが無く、かつAとBが内部に少なくとも一つのポイントを共有"
#~ "する場合にはTRUEを返します。"

#~ msgid ""
#~ "<refpurpose>Returns true if B intersects the interior of A but not the "
#~ "boundary or exterior.</refpurpose>"
#~ msgstr ""
#~ "<refpurpose>BがAの内部とインタセクトするがAの境界と外部とインタセクトしな"
#~ "い場合にはTRUEを返します。</refpurpose>"

#~ msgid ""
#~ "<para>Returns true if B intersects the interior of A but not the boundary "
#~ "or exterior.</para>"
#~ msgstr ""
#~ "<para>BがAの内部とインタセクトするがAの境界と外部とインタセクトしない場合"
#~ "にはTRUEを返します。</para>"

#~ msgid "Returns true if no point in A is outside B"
#~ msgstr "AのポイントがBの外部に存在しない場合にはTRUEを返します。"

#~ msgid "Returns true if no point in B is outside A"
#~ msgstr "BのポイントがAの外側に存在しない場合にはTRUEを返します。"

#~ msgid ""
#~ "Returns true if two geometries have some, but not all, interior points in "
#~ "common."
#~ msgstr ""
#~ "与えられたジオメトリが共通の内部の点を持ち、かつそうでない点を持つ場合には"
#~ "TRUEを返します。"

#~ msgid ""
#~ "<function>ST_Crosses</function> takes two geometry objects and returns "
#~ "<varname>true</varname> if their intersection \"spatially cross\", that "
#~ "is, the geometries have some, but not all interior points in common. The "
#~ "intersection of the interiors of the geometries must not be the empty set "
#~ "and must have a dimensionality less than the maximum dimension of the two "
#~ "input geometries. Additionally, the intersection of the two geometries "
#~ "must not equal either of the source geometries. Otherwise, it returns "
#~ "<varname>false</varname>."
#~ msgstr ""
#~ "<function>ST_Crosses</function>は、二つのジオメトリをとり、インタセクショ"
#~ "ンが「空間的にクロスする」、すなわちジオメトリが共通の内部のポイントを持"
#~ "ち、かつ全ての内部のポイントが共通のポイントにはならない場合に"
#~ "<varname>TRUE</varname>を返します。ジオメトリの内部のインタセクションは、"
#~ "空集合であってはならず、二つのジオメトリの最大次元より低い次元でなければな"
#~ "りません。さらに言うと、二つのジオメトリのインタセクションは、元のジオメト"
#~ "リのいずれとも一致してはなりません。これらを満たさない場合には"
#~ "<varname>FALSE</varname>を返します。"

#~ msgid ""
#~ "<markup>T*T******</markup> (for Point/Line, Point/Area, and Line/Area "
#~ "situations)"
#~ msgstr ""
#~ "<markup>T*T******</markup> (for Point/Line, Point/Area, Line/Areaの場合)"

#~ msgid ""
#~ "<markup>T*****T**</markup> (for Line/Point, Area/Point, and Area/Line "
#~ "situations)"
#~ msgstr ""
#~ "<markup>T*****T**</markup> (for Line/Point, Area/Point, Area/Lineの場合)"

#~ msgid "<markup>0********</markup> (for Line/Line situations)"
#~ msgstr "<markup>0********</markup> (for Line/Lineの場合)"

#~ msgid ""
#~ "Returns true if two geometries do not intersect (they have no point in "
#~ "common)."
#~ msgstr ""
#~ "二つのジオメトリがインタセクトしていなし (共有しているポイントが存在しな"
#~ "い)場合にはTRUEを返します。"

#~ msgid "Returns true if two geometries include the same set of points."
#~ msgstr ""
#~ "二つのジオメトリが同じポイントの集合でできている場合にはTRUEを返します。"

#~ msgid ""
#~ "Returns TRUE if the given Geometries are \"spatially equal\". Use this "
#~ "for a 'better' answer than '='. Note by spatially equal we mean "
#~ "ST_Within(A,B) = true and ST_Within(B,A) = true and also mean ordering of "
#~ "points can be different but represent the same geometry structure. To "
#~ "verify the order of points is consistent, use ST_OrderingEquals (it must "
#~ "be noted ST_OrderingEquals is a little more stringent than simply "
#~ "verifying order of points are the same)."
#~ msgstr ""
#~ "与えられたジオメトリ表現が「空間的に同じ」場合にはTRUEを返します。'='より"
#~ "も「よりよい」答を得るために使います。空間的に同じということは、"
#~ "ST_Within(A,B) = trueかつST_Within(B,A) = trueとなります。また、ポイントの"
#~ "順序が違っても同じジオメトリ構造ならtrueとなります。構成ポイントの順序の確"
#~ "認にはST_OrderingEqualsを使用します (ST_OrderingEqualsはポイントのオーダが"
#~ "同じかを確認するよりも若干厳しくなります)。"

#~ msgid ""
#~ "Returns true if two geometries intersect (they have at least one point in "
#~ "common)."
#~ msgstr ""
#~ "二つのジオメトリがインタセクトしている (少なくとも一つのポイントを共有して"
#~ "いる)場合にはTRUEを返します。"

#~ msgid ""
#~ "If a geometry or geography shares any portion of space then they "
#~ "intersect. For geography -- tolerance is 0.00001 meters (so any points "
#~ "that are close are considered to intersect)"
#~ msgstr ""
#~ "ジオメトリ/ジオグラフィが空間に共有部分がある場合には、インタセクトしてい"
#~ "ます。ジオグラフィでは許容誤差が0.00001メートルです (近い点はインタセクト"
#~ "と考えられてしまいます)。"

#~ msgid ""
#~ "ST_Overlaps, ST_Touches, ST_Within all imply spatial intersection. If any "
#~ "of the aforementioned returns true, then the geometries also spatially "
#~ "intersect. Disjoint implies false for spatial intersection."
#~ msgstr ""
#~ "ST_Overlaps, ST_Touches, ST_Withinは全て空間インタセクションを裏で使ってい"
#~ "ます。前述のいずれかがTRUEを返す場合には、ジオメトリは空間的にインタセクト"
#~ "しています。離れている場合は、空間的なインタセクトについてFALSEとなりま"
#~ "す。"

#~ msgid ""
#~ "Returns true if two geometries represent the same geometry and have "
#~ "points in the same directional order."
#~ msgstr ""
#~ "二つのジオメトリが同じジオメトリを表現し、かつポイントの順序が同じ場合には"
#~ "TRUEを返します。"

#~ msgid ""
#~ "Returns true if two geometries intersect and have the same dimension, but "
#~ "are not completely contained by each other."
#~ msgstr ""
#~ "二つのジオメトリがインタセクトし、同じ次元で、一方に完全に含まれることが無"
#~ "い場合にはTRUEを返します。"

#~ msgid ""
#~ "Returns true if two geometries have at least one point in common, but "
#~ "their interiors do not intersect."
#~ msgstr ""
#~ "ジオメトリが共通のポイントを少なくとも一つ持ち、かつ内部でインタセクトしな"
#~ "い場合にはTRUEを返します。"

#~ msgid ""
#~ "Returns true if no points of A lie in the exterior of B, and A and B have "
#~ "at least one interior point in common."
#~ msgstr ""
#~ "Aの外部にBのポイントが無く、かつAとBが内部に少なくとも一つのポイントを共有"
#~ "する場合にはTRUEを返します。"

#~ msgid "Returns true if two 3D geometries are within a given 3D distance"
#~ msgstr ""
#~ "二つの3次元ジオメトリが与えらえれた3次元距離内にある場合にはTRUEを返しま"
#~ "す。"

#~ msgid ""
#~ "Returns true if two 3D geometries are entirely within a given 3D distance"
#~ msgstr ""
#~ "二つの3次元ジオメトリが完全に与えらえれた3次元距離内にある場合にはTRUEを返"
#~ "します。"

#~ msgid "Returns true if two geometries are entirely within a given distance"
#~ msgstr ""
#~ "二つのジオメトリが完全に与えらえれた距離内にある場合にはTRUEを返します。"

#~ msgid "Returns true if two geometries are within a given distance"
#~ msgstr "二つのジオメトリが与えらえれた距離内にある場合にはTRUEを返します。"

#~ msgid ""
#~ "A subtlety of the definition is that a geometry does not contain its "
#~ "boundary. This implies that polygons and lines do <emphasis>not</"
#~ "emphasis> contain lines and points lying in their boundary. For further "
#~ "details see <ulink url=\"http://lin-ear-th-inking.blogspot.com/2007/06/"
#~ "subtleties-of-ogc-covers-spatial.html\">Subtleties of OGC Covers, "
#~ "Contains, Within</ulink>. (The <xref linkend=\"ST_Covers\"/> predicate "
#~ "provides a more inclusive relationship.) However, a geometry does contain "
#~ "itself. (In contrast, in the <xref linkend=\"ST_ContainsProperly\"/> "
#~ "predicate a geometry does <emphasis>not</emphasis> properly contain "
#~ "itself.)"
#~ msgstr ""
#~ "この定義は、ジオメトリに境界が含まれていない点で微妙です。これは、ポリゴン"
#~ "とラインに境界であるラインとポイントを<emphasis>含まない</emphasis>ことを"
#~ "意味します。詳細については、<ulink url=\"http://lin-ear-th-inking."
#~ "blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html\">Subtleties "
#~ "of OGC Covers, Contains, Within</ulink>をご覧下さい (<xref "
#~ "linkend=\"ST_Covers\"/>は、より包括的な関係を提供します)。しかし、ジオメト"
#~ "リ自体は含まれます (対して<xref linkend=\"ST_ContainsProperly\"/>ではジオ"
#~ "メトリは自身を<emphasis>正しく含むことにはなりません</emphasis>)。"

#~ msgid ""
#~ "The <function>ST_Contains</function> predicate returns <varname>TRUE</"
#~ "varname> in all the following illustrations."
#~ msgstr ""
#~ "次に示す図全てで、<function>ST_Contains</function>は<varname>TRUE</"
#~ "varname>を返します。"

#~ msgid ""
#~ "The <function>ST_Contains</function> predicate returns <varname>FALSE</"
#~ "varname> in all the following illustrations."
#~ msgstr ""
#~ "次に示す図全てで、<function>ST_Contains</function>は<function>FALSE</"
#~ "function>を返します。"

#~ msgid "In mathematical terms, this is expressed as:"
#~ msgstr "数学的に述べると、次のようになります。"

#~ msgid "The DE-9IM Intersection Matrix for the two geometries is:"
#~ msgstr "DE-9IMでは次のようになります。"

#~ msgid ""
#~ "For any other combination of dimensions this predicate returns false."
#~ msgstr "他の次元の組み合わせでは、FALSEが返されます。"

#~ msgid "The following illustrations all return <varname>TRUE</varname>."
#~ msgstr "次に示す図全てで、<varname>TRUE</varname>が返されます。"

#~ msgid ""
#~ "Given 2 linestrings, returns an integer between -3 and 3 indicating what "
#~ "kind of crossing behavior exists between them. 0 indicates no crossing. "
#~ "This is only supported for <varname>LINESTRING</varname>s."
#~ msgstr ""
#~ "二つのラインストリングを与えると、-3から3までの整数が返ります。この整数"
#~ "は、どのようにクロスしているかを示すもので、0は交差無しを意味します。この"
#~ "関数は<varname>LINESTRING</varname>にのみ対応しています。"

#~ msgid ""
#~ "Line 1 (green), Line 2 ball is start point, triangle are end points. "
#~ "Query below."
#~ msgstr ""
#~ "ライン1 (緑)とライン2 (青)、円が始点、三角が終点。クエリは次の通り。"

#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "    ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ "SELECT\n"
#~ " ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ " ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           3 |          -3"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "    ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ "SELECT\n"
#~ " ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ " ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           3 |          -3"

#~ msgid ""
#~ "Line 1 (green), Line 2 (blue) ball is start point, triangle are end "
#~ "points. Query below."
#~ msgstr ""
#~ "ライン1 (緑)とライン2 (青)、円が始点、三角が終点。クエリは次の通り。"

#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "    ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (171 154, 20 140, 71 74, 2.99 90.16)') As "
#~ "line2\n"
#~ ") As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           2 |          -2"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "    ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (171 154, 20 140, 71 74, 2.99 90.16)') As "
#~ "line2\n"
#~ ") As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           2 |          -2"

#~ msgid ""
#~ "SELECT\n"
#~ "  ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "  ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -1 |          1"
#~ msgstr ""
#~ "SELECT\n"
#~ "  ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "  ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -1 |          1"

#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "    ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING(2.99 90.16,71 74,20 140,171 154)') As "
#~ "line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -2 |          2"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "    ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING(2.99 90.16,71 74,20 140,171 154)') As "
#~ "line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -2 |          2"

#~ msgid ""
#~ "SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.geom, s2.geom)\n"
#~ "  FROM streets s1 CROSS JOIN streets s2 ON (s1.gid != s2.gid AND s1.geom "
#~ "&amp;&amp; s2.geom )\n"
#~ "WHERE ST_CrossingDirection(s1.geom, s2.geom) > 0;"
#~ msgstr ""
#~ "SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.geom, s2.geom)\n"
#~ "  FROM streets s1 CROSS JOIN streets s2 ON (s1.gid != s2.gid AND s1.geom "
#~ "&amp;&amp; s2.geom )\n"
#~ "WHERE ST_CrossingDirection(s1.geom, s2.geom) > 0;"

#~ msgid ""
#~ "Returns TRUE if the Geometries \"spatially overlap\". By that we mean "
#~ "they intersect, but one does not completely contain another."
#~ msgstr ""
#~ "ジオメトリが「空間的にオーバラップ」する場合にはTRUEを返します。ジオメトリ"
#~ "がインタセクトして、かつ一方が他方を完全には含まない場合です。"

#~ msgid ""
#~ "--a point on a line is contained by the line and is of a lower dimension, "
#~ "and therefore does not overlap the line\n"
#~ "      nor crosses\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b,\n"
#~ "  ST_Crosses(a,b) As a_crosses_b,\n"
#~ "    ST_Intersects(a, b) As a_intersects_b, ST_Contains(b,a) As "
#~ "b_contains_a\n"
#~ "FROM (SELECT ST_GeomFromText('POINT(1 0.5)') As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "  As foo\n"
#~ "\n"
#~ "a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a\n"
#~ "------------+-------------+----------------+--------------\n"
#~ "f           | f           | t              | t\n"
#~ "\n"
#~ "--a line that is partly contained by circle, but not fully is defined as "
#~ "intersecting and crossing,\n"
#~ "-- but since of different dimension it does not overlap\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b,\n"
#~ "  ST_Intersects(a, b) As a_intersects_b,\n"
#~ "  ST_Contains(a,b) As a_contains_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "  As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | a_contains_b\n"
#~ "-------------+-------------+----------------+--------------\n"
#~ " f           | t           | t              | f\n"
#~ "\n"
#~ " -- a 2-dimensional bent hot dog (aka buffered line string) that "
#~ "intersects a circle,\n"
#~ " -- but is not fully contained by the circle is defined as overlapping "
#~ "since they are of the same dimension,\n"
#~ "--  but it does not cross, because the intersection of the 2 is of the "
#~ "same dimension\n"
#~ "--  as the maximum dimension of the 2\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b, "
#~ "ST_Intersects(a, b) As a_intersects_b,\n"
#~ "ST_Contains(b,a) As b_contains_a,\n"
#~ "ST_Dimension(a) As dim_a, ST_Dimension(b) as dim_b, "
#~ "ST_Dimension(ST_Intersection(a,b)) As dima_intersection_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a,\n"
#~ "  ST_Buffer(ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)'),0.5)  As b)\n"
#~ "  As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a | dim_a | "
#~ "dim_b | dima_intersection_b\n"
#~ "-------------+-------------+----------------+--------------+-------"
#~ "+-------+---------------------\n"
#~ " t           | f           | t              | f            |     2 |     "
#~ "2 |              2"
#~ msgstr ""
#~ "-- 線上にある点は、線に含まれていますが\n"
#~ "-- 低い次元ですので、線とオーバラップもクロスもしません\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b,\n"
#~ "  ST_Crosses(a,b) As a_crosses_b,\n"
#~ "    ST_Intersects(a, b) As a_intersects_b, ST_Contains(b,a) As "
#~ "b_contains_a\n"
#~ "FROM (SELECT ST_GeomFromText('POINT(1 0.5)') As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "  As foo\n"
#~ "\n"
#~ "a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a\n"
#~ "------------+-------------+----------------+--------------\n"
#~ "f           | f           | t              | t\n"
#~ "\n"
#~ "-- ラインは部分的に円に含まれますが、完全にはインタセクトとクロスを満たし"
#~ "ません\n"
#~ "-- 次元の違いからオーバラップしません\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b,\n"
#~ "  ST_Intersects(a, b) As a_intersects_b,\n"
#~ "  ST_Contains(a,b) As a_contains_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "  As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | a_contains_b\n"
#~ "-------------+-------------+----------------+--------------\n"
#~ " f           | t           | t              | f\n"
#~ "\n"
#~ "-- 円にインタセクトした、2次元の曲がったホットドッグ\n"
#~ "-- (または、ふくれたラインストリング)です。\n"
#~ "-- 完全には円に含まれず、同じ次元ですのでオーバラップします。\n"
#~ "-- インタセクションの次元が最大次元と同じ2次元ですから、クロスしません。\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b, "
#~ "ST_Intersects(a, b) As a_intersects_b,\n"
#~ "ST_Contains(b,a) As b_contains_a,\n"
#~ "ST_Dimension(a) As dim_a, ST_Dimension(b) as dim_b, "
#~ "ST_Dimension(ST_Intersection(a,b)) As dima_intersection_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a,\n"
#~ "  ST_Buffer(ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)'),0.5)  As b)\n"
#~ "  As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a | dim_a | "
#~ "dim_b | dima_intersection_b\n"
#~ "-------------+-------------+----------------+--------------+-------"
#~ "+-------+---------------------\n"
#~ " t           | f           | t              | f            |     2 |     "
#~ "2 |              2"

#~ msgid ""
#~ "Returns <varname>TRUE</varname> if A and B intersect, but their interiors "
#~ "do not intersect. Equivalently, A and B have at least one point in "
#~ "common, and the common points lie in the intersection of their "
#~ "boundaries. For Point/Point inputs the relationship is always "
#~ "<varname>FALSE</varname>, since points do not have a boundary."
#~ msgstr ""
#~ "AとBがインタセクトするがAの内部とBの内部がインタセクトしない場合には"
#~ "<varname>TRUE</varname>を返します。AとBが少なくとも一つの共有点があり、共"
#~ "有点が境界同士でインタセクトした箇所に存在することと同じです。ポイント/ポ"
#~ "イント入力では、ポイントは境界を持たないため、常に<varname>FALSE</varname>"
#~ "を返します。"

#~ msgid "In mathematical terms, this relationship is expressed as:"
#~ msgstr "数学的に述べると、この関係は次のようになります。"

#~ msgid ""
#~ "The <function>ST_Touches</function> predicate returns <varname>TRUE</"
#~ "varname> in all the following illustrations."
#~ msgstr ""
#~ "次に示す図全てで、<function>ST_Touches</function>は<varname>TRUE</varname>"
#~ "を返します。"
