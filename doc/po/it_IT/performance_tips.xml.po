# SOME DESCRIPTIVE TITLE.
#
# Translators:
# Tommaso Di Bucchianico, 2013
# Sandro Santilli <strk@kbt.io>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2023-07-15 01:28+0000\n"
"PO-Revision-Date: 2023-09-13 10:51+0000\n"
"Last-Translator: Sandro Santilli <strk@kbt.io>\n"
"Language-Team: Italian <https://weblate.osgeo.org/projects/postgis/"
"performance_tipsxml/it/>\n"
"Language: it_IT\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 5.0\n"

#. Tag: title
#: performance_tips.xml:3
#, no-c-format
msgid "Performance Tips"
msgstr "Suggerimenti per le prestazioni"

#. Tag: title
#: performance_tips.xml:6
#, no-c-format
msgid "Small tables of large geometries"
msgstr "Piccole tabelle contenenti geometrie di grandi dimensioni"

#. Tag: title
#: performance_tips.xml:9
#, no-c-format
msgid "Problem description"
msgstr "Descrizione del problema"

#. Tag: para
#: performance_tips.xml:11
#, no-c-format
msgid ""
"Current PostgreSQL versions (including 9.6) suffer from a query optimizer "
"weakness regarding TOAST tables. TOAST tables are a kind of \"extension "
"room\" used to store large (in the sense of data size) values that do not "
"fit into normal data pages (like long texts, images or complex geometries "
"with lots of vertices), see <link xlink:href=\"http://www.postgresql.org/"
"docs/current/static/storage-toast.html\">the PostgreSQL Documentation for "
"TOAST</link> for more information)."
msgstr ""
"Le versioni attuali di PostgreSQL (compresa la 9.6) soffrono di una "
"debolezza dell'ottimizzatore di query per quanto riguarda le tabelle TOAST. "
"Le tabelle TOAST sono una sorta di \"stanza di estensione\" utilizzata per "
"memorizzare valori di grandi dimensioni (nel senso della dimensione dei dati)"
" che non si adattano alle normali pagine di dati (come testi lunghi, "
"immagini o geometrie complesse con molti vertici), si veda <link xlink:href="
"\"http://www.postgresql.org/docs/current/static/storage-toast.html\">la "
"documentazione PostgreSQL per TOAST</link> per maggiori informazioni)."

#. Tag: para
#: performance_tips.xml:19
#, no-c-format
msgid ""
"The problem appears if you happen to have a table with rather large "
"geometries, but not too many rows of them (like a table containing the "
"boundaries of all European countries in high resolution). Then the table "
"itself is small, but it uses lots of TOAST space. In our example case, the "
"table itself had about 80 rows and used only 3 data pages, but the TOAST "
"table used 8225 pages."
msgstr ""
"Il problema si presenta se si ha una tabella con geometrie piuttosto grandi, "
"ma non troppe righe (come una tabella contenente i confini di tutti i paesi "
"europei in alta risoluzione). In questo caso, la tabella stessa è piccola, "
"ma utilizza molto spazio TOAST. Nel nostro caso di esempio, la tabella "
"stessa aveva circa 80 righe e utilizzava solo 3 pagine di dati, ma la "
"tabella TOAST utilizzava 8225 pagine."

#. Tag: para
#: performance_tips.xml:26
#, no-c-format
msgid ""
"Now issue a query where you use the geometry operator &amp;&amp; to search "
"for a bounding box that matches only very few of those rows. Now the query "
"optimizer sees that the table has only 3 pages and 80 rows. It estimates "
"that a sequential scan on such a small table is much faster than using an "
"index. And so it decides to ignore the GIST index. Usually, this estimation "
"is correct. But in our case, the &amp;&amp; operator has to fetch every "
"geometry from disk to compare the bounding boxes, thus reading all TOAST "
"pages, too."
msgstr ""
"Ora si lanci una query che usi l'operatore &amp;&amp; e che trovi solo poche "
"righe. L'ottimizzatore di query ora vede che la tabella ha solo 3 pagine e "
"80 record. Stima che una scansione sequenziale su una tabella cosi' piccola "
"e' molto piu' veloce rispetto all'uso di un indice, e quindi decide di "
"ignorare l'indice GiST. Normalmente questa stima e' corretta, ma nel nostro "
"caso l'operatorore &amp;&amp; deve estrarre ogni geometria dal disco per "
"confrontare i bounding box finendo con il leggere anche tutte le pagine "
"TOAST."

#. Tag: para
#: performance_tips.xml:35
#, no-c-format
msgid ""
"To see whether your suffer from this issue, use the \"EXPLAIN ANALYZE\" "
"postgresql command. For more information and the technical details, you can "
"read the thread on the PostgreSQL performance mailing list: <link xlink:"
"href=\"http://archives.postgresql.org/pgsql-performance/2005-02/msg00030."
"php\">http://archives.postgresql.org/pgsql-performance/2005-02/msg00030.php</"
"link>"
msgstr ""
"Per controllare se i propri dati sono interessati da questo bug, si può "
"usare il comando PostgreSQL \"EXPLAIN ANALYZE\". Per maggiori informazioni e "
"dettagli tecnici consultare il corrispondente thread sulla mailing list di "
"PostgreSQL: <link xlink:href=\"http://archives.postgresql.org/pgsql-"
"performance/2005-02/msg00030.php\">http://archives.postgresql.org/pgsql-"
"performance/2005-02/msg00030.php</link>"

#. Tag: para
#: performance_tips.xml:41
#, no-c-format
msgid ""
"and newer thread on PostGIS <link xlink:href=\"https://lists.osgeo.org/"
"pipermail/postgis-devel/2017-June/026209.html\">https://lists.osgeo.org/"
"pipermail/postgis-devel/2017-June/026209.html</link>"
msgstr ""
"e una discussione più recente su PostGIS <link xlink:href=\"https://lists."
"osgeo.org/pipermail/postgis-devel/2017-June/026209.html\">https://lists.osgeo"
".org/pipermail/postgis-devel/2017-June/026209.html</link>"

#. Tag: title
#: performance_tips.xml:45
#, no-c-format
msgid "Workarounds"
msgstr "Possibili soluzioni"

#. Tag: para
#: performance_tips.xml:47
#, no-c-format
msgid ""
"The PostgreSQL people are trying to solve this issue by making the query "
"estimation TOAST-aware. For now, here are two workarounds:"
msgstr ""
"Gli sviluppatori di PostgreSQL stanno cercando di risolvere il problema "
"rendendo la valutazione della query indipendente dalla tabella TOAST. Per "
"ora ci sono due possibili soluzioni alternative:"

#. Tag: para
#: performance_tips.xml:50
#, no-c-format
msgid ""
"The first workaround is to force the query planner to use the index. Send "
"\"SET enable_seqscan TO off;\" to the server before issuing the query. This "
"basically forces the query planner to avoid sequential scans whenever "
"possible. So it uses the GIST index as usual. But this flag has to be set on "
"every connection, and it causes the query planner to make misestimations in "
"other cases, so you should \"SET enable_seqscan TO on;\" after the query."
msgstr ""
"La è forzare il query planner ad usare l'indice spaziale usando il comando "
"\"SET enable_seqscan TO off;\" prima di lanciare la query. Questo comando "
"impedisce al query planner di usare lo scan sequenziale della tabella se "
"possibile e lo forza quindi ad usare l'indice GIST. Tuttavia il comando deve "
"essere lanciato ad ogni connessione e, per evitare di confondere il query "
"planner in altri casi, il parametro deve essere resettato dopo l'esecuzione "
"della query interessata con il comando \"SET enable_seqscan TO on;\" ."

#. Tag: para
#: performance_tips.xml:58
#, no-c-format
msgid ""
"The second workaround is to make the sequential scan as fast as the query "
"planner thinks. This can be achieved by creating an additional column that "
"\"caches\" the bbox, and matching against this. In our example, the commands "
"are like:"
msgstr ""
"Il secondo metodo è rendere lo scan sequenziale così veloce come il query "
"planner si aspetta che sia. Questo può essere raggiunto aggiungendo una "
"colonna addizionale in cui salvare la bounding box di ogni geometria. Nel "
"nostro esempio i comandi sarebbero:"

#. Tag: para
#: performance_tips.xml:65
#, no-c-format
msgid ""
"Now change your query to use the &amp;&amp; operator against bbox instead of "
"geom_column, like:"
msgstr ""
"Ora la query deve essere modificata in modo da usare l'operatore &amp;&amp; "
"con la colonna bbox piuttosto che con la colonna geom_column:"

#. Tag: para
#: performance_tips.xml:70
#, no-c-format
msgid ""
"Of course, if you change or add rows to mytable, you have to keep the bbox "
"\"in sync\". The most transparent way to do this would be triggers, but you "
"also can modify your application to keep the bbox column current or run the "
"UPDATE query above after every modification."
msgstr ""
"Ovviamente la colonna bbox deve essere mantenuta attuale quando si "
"modificano o si aggiungono geometrie. La via più semplice per fare questo "
"sarebbe con un trigger, oppure l'applicazione può essere modificata in modo "
"da attualizzare anche la colonna bbox oppure si può lanciare l'UPDATE "
"precedente dopo ogni modifica."

#. Tag: title
#: performance_tips.xml:79
#, no-c-format
msgid "CLUSTERing on geometry indices"
msgstr "CLUSTERing di indici geometrici"

#. Tag: para
#: performance_tips.xml:81
#, no-c-format
msgid ""
"For tables that are mostly read-only, and where a single index is used for "
"the majority of queries, PostgreSQL offers the CLUSTER command. This command "
"physically reorders all the data rows in the same order as the index "
"criteria, yielding two performance advantages: First, for index range scans, "
"the number of seeks on the data table is drastically reduced. Second, if "
"your working set concentrates to some small intervals on the indices, you "
"have a more efficient caching because the data rows are spread along fewer "
"data pages. (Feel invited to read the CLUSTER command documentation from the "
"PostgreSQL manual at this point.)"
msgstr ""
"Per tabelle che vengono per lo più solo lette, e dove un singolo indice è "
"usato dalla maggior parte delle query, PostgreSQL offre il comando CLUSTER. "
"Questo comando riordina fisicamente le righe in modo che l'ordine "
"corrisponda a quello dell'indice. Con questo metodo si migliorano le "
"prestazioni per due motivi: primo, il numero delle ricerche nella tabella "
"dei dati è ridotto drasticamente. Secondo, se i dati interessati dalla query "
"sono concentrati in un piccolo intervallo sull'indice, il processo di "
"mettere in cache sarà più efficiente perché le righe saranno distribuite "
"all'interno di poche pagine. (si invita a leggere la documentazione di "
"PostgreSQL riguardante il comando CLUSTER)."

#. Tag: para
#: performance_tips.xml:91
#, no-c-format
msgid ""
"However, currently PostgreSQL does not allow clustering on PostGIS GIST "
"indices because GIST indices simply ignores NULL values, you get an error "
"message like:"
msgstr ""
"Attualmente però, PostgreSQL non permette di usare il clustering con indici "
"GIST, perché gli indici GIST ignorano i valori nulli:"

#. Tag: para
#: performance_tips.xml:97
#, no-c-format
msgid ""
"As the HINT message tells you, one can work around this deficiency by adding "
"a \"not null\" constraint to the table:"
msgstr ""
"Come suggerito dal messaggio di errore, è possibile aggirare il problema "
"aggiungendo un vincolo \"NOT NULL\" alla tabella:"

#. Tag: para
#: performance_tips.xml:102
#, no-c-format
msgid ""
"Of course, this will not work if you in fact need NULL values in your "
"geometry column. Additionally, you must use the above method to add the "
"constraint, using a CHECK constraint like \"ALTER TABLE blubb ADD CHECK "
"(geometry is not null);\" will not work."
msgstr ""
"Ovviamente questo non funzionerà se la colonna the_geom già contiene valori "
"nulli. Inoltre il vincolo dev'essere definito usando il comando precedente. "
"Usare un vincolo CHECK del tipo \"ALTER TABLE blubb ADD CHECK (geometry is "
"not null);\" non funzionerà."

#. Tag: title
#: performance_tips.xml:109
#, no-c-format
msgid "Avoiding dimension conversion"
msgstr "Evitare la conversione della dimensione"

#. Tag: para
#: performance_tips.xml:111
#, no-c-format
msgid ""
"Sometimes, you happen to have 3D or 4D data in your table, but always access "
"it using OpenGIS compliant ST_AsText() or ST_AsBinary() functions that only "
"output 2D geometries. They do this by internally calling the ST_Force2D() "
"function, which introduces a significant overhead for large geometries. To "
"avoid this overhead, it may be feasible to pre-drop those additional "
"dimensions once and forever:"
msgstr ""
"A volte può accadere di avere dati in 3D o 4D, ma di accederli sempre usando "
"funzioni che danno in output solo geometrie 2D come ST_AsText() oppure "
"ST_AsBinary(). Queste funzioni processano internamente le geometrie "
"eseguendo ST_Force2D() e questo può risultare in un peggioramento delle "
"prestazioni significativo nel caso di geometrie di grandi dimensioni. Per "
"evitare questo problema è consigliabile eliminare le dimensioni non "
"utilizzate una volte e per sempre:"

#. Tag: para
#: performance_tips.xml:120
#, no-c-format
msgid ""
"Note that if you added your geometry column using AddGeometryColumn() "
"there'll be a constraint on geometry dimension. To bypass it you will need "
"to drop the constraint. Remember to update the entry in the geometry_columns "
"table and recreate the constraint afterwards."
msgstr ""
"Se la colonna di tipo geometry è stata aggiunta usando la funzione "
"AddGeometryColumn(), verrà creato anche un vincolo dimensionale sulla "
"geometria. Per aggirare il vincolo sarà necessario cancellarlo. Ricorda di "
"attualizzare il record nella tabella geometry_columns e di ricreare il "
"vincolo successivamente."

#. Tag: para
#: performance_tips.xml:126
#, no-c-format
msgid ""
"In case of large tables, it may be wise to divide this UPDATE into smaller "
"portions by constraining the UPDATE to a part of the table via a WHERE "
"clause and your primary key or another feasible criteria, and running a "
"simple \"VACUUM;\" between your UPDATEs. This drastically reduces the need "
"for temporary disk space. Additionally, if you have mixed dimension "
"geometries, restricting the UPDATE by \"WHERE dimension(geom)&gt;2\" skips "
"re-writing of geometries that already are in 2D."
msgstr ""
"Nel caso di tabelle di grandi dimensioni, può essere opportuno dividere "
"l'UPDATE in porzioni più piccole, vincolando l'UPDATE a una parte della "
"tabella tramite una clausola WHERE e la chiave primaria o un altro criterio "
"fattibile ed eseguendo un semplice \"VACUUM;\" tra gli UPDATE. In questo "
"modo si riduce drasticamente la necessità di spazio temporaneo su disco. "
"Inoltre, se si hanno geometrie di dimensioni miste, limitando "
"l'AGGIORNAMENTO con \"WHERE dimension(geom)&gt;2\" si evita di riscrivere le "
"geometrie che sono già in 2D."
