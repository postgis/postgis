# SOME DESCRIPTIVE TITLE.
#
# Translators:
# David Martinez Morata, 2013-2014
# David Mateos <territorio@terrativa.net>, 2014
# David Mateos <territorio@terrativa.net>, 2014
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2020-12-15 04:51+0000\n"
"PO-Revision-Date: 2014-10-15 16:44+0000\n"
"Last-Translator: Sandro Santilli <strk@kbt.io>\n"
"Language-Team: Spanish (http://www.transifex.com/projects/p/postgis-1/"
"language/es/)\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. Tag: title
#: using_postgis_dataman.xml:3
#, no-c-format
msgid "Data Management"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:6
#, no-c-format
msgid "GIS Objects"
msgstr "Objetos SIG"

#. Tag: para
#: using_postgis_dataman.xml:8
#, fuzzy, no-c-format
msgid ""
"The GIS objects supported by PostGIS are a superset of the \"Simple Features"
"\" standard defined by the OpenGIS Consortium (OGC). PostGIS supports all "
"the objects and functions specified in the OGC \"Simple Features for SQL\" "
"specification (SFS)."
msgstr ""
"Los objetos SIG soportados por PostGIS son una colección de \"Simple Features"
"\" definidas por el OpenGIS Consortium (OGC). A partir de la versión 0.9, "
"PostGIS soporta todos los objetos y funciones de la especificación \"Simple "
"Features for SQL\" del OGC."

#. Tag: para
#: using_postgis_dataman.xml:13
#, fuzzy, no-c-format
msgid ""
"PostGIS extends the standard with support for embedded SRID information."
msgstr ""
"PostGIS extiende el estándar con soporte para coordenadas  3DZ,3DM y 4D."

#. Tag: title
#: using_postgis_dataman.xml:16
#, no-c-format
msgid "OpenGIS WKB and WKT"
msgstr "OpenGIS WKB y WKT"

#. Tag: para
#: using_postgis_dataman.xml:18
#, no-c-format
msgid ""
"The OpenGIS specification defines two standard ways of expressing spatial "
"objects: the Well-Known Text (WKT) form and the Well-Known Binary (WKB) "
"form. Both WKT and WKB include information about the type of the object and "
"the coordinates which form the object."
msgstr ""
"La especificación OpenGIS define dos formas estándar de expresar objetos "
"espaciales: la forma Well-Known Text (WKT) y la forma Well-Known Binary "
"(WKB). Ambas WKT y WKB, incluyen información sobre el tipo de objeto y el "
"sistema de coordenadas del objeto."

#. Tag: para
#: using_postgis_dataman.xml:23
#, no-c-format
msgid ""
"Examples of the text representations (WKT) of the spatial objects of the "
"features are as follows:"
msgstr ""
"Algunos ejemplos de representaciones (WKT) de objetos espaciales de objetos "
"geográficos son de la siguiente manera:"

#. Tag: para
#: using_postgis_dataman.xml:28
#, no-c-format
msgid "POINT(0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:32
#, fuzzy, no-c-format
msgid "POINT Z (0 0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:36
#, fuzzy, no-c-format
msgid "POINT ZM (0 0 0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:40
#, no-c-format
msgid "LINESTRING(0 0,1 1,1 2)"
msgstr "LINESTRING(0 0,1 1,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:44
#, no-c-format
msgid "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"
msgstr "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"

#. Tag: para
#: using_postgis_dataman.xml:48
#, fuzzy, no-c-format
msgid "MULTIPOINT((0 0),(1 2))"
msgstr "MULTIPOINT(0 0,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:52
#, fuzzy, no-c-format
msgid "MULTIPOINT Z ((0 0 0),(1 2 3))"
msgstr "MULTIPOINT(0 0,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:56
#, no-c-format
msgid "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"
msgstr "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"

#. Tag: para
#: using_postgis_dataman.xml:60
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"
msgstr ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"

#. Tag: para
#: using_postgis_dataman.xml:65
#, no-c-format
msgid "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"
msgstr "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"

#. Tag: para
#: using_postgis_dataman.xml:69
#, no-c-format
msgid ""
"The OpenGIS specification also requires that the internal storage format of "
"spatial objects include a spatial referencing system identifier (SRID). The "
"SRID is required when creating spatial objects for insertion into the "
"database."
msgstr ""
"La especificación OpenGIS también requiere que el almacenamiento interno de "
"objetos espaciales incluya el sistema de referencia espacial (SRID). El SRID "
"es necesario al crear objetos espaciales para añadirlos a la base de datos."

#. Tag: para
#: using_postgis_dataman.xml:74
#, no-c-format
msgid ""
"Input/Output of these formats are available using the following interfaces:"
msgstr ""
"La Entrada/Salida de estos formatos están disponibles utilizando las "
"interfaces siguientes:"

#. Tag: programlisting
#: using_postgis_dataman.xml:77
#, no-c-format
msgid ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"
msgstr ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"

#. Tag: para
#: using_postgis_dataman.xml:79
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert an OGC spatial "
"object would be:"
msgstr ""
"Por ejemplo un comando valido de inserción para crear e insertar un objeto "
"espacial OGC podría ser:"

#. Tag: programlisting
#: using_postgis_dataman.xml:82
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"

#. Tag: title
#: using_postgis_dataman.xml:86
#, no-c-format
msgid "PostGIS EWKB, EWKT and Canonical Forms"
msgstr "En PostGIS EWKB, EWKT y foma Canonica"

#. Tag: para
#: using_postgis_dataman.xml:88
#, fuzzy, no-c-format
msgid ""
"First OpenGIS specifications (prior to 1.2.0) only support 2D geometries, "
"and the associated SRID is *never* embedded in the input/output "
"representations."
msgstr ""
"Los formatos OGC solo soportan geometrías 2D, y los SRID asociados nunca son "
"embebidos en las representaciones de entrada/salida."

#. Tag: para
#: using_postgis_dataman.xml:91
#, no-c-format
msgid ""
"Even though the last OpenGIS specification 1.2.1 supports 3DM and 3DZ "
"coordinates specifing ZM qualifiers, it does not include yet the associated "
"SRID in the input/output representations."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:95
#, fuzzy, no-c-format
msgid ""
"PostGIS extended formats add 3DM, 3DZ, 4D coordinates support and embedded "
"SRID information. However, PostGIS EWKB/EWKT outputs have several "
"peculiarities:"
msgstr ""
"PostGIS EWKB/EWKT añade soporte a coordenadas 3dm, 3dz y 4d y a información "
"embebida del SRID."

#. Tag: para
#: using_postgis_dataman.xml:100
#, no-c-format
msgid "For 3DZ geometries they will drop the Z qualifier:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:101
#, no-c-format
msgid "OpenGIS: POINT Z (1 2 3)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:102
#, no-c-format
msgid "EWKB/EWKT: POINT(1 2 3)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:105
#, no-c-format
msgid "For 3DM geometries they will keep the M qualifier:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:106
#, no-c-format
msgid "OpenGIS: POINT M (1 2 3)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:107
#, no-c-format
msgid "EWKB/EWKT: POINTM(1 2 3)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:110
#, no-c-format
msgid "For 4D geometries they will drop the ZM qualifiers:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:111
#, no-c-format
msgid "OpenGIS: POINT ZM (1 2 3 4)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:112
#, no-c-format
msgid "EWKB/EWKT: POINT(1 2 3 4)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:116
#, no-c-format
msgid ""
"By doing this, PostGIS EWKB/EWKT avoids over-specifying dimensionality and a "
"whole categories of potential errors that ISO admits, e.g.:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:121
#, fuzzy, no-c-format
msgid "POINT ZM (1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:124
#, fuzzy, no-c-format
msgid "POINT ZM (1 1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:127
#, fuzzy, no-c-format
msgid "POINT (1 1 1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:132
#, fuzzy, no-c-format
msgid ""
"PostGIS extended formats are currently superset of the OGC one (every valid "
"WKB/WKT is a valid EWKB/EWKT) but this might vary in the future, "
"specifically if OGC comes out with a new format conflicting with our "
"extensions. Thus you SHOULD NOT rely on this feature!"
msgstr ""
"Los formatos extendidos de PostGIS son un superconjunto de los OGC "
"actualmente (todo WKB/WKT valido es un EWKB/EWKT valido) pero esto puede "
"variar en el futuro, especialmente si el OGC saca un nuevo formato que crea "
"conflictos con nuestras extensiones. ¡Por lo tanto NO DEBERIAS confiar en "
"esta característica!"

#. Tag: para
#: using_postgis_dataman.xml:137
#, fuzzy, no-c-format
msgid ""
"Examples of the text representations (EWKT) of the extended spatial objects "
"of the features are as follows."
msgstr ""
"Algunos ejemplos de representaciones (WKT) de objetos espaciales de objetos "
"geográficos son de la siguiente manera:"

#. Tag: para
#: using_postgis_dataman.xml:142
#, no-c-format
msgid "POINT(0 0 0) -- XYZ"
msgstr "POINT(0 0 0) -- XYZ"

#. Tag: para
#: using_postgis_dataman.xml:146
#, no-c-format
msgid "SRID=32632;POINT(0 0) -- XY with SRID"
msgstr "SRID=32632;POINT(0 0) -- XY with SRID"

#. Tag: para
#: using_postgis_dataman.xml:150
#, no-c-format
msgid "POINTM(0 0 0) -- XYM"
msgstr "POINTM(0 0 0) -- XYM"

#. Tag: para
#: using_postgis_dataman.xml:154
#, no-c-format
msgid "POINT(0 0 0 0) -- XYZM"
msgstr "POINT(0 0 0 0) -- XYZM"

#. Tag: para
#: using_postgis_dataman.xml:158
#, no-c-format
msgid "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"
msgstr "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"

#. Tag: para
#: using_postgis_dataman.xml:162
#, no-c-format
msgid "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"
msgstr "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"

#. Tag: para
#: using_postgis_dataman.xml:167
#, no-c-format
msgid ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"
msgstr ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"

#. Tag: para
#: using_postgis_dataman.xml:172
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"
msgstr ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"

#. Tag: para
#: using_postgis_dataman.xml:177
#, no-c-format
msgid "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"
msgstr "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"

#. Tag: para
#: using_postgis_dataman.xml:181
#, no-c-format
msgid "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"
msgstr "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"

#. Tag: para
#: using_postgis_dataman.xml:185
#, no-c-format
msgid ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"
msgstr ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"

#. Tag: para
#: using_postgis_dataman.xml:191
#, no-c-format
msgid "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"
msgstr "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"

#. Tag: para
#: using_postgis_dataman.xml:195
#, no-c-format
msgid "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"
msgstr "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"

#. Tag: para
#: using_postgis_dataman.xml:200
#, fuzzy, no-c-format
msgid ""
"Conversion between these formats is available using the following interfaces:"
msgstr ""
"La Entrada/Salida de estos formatos están disponibles utilizando las "
"interfaces siguientes:"

#. Tag: programlisting
#: using_postgis_dataman.xml:202
#, no-c-format
msgid ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"
msgstr ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"

#. Tag: para
#: using_postgis_dataman.xml:204
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert a PostGIS spatial "
"object would be:"
msgstr ""
"Por ejemplo, una consulta \"insert\" valida para crear e insertas un objeto "
"espacial PostGIS debería ser: "

#. Tag: programlisting
#: using_postgis_dataman.xml:207
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"

#. Tag: para
#: using_postgis_dataman.xml:209
#, fuzzy, no-c-format
msgid ""
"The \"canonical forms\" of a PostgreSQL type are the representations you get "
"with a simple query (without any function call) and the one which is "
"guaranteed to be accepted with a simple insert, update or copy. For the "
"PostGIS 'geometry' type these are:"
msgstr ""
"Las formas \"canónicas\" de un tipo PostgreSQL son las representaciones que "
"obtienes con una consulta simple (sin ninguna llamada a funciones) y la "
"única que esta garantizada en ser aceptada con un simple \"insert\", \"update"
"\" o \"copy\". para los tipos 'geómetra' de PostGIS son:"

#. Tag: programlisting
#: using_postgis_dataman.xml:213
#, no-c-format
msgid ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"
msgstr ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"

#. Tag: para
#: using_postgis_dataman.xml:215
#, no-c-format
msgid ""
"For example this statement reads EWKT and returns HEXEWKB in the process of "
"canonical ascii input/output:"
msgstr ""
"Por ejemplo, esta consulta lee EWKT y devuelve HEXEWKB en el proceso de "
"entrada/salida ascii canónico."

#. Tag: programlisting
#: using_postgis_dataman.xml:218
#, no-c-format
msgid ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"
msgstr ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"

#. Tag: title
#: using_postgis_dataman.xml:221
#, no-c-format
msgid "SQL-MM Part 3"
msgstr "SQL-MM Parte 3"

#. Tag: para
#: using_postgis_dataman.xml:223
#, no-c-format
msgid ""
"The SQL Multimedia Applications Spatial specification extends the simple "
"features for SQL spec by defining a number of circularly interpolated curves."
msgstr ""
"La especificación SQL Multimedia Applications Spatial extiende los objetos "
"simples para la especificación SQL definiendo un numero de curvas "
"interpoladas. "

#. Tag: para
#: using_postgis_dataman.xml:227
#, fuzzy, no-c-format
msgid ""
"The SQL-MM definitions include 3DM, 3DZ and 4D coordinates, but do not allow "
"the embedding of SRID information."
msgstr ""
"Las definiciones SQL-MM incluyen coordenadas 3dm, 3dz y 4d, pero no permiten "
"integrar la información SRID."

#. Tag: para
#: using_postgis_dataman.xml:230
#, fuzzy, no-c-format
msgid ""
"The Well-Known Text extensions are not yet fully supported. Examples of some "
"simple curved geometries are shown below:"
msgstr ""
"Las extensiones de well-know text no están aún completamente soportadas. A "
"continuación se muestran ejemplos de algunas geometrías simples curvadas:"

#. Tag: para
#: using_postgis_dataman.xml:235
#, no-c-format
msgid "CIRCULARSTRING(0 0, 1 1, 1 0)"
msgstr "CIRCULARSTRING(0 0, 1 1, 1 0)"

#. Tag: para
#: using_postgis_dataman.xml:236
#, no-c-format
msgid "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"
msgstr "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"

#. Tag: para
#: using_postgis_dataman.xml:237
#, fuzzy, no-c-format
msgid ""
"The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the "
"linear world. A single segment required three points, the start and end "
"points (first and third) and any other point on the arc. The exception to "
"this is for a closed circle, where the start and end points are the same. In "
"this case the second point MUST be the center of the arc, ie the opposite "
"side of the circle. To chain arcs together, the last point of the previous "
"arc becomes the first point of the next arc, just like in LINESTRING. This "
"means that a valid circular string must have an odd number of points greater "
"than 1."
msgstr ""
"CIRCULARSTRING es el tipo básico de curva, similar a LINESTRING en el mundo "
"lineal. Un segmento simple necesita tres puntos, los puntos de inicio y fin "
"(primero y tercero) y cualquier otro punto del arco. La excepción a esto es "
"para un círculo cerrado, donde el punto de inicio y fin son el mismo. En "
"este caso, el segundo punto DEBE ser el centro del arco, esto es el lado "
"opuesto del círculo. Para encadenar arcos juntos, el último punto del arco "
"previo, se convierte en el primero del siguiente, como ocurre con "
"LINESTRING. Esto quiere decir que una cadena circular válida debe tener un "
"número impar de puntos mayor que 1."

#. Tag: para
#: using_postgis_dataman.xml:250
#, no-c-format
msgid "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"
msgstr "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"

#. Tag: para
#: using_postgis_dataman.xml:251
#, no-c-format
msgid ""
"A compound curve is a single, continuous curve that has both curved "
"(circular) segments and linear segments. That means that in addition to "
"having well-formed components, the end point of every component (except the "
"last) must be coincident with the start point of the following component."
msgstr ""
"Una curva compuesta es una curva simple y continua, que tiene segmentos "
"curvos (circular) y segmentos lineales. Esto significa que ademas de tener "
"componentes bien formados, el punto final de cada componente (excepto el "
"ultimo) debe coincidir con el punto inicial del componente siguiente."

#. Tag: para
#: using_postgis_dataman.xml:259
#, no-c-format
msgid ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"
msgstr ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"

#. Tag: para
#: using_postgis_dataman.xml:261
#, no-c-format
msgid ""
"Example compound curve in a curve polygon: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"
msgstr ""
"Ejemplo de curva compuesta en un polígono curvo: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"

#. Tag: para
#: using_postgis_dataman.xml:265
#, no-c-format
msgid ""
"A CURVEPOLYGON is just like a polygon, with an outer ring and zero or more "
"inner rings. The difference is that a ring can take the form of a circular "
"string, linear string or compound string."
msgstr ""
"Un CURVEPOLYGON es como un poligono, con un anillo externo y cero o mas "
"anillos internos. La diferencia es que que este anillo puede tomar la forma "
"de una cadena circular, cadena lineal o una cadena de curva compuesta."

#. Tag: para
#: using_postgis_dataman.xml:269
#, no-c-format
msgid "As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon."
msgstr ""
"A partir de PostGIS 1.4, PostGIS soporta curvas compuestas en un polígono "
"curvo."

#. Tag: para
#: using_postgis_dataman.xml:273
#, no-c-format
msgid "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"
msgstr "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"

#. Tag: para
#: using_postgis_dataman.xml:274
#, no-c-format
msgid ""
"The MULTICURVE is a collection of curves, which can include linear strings, "
"circular strings or compound strings."
msgstr ""
"Una MULTICURVE es una colección de curvas, que puede incluir cadenas "
"lineales, cadenas curvas o curvas compuestas."

#. Tag: para
#: using_postgis_dataman.xml:279
#, no-c-format
msgid ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"
msgstr ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"

#. Tag: para
#: using_postgis_dataman.xml:282
#, no-c-format
msgid ""
"This is a collection of surfaces, which can be (linear) polygons or curve "
"polygons."
msgstr ""
"Esto es una colección de superficies, que pueden ser polígonos (lineales) o "
"polígonos curvos."

#. Tag: para
#: using_postgis_dataman.xml:288
#, no-c-format
msgid ""
"All floating point comparisons within the SQL-MM implementation are "
"performed to a specified tolerance, currently 1E-8."
msgstr ""
"Todas las comparaciones de coma flotante en la implementación SQL-MM se "
"desarrollan para una tolerancia específica, normalmente 1E-8."

#. Tag: title
#: using_postgis_dataman.xml:294
#, no-c-format
msgid "PostGIS Geography Type"
msgstr "Tipo Geography en PostGIS"

#. Tag: para
#: using_postgis_dataman.xml:296
#, no-c-format
msgid ""
"The geography type provides native support for spatial features represented "
"on \"geographic\" coordinates (sometimes called \"geodetic\" coordinates, or "
"\"lat/lon\", or \"lon/lat\"). Geographic coordinates are spherical "
"coordinates expressed in angular units (degrees)."
msgstr ""
"El tipo \"geography\" proporciona soporte nativo para objetos espaciales "
"representados por coordenadas geográficas ( a veces llamadas coordenadas "
"geodésicas, o \"lat/lon\", o \"lob/lat\"). Las coordenadas geográficas son "
"coordenadas esféricas expresadas en unidades angulares (grados)."

#. Tag: para
#: using_postgis_dataman.xml:298
#, no-c-format
msgid ""
"The basis for the PostGIS geometry type is a plane. The shortest path "
"between two points on the plane is a straight line. That means calculations "
"on geometries (areas, distances, lengths, intersections, etc) can be "
"calculated using cartesian mathematics and straight line vectors."
msgstr ""
"La base del tipo \"geometry\" de PostGIS es un plano. El camino mas corto "
"entre dos puntos en un plano es una linea recta. Esto significa que los "
"cálculos en geometrías (áreas, distancias, longitudes, intersecciones, etc) "
"pueden calcularse utilizando matemáticas cartesiana y vectores lineales."

#. Tag: para
#: using_postgis_dataman.xml:300
#, fuzzy, no-c-format
msgid ""
"The basis for the PostGIS geographic type is a sphere. The shortest path "
"between two points on the sphere is a great circle arc. That means that "
"calculations on geographies (areas, distances, lengths, intersections, etc) "
"must be calculated on the sphere, using more complicated mathematics. For "
"more accurate measurements, the calculations must take the actual spheroidal "
"shape of the world into account."
msgstr ""
"La base del tipo geografico de PostGIS es una esfera. El camino mas corto "
"entre dos puntos en la esfera es el arco de circunferencia mas corto que une "
"los dos puntos. esto significa que los cálculos geográficos (áreas, "
"distancias, longitudes, intersecciones, etc) deben calcularse en la esfera, "
"utilizando matemáticas mas complejas. Para medidas mas precisas, los "
"cálculos deben tomar la forma esferoidal actual del mundo en cuenta, y las "
"matemáticas se vuelven aun mas complejas."

#. Tag: para
#: using_postgis_dataman.xml:302
#, no-c-format
msgid ""
"Because the underlying mathematics is much more complicated, there are fewer "
"functions defined for the geography type than for the geometry type. Over "
"time, as new algorithms are added, the capabilities of the geography type "
"will expand."
msgstr ""
"Debido a que las matemáticas subyacentes son mas complejas, hay varias "
"funciones definidas para el tipo geográfico y no para el tipo geométrico. "
"Con el tiempo, conforme se añadan nuevos algoritmos, las capacidades del "
"tipo geográfico se irán expandiendo."

#. Tag: para
#: using_postgis_dataman.xml:304
#, fuzzy, no-c-format
msgid ""
"It uses a data type called <varname>geography</varname>. None of the GEOS "
"functions support the <varname>geography</varname> type. As a workaround one "
"can convert back and forth between geometry and geography types."
msgstr ""
"Una restricción es que sólo soporta longitud y latitud en WGS84 (SRID:4326). "
"Utiliza un nuevo tipo llamado \"geography\". Ninguna de las funciones de "
"GEOS soporta este nuevo tipo. Para solucionar este problema se puede "
"convertir entre los tipos de \"geometry\" y \"geography\"."

#. Tag: para
#: using_postgis_dataman.xml:307
#, no-c-format
msgid ""
"Prior to PostGIS 2.2, the geography type only supported WGS 84 long lat "
"(SRID:4326). For PostGIS 2.2 and above, any long/lat based spatial reference "
"system defined in the <varname>spatial_ref_sys</varname> table can be used. "
"You can even add your own custom spheroidal spatial reference system as "
"described in <ulink url=\"http://www.bostongis.com/blog/index.php?/"
"archives/266-geography-type-is-not-limited-to-earth.html\">geography type is "
"not limited to earth</ulink>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:311
#, no-c-format
msgid ""
"Regardless which spatial reference system you use, the units returned by the "
"measurement (<xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_Length\"/>, "
"<xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Area\"/>) and for input "
"of <xref linkend=\"ST_DWithin\"/> are in meters."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:313
#, fuzzy, no-c-format
msgid ""
"The geography type uses the PostgreSQL typmod definition format so that a "
"table with a geography field can be added in a single step. All the standard "
"OGC formats except for curves are supported."
msgstr ""
"El nuevo tipo \"geography\" utiliza el formato de definición typmod de "
"PostgreSQL 8.3+ así se puede añadir una tabla con un campo geográfico de "
"forma sencilla. Todos los formatos OGC excepto la curva están soportados."

#. Tag: title
#: using_postgis_dataman.xml:317
#, no-c-format
msgid "Geography Basics"
msgstr "Bases del tipo \"Geography\""

#. Tag: para
#: using_postgis_dataman.xml:318
#, fuzzy, no-c-format
msgid ""
"The geography type does not support curves, TINS, or POLYHEDRALSURFACEs, but "
"other geometry types are supported. Standard geometry type data will "
"autocast to geography if it is of SRID 4326. You can also use the EWKT and "
"EWKB conventions to insert data."
msgstr ""
"El tipo \"geography\" solo soporta el mas simple de los objetos simples. "
"Datos del tipo de geometría estándar serán moldeados al tipo \"geography\" "
"si esta en SRID 4326. También puedes emplear las convenciones EWKT y EWKB "
"para añadir datos."

#. Tag: para
#: using_postgis_dataman.xml:323
#, no-c-format
msgid ""
"POINT: Creating a table with 2D point geography when srid is not specified "
"defaults to 4326 WGS 84 long lat:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:324
#, fuzzy, no-c-format
msgid "CREATE TABLE ptgeogwgs(gid serial PRIMARY KEY, geog geography(POINT) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:325
#, fuzzy, no-c-format
msgid "POINT: Creating a table with 2D point geography in NAD83 longlat:"
msgstr "PUNTO: Creando una tabla con una geometría puntual 2D:"

#. Tag: programlisting
#: using_postgis_dataman.xml:326
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE ptgeognad83(gid serial PRIMARY KEY, geog "
"geography(POINT,4269) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:327
#, fuzzy, no-c-format
msgid "Creating a table with z coordinate point and explicitly specifying srid"
msgstr "Creando una tabla con un punto con coordenada z"

#. Tag: programlisting
#: using_postgis_dataman.xml:328
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE ptzgeogwgs84(gid serial PRIMARY KEY, geog "
"geography(POINTZ,4326) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINTZ,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:331
#, no-c-format
msgid "LINESTRING"
msgstr "LINESTRING"

#. Tag: programlisting
#: using_postgis_dataman.xml:332
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE lgeog(gid serial PRIMARY KEY, geog geography(LINESTRING) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:335
#, no-c-format
msgid "POLYGON"
msgstr "POLYGON"

#. Tag: programlisting
#: using_postgis_dataman.xml:336
#, fuzzy, no-c-format
msgid ""
"--polygon NAD 1927 long lat\n"
"CREATE TABLE lgeognad27(gid serial PRIMARY KEY, geog "
"geography(POLYGON,4267) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:339
#, no-c-format
msgid "MULTIPOINT"
msgstr "MULTIPOINT"

#. Tag: para
#: using_postgis_dataman.xml:342
#, no-c-format
msgid "MULTILINESTRING"
msgstr "MULTILINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:345
#, no-c-format
msgid "MULTIPOLYGON"
msgstr "MULTIPOLYGON"

#. Tag: para
#: using_postgis_dataman.xml:348
#, no-c-format
msgid "GEOMETRYCOLLECTION"
msgstr "GEOMETRYCOLLECTION"

#. Tag: para
#: using_postgis_dataman.xml:352
#, no-c-format
msgid ""
"The geography fields get registered in the <varname>geography_columns</"
"varname> system view."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:354
#, no-c-format
msgid ""
"Now, check the \"geography_columns\" view and see that your table is listed."
msgstr ""
"Ahora, comprueba la vista  \"geography_columns\"  y mira si tu tabla está "
"listada"

#. Tag: para
#: using_postgis_dataman.xml:356
#, no-c-format
msgid ""
"You can create a new table with a GEOGRAPHY column using the CREATE TABLE "
"syntax."
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:359
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"
msgstr ""
"CREATE TABLE global_points ( \n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"

#. Tag: para
#: using_postgis_dataman.xml:362
#, fuzzy, no-c-format
msgid ""
"Note that the location column has type GEOGRAPHY and that geography type "
"supports two optional modifiers: a type modifier that restricts the kind of "
"shapes and dimensions allowed in the column; an SRID modifier that restricts "
"the coordinate reference identifier to a particular number."
msgstr ""
"Se puede notar que la columna de localización es de tipo GEOGRAPHY y este "
"tipo geográfico soporta dos modificadores opcionales: un modificador de tipo "
"que restringe la clase de formas y dimensiones permitidas en la columna; y "
"un modificador SRID que restringe el identificador de las coordenadas de "
"referencia a un número particular."

#. Tag: para
#: using_postgis_dataman.xml:363
#, no-c-format
msgid ""
"Allowable values for the type modifier are: POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. The modifier also supports "
"dimensionality restrictions through suffixes: Z, M and ZM. So, for example a "
"modifier of 'LINESTRINGM' would only allow line strings with three "
"dimensions in, and would treat the third dimension as a measure. Similarly, "
"'POINTZM' would expect four dimensional data."
msgstr ""
"Valores permitdos para el modificador de tipo son: POINT, LINESTRING, "
"POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. El modificador también "
"acepta restricciones dimensionales a través de sufijos: Z, M Y ZM. Así, por "
"ejemplo, un modificador de  'LINESTRINGM'  permitirá sólo líneas con tres "
"dimensiones, y trataría la tercera dimensión como una medida. De forma "
"similar, 'POINTZM' esperará datos de cuatro dimensiones."

#. Tag: para
#: using_postgis_dataman.xml:365
#, no-c-format
msgid ""
"If you do not specify an SRID, the SRID will default to 4326 WGS 84 long/lat "
"will be used, and all calculations will proceed using WGS84."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:366
#, no-c-format
msgid ""
"Once you have created your table, you can see it in the GEOGRAPHY_COLUMNS "
"table:"
msgstr ""
"Una vez hayas creado tu tabla, podras verla en en la tabla GEOGRAPHY_COLUMNS:"

#. Tag: programlisting
#: using_postgis_dataman.xml:367
#, no-c-format
msgid ""
"-- See the contents of the metadata view\n"
"SELECT * FROM geography_columns;"
msgstr ""
"-- Ver el contenido de la vista de metadatos\n"
"SELECT * FROM geography_columns;"

#. Tag: para
#: using_postgis_dataman.xml:369
#, no-c-format
msgid ""
"You can insert data into the table the same as you would if it was using a "
"GEOMETRY column:"
msgstr ""
"Puedes añadir datos en la tabla de la misma forma que si fuera una columna "
"GEOMETRY:"

#. Tag: programlisting
#: using_postgis_dataman.xml:371
#, fuzzy, no-c-format
msgid ""
"-- Add some data into the test table\n"
"INSERT INTO global_points (name, location) VALUES ('Town', 'SRID=4326;"
"POINT(-110 30)');\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', 'SRID=4326;"
"POINT(-109 29)');\n"
"INSERT INTO global_points (name, location) VALUES ('London', 'SRID=4326;"
"POINT(0 49)');"
msgstr ""
"-- Añade algunos datos en la tabla de test\n"
"INSERT INTO global_points (name, location) VALUES ('Town', "
"ST_GeographyFromText('SRID=4326;POINT(-110 30)') );\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', "
"ST_GeographyFromText('SRID=4326;POINT(-109 29)') );\n"
"INSERT INTO global_points (name, location) VALUES ('London', "
"ST_GeographyFromText('SRID=4326;POINT(0 49)') );"

#. Tag: para
#: using_postgis_dataman.xml:373
#, no-c-format
msgid ""
"Creating an index works the same as GEOMETRY. PostGIS will note that the "
"column type is GEOGRAPHY and create an appropriate sphere-based index "
"instead of the usual planar index used for GEOMETRY."
msgstr ""
"Crear un indice es igual que para GEOMETRY. PostGIS detectará que el tipo de "
"columna es GEOGRAPHY y creara un indice basado en una esfera apropiado en "
"vez de el indice usual basado en plano utilizado para columnas GEOMETRY"

#. Tag: programlisting
#: using_postgis_dataman.xml:376
#, no-c-format
msgid ""
"-- Index the test table with a spherical index\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"
msgstr ""
"-- Crea un indice en la tabla de test con un indice esferico\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"

#. Tag: para
#: using_postgis_dataman.xml:379
#, no-c-format
msgid ""
"Query and measurement functions use units of meters. So distance parameters "
"should be expressed in meters, and return values should be expected in "
"meters (or square meters for areas)."
msgstr ""
"Las consultas y las funciones de medidas utilizan metros cho unidad. Asi que "
"los parámetros de distancia deben estar expresados en metros, y los valores "
"devueltos deben estar expresados en metros (o metros cuadrados para áreas)"

#. Tag: programlisting
#: using_postgis_dataman.xml:381
#, fuzzy, no-c-format
msgid ""
"-- Show a distance query and note, London is outside the 1000km tolerance\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, 'SRID=4326;"
"POINT(-110 29)'::geography, 1000000);"
msgstr ""
"-- Muestra una consulta de distancia y observa que , Londres esta fuera de "
"la tolerancia de 1000km\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, "
"ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);"

#. Tag: para
#: using_postgis_dataman.xml:384
#, fuzzy, no-c-format
msgid ""
"You can see the power of GEOGRAPHY in action by calculating how close a "
"plane flying from Seattle to London (LINESTRING(-122.33 47.606, 0.0 51.5)) "
"comes to Reykjavik (POINT(-21.96 64.15))."
msgstr ""
"Puedes observar la potencia de GEOGRAPHY en directo calculando como de "
"próximo, un avión volando de Seattle a Londres (LINESTRING(-122.33 47.606, "
"0.0 51.5)) viene a Reykjavik (POINT(-21.96 64.15))."

#. Tag: programlisting
#: using_postgis_dataman.xml:386
#, fuzzy, no-c-format
msgid ""
"-- Distance calculation using GEOGRAPHY (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)'::geography);"
msgstr ""
"-- Calculo de distancia utilizando GEOGRAPHY (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)':: geography);"

#. Tag: programlisting
#: using_postgis_dataman.xml:389
#, fuzzy, no-c-format
msgid ""
"-- Distance calculation using GEOMETRY (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)'::geometry);"
msgstr ""
"-- Calculo de distancia utilizando GEOMETRY (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)':: geometry);"

#. Tag: para
#: using_postgis_dataman.xml:392
#, no-c-format
msgid ""
"Testing different lon/lat projects. Any long lat spatial reference system "
"listed in <varname>spatial_ref_sys</varname> table is allowed."
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:394
#, fuzzy, no-c-format
msgid ""
"-- NAD 83 lon/lat\n"
"SELECT 'SRID=4269;POINT(-123 34)'::geography;\n"
"                    geography\n"
"----------------------------------------------------\n"
" 0101000020AD1000000000000000C05EC00000000000004140\n"
"(1 row)"
msgstr ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"

#. Tag: programlisting
#: using_postgis_dataman.xml:396
#, fuzzy, no-c-format
msgid ""
"-- NAD27 lon/lat\n"
"SELECT 'SRID=4267;POINT(-123 34)'::geography;\n"
"\n"
"                    geography\n"
"----------------------------------------------------\n"
" 0101000020AB1000000000000000C05EC00000000000004140\n"
"(1 row)"
msgstr ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"

#. Tag: programlisting
#: using_postgis_dataman.xml:398
#, no-c-format
msgid ""
"-- NAD83 UTM zone meters, yields error since its a meter based projection\n"
"SELECT 'SRID=26910;POINT(-123 34)'::geography;\n"
"\n"
"ERROR:  Only lon/lat coordinate systems are supported in geography.\n"
"LINE 1: SELECT 'SRID=26910;POINT(-123 34)'::geography;"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:400
#, no-c-format
msgid ""
"The GEOGRAPHY type calculates the true shortest distance over the sphere "
"between Reykjavik and the great circle flight path between Seattle and "
"London."
msgstr ""
"El tipo GEOGRAPHY calcula la distancia real mas corta sobre la esfera entre "
"Reykjavik y el camino circular mayor de vuelo entre Seattle y London."

#. Tag: para
#: using_postgis_dataman.xml:402
#, no-c-format
msgid ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> The GEOMETRY type calculates a meaningless cartesian distance "
"between Reykjavik and the straight line path from Seattle to London plotted "
"on a flat map of the world. The nominal units of the result might be called "
"\"degrees\", but the result doesn't correspond to any true angular "
"difference between the points, so even calling them \"degrees\" is "
"inaccurate."
msgstr ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> El tipo GEOMETRY calcula una distancia cartesiana sin sentido "
"entre Reykjavik y el camino recto desde Seattle a Londres dibujado en un "
"mapa plano del mundo. Las unidades nominales del resultado debe llamarse "
"\"grados\", pero el resultado no corresponde con ninguna diferencia angular "
"entre los puntos, así que incluso llamándolo \"grados\" es inexacta."

#. Tag: title
#: using_postgis_dataman.xml:406
#, no-c-format
msgid "When to use Geography Data type over Geometry data type"
msgstr "¿Cuando utilizar el tipo Geografico en vez de Geometrico?"

#. Tag: para
#: using_postgis_dataman.xml:407
#, fuzzy, no-c-format
msgid ""
"The geography type allows you to store data in longitude/latitude "
"coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY "
"than there are on GEOMETRY; those functions that are defined take more CPU "
"time to execute."
msgstr ""
"El nuevo tipo GEOGRAPHY te permite almacenar datos en coordenadas longitud/"
"latitud, pero con un coste: hay algunas funciones definidas en GEOGRAPHY que "
"están en GEOMETRY; estas funciones que están definidas toman mas tiempo en "
"la CPU a ejecutarse"

#. Tag: para
#: using_postgis_dataman.xml:408
#, no-c-format
msgid ""
"The type you choose should be conditioned on the expected working area of "
"the application you are building. Will your data span the globe or a large "
"continental area, or is it local to a state, county or municipality?"
msgstr ""
"El tipo que elijas debe estar condicionado por la extension del área de "
"trabajo de la aplicación que estas construyendo. ¿Tus datos se extienden por "
"el globo o una zona continental grande? ¿O es un estado, región o municipio?"

#. Tag: para
#: using_postgis_dataman.xml:410
#, no-c-format
msgid ""
"If your data is contained in a small area, you might find that choosing an "
"appropriate projection and using GEOMETRY is the best solution, in terms of "
"performance and functionality available."
msgstr ""
"Si tus datos están un área pequeña, la mejor solución seria elegir una "
"proyección adecuada y utilizando GEOMETRY, en términos de rendimiento y "
"funcionalidades disponibles."

#. Tag: para
#: using_postgis_dataman.xml:411
#, no-c-format
msgid ""
"If your data is global or covers a continental region, you may find that "
"GEOGRAPHY allows you to build a system without having to worry about "
"projection details. You store your data in longitude/latitude, and use the "
"functions that have been defined on GEOGRAPHY."
msgstr ""
"Si tus datos son globales o cubren una región continental, veras que "
"GEOGRAPHY te permite construir un sistema sin tener que preocuparte sobre "
"detalles de proyección. Almacenas tus datos en longitud/latitud, y utilizas "
"las funciones definidas en GEOGRAPHY."

#. Tag: para
#: using_postgis_dataman.xml:413
#, no-c-format
msgid ""
"If you don't understand projections, and you don't want to learn about them, "
"and you're prepared to accept the limitations in functionality available in "
"GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. "
"Simply load your data up as longitude/latitude and go from there."
msgstr ""
"Si no entiendes las proyecciones, y no quieres aprender sobre ellas, y estas "
"preparado a aceptar las funcionalidades limitadas disponibles en GEOGRAPHY, "
"entonces sera mas fácil para ti, utilizar GEOGRAPHY en lugar de GEOMETRY. "
"Simplemente carga tus datos como longitud/latitud y continua desde allí."

#. Tag: para
#: using_postgis_dataman.xml:416
#, no-c-format
msgid ""
"Refer to <xref linkend=\"PostGIS_TypeFunctionMatrix\"/> for compare between "
"what is supported for Geography vs. Geometry. For a brief listing and "
"description of Geography functions, refer to <xref linkend="
"\"PostGIS_GeographyFunctions\"/>"
msgstr ""
"Para tener una comparación entre lo que esta soportado entre Geography y "
"Geometry ve a  <xref linkend=\"PostGIS_TypeFunctionMatrix\"/>. Para obtener "
"una lista con la descripción de las funciones Geography ve a <xref linkend="
"\"PostGIS_GeographyFunctions\"/>"

#. Tag: title
#: using_postgis_dataman.xml:422
#, no-c-format
msgid "Geography Advanced FAQ"
msgstr "Preguntas frecuentes Avanzadas de Geography"

#. Tag: para
#: using_postgis_dataman.xml:426
#, no-c-format
msgid "Do you calculate on the sphere or the spheroid?"
msgstr "¿Se calcula en la esfera o en el esferoide?"

#. Tag: para
#: using_postgis_dataman.xml:430
#, no-c-format
msgid ""
"By default, all distance and area calculations are done on the spheroid. You "
"should find that the results of calculations in local areas match up will "
"with local planar results in good local projections. Over larger areas, the "
"spheroidal calculations will be more accurate than any calculation done on a "
"projected plane."
msgstr ""
"Por defecto, todos los cálculos de distancia y área están hechos sobre el "
"esferoide. Deberías ver que los resultados de los cálculos en áreas locales "
"deberán coincidir con los resultados en coordenadas locales planas con "
"proyecciones locales correctas. En grandes áreas, los cálculos esferoidales "
"serán mas precisas que cualquier calculo realizado en planas."

#. Tag: para
#: using_postgis_dataman.xml:433
#, no-c-format
msgid ""
"All the geography functions have the option of using a sphere calculation, "
"by setting a final boolean parameter to 'FALSE'. This will somewhat speed up "
"calculations, particularly for cases where the geometries are very simple."
msgstr ""
"Todas las funciones \"geography\" tienen la opción de utilizar el calculo "
"sobre la esfera, seleccionando el parámetro final boleano a 'FALSE'. Esto "
"puede acelerar los cálculos, particularmente en casos donde las geometrias "
"son muy simples."

#. Tag: para
#: using_postgis_dataman.xml:439
#, no-c-format
msgid "What about the date-line and the poles?"
msgstr "¿Que ocurre con los husos horarios y los polos?"

#. Tag: para
#: using_postgis_dataman.xml:443
#, no-c-format
msgid ""
"All the calculations have no conception of date-line or poles, the "
"coordinates are spherical (longitude/latitude) so a shape that crosses the "
"dateline is, from a calculation point of view, no different from any other "
"shape."
msgstr ""
"Todos los cálculos no tienen nociones de husos horarios o polos, las "
"coordenadas son esféricas(longitud/latitud) así que una forma que atraviesa "
"husos horarios no es, desde un punto de vista de los cálculos, a cualquier "
"otra forma."

#. Tag: para
#: using_postgis_dataman.xml:451
#, no-c-format
msgid "What is the longest arc you can process?"
msgstr "¿Cual es el arco mas largo que se pude procesar?"

#. Tag: para
#: using_postgis_dataman.xml:455
#, no-c-format
msgid ""
"We use great circle arcs as the \"interpolation line\" between two points. "
"That means any two points are actually joined up two ways, depending on "
"which direction you travel along the great circle. All our code assumes that "
"the points are joined by the *shorter* of the two paths along the great "
"circle. As a consequence, shapes that have arcs of more than 180 degrees "
"will not be correctly modelled."
msgstr ""
"Utilizamos grandes arcos de circulo como la \"linea de interpolación\" entre "
"dos puntos. Esto significa que actualmente, dos puntos se unen de dos "
"formas, dependiendo de la dirección del viaje sobre el arco. Todo nuestro "
"código asume que los puntos están unidos por el *mas corto* de los dos "
"caminos a traves del arco de circunferencia. Como consecuencia, las formas "
"que tienen arcos mayores de 180 grados no serán modeladas correctamente."

#. Tag: para
#: using_postgis_dataman.xml:462
#, no-c-format
msgid ""
"Why is it so slow to calculate the area of Europe / Russia / insert big "
"geographic region here ?"
msgstr ""
"¿ Por que es tan lento el calculo del area de Europa / Rusia / añade una "
"región geográfica grande aquí?"

#. Tag: para
#: using_postgis_dataman.xml:466
#, no-c-format
msgid ""
"Because the polygon is so darned huge! Big areas are bad for two reasons: "
"their bounds are huge, so the index tends to pull the feature no matter what "
"query you run; the number of vertices is huge, and tests (distance, "
"containment) have to traverse the vertex list at least once and sometimes N "
"times (with N being the number of vertices in the other candidate feature)."
msgstr ""
"¡Por que el poligono es condenadamente grande! Las grandes áreas son malas "
"por dos razones: Sus limites son grandes, así que el indice tiende a tirar "
"de la función sin importar la consulta que estes ejecutando; el numero de "
"vértices es grande, y los tests (distancia, de contención) tiene que "
"recorrer la lista de vértices al menos una vez y a veces N veces ( con N "
"igual al numero de vértices en el otro objeto candidato)."

#. Tag: para
#: using_postgis_dataman.xml:471
#, fuzzy, no-c-format
msgid ""
"As with GEOMETRY, we recommend that when you have very large polygons, but "
"are doing queries in small areas, you \"denormalize\" your geometric data "
"into smaller chunks so that the index can effectively subquery parts of the "
"object and so queries don't have to pull out the whole object every time. "
"Please consult <xref linkend=\"ST_Subdivide\"/> function documentation. Just "
"because you *can* store all of Europe in one polygon doesn't mean you "
"*should*."
msgstr ""
"Como con GEOMETRY, recomendamos que cuando tengas polígonos muy grandes, "
"pero haces consultas en áreas pequeñas, deberías \"desnormalizar\" tus datos "
"geométricos en trozos pequeños así el indice puede hacer subconsultas "
"eficientes del objeto y las consultas no tienen que utilizar el objeto "
"entero cada vez. Solo por que *puedas* almacenar toda Europa en un polígono "
"no significa que *debas*."

#. Tag: title
#: using_postgis_dataman.xml:480
#, no-c-format
msgid "Spatial Metadata Tables"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:482
#, fuzzy, no-c-format
msgid ""
"The OpenGIS \"Simple Features Specification for SQL\" defines some metadata "
"tables to describe geometry table structure and coordinate systems. In order "
"to ensure that metadata remains consistent, operations such as creating and "
"removing a spatial column are carried out through special procedures defined "
"by OpenGIS."
msgstr ""
"La especificación \"Simple Features Specification for SQL\"del OpenGIS, "
"define estándares del tipo de objetos GIS, las funciones necesarias para "
"manipularlos, y un conjunto de tablas de metadatos. Para asegurar que los "
"metadatos permanecen consistentes, operaciones como crear o borrar una "
"columna espacial están llevados a cabo a través de procedimientos especiales "
"definidos por el OpenGIS."

#. Tag: para
#: using_postgis_dataman.xml:488
#, no-c-format
msgid ""
"There are two OpenGIS meta-data tables: <varname>SPATIAL_REF_SYS</varname> "
"and <varname>GEOMETRY_COLUMNS</varname>. The <varname>SPATIAL_REF_SYS</"
"varname> table holds the numeric IDs and textual descriptions of coordinate "
"systems used in the spatial database."
msgstr ""
"Hay dos tablas de metadatos definidas por el OpenGIS: "
"<varname>SPATIAL_REF_SYS</varname> y <varname>GEOMETRY_COLUMNS</varname>. La "
"tabla <varname>SPATIAL_REF_SYS</varname> almacena los IDs numéricos y las "
"descripciones textuales de los sistemas de coordenadas utilizados en la base "
"de datos espaciales."

#. Tag: title
#: using_postgis_dataman.xml:495
#, no-c-format
msgid "The SPATIAL_REF_SYS Table and Spatial Reference Systems"
msgstr "La tabla SPATIAL_REF_SYS y los Sistemas de Referencia Espacial"

#. Tag: para
#: using_postgis_dataman.xml:497
#, fuzzy, no-c-format
msgid ""
"The <varname>SPATIAL_REF_SYS</varname> table used by PostGIS is an OGC-"
"compliant database table that lists over 3000 known <ulink url=\"https://en."
"wikipedia.org/wiki/Spatial_reference_system\">spatial reference systems</"
"ulink> and details needed to transform (reproject) between them."
msgstr ""
"La tabla spatial_ref_sys es una tabla incluida en PostGIS y cumple con el "
"estafar OGC, que contiene una lista de unos 3000 <ulink url=\"http://www."
"sharpgis.net/post/2007/05/Spatial-references2c-coordinate-systems2c-"
"projections2c-datums2c-ellipsoids-e28093-confusing.aspx\">sistemas de "
"referencia espaciales</ulink>  conocidos y los detalles necesarios para "
"transformar/reproyectar entre ellos."

#. Tag: para
#: using_postgis_dataman.xml:502
#, fuzzy, no-c-format
msgid ""
"The PostGIS <varname>SPATIAL_REF_SYS</varname> table contains over 3000 of "
"the most common spatial reference system definitions that are handled by the "
"<ulink url=\"https://proj.org\">PROJ</ulink> projection library. But there "
"are many coordinate systems that it does not contain. You can define your "
"own custom spatial reference system if you are familiar with PROJ "
"constructs. Keep in mind that most spatial reference systems are regional "
"and have no meaning when used outside of the bounds they were intended for."
msgstr ""
"Aunque la tabla spatial_ref_sys de PostGIS contiene unas 3000 definiciones "
"de sistemas de referencia espaciales mas comunes, esto puede ser manejado "
"con la librería proj, no contiene todos los sistemas conocidos y puedes "
"definir tus propias proyecciones si estas familiarizado con el constructor "
"de proj4. Piensa que la mayoría de sistemas de referencia son regionales y "
"no tiene sentido utilizarlos fuera de los limites para los cuales fueron "
"definidos."

#. Tag: para
#: using_postgis_dataman.xml:510
#, fuzzy, no-c-format
msgid ""
"A resource for finding spatial reference systems not defined in the core set "
"is <ulink url=\"http://spatialreference.org/\">http://spatialreference.org/</"
"ulink>"
msgstr ""
"Un recurso muy bueno para encontrar sistemas de referencia espaciales no "
"definidos en el núcleo de la librería es <ulink url=\"http://"
"spatialreference.org/\">http://spatialreference.org/</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:512
#, fuzzy, no-c-format
msgid ""
"Some commonly used spatial reference systems are: <ulink url=\"http://"
"spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</ulink>, <ulink "
"url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD 83 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/\">3395 - WGS "
"84 World Mercator</ulink>, <ulink url=\"http://spatialreference.org/ref/"
"epsg/2163/\">2163 - US National Atlas Equal Area</ulink>, and the 60 WGS84 "
"UTM zones. UTM zones are one of the most ideal for measurement, but only "
"cover 6-degree regions. (To determine which UTM zone to use for your area of "
"interest, see the <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
"UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper function</"
"ulink>.)"
msgstr ""
"Algunos de los sistemas de referencia espaciales mas comunes en Estados "
"Unidos son: <ulink url=\"http://spatialreference.org/ref/epsg/4326/\">4326 - "
"WGS 84 Long Lat </ulink>, <ulink url=\"http://spatialreference.org/ref/"
"epsg/4269/\">4269 - NAD 83 Long Lat (en Norte America )</ulink>, <ulink url="
"\"http://spatialreference.org/ref/epsg/3395/\">3395 - WGS 84 World Mercator</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/2163/\">2163 - US "
"National Atlas Equal Area (en Estados Unidos )</ulink>,Sistemas de "
"referencia espaciales para cada zona, NAD 83, WGS 84 UTM y UTM son de los "
"mas idóneos para medidas, pero solo cubren regiones de 6 grados."

#. Tag: para
#: using_postgis_dataman.xml:521
#, fuzzy, no-c-format
msgid ""
"US states use State Plane spatial reference systems (meter or feet based) - "
"usually one or 2 exists per state. Most of the meter-based ones are in the "
"core set, but many of the feet-based ones or ESRI created ones will need to "
"be copied from <ulink url=\"http://spatialreference.org\">spatialreference."
"org</ulink>."
msgstr ""
"Algunos sistemas de referencia espaciales planos de Estados Unidos (basados "
"en metros o pies) - normalmente existen uno o 2 por Estado de Estados "
"Unidos. La mayoría de los basados en metros están en el núcleo de "
"definiciones, pero algunos de los basados en pies o los creados por ESRI "
"deberás crearlos desde <ulink url=\"http://spatialreference.org"
"\">spatialreference.org</ulink>."

#. Tag: para
#: using_postgis_dataman.xml:527
#, no-c-format
msgid ""
"You can even define non-Earth-based coordinate systems, such as <ulink url="
"\"http://spatialreference.org/ref/iau2000/mars-2000/\">Mars 2000</ulink> "
"This Mars coordinate system is non-planar (it's in degrees spheroidal), but "
"you can use it with the <varname>geography</varname> type to obtain length "
"and proximity measurements in meters instead of degrees."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:532
#, fuzzy, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> table definition is:"
msgstr ""
"La definición de la tabla <varname>SPATIAL_REF_SYS</varname> es la siguiente:"

#. Tag: programlisting
#: using_postgis_dataman.xml:534
#, no-c-format
msgid ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"
msgstr ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"

#. Tag: para
#: using_postgis_dataman.xml:536 using_postgis_dataman.xml:619
#, fuzzy, no-c-format
msgid "The columns are:"
msgstr "Las opciones del comando son:"

#. Tag: term
#: using_postgis_dataman.xml:540 using_postgis_dataman.xml:652
#, fuzzy, no-c-format
msgid "SRID"
msgstr "AUTH_SRID"

#. Tag: para
#: using_postgis_dataman.xml:543
#, fuzzy, no-c-format
msgid ""
"An integer code that uniquely identifies the <ulink url=\"http://en."
"wikipedia.org/wiki/SRID\">Spatial Reference System</ulink> (SRS) within the "
"database."
msgstr ""
"Un valor entero único que identifica el Sistema de Referencia Espacial (SRS "
"de sus siglas en ingles) con la base de datos. "

#. Tag: term
#: using_postgis_dataman.xml:549
#, no-c-format
msgid "AUTH_NAME"
msgstr "AUTH_NAME"

#. Tag: para
#: using_postgis_dataman.xml:552
#, fuzzy, no-c-format
msgid ""
"The name of the standard or standards body that is being cited for this "
"reference system. For example, \"EPSG\" is a valid <varname>AUTH_NAME</"
"varname>."
msgstr ""
"El nombre del estándar o estándares que es citado para este sistema de "
"referencia. Por ejemplo, \"EPSG\" seria un <varname>AUTH_NAME</varname> "
"valido."

#. Tag: term
#: using_postgis_dataman.xml:559
#, no-c-format
msgid "AUTH_SRID"
msgstr "AUTH_SRID"

#. Tag: para
#: using_postgis_dataman.xml:562
#, no-c-format
msgid ""
"The ID of the Spatial Reference System as defined by the Authority cited in "
"the <varname>AUTH_NAME</varname>. In the case of EPSG, this is where the "
"EPSG projection code would go."
msgstr ""
"El ID del Sistema de Referencia Espacial definido por el Autor citado en "
"<varname>AUTH_NAME</varname>. En el caso de EPSG, este es lugar donde deberá "
"ir el código de la proyección EPSG."

#. Tag: term
#: using_postgis_dataman.xml:569
#, no-c-format
msgid "SRTEXT"
msgstr "SRTEXT"

#. Tag: para
#: using_postgis_dataman.xml:572
#, no-c-format
msgid ""
"The Well-Known Text representation of the Spatial Reference System. An "
"example of a WKT SRS representation is:"
msgstr ""
"La representación Well-Known Text del Sistema de Referencia Espacial (SRS). "
"Un ejemplo de representación WKT SRS es:"

#. Tag: programlisting
#: using_postgis_dataman.xml:575
#, no-c-format
msgid ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"
msgstr ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"

#. Tag: para
#: using_postgis_dataman.xml:577
#, fuzzy, no-c-format
msgid ""
"For a listing of EPSG projection codes and their corresponding WKT "
"representations, see <ulink url=\"http://www.opengeospatial.org/\">http://"
"www.opengeospatial.org/</ulink>. For a discussion of SRS WKT in general, see "
"the OpenGIS \"Coordinate Transformation Services Implementation Specification"
"\" at <ulink url=\"http://www.opengeospatial.org/standards\">http://www."
"opengeospatial.org/standards</ulink>. For information on the European "
"Petroleum Survey Group (EPSG) and their database of spatial reference "
"systems, see <ulink url=\"http://www.epsg.org/\">http://www.epsg.org</ulink>."
msgstr ""
"Para obtener una lista de los códigos EPSG y sus correspondientes "
"representaciones WKT, visita <ulink url=\"http://www.opengeospatial.org/"
"\">http://www.opengeospatial.org/</ulink>. Para obtener  información general "
"sobre WKT, visita el OpenGIS \"Coordinate Transformation Services "
"Implementation Specification\" en <ulink url=\"http://www.opengeospatial.org/"
"standards\">http://www.opengeospatial.org/standards</ulink>. Para obtener "
"información del European Petroleum Survey Group (EPSG) y su base de datos de "
"sistemas de referencia espacial, visita <ulink url=\"http://www.epsg.org/"
"\">http://www.epsg.org</ulink>."

#. Tag: term
#: using_postgis_dataman.xml:590
#, no-c-format
msgid "PROJ4TEXT"
msgstr "PROJ4TEXT"

#. Tag: para
#: using_postgis_dataman.xml:593
#, fuzzy, no-c-format
msgid ""
"PostGIS uses the PROJ library to provide coordinate transformation "
"capabilities. The <varname>PROJ4TEXT</varname> column contains the Proj4 "
"coordinate definition string for a particular SRID. For example:"
msgstr ""
"PostGIS utiliza la libreria Proj4 para ejecutar transformaciones de "
"coordenadas. La columna <varname>PROJ4TEXT</varname> contiene la cadena de "
"definición de coordenadas Proj4 para un SRID particular. Por ejemplo:"

#. Tag: programlisting
#: using_postgis_dataman.xml:598
#, no-c-format
msgid "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"
msgstr "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"

#. Tag: para
#: using_postgis_dataman.xml:600
#, fuzzy, no-c-format
msgid ""
"For more information see the <ulink url=\"https://proj.org/\">Proj4 web "
"site</ulink>. The <filename>spatial_ref_sys.sql</filename> file contains "
"both <varname>SRTEXT</varname> and <varname>PROJ4TEXT</varname> definitions "
"for all EPSG projections."
msgstr ""
"Para obtener mas información, puedes visitar el sitio web de Proj4 en <ulink "
"url=\"http://trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. El "
"fichero <filename>spatial_ref_sys.sql</filename> contiene ambas definiciones "
"<varname>SRTEXT</varname> y <varname>PROJ4TEXT</varname> para todas las "
"proyecciones EPSG."

#. Tag: title
#: using_postgis_dataman.xml:611
#, fuzzy, no-c-format
msgid "The GEOMETRY_COLUMNS View"
msgstr "La VISTA GEOMETRY_COLUMNS"

#. Tag: para
#: using_postgis_dataman.xml:613
#, no-c-format
msgid ""
"<varname>GEOMETRY_COLUMNS</varname> is a view reading from database system "
"catalog tables. Its structure is:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:616
#, no-c-format
msgid "\\d geometry_columns"
msgstr "\\d geometry_columns"

#. Tag: screen
#: using_postgis_dataman.xml:617
#, no-c-format
msgid ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"
msgstr ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"

#. Tag: term
#: using_postgis_dataman.xml:623
#, no-c-format
msgid "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"
msgstr "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"

#. Tag: para
#: using_postgis_dataman.xml:626
#, no-c-format
msgid ""
"The fully qualified name of the feature table containing the geometry "
"column. Note that the terms \"catalog\" and \"schema\" are Oracle-ish. There "
"is not PostgreSQL analogue of \"catalog\" so that column is left blank -- "
"for \"schema\" the PostgreSQL schema name is used (<varname>public</varname> "
"is the default)."
msgstr ""
"El nombre completo de la tabla de entidad que contiene la columna de "
"geometría. Observa que los términos \"catalog\" y \"schema\" son como en "
"Oracle. No hay analogía en PostgreSQL para \"catalogo\" así que esta columna "
"esta en blanco -- para \"schema\" se usa el nombre de esquema de PostgreSQL  "
"(<varname>public</varname> es por defecto)."

#. Tag: term
#: using_postgis_dataman.xml:635
#, no-c-format
msgid "F_GEOMETRY_COLUMN"
msgstr "F_GEOMETRY_COLUMN"

#. Tag: para
#: using_postgis_dataman.xml:638
#, no-c-format
msgid "The name of the geometry column in the feature table."
msgstr ""
"El nombre de la columna de geometrías de la tabla de objetos espaciales."

#. Tag: term
#: using_postgis_dataman.xml:643
#, no-c-format
msgid "COORD_DIMENSION"
msgstr "COORD_DIMENSION"

#. Tag: para
#: using_postgis_dataman.xml:646
#, no-c-format
msgid "The spatial dimension (2, 3 or 4 dimensional) of the column."
msgstr "Dimension espacial (2, 3 o 4 dimensiones) de la columna."

#. Tag: para
#: using_postgis_dataman.xml:655
#, no-c-format
msgid ""
"The ID of the spatial reference system used for the coordinate geometry in "
"this table. It is a foreign key reference to the <varname>SPATIAL_REF_SYS</"
"varname>."
msgstr ""
"El ID del sistema de referencia espacial utilizado para las coordenadas de "
"las geometrías en la tabla. Es una clave foránea con referencia a la tabla "
"<varname>SPATIAL_REF_SYS</varname>."

#. Tag: term
#: using_postgis_dataman.xml:662
#, no-c-format
msgid "TYPE"
msgstr "TYPE"

#. Tag: para
#: using_postgis_dataman.xml:665
#, no-c-format
msgid ""
"The type of the spatial object. To restrict the spatial column to a single "
"type, use one of: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, "
"MULTIPOLYGON, GEOMETRYCOLLECTION or corresponding XYM versions POINTM, "
"LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, "
"GEOMETRYCOLLECTIONM. For heterogeneous (mixed-type) collections, you can use "
"\"GEOMETRY\" as the type."
msgstr ""
"El tipo de objeto espacial. Para restringir la columna espacial a un tipo "
"unico, utiliza uno de: POINT, LINESTRING, POLYGON, MULTIPOINT, "
"MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION o su version "
"correspondiente de XYM POINTM, LINESTRINGM, POLYGONM, MULTIPOINTM, "
"MULTILINESTRINGM, MULTIPOLYGONM, GEOMETRYCOLLECTIONM. Para colecciones "
"heterogéneas (tipos mixtos), puedes utilizar \"GEOMETRY\" como tipo."

#. Tag: para
#: using_postgis_dataman.xml:674
#, no-c-format
msgid ""
"This attribute is (probably) not part of the OpenGIS specification, but is "
"required for ensuring type homogeneity."
msgstr ""
"Este no es (probablemente) parte de la especificación OpenGIS, pero es "
"necesario para asegurar la homogeneidad de tipos. "

#. Tag: title
#: using_postgis_dataman.xml:684
#, no-c-format
msgid "Creating a Spatial Table"
msgstr "Crear una tabla espacial"

#. Tag: para
#: using_postgis_dataman.xml:686
#, no-c-format
msgid ""
"Creating a table with spatial data, can be done in one step. As shown in the "
"following example which creates a roads table with a 2D linestring geometry "
"column in WGS84 long lat"
msgstr ""
"Crear una tabla con datos espaciales se puede hacer en un solo paso. Como se "
"muestra en el siguiente ejemplo que crea una tabla de carreteras con una "
"columna de tipo lineal de 2D en WGS84 long lat."

#. Tag: programlisting
#: using_postgis_dataman.xml:688
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE ROADS (ID serial, ROAD_NAME text, geom "
"geometry(LINESTRING,4326) );"
msgstr ""
"CREATE TABLE ROADS ( ID int4\n"
"                  , ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:690
#, no-c-format
msgid ""
"We can add additional columns using standard ALTER TABLE command as we do in "
"this next example where we add a 3-D linestring."
msgstr ""
"Podemos añadir columnas adicionales utilizando el comando estándar ALTER "
"TABLE como se muestra en el siguiente ejemplo donde añadimos una columna de "
"lineas en 3D."

#. Tag: programlisting
#: using_postgis_dataman.xml:691
#, no-c-format
msgid "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"
msgstr "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"

#. Tag: title
#: using_postgis_dataman.xml:695
#, fuzzy, no-c-format
msgid "Manually Registering Geometry Columns"
msgstr ""
"Registrando la columna de geometrias de forma manual en la tabla "
"geometry_columns"

#. Tag: para
#: using_postgis_dataman.xml:697
#, fuzzy, no-c-format
msgid ""
"Two of the cases where you may need this are the case of SQL Views and bulk "
"inserts. For bulk insert case, you can correct the registration in the "
"geometry_columns table by constraining the column or doing an alter table. "
"For views, you could expose using a CAST operation. Note, if your column is "
"typmod based, the creation process would register it correctly, so no need "
"to do anything. Also views that have no spatial function applied to the "
"geometry will register the same as the underlying table geometry column."
msgstr ""
"Dos de los casos en lo que esto ocurre, pero no puedes utilizar "
"AddGeometryColumn, es el caso de vistas SQL e inserciones masivas. Para esto "
"casos, puedes corregir el registro en la tabla geometry_columns creando una "
"restricción en la columna. A saber que en PostGIS 2.0+, si tu columna esta "
"basada en typmod, el proceso de creación lo registrará correctamente, así "
"que no necesitas hacer nada."

#. Tag: programlisting
#: using_postgis_dataman.xml:702
#, fuzzy, no-c-format
msgid ""
"-- Lets say you have a view created like this\n"
"CREATE VIEW public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom, 3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- For it to register correctly\n"
"-- You need to cast the geometry\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom, 3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- If you know the geometry type for sure is a 2D POLYGON then you could do\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"
msgstr ""
"--Imaginemos que tienes una vista creada de la siguiente manera\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"        \n"
"-- Para registrarla de forma correcta en  PostGIS 2.0+ \n"
"-- Necesitas hacer una conversión de tipos cast\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"        \n"
"-- Si sabes que el tipo de geometria de forma segura es 2D POLYGON entonces "
"puedes hacer\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"

#. Tag: programlisting
#: using_postgis_dataman.xml:703
#, fuzzy, no-c-format
msgid ""
"--Lets say you created a derivative table by doing a bulk insert\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"-- Create 2D index on new table\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"\n"
"-- If your points are 3D points or 3M points,\n"
"-- then you might want to create an nd index instead of a 2D index\n"
"CREATE INDEX my_special_pois_geom_gist_nd\n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"-- To manually register this new table's geometry column in "
"geometry_columns.\n"
"-- Note it will also change the underlying structure of the table to\n"
"-- to make the column typmod based.\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n"
"\n"
"-- If you are using PostGIS 2.0 and for whatever reason, you\n"
"-- you need the constraint based definition behavior\n"
"-- (such as case of inherited tables where all children do not have the same "
"type and srid)\n"
"-- set optional use_typmod argument to false\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"
msgstr ""
"--Supongamos que has creado una tabla derivada al hacer una inserción "
"masiva\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"--Creamos un indice 2d en la tabla nueva\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"  \n"
"-- Si tus puntos son 3D o 3M, \n"
"-- Entonces querrás crear un indice nd en vez de un indice 2d\n"
"-- de la siguiente manera\n"
"CREATE INDEX my_special_pois_geom_gist_nd \n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"--Para registrar de forma manual la columna geometrica de la nueva tabla en "
"tu tabla geometry_columns\n"
"-- Fijate que este método funcionara en ambas versiones PostGIS 2.0+ y "
"PostGIS 1.4+\n"
"-- Para PostGIS 2.0 también cambiará  la estructura subyacente de la tabla "
"para\n"
"-- hacer la columna basada en typmod.\n"
"-- Para PostGIS anterior a 2.0, también se puede utilizar para registrar "
"vistas\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass); \n"
"\n"
"--Si esta utilizando PostGIS 2.0 y por cualquier razón,\n"
"-- necesitas la definición basada en las antiguas restricciones \n"
"-- (como el caso de tablas heredadas donde todas las tablas dependientes no "
"tienen el mismo tipo y srid)\n"
"-- selecciona el nuevo argumento opcional  use_typmod como false\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"

#. Tag: para
#: using_postgis_dataman.xml:705
#, fuzzy, no-c-format
msgid ""
"Although the old-constraint based method is still supported, a constraint-"
"based geometry column used directly in a view, will not register correctly "
"in geometry_columns, as will a typmod one. In this example we define a "
"column using typmod and another using constraints."
msgstr ""
"Aunque el método antiguo basado en restricciones aún se puede utilizar, una "
"columna geométrica basada en el uso de restricciones utilizada directamente "
"en la vista, no se registrará correctamente en geometry_columns, al igual "
"que una typmod. En este ejemplo se define una columna utilizando typmod y "
"otro mediante restricciones."

#. Tag: programlisting
#: using_postgis_dataman.xml:708
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY, poi_name text, cat text, geom "
"geometry(POINT,4326));\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"
msgstr ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY\n"
"   , poi_name text, cat varchar(20)\n"
"   , geom geometry(POINT,4326) );\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"

#. Tag: para
#: using_postgis_dataman.xml:709
#, no-c-format
msgid "If we run in psql"
msgstr "Si ejecutamos en psql"

#. Tag: programlisting
#: using_postgis_dataman.xml:710
#, no-c-format
msgid "\\d pois_ny;"
msgstr "\\d pois_ny;"

#. Tag: para
#: using_postgis_dataman.xml:711
#, no-c-format
msgid ""
"We observe they are defined differently -- one is typmod, one is constraint"
msgstr ""
"Vemos que están definidas de forma diferente -- una es typmod, la otra por "
"restricciones."

#. Tag: screen
#: using_postgis_dataman.xml:712
#, fuzzy, no-c-format
msgid ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"
msgstr ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text \n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"

#. Tag: para
#: using_postgis_dataman.xml:713
#, no-c-format
msgid "In geometry_columns, they both register correctly"
msgstr "En geometry_columns, ambas se registran de forma correcta"

#. Tag: programlisting
#: using_postgis_dataman.xml:714
#, fuzzy, no-c-format
msgid ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"
msgstr ""
"SELECT f_table_name, f_geometry_column, srid, type \n"
"        FROM geometry_columns \n"
"        WHERE f_table_name = 'pois_ny';"

#. Tag: screen
#: using_postgis_dataman.xml:715
#, no-c-format
msgid ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"

#. Tag: para
#: using_postgis_dataman.xml:716
#, no-c-format
msgid "However -- if we were to create a view like this"
msgstr "De todas formas -- si queremos crear una vista de la siguiente forma"

#. Tag: programlisting
#: using_postgis_dataman.xml:717
#, fuzzy, no-c-format
msgid ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"CREATE VIEW vw_pois_ny_parks AS \n"
"SELECT * \n"
"  FROM pois_ny \n"
"  WHERE cat='park';\n"
"  \n"
"SELECT f_table_name, f_geometry_column, srid, type \n"
"        FROM geometry_columns \n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: para
#: using_postgis_dataman.xml:718
#, no-c-format
msgid ""
"The typmod based geom view column registers correctly, but the constraint "
"based one does not."
msgstr ""
"La columna de la vista basada en typmos se registra de forma correcta, pero "
"la basada en restricciones no."

#. Tag: screen
#: using_postgis_dataman.xml:720
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"
msgstr ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"

#. Tag: para
#: using_postgis_dataman.xml:722
#, fuzzy, no-c-format
msgid ""
"This may change in future versions of PostGIS, but for now to force the "
"constraint-based view column to register correctly, you need to do this:"
msgstr ""
"Esto puede cambiar en versiones futuras de PostGIS, pero por el momento, "
"para forzar a las vistas basadas en restricciones a registrarse de forma "
"correcta, debemos hacer lo siguiente:"

#. Tag: programlisting
#: using_postgis_dataman.xml:724
#, fuzzy, no-c-format
msgid ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT gid, poi_name, cat,\n"
"  geom,\n"
"  geom_2160::geometry(POINT,2160) As geom_2160\n"
"  FROM pois_ny\n"
"  WHERE cat = 'park';\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS \n"
"SELECT gid, poi_name, cat\n"
"  , geom\n"
"  , geom_2160::geometry(POINT,2160) As geom_2160 \n"
"  FROM pois_ny \n"
"  WHERE cat='park';\n"
"SELECT f_table_name, f_geometry_column, srid, type \n"
"        FROM geometry_columns \n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: screen
#: using_postgis_dataman.xml:725
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"

#. Tag: title
#: using_postgis_dataman.xml:730
#, no-c-format
msgid "Geometry Validation"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:732
#, no-c-format
msgid ""
"PostGIS is compliant with the Open Geospatial Consortium’s (OGC) OpenGIS "
"Specifications. As such, many PostGIS methods require, or more accurately, "
"assume that geometries that are operated on are both simple and valid. For "
"example, it does not make sense to calculate the area of a polygon that has "
"a hole defined outside of the polygon, or to construct a polygon from a non-"
"simple boundary line."
msgstr ""
"PostGIS es compatible con la especificación Open Geospatial Consortium’s "
"(OGC) OpenGIS Specifications. Como tal, muchos métodos PostGIS requieren, o "
"más exactamente, asume que las geometrías con las que se opera son a la vez "
"simples y válidas. Por ejemplo, no tiene sentido calcular el área de un "
"polígono que tiene un agujero definido fuera del polígono, o para la "
"construcción de un polígono a partir de una línea de límite no simple."

#. Tag: para
#: using_postgis_dataman.xml:739
#, no-c-format
msgid ""
"According to the OGC Specifications, a <emphasis>simple</emphasis> geometry "
"is one that has no anomalous geometric points, such as self intersection or "
"self tangency and primarily refers to 0 or 1-dimensional geometries (i.e. "
"<varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). Geometry validity, on "
"the other hand, primarily refers to 2-dimensional geometries (i.e. "
"<varname>[MULTI]POLYGON)</varname> and defines the set of assertions that "
"characterizes a valid polygon. The description of each geometric class "
"includes specific conditions that further detail geometric simplicity and "
"validity."
msgstr ""
"Según las especificaciones OGC, una geometría <emphasis>simple</emphasis>, "
"es aquella que no tiene puntos geométricos anómalos, con autointersección o "
"auto tangencia y principalmente se refiere a geometrías de 0 o 1 dimensiones "
"(i.e. <varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). La validez de "
"geometrias, por otro lado, se refiere a geometrias de dimension 2 (i.e. "
"<varname>[MULTI]POLYGON)</varname> y define el conjunto afirmaciones que "
"caracterizan un polígono valido. La descripción de cada clase de geometría "
"incluye condiciones especificas que simplemente detalles de simplicidad y "
"validez geométricas."

#. Tag: para
#: using_postgis_dataman.xml:749
#, fuzzy, no-c-format
msgid ""
"A <varname>POINT</varname> is inherently <emphasis>simple</emphasis> as a 0-"
"dimensional geometry object."
msgstr ""
"Un <varname>POINT</varname> es hereditariamente <emphasis>simple</emphasis> "
"como un objeto de geometría 0-dimensional."

#. Tag: para
#: using_postgis_dataman.xml:752
#, no-c-format
msgid ""
"<varname>MULTIPOINT</varname>s are <emphasis>simple</emphasis> if no two "
"coordinates (<varname>POINT</varname>s) are equal (have identical coordinate "
"values)."
msgstr ""
"<varname>MULTIPOINT</varname>s son simples <emphasis>simple</emphasis> si "
"dos coordenadas (<varname>POINT</varname>s) no son iguales (tienen valores "
"de coordenadas identicos)."

#. Tag: para
#: using_postgis_dataman.xml:756
#, no-c-format
msgid ""
"A <varname>LINESTRING</varname> is <emphasis>simple</emphasis> if it does "
"not pass through the same <varname>POINT</varname> twice (except for the "
"endpoints, in which case it is referred to as a linear ring and additionally "
"considered closed)."
msgstr ""
"Una <varname>LINESTRING</varname> es <emphasis>simple</emphasis> si no pasa "
"dos veces por el mismo <varname>POINT</varname> (excepto para puntos "
"finales, en cuyo caso nos referimos como linear ring y considerado como "
"cerrado)."

#. Tag: emphasis
#: using_postgis_dataman.xml:771
#, no-c-format
msgid "<emphasis>(a)</emphasis>"
msgstr "<emphasis>(a)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:781
#, no-c-format
msgid "<emphasis>(b)</emphasis>"
msgstr "<emphasis>(b)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:793
#, no-c-format
msgid "<emphasis>(c)</emphasis>"
msgstr "<emphasis>(c)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:803
#, no-c-format
msgid "<emphasis>(d)</emphasis>"
msgstr "<emphasis>(d)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:813
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(a)</emphasis> and <emphasis role=\"bold\">(c)</"
"emphasis> are simple <varname>LINESTRING</varname>s, <emphasis role=\"bold"
"\">(b)</emphasis> and <emphasis role=\"bold\">(d)</emphasis> are not."
msgstr ""
"<emphasis role=\"bold\">(a)</emphasis> y <emphasis role=\"bold\">(c)</"
"emphasis>son <varname>LINESTRING</varname>s simples, <emphasis role=\"bold"
"\">(b)</emphasis> y <emphasis role=\"bold\">(d)</emphasis> no lo son."

#. Tag: para
#: using_postgis_dataman.xml:822
#, no-c-format
msgid ""
"A <varname>MULTILINESTRING</varname> is <emphasis>simple</emphasis> only if "
"all of its elements are simple and the only intersection between any two "
"elements occurs at <varname>POINT</varname>s that are on the boundaries of "
"both elements."
msgstr ""
"Una <varname>MULTILINESTRING</varname> es <emphasis>simple</emphasis> solo "
"si todos sus elementos son simples y las únicas intersecciones entre "
"cualquiera de sus elementos, se produce en <varname>POINT</varname>s que "
"están en los limites de ambos elementos."

#. Tag: emphasis
#: using_postgis_dataman.xml:837
#, no-c-format
msgid "<emphasis>(e)</emphasis>"
msgstr "<emphasis>(e)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:847
#, no-c-format
msgid "<emphasis>(f)</emphasis>"
msgstr "<emphasis>(f)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:857
#, no-c-format
msgid "<emphasis>(g)</emphasis>"
msgstr "<emphasis>(g)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:867
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(e)</emphasis> and <emphasis role=\"bold\">(f)</"
"emphasis> are simple <varname>MULTILINESTRING</varname>s, <emphasis role="
"\"bold\">(g)</emphasis> is not."
msgstr ""
"<emphasis role=\"bold\">(e)</emphasis> y <emphasis role=\"bold\">(f)</"
"emphasis> son <varname>MULTILINESTRING</varname>s simples, <emphasis role="
"\"bold\">(g)</emphasis> no lo es."

#. Tag: para
#: using_postgis_dataman.xml:876
#, no-c-format
msgid ""
"By definition, a <varname>POLYGON</varname> is always <emphasis>simple</"
"emphasis>. It is <emphasis>valid</emphasis> if no two rings in the boundary "
"(made up of an exterior ring and interior rings) cross. The boundary of a "
"<varname>POLYGON</varname> may intersect at a <varname>POINT</varname> but "
"only as a tangent (i.e. not on a line). A <varname>POLYGON</varname> may not "
"have cut lines or spikes and the interior rings must be contained entirely "
"within the exterior ring."
msgstr ""
"Por definición, un <varname>POLYGON</varname> siempre será <emphasis>simple</"
"emphasis>. Es <emphasis>valido</emphasis> si dos anillos del borde (formado "
"por un anillo exterior y los anillos interiores) no se cruzan. El borde de "
"un <varname>POLYGON</varname> debe intersectarse en un <varname>POINT</"
"varname> pero solo como tangente (i.e. no en una linea). Un "
"<varname>POLYGON</varname>no debe tener lineas de corte  o picos y los "
"anillos interiores deben estar contenidos por entero por el anillo exterior."

#. Tag: emphasis
#: using_postgis_dataman.xml:894
#, no-c-format
msgid "<emphasis>(h)</emphasis>"
msgstr "<emphasis>(h)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:904
#, no-c-format
msgid "<emphasis>(i)</emphasis>"
msgstr "<emphasis>(i)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:914
#, no-c-format
msgid "<emphasis>(j)</emphasis>"
msgstr "<emphasis>(j)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:926
#, no-c-format
msgid "<emphasis>(k)</emphasis>"
msgstr "<emphasis>(k)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:936
#, no-c-format
msgid "<emphasis>(l)</emphasis>"
msgstr "<emphasis>(l)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:946
#, no-c-format
msgid "<emphasis>(m)</emphasis>"
msgstr "<emphasis>(m)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:955
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(h)</emphasis> and <emphasis role=\"bold\">(i)</"
"emphasis> are valid <varname>POLYGON</varname>s, <emphasis role=\"bold\">(j-"
"m)</emphasis> cannot be represented as single <varname>POLYGON</varname>s, "
"but <emphasis role=\"bold\">(j)</emphasis> and <emphasis role=\"bold\">(m)</"
"emphasis> could be represented as a valid <varname>MULTIPOLYGON</varname>."
msgstr ""
"<emphasis role=\"bold\">(h)</emphasis> y <emphasis role=\"bold\">(i)</"
"emphasis> son <varname>POLYGON</varname>s validos, <emphasis role=\"bold"
"\">(j-m)</emphasis> no se pueden representar como <varname>POLYGON</"
"varname>s simples, pero <emphasis role=\"bold\">(j)</emphasis> y <emphasis "
"role=\"bold\">(m)</emphasis> pueden representarse como un "
"<varname>MULTIPOLYGON</varname> valido."

#. Tag: para
#: using_postgis_dataman.xml:967
#, no-c-format
msgid ""
"A <varname>MULTIPOLYGON</varname> is <emphasis>valid</emphasis> if and only "
"if all of its elements are valid and the interiors of no two elements "
"intersect. The boundaries of any two elements may touch, but only at a "
"finite number of <varname>POINT</varname>s."
msgstr ""
"Un <varname>MULTIPOLYGON</varname> es <emphasis>válido</emphasis> si y sólo "
"si todos sus elementos son válidos y no se producen intersecciones entre los "
"interiores de ningún par de elementos. Los límietes de cualquiera de los dos "
"elementos pueden tocarse, pero sólo en un número finito de <varname>POINT</"
"varname>s."

#. Tag: emphasis
#: using_postgis_dataman.xml:982
#, no-c-format
msgid "<emphasis>(n)</emphasis>"
msgstr "<emphasis>(n)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:992
#, no-c-format
msgid "<emphasis>(o)</emphasis>"
msgstr "<emphasis>(o)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1002
#, no-c-format
msgid "<emphasis>(p)</emphasis>"
msgstr "<emphasis>(p)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1011
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(n)</emphasis> and <emphasis role=\"bold\">(o)</"
"emphasis> are not valid <varname>MULTIPOLYGON</varname>s. <emphasis role="
"\"bold\">(p)</emphasis>, however, is valid."
msgstr ""
"<emphasis role=\"bold\">(n)</emphasis> y <emphasis role=\"bold\">(o)</"
"emphasis> no son  <varname>MULTIPOLYGON</varname>s validos. <emphasis role="
"\"bold\">(p)</emphasis>, sin embargo, es valido."

#. Tag: para
#: using_postgis_dataman.xml:1020
#, no-c-format
msgid ""
"Most of the functions implemented by the GEOS library rely on the assumption "
"that your geometries are valid as specified by the OpenGIS Simple Feature "
"Specification. To check simplicity or validity of geometries you can use the "
"<link linkend=\"ST_IsSimple\">ST_IsSimple()</link> and <link linkend="
"\"ST_IsValid\">ST_IsValid()</link>"
msgstr ""
"La mayoría de las funciones implementadas por la biblioteca GEOS dependen de "
"la asunción de que las geometrías son válidad según lo especificado en la "
"OpenGIS Simple Feature Specification. Para comprobar la simplicidad o "
"validez de geometrías se puede usar <link linkend=\"ST_IsSimple"
"\">ST_IsSimple()</link> and <link linkend=\"ST_IsValid\">ST_IsValid()</link>"

#. Tag: programlisting
#: using_postgis_dataman.xml:1026
#, no-c-format
msgid ""
"-- Typically, it doesn't make sense to check\n"
"-- for validity on linear features since it will always return TRUE.\n"
"-- But in this example, PostGIS extends the definition of the OGC IsValid\n"
"-- by returning false if a LineString has less than 2 *distinct* vertices.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"
msgstr ""
"--Normalmente, no tiene sentido hacer la comprobación\n"
"-- de validez o elementos lineales, ya que siempre devolverá TRUE.\n"
"-- Pero en este ejemplo, PostGIS extiende la deficinción del IsValid de OGC\n"
"--devolviendo FALSE si una LineString tiene menos de 2 vértices "
"*distintos*.\n"
"gisdb=# SELECT\n"
"ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
"st_isvalid | st_isvalid\n"
"------------+-----------\n"
"t | f"

#. Tag: para
#: using_postgis_dataman.xml:1028
#, no-c-format
msgid ""
"By default, PostGIS does not apply this validity check on geometry input, "
"because testing for validity needs lots of CPU time for complex geometries, "
"especially polygons. If you do not trust your data sources, you can manually "
"enforce such a check to your tables by adding a check constraint:"
msgstr ""
"Por defecto, PostGIS no comprueba la validez en las geometrías entrantes, "
"porque los test de validez necesitan gran cantidad de tiempo de CPU para "
"geometrías complejas, en especial polígonos. Si no se está seguro de la "
"fuente de datos se puede forzar manualmente a realizar la comprobación de "
"las tablas añadiendo una restricción de comprobación: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1034
#, no-c-format
msgid ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"
msgstr ""
"ALTER TABLE mytable\n"
"ADD CONSTRAINT geometry_valid_check\n"
"CHECK (ST_IsValid(the_geom));"

#. Tag: para
#: using_postgis_dataman.xml:1036
#, fuzzy, no-c-format
msgid ""
"If you encounter any strange error messages such as \"GEOS Intersection() "
"threw an error!\" when calling PostGIS functions with valid input "
"geometries, you likely found an error in either PostGIS or one of the "
"libraries it uses, and you should contact the PostGIS developers. The same "
"is true if a PostGIS function returns an invalid geometry for valid input."
msgstr ""
"Si eincuentras algún mensaje de error extraño como  \"GEOS Intersection() "
"threw an error!\" o \"JTS Intersection() threw an error!\" al llamar a las "
"funciones de  PostGIS con geometrías de entrada válidas, seguramente se deba "
"a algún error bien en  PostGIS o en una de las bibliotecas que usa, y "
"deberías contactar con el equipo de desarrollo de PostGIS. Lo mismo es "
"aplicable si una función de PostGIS devuelve una geometría inválida a partir "
"de una entrada válida. "

#. Tag: para
#: using_postgis_dataman.xml:1044
#, no-c-format
msgid ""
"Strictly compliant OGC geometries cannot have Z or M values. The <link "
"linkend=\"ST_IsValid\">ST_IsValid()</link> function won't consider higher "
"dimensioned geometries invalid! Invocations of <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> will add a constraint "
"checking geometry dimensions, so it is enough to specify 2 there."
msgstr ""
"Geometrías estrictamente compatibles con OGC no pueden tener valores Z o M."
"¡La función <link linkend=\"ST_IsValid\">ST_IsValid()</link> no considerará "
"invalidas las geometrías con mas dimensiones! Llamadas a <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> añadirá restricciones al "
"comprobar las dimensiones de las geometrías, así que es suficiente con "
"especificar 2."

#. Tag: title
#: using_postgis_dataman.xml:1054
#, fuzzy, no-c-format
msgid "Loading Spatial Data"
msgstr "Cargando Datos SIG"

#. Tag: para
#: using_postgis_dataman.xml:1056
#, fuzzy, no-c-format
msgid ""
"Once you have created a spatial table, you are ready to upload spatial data "
"to the database. There are two built-in ways to get spatial data into a "
"PostGIS/PostgreSQL database: using formatted SQL statements or using the "
"Shapefile loader."
msgstr ""
"Una vez creada la tabla espacial, estas listo para cargar datos SIG en la "
"base de datos. Actualmente, existen dos formas de poner los datos en una "
"base de datos PostGIS/PostgreSQL: utilizando sentencias SQL formateadas, o "
"utilizando el cargador de ficheros Shape."

#. Tag: title
#: using_postgis_dataman.xml:1062
#, fuzzy, no-c-format
msgid "Using SQL to Load Data"
msgstr "Utilizando el cargador de ficheros Shape"

#. Tag: para
#: using_postgis_dataman.xml:1064
#, fuzzy, no-c-format
msgid ""
"If spatial data can be converted to a text representation (as either WKT or "
"WKB), then using SQL might be the easiest way to get data into PostGIS. Data "
"can be bulk-loaded into PostGIS/PostgreSQL by loading a text file of SQL "
"<code>INSERT</code> statements using the <code>psql</code> SQL utility."
msgstr ""
"Si puedes convertir tus datos en una representación de texto, entonces "
"utilizar SQL formateado debería ser la forma mas sencilla de cargar tus "
"datos en PostGIS. Asi como en Oracle o otras bases de datos SQL, los datos "
"pueden ser cargados en masa mediante la canalización de un fichero de texto "
"grande, lleno de sentencias SQL \"INSERT\" en el terminal SQL."

#. Tag: para
#: using_postgis_dataman.xml:1069
#, fuzzy, no-c-format
msgid ""
"A SQL load file (<filename>roads.sql</filename> for example) might look like "
"this:"
msgstr ""
"Un fichero de carga (<filename>roads.sql</filename> por ejemplo) debería "
"parecerse a esto:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1072
#, fuzzy, no-c-format
msgid ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,'LINESTRING(191232 243118,191108 243242)','Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,'LINESTRING(189141 244158,189265 244817)','Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,'LINESTRING(192783 228138,192612 229814)','Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,'LINESTRING(189412 252431,189631 259122)','Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,'LINESTRING(190131 224148,190871 228134)','Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,'LINESTRING(198231 263418,198213 268322)','Dave Cres');\n"
"COMMIT;"
msgstr ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 "
"243242)',-1),'Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 "
"244817)',-1),'Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 "
"229814)',-1),'Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 "
"259122)',-1),'Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 "
"228134)',-1),'Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 "
"268322)',-1),'Dave Cres');\n"
"COMMIT;"

#. Tag: para
#: using_postgis_dataman.xml:1074
#, fuzzy, no-c-format
msgid "The SQL file can be loaded into PostgreSQL using <code>psql</code>:"
msgstr ""
"El fichero de datos puede canalizarse en PostgreSQL de manera sencilla con "
"el terminar de comandos SQL \"psql\":"

#. Tag: programlisting
#: using_postgis_dataman.xml:1076
#, no-c-format
msgid "psql -d [database] -f roads.sql"
msgstr "psql -d [database] -f roads.sql"

#. Tag: title
#: using_postgis_dataman.xml:1080
#, fuzzy, no-c-format
msgid "Using the Shapefile Loader"
msgstr "Utilizando el cargador de ficheros Shape"

#. Tag: para
#: using_postgis_dataman.xml:1082
#, fuzzy, no-c-format
msgid ""
"The <filename>shp2pgsql</filename> data loader converts Shapefiles into SQL "
"suitable for insertion into a PostGIS/PostgreSQL database either in geometry "
"or geography format. The loader has several operating modes selected by "
"command line flags."
msgstr ""
"El cargador de datos Shape <filename>shp2pgsql</filename> convierte fichero "
"Shape de ESRI en comandos SQL para la inserción en bases de datos PostGIS/"
"PostgreSQL en formatos geometry o geography. El cargador tiene diferentes "
"modos de operar según las opciones escritas en el comando:"

#. Tag: para
#: using_postgis_dataman.xml:1087
#, fuzzy, no-c-format
msgid ""
"There is also a <filename>shp2pgsql-gui</filename> graphical interface with "
"most of the options as the command-line loader. This may be easier to use "
"for one-off non-scripted loading or if you are new to PostGIS. It can also "
"be configured as a plugin to PgAdminIII."
msgstr ""
"Ademas del cargador por linea de comandos shp2pgsql, existe una interfaz "
"gráfica llamada <filename>shp2pgsql-gui</filename>, con la mayoría de las "
"opciones del cargador por linea de comandos, pero puede ser mas sencillo de "
"utilizar para aquellas que no estén en scripts o ficheros único o si eres "
"nuevo en PostGIS. También se puede configurara como un plugin de PgAdminIII."

#. Tag: term
#: using_postgis_dataman.xml:1095
#, no-c-format
msgid "(c|a|d|p) These are mutually exclusive options:"
msgstr "(c|a|d|p) Estas opciones son exclusivas entre ellas:"

#. Tag: term
#: using_postgis_dataman.xml:1100
#, no-c-format
msgid "<term>-c</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1102
#, fuzzy, no-c-format
msgid ""
"Creates a new table and populates it from the Shapefile. <emphasis>This is "
"the default mode.</emphasis>"
msgstr ""
"Crea una nueva tabla y la rellena desde el shapefile. <emphasis>Esta es la "
"opción por defecto.</emphasis>"

#. Tag: term
#: using_postgis_dataman.xml:1110
#, no-c-format
msgid "<term>-a</term>"
msgstr "<term>-a</term>"

#. Tag: para
#: using_postgis_dataman.xml:1112
#, fuzzy, no-c-format
msgid ""
"Appends data from the Shapefile into the database table. Note that to use "
"this option to load multiple files, the files must have the same attributes "
"and same data types."
msgstr ""
"Añade los datos del shapefile en la tabla de la base de datos. Observa que "
"para utilizar esta opción para cargar varios ficheros, los ficheros deben "
"tener los mismos atributos y los mismos tipos de datos."

#. Tag: term
#: using_postgis_dataman.xml:1121
#, no-c-format
msgid "<term>-d</term>"
msgstr "<term>-d</term>"

#. Tag: para
#: using_postgis_dataman.xml:1123
#, fuzzy, no-c-format
msgid ""
"Drops the database table before creating a new table with the data in the "
"Shapefile."
msgstr ""
"Borra la tabla de la base de datos antes de crear una nueva tabla con los "
"datos del shapefile en su interior."

#. Tag: term
#: using_postgis_dataman.xml:1130
#, no-c-format
msgid "<term>-p</term>"
msgstr "<term>-p</term>"

#. Tag: para
#: using_postgis_dataman.xml:1132
#, no-c-format
msgid ""
"Only produces the table creation SQL code, without adding any actual data. "
"This can be used if you need to completely separate the table creation and "
"data loading steps."
msgstr ""
"Solo produce el código del comando SQL de creación de la tabla, sin añadir "
"ningún dato. Esto puede utilizarse si necesitas separar completamente los "
"pasos de creación de la tabla y de carga de datos"

#. Tag: term
#: using_postgis_dataman.xml:1145
#, no-c-format
msgid "<term>-?</term>"
msgstr "<term>-?</term>"

#. Tag: para
#: using_postgis_dataman.xml:1147
#, no-c-format
msgid "Display help screen."
msgstr "Muestra la ayuda en pantalla."

#. Tag: term
#: using_postgis_dataman.xml:1154
#, no-c-format
msgid "<term>-D</term>"
msgstr "<term>-D</term>"

#. Tag: para
#: using_postgis_dataman.xml:1156
#, no-c-format
msgid ""
"Use the PostgreSQL \"dump\" format for the output data. This can be combined "
"with -a, -c and -d. It is much faster to load than the default \"insert\" "
"SQL format. Use this for very large data sets."
msgstr ""
"Utiliza el formato \"dump\" de PostgreSQL en la salida de datos. Esto puede "
"combinarse con -a, -c, y -d. Es mucho mas rápido cargar este fichero \"dump"
"\" que utilizando en comando SQL \"INSERT\" por defecto. Utiliza esto ara "
"grandes conjuntos de datos."

#. Tag: term
#: using_postgis_dataman.xml:1165
#, fuzzy, no-c-format
msgid "-s [&lt;FROM_SRID&gt;:]&lt;SRID&gt;"
msgstr "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1167
#, fuzzy, no-c-format
msgid ""
"Creates and populates the geometry tables with the specified SRID. "
"Optionally specifies that the input shapefile uses the given FROM_SRID, in "
"which case the geometries will be reprojected to the target SRID."
msgstr ""
"Crea y rellena las tablas geométricas con el SRID especificado. "
"Opcionalmente especifica que el fichero shapefile utiliza el dado en "
"FROM_SRID, en tal caso las geometrías se reproyectarán  al SRID destino. "
"FROM_SRID no puede espeficarse con -D "

#. Tag: term
#: using_postgis_dataman.xml:1177
#, no-c-format
msgid "<term>-k</term>"
msgstr "<term>-k</term>"

#. Tag: para
#: using_postgis_dataman.xml:1179
#, no-c-format
msgid ""
"Keep identifiers' case (column, schema and attributes). Note that attributes "
"in Shapefile are all UPPERCASE."
msgstr ""
"Mantiene las mayúsculas en los identificadores (columnas, esquemas y "
"atributos). Observa que los atributos en los shapefiles están siempre en "
"MAYÚSCULAS."

#. Tag: term
#: using_postgis_dataman.xml:1187
#, no-c-format
msgid "<term>-i</term>"
msgstr "<term>-i</term>"

#. Tag: para
#: using_postgis_dataman.xml:1189
#, no-c-format
msgid ""
"Coerce all integers to standard 32-bit integers, do not create 64-bit "
"bigints, even if the DBF header signature appears to warrant it."
msgstr ""
"Fuerza la creación de enteros a enteros estándar de 32-bits, no crea enteros "
"bigint de 64-bits, aunque la firma de la cabecera del DBF parezca que lo "
"garantiza."

#. Tag: term
#: using_postgis_dataman.xml:1197
#, no-c-format
msgid "<term>-I</term>"
msgstr "<term>-I</term>"

#. Tag: para
#: using_postgis_dataman.xml:1199
#, no-c-format
msgid "Create a GiST index on the geometry column."
msgstr "Crea un indice GiST de la columna de geometrias."

#. Tag: term
#: using_postgis_dataman.xml:1206
#, fuzzy, no-c-format
msgid "<term>-m</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1208
#, no-c-format
msgid ""
"-m <filename>a_file_name</filename> Specify a file containing a set of "
"mappings of (long) column names to 10 character DBF column names. The "
"content of the file is one or more lines of two names separated by white "
"space and no trailing or leading space. For example:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1213
#, no-c-format
msgid ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"
msgstr ""

#. Tag: term
#: using_postgis_dataman.xml:1219
#, no-c-format
msgid "<term>-S</term>"
msgstr "<term>-S</term>"

#. Tag: para
#: using_postgis_dataman.xml:1221
#, no-c-format
msgid ""
"Generate simple geometries instead of MULTI geometries. Will only succeed if "
"all the geometries are actually single (I.E. a MULTIPOLYGON with a single "
"shell, or or a MULTIPOINT with a single vertex)."
msgstr ""
"Genera geometrías simples en lugar de MULTI geometrías. Solo funcionará si "
"todas las geometrias son actualmente simples (I.E. un MULTIPOLYGON con una "
"única capa, o un MULTIPOINT con un único vértice). "

#. Tag: term
#: using_postgis_dataman.xml:1230
#, no-c-format
msgid "-t &lt;dimensionality&gt;"
msgstr "-t &lt;dimensionality&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1232
#, no-c-format
msgid ""
"Force the output geometry to have the specified dimensionality. Use the "
"following strings to indicate the dimensionality: 2D, 3DZ, 3DM, 4D."
msgstr ""
"Fuerza a que la geometría de salida tenga la dimensión especificada. Utiliza "
"las siguientes cadenas para indicar la dimensión: 2D, 3DZ, 3DM, 4D."

#. Tag: para
#: using_postgis_dataman.xml:1236
#, no-c-format
msgid ""
"If the input has fewer dimensions that specified, the output will have those "
"dimensions filled in with zeroes. If the input has more dimensions that "
"specified, the unwanted dimensions will be stripped."
msgstr ""
"Si la entrada tiene menos dimensiones de las especificadas, la salida tendrá "
"estas dimensiones rellenas con ceros. Si la entrada tiene mas dimensiones de "
"las especificadas, las dimensiones no deseadas se eliminarán."

#. Tag: term
#: using_postgis_dataman.xml:1245
#, no-c-format
msgid "<term>-w</term>"
msgstr "<term>-w</term>"

#. Tag: para
#: using_postgis_dataman.xml:1247
#, no-c-format
msgid ""
"Output WKT format, instead of WKB. Note that this can introduce coordinate "
"drifts due to loss of precision."
msgstr ""
"Salida en formato WKT, en vez de WKB. Observa que esto puede introducir "
"derivas en las coordenadas debido a la perdida de precisión."

#. Tag: term
#: using_postgis_dataman.xml:1255
#, no-c-format
msgid "<term>-e</term>"
msgstr "<term>-e</term>"

#. Tag: para
#: using_postgis_dataman.xml:1257
#, no-c-format
msgid ""
"Execute each statement on its own, without using a transaction. This allows "
"loading of the majority of good data when there are some bad geometries that "
"generate errors. Note that this cannot be used with the -D flag as the \"dump"
"\" format always uses a transaction."
msgstr ""
"Ejecuta cada sentencia una por una, sin utilizar una transacción. Esto "
"permite cargar la mayoría de datos correctos cuando existen algunas "
"geometrías no validas que generan errores. Observa que esta opción no se "
"puede utilizar con -D ya que el formato \"dump\" siempre utiliza "
"transacciones."

#. Tag: term
#: using_postgis_dataman.xml:1267
#, no-c-format
msgid "-W &lt;encoding&gt;"
msgstr "-W &lt;encoding&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1269
#, no-c-format
msgid ""
"Specify encoding of the input data (dbf file). When used, all attributes of "
"the dbf are converted from the specified encoding to UTF8. The resulting SQL "
"output will contain a <code>SET CLIENT_ENCODING to UTF8</code> command, so "
"that the backend will be able to reconvert from UTF8 to whatever encoding "
"the database is configured to use internally."
msgstr ""
"Especifica la codificación de los datos de entrada (fichero dbf). Cuando se "
"utiliza, todos los atributos del fichero dbf son convertidos desde la "
"codificación especificada a UTF8. La salida SQL resultante contendrá un "
"comando <code>SET CLIENT_ENCODING to UTF8</code>, así que el backend sera "
"capaz de reconvertir desde UTF8 a cualquier codificación que este "
"configurada en la base de datos para uso interno."

#. Tag: term
#: using_postgis_dataman.xml:1279
#, no-c-format
msgid "-N &lt;policy&gt;"
msgstr "-N &lt;policy&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1281
#, no-c-format
msgid "NULL geometries handling policy (insert*,skip,abort)"
msgstr "Políticas de gestión de geometrías NULL (insert*, skip, abort)"

#. Tag: term
#: using_postgis_dataman.xml:1287
#, no-c-format
msgid "<term>-n</term>"
msgstr "<term>-n</term>"

#. Tag: para
#: using_postgis_dataman.xml:1289
#, no-c-format
msgid ""
"-n Only import DBF file. If your data has no corresponding shapefile, it "
"will automatically switch to this mode and load just the dbf. So setting "
"this flag is only needed if you have a full shapefile set, and you only want "
"the attribute data and no geometry."
msgstr ""
"-n solo importa los ficheros dbf. Si tus datos no tienen shapefiles "
"correspondientes, se cambiara de forma automática a este modo y se cargara "
"únicamente el dbf. Así que esta opción solo se necesita si lo unifico que "
"quieres cargar son los atributos y no las geometrías."

#. Tag: term
#: using_postgis_dataman.xml:1297
#, no-c-format
msgid "<term>-G</term>"
msgstr "<term>-G</term>"

#. Tag: para
#: using_postgis_dataman.xml:1299
#, no-c-format
msgid ""
"Use geography type instead of geometry (requires lon/lat data) in WGS84 long "
"lat (SRID=4326)"
msgstr ""
"Utiliza el tipo \"geography\" en lugar del tipo \"geometry\" (requiere datos "
"en lon/lat) en WGS84 long lat (SRID=4326)"

#. Tag: term
#: using_postgis_dataman.xml:1305
#, no-c-format
msgid "-T &lt;tablespace&gt;"
msgstr "-T &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1307
#, no-c-format
msgid ""
"Specify the tablespace for the new table. Indexes will still use the default "
"tablespace unless the -X parameter is also used. The PostgreSQL "
"documentation has a good description on when to use custom tablespaces."
msgstr ""
"Especifica el \"tablespace\" para la nueva tabla.Los indices seguirán "
"utilizando el \"tablespace\" por defecto a menos que el parámetro -X este en "
"uso. La documentación de PostgreSQL tiene una buena descripción de los "
"\"tablespaces\" personalizados."

#. Tag: term
#: using_postgis_dataman.xml:1315
#, no-c-format
msgid "-X &lt;tablespace&gt;"
msgstr "-X &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1317
#, no-c-format
msgid ""
"Specify the tablespace for the new table's indexes. This applies to the "
"primary key index, and the GIST spatial index if -I is also used."
msgstr ""
"Especifica el \"tablespace\" para los indices de la nueva tabla. Esto se "
"aplica a los indices de clave primaria y a los indices espaciales GiST si se "
"usa también la opción -l."

#. Tag: para
#: using_postgis_dataman.xml:1325
#, fuzzy, no-c-format
msgid ""
"An example session using the loader to create an input file and loading it "
"might look like this:"
msgstr ""
"Un ejemplo de sesión utilizando el cargador para crear un fichero de entrada "
"y cargarlo debe parecerse a esto:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1330
#, no-c-format
msgid ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"
msgstr ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"

#. Tag: para
#: using_postgis_dataman.xml:1332
#, fuzzy, no-c-format
msgid "A conversion and load can be done in one step using UNIX pipes:"
msgstr ""
"Una conversion y carga puede hacerse en un solo paso utilizando el símbolo "
"tubería en sistemas UNIX:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1336
#, no-c-format
msgid "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"
msgstr "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"

#. Tag: title
#: using_postgis_dataman.xml:1341
#, fuzzy, no-c-format
msgid "Extracting Spatial Data"
msgstr "Crear una tabla espacial"

#. Tag: para
#: using_postgis_dataman.xml:1343
#, fuzzy, no-c-format
msgid ""
"Spatial data can be extracted from the database using either SQL or the "
"Shapefile dumper. The section on SQL presents some of the functions "
"available to do comparisons and queries on spatial tables."
msgstr ""
"Los datos se pueden extraer de la base de datos utilizando SQL o el cargador/"
"dumper de ficheros Shape. En la sección SQL hablaremos de algunos de los "
"operadores disponibles para hacer comparaciones y consultas en tablas "
"espaciales."

#. Tag: title
#: using_postgis_dataman.xml:1349
#, no-c-format
msgid "Using SQL to Extract Data"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1351
#, fuzzy, no-c-format
msgid ""
"The most straightforward way of extracting spatial data out of the database "
"is to use a SQL <code>SELECT</code> query to define the data set to be "
"extracted and dump the resulting columns into a parsable text file:"
msgstr ""
"El medio más directo para hacer una extracción de datos de la base de datos "
"es utilizar una consulta de selección SQL para reducir el número de "
"registros y columnas devueltas y volcar las columnas resultantes en un "
"archivo de texto analizable:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1356
#, no-c-format
msgid ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"
msgstr ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"

#. Tag: para
#: using_postgis_dataman.xml:1358
#, fuzzy, no-c-format
msgid ""
"There will be times when some kind of restriction is necessary to cut down "
"the number of records returned. In the case of attribute-based restrictions, "
"use the same SQL syntax as used with a non-spatial table. In the case of "
"spatial restrictions, the following functions are useful:"
msgstr ""
"Sin embargo, habrá ocasiones que debido a algún tipo de restricción será "
"necesario reducir el número de campos que se devuelven . En el caso de "
"restricciones basadas en los atributos, sólo tienes que utilizar la misma "
"sintaxis SQL de forma normal como con una tabla no espacial. En el caso de "
"restricciones espaciales, están disponibles los siguientes operadores:"

#. Tag: term
#: using_postgis_dataman.xml:1366
#, no-c-format
msgid "ST_Intersects"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1369
#, no-c-format
msgid "This function tells whether two geometries share any space."
msgstr ""

#. Tag: term
#: using_postgis_dataman.xml:1374
#, no-c-format
msgid "<term>=</term>"
msgstr "<term>=</term>"

#. Tag: para
#: using_postgis_dataman.xml:1377
#, no-c-format
msgid ""
"This tests whether two geometries are geometrically identical. For example, "
"if 'POLYGON((0 0,1 1,1 0,0 0))' is the same as 'POLYGON((0 0,1 1,1 0,0 "
"0))' (it is)."
msgstr ""
"Este test comprueba si dos geometrías son geométricamente idénticas. Por "
"ejemplo, si 'POLYGON((0 0,1 1,1 0,0 0))' es la misma que 'POLYGON((0 0,1 1,1 "
"0,0 0))' (si que lo es)."

#. Tag: para
#: using_postgis_dataman.xml:1385
#, fuzzy, no-c-format
msgid ""
"Next, you can use these operators in queries. Note that when specifying "
"geometries and boxes on the SQL command line, you must explicitly turn the "
"string representations into geometries function. The 312 is a fictitious "
"spatial reference system that matches our data. So, for example:"
msgstr ""
"A continuación, puedes utilizar estos operadores en las consultas. Ten en "
"cuenta que al especificar geometrías y cajas en la línea de comandos SQL, "
"debes activar de forma explícita las representaciones de cadena en "
"geometrías utilizando la función \"ST_GeomFromText ()\". El 312 es un "
"sistema de referencia espacial ficticio que coincide con nuestros datos. Así "
"que, por ejemplo:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1391
#, fuzzy, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE roads_geom='SRID=312;LINESTRING(191232 243118,191108 243242)'::"
"geometry;"
msgstr ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE ST_OrderingEquals(roads_geom , ST_GeomFromText('LINESTRING(191232 "
"243118,191108 243242)',312) ) ;"

#. Tag: para
#: using_postgis_dataman.xml:1393
#, no-c-format
msgid ""
"The above query would return the single record from the \"ROADS_GEOM\" table "
"in which the geometry was equal to that value."
msgstr ""
"La consulta anterior deberá devolver el único registro de la tabla "
"\"ROADS_GEOM\" cuya geometría era igual a este valor."

#. Tag: para
#: using_postgis_dataman.xml:1396
#, no-c-format
msgid ""
"To check whether some of the roads passes in the area defined by a polygon:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1398
#, fuzzy, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE ST_Intersects(roads_geom, 'SRID=312;POLYGON((...))');"
msgstr ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))',312);"

#. Tag: para
#: using_postgis_dataman.xml:1402
#, fuzzy, no-c-format
msgid ""
"The most common spatial query will probably be a \"frame-based\" query, used "
"by client software, like data browsers and web mappers, to grab a \"map frame"
"\" worth of data for display."
msgstr ""
"La consulta espacial más común probablemente será una consulta \"basada en "
"cuadros\", utilizada por el software cliente, como navegadores de datos o "
"aplicaciones webmapping, para tomar un valor del \"marco del mapa \" de los "
"datos para su visualización. La consulta para el uso de un objeto \"BOX3D\" "
"para el marco, se parece a esto:"

#. Tag: para
#: using_postgis_dataman.xml:1405
#, no-c-format
msgid ""
"When using the \"&amp;&amp;\" operator, you can specify either a BOX3D as "
"the comparison feature or a GEOMETRY. When you specify a GEOMETRY, however, "
"its bounding box will be used for the comparison."
msgstr ""
"Cuando utilizamos el operador \"&amp;&amp;\", puedes especificar ya sea un "
"BOX3D como la función de comparación o una GEOMETRY. Cuando se especifica "
"una geometría, sin embargo, se utiliza para la comparación su cuadro "
"delimitador (bounding box)."

#. Tag: para
#: using_postgis_dataman.xml:1409
#, no-c-format
msgid "Using a \"BOX3D\" object for the frame, such a query looks like this:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1411
#, no-c-format
msgid ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"
msgstr ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"

#. Tag: para
#: using_postgis_dataman.xml:1413
#, no-c-format
msgid ""
"Note the use of the SRID 312, to specify the projection of the envelope."
msgstr ""
"Observa el uso del SRID 123, para espeficar la proyección de la envolvente."

#. Tag: title
#: using_postgis_dataman.xml:1419
#, fuzzy, no-c-format
msgid "Using the Shapefile Dumper"
msgstr "Uso del Dumper"

#. Tag: para
#: using_postgis_dataman.xml:1421
#, fuzzy, no-c-format
msgid ""
"The <filename>pgsql2shp</filename> table dumper connects to the database and "
"converts a table (possibly defined by a query) into a shape file. The basic "
"syntax is:"
msgstr ""
"El comando dump de las tablas <filename>pgsql2shp</filename> conecta "
"directamente con la base de datos y convierte la tabla (posiblemente "
"definido por una consulta) en un fichero shape. La sintaxis básica es:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1425
#, no-c-format
msgid ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"
msgstr ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"

#. Tag: programlisting
#: using_postgis_dataman.xml:1427
#, no-c-format
msgid "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"
msgstr "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1429
#, no-c-format
msgid "The commandline options are:"
msgstr "Las opciones del comando son:"

#. Tag: term
#: using_postgis_dataman.xml:1433
#, no-c-format
msgid "-f &lt;filename&gt;"
msgstr "-f &lt;filename&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1436
#, no-c-format
msgid "Write the output to a particular filename."
msgstr "Escribe la salida en un fichero con un nombre particular"

#. Tag: term
#: using_postgis_dataman.xml:1441
#, no-c-format
msgid "-h &lt;host&gt;"
msgstr "-h &lt;host&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1444
#, no-c-format
msgid "The database host to connect to."
msgstr "Especifica el servidor al que conectarse."

#. Tag: term
#: using_postgis_dataman.xml:1449
#, no-c-format
msgid "-p &lt;port&gt;"
msgstr "-p &lt;port&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1452
#, no-c-format
msgid "The port to connect to on the database host."
msgstr ""
"Especifica el puerto del servidor de la base de datos al que conectarse."

#. Tag: term
#: using_postgis_dataman.xml:1457
#, no-c-format
msgid "-P &lt;password&gt;"
msgstr "-P &lt;password&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1460
#, no-c-format
msgid "The password to use when connecting to the database."
msgstr "La contraseña a utilizar en la conexión de la base de datos."

#. Tag: term
#: using_postgis_dataman.xml:1465
#, no-c-format
msgid "-u &lt;user&gt;"
msgstr "-u &lt;user&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1468
#, no-c-format
msgid "The username to use when connecting to the database."
msgstr "El nombre del usuario a utilizar en la conexión a la base de datos."

#. Tag: term
#: using_postgis_dataman.xml:1473
#, no-c-format
msgid "-g &lt;geometry column&gt;"
msgstr "-g &lt;geometry column&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1476
#, no-c-format
msgid ""
"In the case of tables with multiple geometry columns, the geometry column to "
"use when writing the shape file."
msgstr ""
"En el caso que las tablas tengan varias columnas de geometrías, la columna "
"de geometrías a utilizar cuando se escriba el fichero shape."

#. Tag: term
#: using_postgis_dataman.xml:1482
#, no-c-format
msgid "<term>-b</term>"
msgstr "<term>-b</term>"

#. Tag: para
#: using_postgis_dataman.xml:1485
#, no-c-format
msgid ""
"Use a binary cursor. This will make the operation faster, but will not work "
"if any NON-geometry attribute in the table lacks a cast to text."
msgstr ""
"Utiliza un cursor binario. Esto hada las operaciones mas rápido, pero no "
"funcionará si algún atributo NO-geométrico de la tabla carece de conversion "
"a texto."

#. Tag: term
#: using_postgis_dataman.xml:1492
#, no-c-format
msgid "<term>-r</term>"
msgstr "<term>-r</term>"

#. Tag: para
#: using_postgis_dataman.xml:1495
#, no-c-format
msgid ""
"Raw mode. Do not drop the <varname>gid</varname> field, or escape column "
"names."
msgstr ""
"Modo Raw. No suprime el campo <varname>gid</varname>, o omite los nombres de "
"las columnas."

#. Tag: term
#: using_postgis_dataman.xml:1501
#, no-c-format
msgid "-m <varname>filename</varname>"
msgstr "-m <varname>filename</varname>"

#. Tag: para
#: using_postgis_dataman.xml:1503
#, no-c-format
msgid ""
"Remap identifiers to ten character names. The content of the file is lines "
"of two symbols separated by a single white space and no trailing or leading "
"space: VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."
msgstr ""
"Reasignar los identificadores de diez nombres de los personajes. El "
"contenido del archivo son líneas de dos símbolos separados por un único "
"espacio en blanco y sin espacios al final, o al inicio: VERYLONGSYMBOL "
"SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."

#. Tag: title
#: using_postgis_dataman.xml:1516
#, fuzzy, no-c-format
msgid "Building Spatial Indexes"
msgstr "Contruir Indices"

#. Tag: para
#: using_postgis_dataman.xml:1518
#, fuzzy, no-c-format
msgid ""
"Indexes make using a spatial database for large data sets possible. Without "
"indexing, a search for features would require a sequential scan of every "
"record in the database. Indexing speeds up searching by organizing the data "
"into a structure which can be quickly traversed to find records."
msgstr ""
"Los índices son los que hacen posible el uso de una base de datos espacial "
"para conjuntos de datos muy grandes. Sin indexación, cualquier búsqueda de "
"una característica requeriría un \"recorrido secuencial\" de cada registro "
"en la base de datos. La Indexación acelera la búsqueda mediante la "
"organización de los datos en un árbol de búsqueda que puede ser recorrido "
"con rapidez para encontrar un registro en particular. PostgreSQL soporta "
"tres tipos de índices por defecto: índices B-Tree, índices R-Tree, e índices "
"GIST."

#. Tag: para
#: using_postgis_dataman.xml:1524
#, no-c-format
msgid ""
"The B-tree index method commonly used for attribute data is not very useful "
"for spatial data, since it only supports storing and querying data in a "
"single dimension. Data such as geometry which has 2 or more dimensions) "
"requires an index method that supports range query across all the data "
"dimensions. (That said, it is possible to effectively index so-called XY "
"data using a B-tree and explict range searches.) One of the main advantages "
"of PostgreSQL for spatial data handling is that it offers several kinds of "
"indexes which work well for multi-dimensional data: GiST, BRIN and SP-GiST "
"indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1536
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"bold\">GiST (Generalized Search Tree)</emphasis> indexes "
"break up data into \"things to one side\", \"things which overlap\", "
"\"things which are inside\" and can be used on a wide range of data-types, "
"including GIS data. PostGIS uses an R-Tree index implemented on top of GiST "
"to index spatial data. GiST is the most commonly-used and versatile spatial "
"index method, and offers very good query performance."
msgstr ""
"Los indices GiST (Generalized Search Trees o Arbol de búsquedas "
"generalizado) dividen los datos en \"cosas a un lado\", \"cosas que se "
"solapan\", \"cosas que están dentro\" y se pueden utilizar en una amplia "
"gama de tipos de datos, incluyendo los datos SIG. PostGIS utiliza un índice "
"R-Tree implementado sobre GiST para indexar datos GIS."

#. Tag: para
#: using_postgis_dataman.xml:1546
#, no-c-format
msgid ""
"<emphasis role=\"bold\">BRIN (Block Range Index)</emphasis> indexes operate "
"by summarizing the spatial extent of ranges of table records. Search is done "
"via a scan of the ranges. BRIN is only appropriate for use for some kinds of "
"data (spatially sorted, with infrequent or no update). But it provides much "
"faster index create time, and much smaller index size."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1556
#, no-c-format
msgid ""
"<emphasis role=\"bold\">SP-GiST (Space-Partitioned Generalized Search Tree)</"
"emphasis> is a generic index method that supports partitioned search trees "
"such as quad-trees, k-d trees, and radix trees (tries)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1563
#, no-c-format
msgid ""
"For more information see the <ulink url=\"https://postgis.net/workshops/"
"postgis-intro/indexing.html\">PostGIS Workshop</ulink>, and the <ulink url="
"\"https://www.postgresql.org/docs/current/indexes.html\">PostgreSQL "
"documentation</ulink>."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1569
#, no-c-format
msgid "GiST Indexes"
msgstr "Indices GiST"

#. Tag: para
#: using_postgis_dataman.xml:1571
#, no-c-format
msgid ""
"GiST stands for \"Generalized Search Tree\" and is a generic form of "
"indexing. In addition to GIS indexing, GiST is used to speed up searches on "
"all kinds of irregular data structures (integer arrays, spectral data, etc) "
"which are not amenable to normal B-Tree indexing."
msgstr ""
"GiST significa \"Generalized Search Tree\" de sus siglas en inglés o \"Arbol "
"de Búsqueda Generalizado\" y es una forma genérica de indexación. Además de "
"la indexación de datos SIG, GiST se utiliza para acelerar las búsquedas en "
"todo tipo de estructuras irregulares de datos (arrays de enteros, datos "
"espectrales, etc) que no son susceptibles de indexación por árbol normal."

#. Tag: para
#: using_postgis_dataman.xml:1576
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields)."
msgstr ""
"Una vez que una tabla de datos GIS supera unos pocos miles de filas, tendrás "
"que construir un índice para acelerar las búsquedas espaciales de los datos "
"(a menos que todas las búsquedas se basen en atributos, en cuyo caso querrás "
"construir un índice normal en los campos de atributo)."

#. Tag: para
#: using_postgis_dataman.xml:1581
#, no-c-format
msgid ""
"The syntax for building a GiST index on a \"geometry\" column is as follows:"
msgstr ""
"La sintaxis para la creación de un indice GiST en una columna \"geometry\" "
"es como sigue:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1585
#, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1587
#, fuzzy, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get the an n-dimensional "
"index for the geometry type, you can create one using this syntax:"
msgstr ""
"La sintaxis anterior siempre construirá un índice 2D. Para obtener el índice "
"de dimensión n soportado en PostGIS 2.0 + para el tipo geometría, puedes "
"crearlo utilizando esta sintaxis"

#. Tag: programlisting
#: using_postgis_dataman.xml:1588
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1590
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive exercise. It also "
"blocks write access to your table for the time it creates, so on a "
"production system you may want to do in in a slower CONCURRENTLY-aware way:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1591
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING GIST "
"( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1593 using_postgis_dataman.xml:1761
#, no-c-format
msgid ""
"After building an index, it is sometimes helpful to force PostgreSQL to "
"collect table statistics, which are used to optimize query plans:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1596 using_postgis_dataman.xml:1764
#, no-c-format
msgid "VACUUM ANALYZE [table_name] [(column_name)];"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1601
#, fuzzy, no-c-format
msgid "BRIN Indexes"
msgstr "Indices GiST"

#. Tag: para
#: using_postgis_dataman.xml:1603
#, no-c-format
msgid ""
"BRIN stands for \"Block Range Index\". It is an general-purpose <ulink url="
"\"https://www.postgresql.org/docs/current/brin.html\">index method</ulink> "
"introduced in PostgreSQL 9.5. BRIN is a <emphasis>lossy</emphasis> index "
"method, meaning that a a secondary check is required to confirm that a "
"record matches a given search condition (which is the case for all provided "
"spatial indexes). It provides much faster index creation and much smaller "
"index size, with reasonable read performance. Its primary purpose is to "
"support indexing very large tables on columns which have a correlation with "
"their physical location within the table. In addition to spatial indexing, "
"BRIN can speed up searches on various kinds of attribute data structures "
"(integer, arrays etc)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1617
#, fuzzy, no-c-format
msgid ""
"Once a spatial table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data. GiST indexes are very "
"performant as long as their size doesn't exceed the amount of RAM available "
"for the database, and as long as you can afford the index storage size, and "
"the cost of index update on write. Otherwise, for very large tables BRIN "
"index can be considered as an alternative."
msgstr ""
"Una vez que una tabla de datos GIS supera unos pocos miles de filas, tendrás "
"que construir un índice para acelerar las búsquedas espaciales de los datos "
"(a menos que todas las búsquedas se basen en atributos, en cuyo caso querrás "
"construir un índice normal en los campos de atributo)."

#. Tag: para
#: using_postgis_dataman.xml:1624
#, no-c-format
msgid ""
"A BRIN index stores the bounding box enclosing all the geometries contained "
"in the rows in a contiguous set of table blocks, called a <emphasis>block "
"range</emphasis>. When executing a query using the index the block ranges "
"are scanned to find the ones that intersect the query extent. This is "
"efficient only if the data is physically ordered so that the bounding boxes "
"for block ranges have minimal overlap (and ideally are mutually exclusive). "
"The resulting index is very small in size, but is typically less performant "
"for read than a GiST index over the same data."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1634
#, no-c-format
msgid ""
"Building a BRIN index is much less CPU-intensive than building a GiST index. "
"It's common to find that a BRIN index is ten times faster to build than a "
"GiST index over the same data. And because a BRIN index stores only one "
"bounding box for each range of table blocks, it's common to use up to a "
"thousand times less disk space than a GiST index."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1640
#, no-c-format
msgid ""
"You can choose the number of blocks to summarize in a range. If you decrease "
"this number, the index will be bigger but will probably provide better "
"performance."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1644
#, no-c-format
msgid ""
"For BRIN to be effective, the table data should be stored in a physical "
"order which minimizes the amount of block extent overlap. It may be that the "
"data is already sorted appropriately (for instance, if it is loaded from "
"another dataset that is already sorted in spatial order). Otherwise, this "
"can be accomplished by sorting the data by a one-dimensional spatial key. "
"One way to do this is to create a new table sorted by the geometry values "
"(which in recent PostGIS versions uses an efficient Hilbert curve ordering):"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1653
#, no-c-format
msgid ""
"CREATE TABLE table_sorted AS\n"
"   SELECT * FROM table  ORDER BY geom;"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1655
#, no-c-format
msgid ""
"Alternatively, data can be sorted in-place by using a GeoHash as a "
"(temporary) index, and clustering on that index:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1659
#, no-c-format
msgid ""
"CREATE INDEX idx_temp_geohash ON table\n"
"    USING btree (ST_GeoHash( ST_Transform( geom, 4326 ), 20));\n"
"CLUSTER table USING idx_temp_geohash;"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1662
#, fuzzy, no-c-format
msgid ""
"The syntax for building a BRIN index on a <code>geometry</code> column is:"
msgstr ""
"La sintaxis para la creación de un indice GiST en una columna \"geometry\" "
"es como sigue:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1664
#, fuzzy, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geome_col] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1666
#, fuzzy, no-c-format
msgid ""
"The above syntax builds a 2D index. To build a 3D-dimensional index, use "
"this syntax:"
msgstr ""
"La sintaxis anterior siempre construirá un índice 2D. Para obtener el índice "
"de dimensión n soportado en PostGIS 2.0 + para el tipo geometría, puedes "
"crearlo utilizando esta sintaxis"

#. Tag: programlisting
#: using_postgis_dataman.xml:1668
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename]\n"
"    USING BRIN ([geome_col] brin_geometry_inclusion_ops_3d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1670
#, no-c-format
msgid "You can also get a 4D-dimensional index using the 4D operator class:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1672
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename]\n"
"    USING BRIN ([geome_col] brin_geometry_inclusion_ops_4d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1674
#, no-c-format
msgid ""
"The above commands use the default number of blocks in a range, which is "
"128. To specify the number of blocks to summarise in a range, use this syntax"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1677
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename]\n"
"    USING BRIN ( [geome_col] ) WITH (pages_per_range = [number]);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1679
#, no-c-format
msgid ""
"Keep in mind that a BRIN index only stores one index entry for a large "
"number of rows. If your table stores geometries with a mixed number of "
"dimensions, it's likely that the resulting index will have poor performance. "
"You can avoid this performance penalty by choosing the operator class with "
"the least number of dimensions of the stored geometries"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1687
#, fuzzy, no-c-format
msgid ""
"The <code>geography</code> datatype is supported for BRIN indexing. The "
"syntax for building a BRIN index on a geography column is:"
msgstr ""
"La sintaxis para la creación de un indice GiST en una columna \"geometry\" "
"es como sigue:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1690
#, fuzzy, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geog_col] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1692
#, fuzzy, no-c-format
msgid ""
"The above syntax builds a 2D-index for geospatial objects on the spheroid."
msgstr ""
"La sintaxis anterior siempre construirá un índice 2D. Para obtener el índice "
"de dimensión n soportado en PostGIS 2.0 + para el tipo geometría, puedes "
"crearlo utilizando esta sintaxis"

#. Tag: para
#: using_postgis_dataman.xml:1694
#, no-c-format
msgid ""
"Currently, only \"inclusion support\" is provided, meaning that just the "
"<varname>&amp;&amp;</varname>, <varname>~</varname> and <varname>@</varname> "
"operators can be used for the 2D cases (for both <code>geometry</code> and "
"<code>geography</code>), and just the <varname>&amp;&amp;&amp;</varname> "
"operator for 3D geometries. There is currently no support for kNN searches."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1701
#, no-c-format
msgid ""
"An important difference between BRIN and other index types is that the "
"database does not maintain the index dynamically. Changes to spatial data in "
"the table are simply appended to the end of the index. This will cause index "
"search performance to degrade over time. The index can be updated by "
"performing a <code>VACUUM</code>, or by using a special function "
"<code>brin_summarize_new_values(regclass)</code>. For this reason BRIN may "
"be most appropriate for use with data that is read-only, or only rarely "
"changing. For more information refer to the <ulink url=\"https://www."
"postgresql.org/docs/current/brin-intro.html#BRIN-OPERATION\">manual</ulink>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1711
#, no-c-format
msgid "To summarize using BRIN for spatial data:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1715
#, no-c-format
msgid "Index build time is very fast, and index size is very small."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1716
#, no-c-format
msgid "Index query time is slower than GiST, but can still be very acceptable."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1717
#, no-c-format
msgid "Requires table data to be sorted in a spatial ordering."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1718
#, no-c-format
msgid "Requires manual index maintenance."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1719
#, no-c-format
msgid ""
"Most appropriate for very large tables, with low or no overlap (e.g. "
"points), and which are static or change infrequently."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1727
#, fuzzy, no-c-format
msgid "SP-GiST Indexes"
msgstr "Indices GiST"

#. Tag: para
#: using_postgis_dataman.xml:1729
#, no-c-format
msgid ""
"SP-GiST stands for \"Space-Partitioned Generalized Search Tree\" and is a "
"generic form of indexing that supports partitioned search trees, such as "
"quad-trees, k-d trees, and radix trees (tries). The common feature of these "
"data structures is that they repeatedly divide the search space into "
"partitions that need not be of equal size. In addition to GIS indexing, SP-"
"GiST is used to speed up searches on many kinds of data, such as phone "
"routing, ip routing, substring search, etc."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1737
#, no-c-format
msgid ""
"As it is the case for GiST indexes, SP-GiST indexes are lossy, in the sense "
"that they store the bounding box enclosing spatial objects. SP-GiST indexes "
"can be considered as an alternative to GiST indexes. The performance tests "
"reveal that SP-GiST indexes are especially beneficial when there are many "
"overlapping objects, that is, with so-called “spaghetti data”."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1744
#, fuzzy, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, an SP-GiST index may be "
"used to speed up spatial searches of the data. The syntax for building an SP-"
"GiST index on a \"geometry\" column is as follows:"
msgstr ""
"Una vez que una tabla de datos GIS supera unos pocos miles de filas, tendrás "
"que construir un índice para acelerar las búsquedas espaciales de los datos "
"(a menos que todas las búsquedas se basen en atributos, en cuyo caso querrás "
"construir un índice normal en los campos de atributo)."

#. Tag: programlisting
#: using_postgis_dataman.xml:1748
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING SPGIST ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1750
#, fuzzy, no-c-format
msgid ""
"The above syntax will build a 2-dimensional index. A 3-dimensional index for "
"the geometry type can be created using the 3D operator class:"
msgstr ""
"La sintaxis anterior siempre construirá un índice 2D. Para obtener el índice "
"de dimensión n soportado en PostGIS 2.0 + para el tipo geometría, puedes "
"crearlo utilizando esta sintaxis"

#. Tag: programlisting
#: using_postgis_dataman.xml:1753
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING SPGIST ([geometryfield] "
"spgist_geometry_ops_3d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1755
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive operation. It also "
"blocks write access to your table for the time it creates, so on a "
"production system you may want to do in in a slower CONCURRENTLY-aware way:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1759
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING SPGIST "
"( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1766
#, no-c-format
msgid ""
"An SP-GiST index can accelerate queries involving the following operators:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1768
#, no-c-format
msgid ""
"&lt;&lt;, &amp;&lt;, &amp;&gt;, &gt;&gt;, &lt;&lt;|, &amp;&lt;|, |&amp;&gt;, "
"|&gt;&gt;, &amp;&amp;, @&gt;, &lt;@, and ~=, for 2-dimensional indexes,"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1769
#, no-c-format
msgid "&amp;/&amp;, ~==, @&gt;&gt;, and &lt;&lt;@, for 3-dimensional indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1771
#, no-c-format
msgid "There is no support for kNN searches at the moment."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1774
#, no-c-format
msgid "Using Indexes"
msgstr "Utilizando Indices"

#. Tag: para
#: using_postgis_dataman.xml:1776
#, fuzzy, no-c-format
msgid ""
"Ordinarily, indexes invisibly speed up data access: once the index is built, "
"the PostgreSQL query planner automatically decides when to use index "
"information to speed up a query plan. Unfortunately, the query planner "
"sometimes does not optimize the use of GiST indexes, so queries end up using "
"slow sequential scans instead of a spatial index."
msgstr ""
"Por lo general, los índices aceleran el acceso de datos de forma invisible: "
"una vez construido el índice, el optimizador de consultas decide de manera "
"transparente cuándo utilizar la información del índice para acelerar un plan "
"de consulta. Por desgracia, el planeador de consultas de PostgreSQL no "
"optimiza el uso de índices GiST bien, así que a veces las búsquedas que "
"deben utilizar un índice espacial en lugar del indice por defecto, explora "
"toda la tabla de forma secuencia."

#. Tag: para
#: using_postgis_dataman.xml:1782
#, fuzzy, no-c-format
msgid ""
"If you find your spatial indexes are not being used, there are a couple "
"things you can do:"
msgstr ""
"Si observas que los indices espaciales no se están utilizando (o tus indices "
"de atributos, en su defecto) hay un par de cosas que puedes hacer:"

#. Tag: para
#: using_postgis_dataman.xml:1787
#, no-c-format
msgid ""
"Examine the query plan and check your query actually computes the thing you "
"need. An erroneous JOIN, either forgotten or to the wrong table, can "
"unexpectedly retrieve table records multiple times. To get the query plan, "
"execute with <code>EXPLAIN</code> in front of the query."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1794
#, no-c-format
msgid ""
"Make sure statistics are gathered about the number and distributions of "
"values in a table, to provide the query planner with better information to "
"make decisions around index usage. <command>VACUUM ANALYZE</command> will "
"compute both."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1799
#, no-c-format
msgid ""
"You should regularly vacuum your databases anyways - many PostgreSQL DBAs "
"have <command>VACUUM</command> run as an off-peak cron job on a regular "
"basis."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1804
#, fuzzy, no-c-format
msgid ""
"If vacuuming does not help, you can temporarily force the planner to use the "
"index information by using the <command>set enable_seqscan to off;</command> "
"command. This way you can check whether planner is at all capable to "
"generate an index accelerated query plan for your query. You should only use "
"this command only for debug: generally speaking, the planner knows better "
"than you do about when to use indexes. Once you have run your query, do not "
"forget to set <varname>ENABLE_SEQSCAN</varname> back on, so that other "
"queries will utilize the planner as normal."
msgstr ""
"Si ejecutando vacuum no funciona, se puede forzar al planificador para "
"utilizar la información de índice utilizando el comando <command>SET "
"ENABLE_SEQSCAN=OFF</command>. Debes utilizar este comando con moderación y "
"sólo en consultas sobre datos indexados espacialmente: en términos "
"generales, el planificador sabe más que tu acerca de cuándo utilizar los "
"índices de B-Tree normales. Una vez que hayas ejecutado la consulta, debes "
"considerar el restablecimiento de la variable <varname>ENABLE_SEQSCAN</"
"varname> de nuevo, de manera que las demás consultas utilizarán el "
"planificador de la forma habitual."

#. Tag: para
#: using_postgis_dataman.xml:1816
#, fuzzy, no-c-format
msgid ""
"If <command>set enable_seqscan to off;</command> helps your query to run, "
"your Postgres is likely not tuned for your hardware. If you find the planner "
"wrong about the cost of sequential vs index scans try reducing the value of "
"<varname>random_page_cost</varname> in postgresql.conf or using <command>set "
"random_page_cost to 1.1;</command>. Default value for the parameter is 4, "
"try setting it to 1 (on SSD) or 2 (on fast magnetic disks). Decreasing the "
"value makes the planner more inclined of using Index scans."
msgstr ""
"Si ves que el planificador se equivoca sobre el costo de exploraciones "
"secuenciales vs índices, intenta reducir el valor de random_page_cost en "
"postgresql.conf o usando SET random_page_cost = #. El valor por defecto para "
"el parámetro es de 4, prueba a ajustarlo a 1 o 2. Disminuyendo el valor, "
"haces que el planificador se incline mas por utilizar exploraciones con "
"índice."

#. Tag: para
#: using_postgis_dataman.xml:1826
#, no-c-format
msgid ""
"If <command>set enable_seqscan to off;</command> does not help your query, "
"the query may be using a SQL construct that the Postgres planner is not yet "
"able to optimize. It may be possible to rewrite the query in a way that the "
"planner is able to handle. For example, a subquery with an inline SELECT may "
"not produce an efficient plan, but could possibly be rewritten using a "
"LATERAL JOIN."
msgstr ""

#~ msgid "Using PostGIS: Data Management and Queries"
#~ msgstr "Utilizando PostGIS: Gestión de Datos y Consultas"

#~ msgid "Using OpenGIS Standards"
#~ msgstr "Utilizando estandares OpenGIS"

#~ msgid ""
#~ "For details on determining which UTM zone to use for your area of "
#~ "interest, check out the <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
#~ "UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper "
#~ "function</ulink>."
#~ msgstr ""
#~ "Para saber detalles sobre como determinar la zona UTM a utilizar en tu "
#~ "área de interés, echalé un vistazo a la <ulink url=\"http://trac.osgeo."
#~ "org/postgis/wiki/UsersWikiplpgsqlfunctionsDistance\">función de ayuda "
#~ "utmzone PostGIS plpgsql </ulink>."

#~ msgid "The <varname>SPATIAL_REF_SYS</varname> columns are as follows:"
#~ msgstr "Las columnas <varname>SPATIAL_REF_SYS</varname> son como sigue:"

#~ msgid "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"
#~ msgstr "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"

#~ msgid "<term>SRID</term>"
#~ msgstr "<term>SRID</term>"

#~ msgid "Ensuring OpenGIS compliancy of geometries"
#~ msgstr "Asegurando la compatibilidad de geometrias con OpenGIS"

#~ msgid "Dimensionally Extended 9 Intersection Model (DE-9IM)"
#~ msgstr "Modelo de intersección 9 dimensionalmente extendido(DE-9IM)"

#, fuzzy
#~ msgid ""
#~ "It is sometimes the case that the typical spatial predicates (<xref "
#~ "linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
#~ "linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Touches\"/>, ...) are "
#~ "insufficient in and of themselves to adequately provide that desired "
#~ "spatial filter."
#~ msgstr ""
#~ "A veces se da el caso que los predicados espaciales típicos (<xref "
#~ "linkend=\"ST_Contains\"/>, <xref linkend=\"ST_Crosses\"/>, <xref linkend="
#~ "\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>, ...) son "
#~ "insuficientes en si mismos para proveer el filtro espacial deseado."

#~ msgid ""
#~ "For example, consider a linear dataset representing a road network. It "
#~ "may be the task of a GIS analyst to identify all road segments that cross "
#~ "each other, not at a point, but on a line, perhaps invalidating some "
#~ "business rule. In this case, <xref linkend=\"ST_Crosses\"/> does not "
#~ "adequately provide the necessary spatial filter since, for linear "
#~ "features, it returns <varname>true</varname> only where they cross at a "
#~ "point."
#~ msgstr ""
#~ "Por ejemplo, considera un conjunto de datos lineales representando una "
#~ "red de transportes. Es tarea del analista SIG identificar todos los "
#~ "segmentos de carreteras que se intersectan con otros, no en un punto, "
#~ "pero en una linea, quizás invalidando algunas reglas. En este caso,  "
#~ "<xref linkend=\"ST_Crosses\"/> no nos proporcionara el filtro espacial "
#~ "adecuado ya que , para elementos lineales, devolverá <varname>true</"
#~ "varname> solo en el caso de intersección en un punto."

#~ msgid ""
#~ "One two-step solution might be to first perform the actual intersection "
#~ "(<xref linkend=\"ST_Intersection\"/>) of pairs of road segments that "
#~ "spatially intersect (<xref linkend=\"ST_Intersects\"/>), and then compare "
#~ "the intersection's <xref linkend=\"ST_GeometryType\"/> with "
#~ "'<varname>LINESTRING</varname>' (properly dealing with cases that return "
#~ "<varname>GEOMETRYCOLLECTION</varname>s of <varname>[MULTI]POINT</"
#~ "varname>s, <varname>[MULTI]LINESTRING</varname>s, etc.)."
#~ msgstr ""
#~ "Una solución en dos pasos podría ser, primero hacer una consulta de las "
#~ "intersecciones (<xref linkend=\"ST_Intersection\"/>) de los pares de vías "
#~ "de comunicación que se intersectan espacialmente (<xref linkend="
#~ "\"ST_Intersects\"/>), y entonces comparar las intersecciones <xref "
#~ "linkend=\"ST_GeometryType\"/> con '<varname>LINESTRING</"
#~ "varname>' (gestionando correctamente los casos que devuelvan "
#~ "<varname>GEOMETRYCOLLECTION</varname> de <varname>[MULTI]POINT</"
#~ "varname>s, <varname>[MULTI]LINESTRING</varname>s, etc.)."

#~ msgid "A more elegant / faster solution may indeed be desirable."
#~ msgstr "Una solución mas elegante/rápida  de hecho puede ser deseable."

#~ msgid ""
#~ "A second [theoretical] example may be that of a GIS analyst trying to "
#~ "locate all wharfs or docks that intersect a lake's boundary on a line and "
#~ "where only one end of the wharf is up on shore. In other words, where a "
#~ "wharf is within, but not completely within a lake, intersecting the "
#~ "boundary of a lake on a line, and where the wharf's endpoints are both "
#~ "completely within and on the boundary of the lake. The analyst may need "
#~ "to use a combination of spatial predicates to isolate the sought after "
#~ "features:"
#~ msgstr ""
#~ "Un [teórico] segundo ejemplo puede ser el de un analista SIG intentando "
#~ "localizar todos los muelles que intersectan los limites de un lago en una "
#~ "linea y donde solo un extremo del muelle este en la orilla. En otras "
#~ "palabras, cuando el muelle este contenido , pero no completamente en el "
#~ "lago, intersectando el borde del lago en una linea, y donde los puntos "
#~ "finales del muelle estén completamente en el borde del lago. El analista "
#~ "necesitará utilizar una combinación de predicados espaciales para aislar "
#~ "el problema:"

#~ msgid "(lake, wharf) = TRUE"
#~ msgstr "(lake, wharf) = TRUE"

#~ msgid "(lake, wharf) = FALSE"
#~ msgstr "(lake, wharf) = FALSE"

#~ msgid "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"
#~ msgstr "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"

#~ msgid ""
#~ "(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
#~ "linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/"
#~ ">(lake)))) = 1"
#~ msgstr ""
#~ "(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
#~ "linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/"
#~ ">(lake)))) = 1"

#~ msgid "... (needless to say, this could get quite complicated)"
#~ msgstr ""
#~ "... (ni que decir tiene que esto podría llegar a ser muy complicado)"

#~ msgid ""
#~ "So enters the Dimensionally Extended 9 Intersection Model, or DE-9IM for "
#~ "short."
#~ msgstr ""
#~ "Así que introducimos el Modelo de Intersección 9 Dimensionalmente "
#~ "Extendido, o DE-9IM para abreviar."

#~ msgid "Theory"
#~ msgstr "Teoria"

#~ msgid ""
#~ "According to the <ulink url=\"http://www.opengeospatial.org/standards/sfs"
#~ "\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, "
#~ "\"the basic approach to comparing two geometries is to make pair-wise "
#~ "tests of the intersections between the Interiors, Boundaries and "
#~ "Exteriors of the two geometries and to classify the relationship between "
#~ "the two geometries based on the entries in the resulting 'intersection' "
#~ "matrix.\""
#~ msgstr ""
#~ "Según la especificación <ulink url=\"http://www.opengeospatial.org/"
#~ "standards/sfs\">OpenGIS Simple Features Implementation Specification for "
#~ "SQL</ulink>, \"El enfoque básico para comparar dos geometrías es hacer un "
#~ "test por pares de la intersección entre los interiores, bordes y "
#~ "exteriores de las dos geometrías y clasificar las relaciones entre las "
#~ "dos geometrías basandose en las entradas de la 'matriz de intersección' "
#~ "resultante.\""

#~ msgid "<glossterm>Boundary</glossterm>"
#~ msgstr "<glossterm>Borde</glossterm>"

#~ msgid ""
#~ "The boundary of a geometry is the set of geometries of the next lower "
#~ "dimension. For <varname>POINT</varname>s, which have a dimension of 0, "
#~ "the boundary is the empty set. The boundary of a <varname>LINESTRING</"
#~ "varname> are the two endpoints. For <varname>POLYGON</varname>s, the "
#~ "boundary is the linework that make up the exterior and interior rings."
#~ msgstr ""
#~ "El borde de una geometría es el conjunto de geometrias de la dimension "
#~ "menor siguiente. Para <varname>POINT</varname>s, que tienen dimension 0, "
#~ "el borde es un conjunto vacío. El borde para un <varname>LINESTRING</"
#~ "varname> son los dos puntos de los extremos. Para <varname>POLYGON</"
#~ "varname>s, el borde son las lineas que delimitan los anillos exteriores e "
#~ "interiores."

#~ msgid "<glossterm>Interior</glossterm>"
#~ msgstr "<glossterm>Interior</glossterm>"

#~ msgid ""
#~ "The interior of a geometry are those points of a geometry that are left "
#~ "when the boundary is removed. For <varname>POINT</varname>s, the interior "
#~ "is the <varname>POINT</varname> itself. The interior of a "
#~ "<varname>LINESTRING</varname> are the set of real points between the "
#~ "endpoints. For <varname>POLYGON</varname>s, the interior is the areal "
#~ "surface inside the polygon."
#~ msgstr ""
#~ "El interior de una geometría son los puntos de la geometría que quedan "
#~ "cuando el borde es eliminado. Para <varname>POINT</varname>s, el interior "
#~ "es el propio <varname>POINT</varname>. El interior de una "
#~ "<varname>LINESTRING</varname> es el conjunto de puntos reales entre los "
#~ "puntos de los extremos. Para <varname>POLYGON</varname>s, el interior es "
#~ "una superficie real dentro del polígono. "

#~ msgid "<glossterm>Exterior</glossterm>"
#~ msgstr "<glossterm>Exterior</glossterm>"

#~ msgid ""
#~ "The exterior of a geometry is the universe, an areal surface, not on the "
#~ "interior or boundary of the geometry."
#~ msgstr ""
#~ "El Exterior de una geometría es el universo, una superficie real, que no "
#~ "se encuentra en el interior o en el borde de la geometría."

#~ msgid ""
#~ "Given geometry <emphasis>a</emphasis>, where the <emphasis>I(a)</"
#~ "emphasis>, <emphasis>B(a)</emphasis>, and <emphasis>E(a)</emphasis> are "
#~ "the <emphasis>Interior</emphasis>, <emphasis>Boundary</emphasis>, and "
#~ "<emphasis>Exterior</emphasis> of a, the mathematical representation of "
#~ "the matrix is:"
#~ msgstr ""
#~ "Dada una geometria <emphasis>a</emphasis>, donde <emphasis>I(a)</"
#~ "emphasis>, <emphasis>B(a)</emphasis>, y <emphasis>E(a)</emphasis> son el "
#~ "<emphasis>Interior</emphasis>, <emphasis>Borde</emphasis>, y "
#~ "<emphasis>Exterior</emphasis> de a, la representación matemática de la "
#~ "matriz es:"

#~ msgid "<emphasis role=\"bold\">Interior</emphasis>"
#~ msgstr "<emphasis role=\"bold\">Interior</emphasis>"

#~ msgid "<emphasis role=\"bold\">Boundary</emphasis>"
#~ msgstr "<emphasis role=\"bold\">Borde</emphasis>"

#~ msgid "<emphasis role=\"bold\">Exterior</emphasis>"
#~ msgstr "<emphasis role=\"bold\">Exterior</emphasis>"

#~ msgid ""
#~ "Where <emphasis>dim(a)</emphasis> is the dimension of <emphasis>a</"
#~ "emphasis> as specified by <xref linkend=\"ST_Dimension\"/> but has the "
#~ "domain of <literal>{0,1,2,T,F,*}</literal>"
#~ msgstr ""
#~ "Donde <emphasis>dim(a)</emphasis> representa la dimensión de  "
#~ "<emphasis>a</emphasis> como se especifica en  <xref linkend=\"ST_Dimension"
#~ "\"/> pero tiene un dominio de <literal>{0,1,2,T,F,*}</literal>"

#~ msgid "<literal>0</literal> =&gt; point"
#~ msgstr "<literal>0</literal> =&gt; punto"

#~ msgid "<literal>1</literal> =&gt; line"
#~ msgstr "<literal>1</literal> =&gt; linea"

#~ msgid "<literal>2</literal> =&gt; area"
#~ msgstr "<literal>2</literal> =&gt; area"

#~ msgid "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"
#~ msgstr "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"

#~ msgid "<literal>F</literal> =&gt; empty set"
#~ msgstr "<literal>F</literal> =&gt; empty set"

#~ msgid "<literal>*</literal> =&gt; don't care"
#~ msgstr "<literal>*</literal> =&gt; no importa que valor"

#~ msgid "Visually, for two overlapping polygonal geometries, this looks like:"
#~ msgstr ""
#~ "Visualmente, para dos geometriías que se superponen, debera parecerse a:"

#~ msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"
#~ msgstr ""
#~ "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"

#~ msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"
#~ msgstr ""
#~ "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"

#~ msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"
#~ msgstr ""
#~ "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"

#~ msgid ""
#~ "Read from left to right and from top to bottom, the dimensional matrix is "
#~ "represented, '<emphasis role=\"bold\">212101212</emphasis>'."
#~ msgstr ""
#~ "Si leemos la matriz de izquierda a derecha y de arriba a bajo, la matriz "
#~ "dimensional esta representada por, '<emphasis role=\"bold\">212101212</"
#~ "emphasis>'."

#~ msgid ""
#~ "A relate matrix that would therefore represent our first example of two "
#~ "lines that intersect on a line would be: '<emphasis role=\"bold"
#~ "\">1*1***1**</emphasis>'"
#~ msgstr ""
#~ "Una matriz que representaría el ejemplo anterior de las dos lineas que se "
#~ "interceptan en una linea seria: '<emphasis role=\"bold\">1*1***1**</"
#~ "emphasis>'"

#, fuzzy
#~ msgid ""
#~ "-- Identify road segments that cross on a line\n"
#~ "SELECT a.id\n"
#~ "FROM roads a, roads b\n"
#~ "WHERE a.id != b.id\n"
#~ "AND a.geom &amp;&amp; b.geom\n"
#~ "AND ST_Relate(a.geom, b.geom, '1*1***1**');"
#~ msgstr ""
#~ "-- Identificar los segmentos de lineas que se cruzan en una linea\n"
#~ "SELECT a.id\n"
#~ "FROM roads a, roads b\n"
#~ "WHERE a.id != b.id \n"
#~ "AND a.geom &amp;&amp; b.geom\n"
#~ "AND ST_Relate(a.geom, b.geom, '1*1***1**');"

#~ msgid ""
#~ "A relate matrix that represents the second example of wharfs partly on "
#~ "the lake's shoreline would be '<emphasis role=\"bold\">102101FF2</"
#~ "emphasis>'"
#~ msgstr ""
#~ "La matriz que representaría el segundo ejemplo de los muelles en los "
#~ "lagos seria: '<emphasis role=\"bold\">102101FF2</emphasis>'"

#~ msgid ""
#~ "-- Identify wharfs partly on a lake's shoreline\n"
#~ "SELECT a.lake_id, b.wharf_id\n"
#~ "FROM lakes a, wharfs b\n"
#~ "WHERE a.geom &amp;&amp; b.geom\n"
#~ "AND ST_Relate(a.geom, b.geom, '102101FF2');"
#~ msgstr ""
#~ "-- Identificar los muelles que están parcialmente en la orilla del lago\n"
#~ "SELECT a.lake_id, b.wharf_id\n"
#~ "FROM lakes a, wharfs b\n"
#~ "WHERE a.geom &amp;&amp; b.geom\n"
#~ "AND ST_Relate(a.geom, b.geom, '102101FF2');"

#~ msgid "For more information or reading, see:"
#~ msgstr "Para mas información o documentación, visita:"

#~ msgid ""
#~ "<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
#~ "Features Implementation Specification for SQL</ulink> (version 1.1, "
#~ "section 2.1.13.2)"
#~ msgstr ""
#~ "<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
#~ "Features Implementation Specification for SQL</ulink> (versión 1.1, "
#~ "sección 2.1.13.2)"

#, fuzzy
#~ msgid "Dimensionally Extended Nine-Intersection Model (DE-9IM)"
#~ msgstr "Modelo de intersección 9 dimensionalmente extendido(DE-9IM)"

#~ msgid "GeoTools: Point Set Theory and the DE-9IM Matrix"
#~ msgstr "GeoTools: Point Set Theory and the DE-9IM Matrix"

#~ msgid "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"
#~ msgstr "<emphasis>Encyclopedia of GIS</emphasis> por Hui Xiong"

#, fuzzy
#~ msgid "Loading Data Using SQL"
#~ msgstr "Cargando Datos SIG"

#~ msgid "Retrieving GIS Data"
#~ msgstr "Recuperando datos SIG"

#, fuzzy
#~ msgid ""
#~ "B-Trees are used for data which can be sorted along one axis; for "
#~ "example, numbers, letters, dates. Spatial data can be sorted along a "
#~ "space-filling curve, Z-order curve or Hilbert curve. This representation "
#~ "however does not allow speeding up common operations."
#~ msgstr ""
#~ "B-Trees se utiliza para datos que pueden ser ordenados a lo largo de un "
#~ "eje, por ejemplo, números, letras, fechas.Los datos SIG no pueden ser "
#~ "racionalmente ordenados a lo largo de un eje (¿cual es mayor? ¿(0,0) o "
#~ "(0,1) o (1,0)?) así que los indices B-Tree no son de ninguna utilidad "
#~ "para nosotros."

#~ msgid "Complex Queries"
#~ msgstr "Consultas Complejas"

#, fuzzy
#~ msgid ""
#~ "The <emphasis>raison d'etre</emphasis> of spatial database functionality "
#~ "is performing queries inside the database which would ordinarily require "
#~ "desktop GIS functionality. Using PostGIS effectively requires knowing "
#~ "what spatial functions are available, and ensuring that appropriate "
#~ "indexes are in place to provide good performance. The SRID of 312 used in "
#~ "these examples is purely for demonstration. You should be using a REAL "
#~ "SRID listed in the the spatial_ref_sys table and one that matches the "
#~ "projection of your data. If your data has no spatial reference system "
#~ "specified, you should be THINKING very thoughtfully why it doesn't and "
#~ "maybe it should."
#~ msgstr ""
#~ "La <emphasis> razón de ser </emphasis > de la funcionalidad de base de "
#~ "datos espaciales es la de realizar consultas dentro de la base de datos "
#~ "que normalmente requieren la funcionalidad GIS de escritorio. Usando "
#~ "PostGIS de forma eficiente requiere saber que funciones espaciales están "
#~ "disponibles, y asegurar que los índices adecuados estén en su lugar para "
#~ "proporcionar un buen rendimiento. El SRID 312 utilizado en estos ejemplos "
#~ "es únicamente para la demostración . Debes estar utilizando un SRID "
#~ "VERDADERO de los enumerados en la tabla spatial_ref_sys y uno que "
#~ "coincida con la proyección de tus datos. Si los datos no tiene ningún "
#~ "sistema de referencia espacial especificado, debes pensar muy "
#~ "cuidadosamente por qué no lo hace y tal vez debería. Si el motivo se debe "
#~ "a que estás modelando algo que no tiene un sistema de referencia espacial "
#~ "geográfico definido,  como la parte interna de una molécula o una buena "
#~ "ubicación en Marte para el transporte de la raza humana en caso de un "
#~ "holocausto nuclear, entonces simplemente deja de lado el SRID o inventa "
#~ "uno e insertarlo en la tabla <varname>spatial_ref_sys</varname >."

#~ msgid "Taking Advantage of Indexes"
#~ msgstr "Aprovechando los Indices"

#~ msgid ""
#~ "When constructing a query it is important to remember that only the "
#~ "bounding-box-based operators such as &amp;&amp; can take advantage of the "
#~ "GiST spatial index. Functions such as <varname>ST_Distance()</varname> "
#~ "cannot use the index to optimize their operation. For example, the "
#~ "following query would be quite slow on a large table:"
#~ msgstr ""
#~ "Conuando construyes una consulta, es importante recordar que solo los "
#~ "operadores basados en cajas (bounding box) como &amp;&amp; pueden "
#~ "aprovechar los indices espaciales GiST. funciones como "
#~ "<varname>ST_Distance()</varname> no pueden utilizar el indice para "
#~ "optimizar las operaciones. Por ejemplo, la consulta siguiente sera algo "
#~ "lenta en una tabla grande:"

#, fuzzy
#~ msgid ""
#~ "SELECT the_geom\n"
#~ "FROM geom_table\n"
#~ "WHERE ST_Distance(the_geom, 'SRID=312;POINT(100000 200000)') &lt; 100"
#~ msgstr ""
#~ "SELECT the_geom\n"
#~ "FROM geom_table\n"
#~ "WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) "
#~ "&lt; 100"

#, fuzzy
#~ msgid ""
#~ "This query is selecting all the geometries in geom_table which are within "
#~ "100 units of the point (100000, 200000). It will be slow because it is "
#~ "calculating the distance between each point in the table and our "
#~ "specified point, ie. one <varname>ST_Distance()</varname> calculation for "
#~ "each row in the table. We can avoid this by using the single step index "
#~ "accelerated function ST_DWithin to reduce the number of distance "
#~ "calculations required:"
#~ msgstr ""
#~ "Esta consulta es la selección de todas las geometrías en geom_table que "
#~ "están a menos de 100 unidades del punto (100000, 200000). La consulta "
#~ "será lenta porque está calculando la distancia entre cada punto en la "
#~ "tabla y nuestro punto especificado, es decir, un cálculo <varname> "
#~ "ST_Distance() </varname> para cada fila de la tabla. Podemos evitar esto "
#~ "mediante el operador &amp;&amp; para reducir el número de cálculos de "
#~ "distancia requeridos:"

#, fuzzy
#~ msgid ""
#~ "SELECT the_geom\n"
#~ "FROM geom_table\n"
#~ "WHERE ST_DWithin(the_geom, 'SRID=312;POINT(100000 200000)', 100)"
#~ msgstr ""
#~ "SELECT the_geom\n"
#~ "FROM geom_table\n"
#~ "WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) "
#~ "&lt; 100"

#, fuzzy
#~ msgid ""
#~ "This query selects the same geometries, but it does it in a more "
#~ "efficient way. Assuming there is a GiST index on the_geom, the query "
#~ "planner will recognize that it can use the index to reduce the number of "
#~ "rows before calculating the result of the <varname>ST_Distance()</"
#~ "varname> function. Notice that the <varname>ST_MakeEnvelope</varname> "
#~ "geometry which is used in the &amp;&amp; operation is a 200 unit square "
#~ "box centered on the original point - this is our \"query box\". The &amp;"
#~ "&amp; operator uses the index to quickly reduce the result set down to "
#~ "only those geometries which have bounding boxes that overlap the \"query "
#~ "box\". Assuming that our query box is much smaller than the extents of "
#~ "the entire geometry table, this will drastically reduce the number of "
#~ "distance calculations that need to be done."
#~ msgstr ""
#~ "Esta consulta selecciona las mismas geometrías, pero lo hace de una "
#~ "manera más eficiente. Suponiendo que hay un índice GiST en the_geom, el "
#~ "planificador de consultas reconocerá que se puede utilizar el índice para "
#~ "reducir el número de filas antes de calcular el resultado de la función "
#~ "<varname>ST_Distance()</varname>. Fijate como la geometría de "
#~ "<varname>ST_MakeEnvelope</varname> que se utiliza en la operación &amp;"
#~ "&amp;, es una caja cuadrada de 200 unidades centrada en el punto de "
#~ "origen - esta es nuestra \"caja de búsqueda\" o \"query box\". El "
#~ "operador &amp;&amp; utiliza el índice para reducir rápidamente el "
#~ "conjunto de resultados a sólo aquellas geometrías que tienen su caja o "
#~ "\"bounding box\" que se superponen a la \"caja de búsqueda\". Suponiendo "
#~ "que nuestra caja de consulta es mucho más pequeña que la extensión de "
#~ "toda la tabla de geometría, esto reducirá drásticamente el número de "
#~ "cálculos de distancia que hay que hacer."

#~ msgid "Examples of Spatial SQL"
#~ msgstr "Ejemplos de consultas espaciales SQL"

#~ msgid ""
#~ "The examples in this section will make use of two tables, a table of "
#~ "linear roads, and a table of polygonal municipality boundaries. The table "
#~ "definitions for the <varname>bc_roads</varname> table is:"
#~ msgstr ""
#~ "Los ejemplos en esta sección utilizan dos tablas, una tabla de vías de "
#~ "comunicación lineales, y una tabla de polígonos con limites municipales. "
#~ "La definición de la tabla <varname>bc_roads</varname> es:"

#~ msgid ""
#~ "Column      | Type              | Description\n"
#~ "------------+-------------------+-------------------\n"
#~ "gid         | integer           | Unique ID\n"
#~ "name        | character varying | Road Name\n"
#~ "the_geom    | geometry          | Location Geometry (Linestring)"
#~ msgstr ""
#~ "Column      | Type              | Description\n"
#~ "------------+-------------------+-------------------\n"
#~ "gid         | integer           | Unique ID\n"
#~ "name        | character varying | Road Name\n"
#~ "the_geom    | geometry          | Location Geometry (Linestring)"

#~ msgid ""
#~ "The table definition for the <varname>bc_municipality</varname> table is:"
#~ msgstr "La definición de la tabla <varname>bc_municipality</varname> es:"

#~ msgid ""
#~ "Column     | Type              | Description\n"
#~ "-----------+-------------------+-------------------\n"
#~ "gid        | integer           | Unique ID\n"
#~ "code       | integer           | Unique ID\n"
#~ "name       | character varying | City / Town Name\n"
#~ "the_geom   | geometry          | Location Geometry (Polygon)"
#~ msgstr ""
#~ "Column     | Type              | Description\n"
#~ "-----------+-------------------+-------------------\n"
#~ "gid        | integer           | Unique ID\n"
#~ "code       | integer           | Unique ID\n"
#~ "name       | character varying | City / Town Name\n"
#~ "the_geom   | geometry          | Location Geometry (Polygon)"

#~ msgid "What is the total length of all roads, expressed in kilometers?"
#~ msgstr ""
#~ "¿Cual es la longitud total de todas las carreteras expresadas en "
#~ "kilómetros?"

#~ msgid "You can answer this question with a very simple piece of SQL:"
#~ msgstr "Puedes contestar a esta pregunta con una consulta SQL muy simple:"

#~ msgid ""
#~ "SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
#~ "\n"
#~ "km_roads\n"
#~ "------------------\n"
#~ "70842.1243039643\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
#~ "\n"
#~ "km_roads\n"
#~ "------------------\n"
#~ "70842.1243039643\n"
#~ "(1 row)"

#~ msgid "How large is the city of Prince George, in hectares?"
#~ msgstr "¿Cual es la superficie de la ciudad Prince George en hectáreas?"

#~ msgid ""
#~ "This query combines an attribute condition (on the municipality name) "
#~ "with a spatial calculation (of the area):"
#~ msgstr ""
#~ "Esta consulta combina una condición de atributo (en el nombre del "
#~ "municipio) con un calculo espacial (del area):"

#~ msgid ""
#~ "SELECT\n"
#~ "  ST_Area(the_geom)/10000 AS hectares\n"
#~ "FROM bc_municipality\n"
#~ "WHERE name = 'PRINCE GEORGE';\n"
#~ "\n"
#~ "hectares\n"
#~ "------------------\n"
#~ "32657.9103824927\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT\n"
#~ "  ST_Area(the_geom)/10000 AS hectares\n"
#~ "FROM bc_municipality\n"
#~ "WHERE name = 'PRINCE GEORGE';\n"
#~ "\n"
#~ "hectares\n"
#~ "------------------\n"
#~ "32657.9103824927\n"
#~ "(1 row)"

#~ msgid "What is the largest municipality in the province, by area?"
#~ msgstr "¿Cual es el municipio con mayor superficie de la provincia?"

#~ msgid ""
#~ "This query brings a spatial measurement into the query condition. There "
#~ "are several ways of approaching this problem, but the most efficient is "
#~ "below:"
#~ msgstr ""
#~ "Esta consulta incluye un calculo espacial en la condición de la consulta. "
#~ "Hay varias formas de plantear el problema, pero la mas eficiente es la "
#~ "siguiente:"

#~ msgid ""
#~ "SELECT\n"
#~ "  name,\n"
#~ "  ST_Area(the_geom)/10000 AS hectares\n"
#~ "FROM\n"
#~ "  bc_municipality\n"
#~ "ORDER BY hectares DESC\n"
#~ "LIMIT 1;\n"
#~ "\n"
#~ "name           | hectares\n"
#~ "---------------+-----------------\n"
#~ "TUMBLER RIDGE  | 155020.02556131\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT\n"
#~ "  name,\n"
#~ "  ST_Area(the_geom)/10000 AS hectares\n"
#~ "FROM\n"
#~ "  bc_municipality\n"
#~ "ORDER BY hectares DESC\n"
#~ "LIMIT 1;\n"
#~ "\n"
#~ "name           | hectares\n"
#~ "---------------+-----------------\n"
#~ "TUMBLER RIDGE  | 155020.02556131\n"
#~ "(1 row)"

#~ msgid ""
#~ "Note that in order to answer this query we have to calculate the area of "
#~ "every polygon. If we were doing this a lot it would make sense to add an "
#~ "area column to the table that we could separately index for performance. "
#~ "By ordering the results in a descending direction, and them using the "
#~ "PostgreSQL \"LIMIT\" command we can easily pick off the largest value "
#~ "without using an aggregate function like max()."
#~ msgstr ""
#~ "Observa que para responder a esta consulta debemos calcular el area de "
#~ "todos los polígonos. Si estuviéramos haciendo esto mucho tendría sentido "
#~ "crear una columna de area en la tabla que podríamos indexar por motivos "
#~ "de rendimiento. Ordenar el resultado de forma descendente, y utilizando "
#~ "el comando \"LIMIT\" de PostgreSQL podemos extraer el valor mas grande de "
#~ "forma sencilla sin utilizar una función agregada como max()."

#~ msgid ""
#~ "What is the length of roads fully contained within each municipality?"
#~ msgstr ""
#~ "¿Cuál es la longitud de las carreteras contenidas por completo dentro de "
#~ "cada municipio?"

#~ msgid ""
#~ "This is an example of a \"spatial join\", because we are bringing "
#~ "together data from two tables (doing a join) but using a spatial "
#~ "interaction condition (\"contained\") as the join condition rather than "
#~ "the usual relational approach of joining on a common key:"
#~ msgstr ""
#~ "Este es un ejemplo de \"unión espacial\", ya que estamos utilizando datos "
#~ "de dos tablas (haciendo una unión) pero utilizando una condición de "
#~ "interacción espacial (\"contained\") como la condición de unión en lugar "
#~ "del enfoque relacional habitual de unión de  la clave primaria:"

#, fuzzy
#~ msgid ""
#~ "SELECT\n"
#~ "  m.name,\n"
#~ "  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
#~ "FROM\n"
#~ "  bc_roads AS r,\n"
#~ "  bc_municipality AS m\n"
#~ "WHERE\n"
#~ "  ST_Contains(m.the_geom, r.the_geom)\n"
#~ "GROUP BY m.name\n"
#~ "ORDER BY roads_km;\n"
#~ "\n"
#~ "name                        | roads_km\n"
#~ "----------------------------+------------------\n"
#~ "SURREY                      | 1539.47553551242\n"
#~ "VANCOUVER                   | 1450.33093486576\n"
#~ "LANGLEY DISTRICT            | 833.793392535662\n"
#~ "BURNABY                     | 773.769091404338\n"
#~ "PRINCE GEORGE               | 694.37554369147\n"
#~ "..."
#~ msgstr ""
#~ "SELECT\n"
#~ "  m.name,\n"
#~ "  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
#~ "FROM\n"
#~ "  bc_roads AS r,\n"
#~ "  bc_municipality AS m\n"
#~ "WHERE\n"
#~ "  ST_Contains(m.the_geom,r.the_geom)\n"
#~ "GROUP BY m.name\n"
#~ "ORDER BY roads_km;\n"
#~ "\n"
#~ "name                        | roads_km\n"
#~ "----------------------------+------------------\n"
#~ "SURREY                      | 1539.47553551242\n"
#~ "VANCOUVER                   | 1450.33093486576\n"
#~ "LANGLEY DISTRICT            | 833.793392535662\n"
#~ "BURNABY                     | 773.769091404338\n"
#~ "PRINCE GEORGE               | 694.37554369147\n"
#~ "..."

#~ msgid ""
#~ "This query takes a while, because every road in the table is summarized "
#~ "into the final result (about 250K roads for our particular example "
#~ "table). For smaller overlays (several thousand records on several "
#~ "hundred) the response can be very fast."
#~ msgstr ""
#~ "Esta consulta toma un tiempo, ya que todas las carreteras de la tabla se "
#~ "resume en el resultado final (unas 250k carreteras para nuestra tabla del "
#~ "ejemplo). Para superposiciones mas pequeñas (de algunos cientos o miles "
#~ "de registros) la respuesta puede ser muy rápida."

#~ msgid ""
#~ "Create a new table with all the roads within the city of Prince George."
#~ msgstr ""
#~ "Crear una tabla con todas las carreteras de la ciudad Prince George."

#~ msgid ""
#~ "This is an example of an \"overlay\", which takes in two tables and "
#~ "outputs a new table that consists of spatially clipped or cut resultants. "
#~ "Unlike the \"spatial join\" demonstrated above, this query actually "
#~ "creates new geometries. An overlay is like a turbo-charged spatial join, "
#~ "and is useful for more exact analysis work:"
#~ msgstr ""
#~ "Este es un ejemplo de \"superposición\", que tomo dos tablas y extrae una "
#~ "tabla nueva que contiene un resultado de un recorte espacial. A "
#~ "diferencia de la \"Unión espacial\" del ejemplo anterior, esta consulta "
#~ "en realidad crea nuevas geometrías. Una superposición es como una unión "
#~ "espacial \"turbo-cargada\", y es útil para un trabajo de análisis mas "
#~ "exacto:"

#, fuzzy
#~ msgid ""
#~ "CREATE TABLE pg_roads as\n"
#~ "SELECT\n"
#~ "  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
#~ "  ST_Length(r.the_geom) AS rd_orig_length,\n"
#~ "  r.*\n"
#~ "FROM\n"
#~ "  bc_roads AS r,\n"
#~ "  bc_municipality AS m\n"
#~ "WHERE\n"
#~ "  m.name = 'PRINCE GEORGE'\n"
#~ "        AND ST_Intersects(r.the_geom, m.the_geom);"
#~ msgstr ""
#~ "CREATE TABLE pg_roads as\n"
#~ "SELECT\n"
#~ "  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
#~ "  ST_Length(r.the_geom) AS rd_orig_length,\n"
#~ "  r.*\n"
#~ "FROM\n"
#~ "  bc_roads AS r,\n"
#~ "  bc_municipality AS m\n"
#~ "WHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);"

#~ msgid "What is the length in kilometers of \"Douglas St\" in Victoria?"
#~ msgstr "¿Cual es la longitud en kilómetros de \"Douglas St\" en Victoria?"

#, fuzzy
#~ msgid ""
#~ "SELECT\n"
#~ "  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
#~ "FROM\n"
#~ "  bc_roads r,\n"
#~ "  bc_municipality m\n"
#~ "WHERE\n"
#~ "        r.name = 'Douglas St'\n"
#~ "        AND m.name = 'VICTORIA'\n"
#~ "        AND ST_Intersects(m.the_geom, r.the_geom);\n"
#~ "\n"
#~ "kilometers\n"
#~ "------------------\n"
#~ "4.89151904172838\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT\n"
#~ "  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
#~ "FROM\n"
#~ "  bc_roads r,\n"
#~ "  bc_municipality m\n"
#~ "WHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA'\n"
#~ "        AND ST_Contains(m.the_geom, r.the_geom) ;\n"
#~ "\n"
#~ "kilometers\n"
#~ "------------------\n"
#~ "4.89151904172838\n"
#~ "(1 row)"

#~ msgid "What is the largest municipality polygon that has a hole?"
#~ msgstr "¿Cual es el polígono de municipios mas grande que tiene un agujero?"

#~ msgid ""
#~ "SELECT gid, name, ST_Area(the_geom) AS area\n"
#~ "FROM bc_municipality\n"
#~ "WHERE ST_NRings(the_geom) &gt; 1\n"
#~ "ORDER BY area DESC LIMIT 1;\n"
#~ "\n"
#~ "gid  | name         | area\n"
#~ "-----+--------------+------------------\n"
#~ "12   | SPALLUMCHEEN | 257374619.430216\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT gid, name, ST_Area(the_geom) AS area\n"
#~ "FROM bc_municipality\n"
#~ "WHERE ST_NRings(the_geom) &gt; 1\n"
#~ "ORDER BY area DESC LIMIT 1;\n"
#~ "\n"
#~ "gid  | name         | area\n"
#~ "-----+--------------+------------------\n"
#~ "12   | SPALLUMCHEEN | 257374619.430216\n"
#~ "(1 row)"

#~ msgid ""
#~ "PostGIS prior to 1.4 does not support compound curves in a curve polygon, "
#~ "but PostGIS 1.4 and above do support the use of Compound Curves in a "
#~ "Curve Polygon."
#~ msgstr ""
#~ "Versiones anteriores a la 1.4 de PostGIS no soportan curvas compuestas en "
#~ "un polígono curvo, pero PortGIS 1.4 y superiores soportan el uso de "
#~ "Curvas Compuestas en Poligonos Curvos."

#~ msgid ""
#~ "The new geography fields don't get registered in the "
#~ "<varname>geometry_columns</varname>. They get registered in a new view "
#~ "called geography_columns which is a view against the system catalogs so "
#~ "is always automatically kept up to date without need for an AddGeom... "
#~ "like function."
#~ msgstr ""
#~ "Los nuevos campos geográficos no estarán registrados en "
#~ "<varname>geometry_columns</varname>. Estarán registrados en una nueva "
#~ "vista llamada geography_columns que es una vista contra los catálogos del "
#~ "sistema, así que siempre actualizara de forma automática sin necesidad de "
#~ "ninguna función de tipo AddGeom..."

#~ msgid ""
#~ "You can create a new table with a GEOGRAPHY column using the CREATE TABLE "
#~ "syntax. Unlike GEOMETRY, there is no need to run a separate "
#~ "AddGeometryColumns() process to register the column in metadata."
#~ msgstr ""
#~ "Puedes crear una nueva tabla con una columna GEOGRAPHY usando la sintaxis "
#~ "de CREATE TABLE. A diferencia de GEOMETRY, no hay necesidad de ejecutar "
#~ "un proceso separado de AddGeometryColumns() para registrar la columna en "
#~ "los metadatos."

#~ msgid ""
#~ "The SRID modifier is currently of limited use: only 4326 (WGS84) is "
#~ "allowed as a value. If you do not specify an SRID, the a value 0 "
#~ "(undefined spheroid) will be used, and all calculations will proceed "
#~ "using WGS84 anyways."
#~ msgstr ""
#~ "El modificador SRID tiene un uso limitado actualmente: solo esta "
#~ "permitido el valor 4326 (WGS84). Si no especificas un SRID, se utilizara "
#~ "el valor 0 (esferoide indefinido), y todos los cálculos se harán "
#~ "utilizando el esferoide WGS84 de todas formas."

#~ msgid ""
#~ "In the future, alternate SRIDs will allow calculations on spheroids other "
#~ "than WGS84."
#~ msgstr ""
#~ "En el futuro, SRID diferentes permitirán cálculos en esferoides "
#~ "diferentes al WGS84."

#~ msgid ""
#~ "In versions of PostGIS prior to 2.0.0, geometry_columns was a table that "
#~ "could be directly edited, and sometimes got out of synch with the actual "
#~ "definition of the geometry columns. In PostGIS 2.0.0, "
#~ "<varname>GEOMETRY_COLUMNS</varname> became a view with the same front-"
#~ "facing structure as prior versions, but reading from database system "
#~ "catalogs Its structure is as follows:"
#~ msgstr ""
#~ "En versiones anteriores a PostGIS 2.0.0, geometry_column era una tabla "
#~ "que podía ser editada directamente, y a veces no estaba sincronizada con "
#~ "la definición actual de las columnas geométricas. En PostGIS 2.0.0,"
#~ "<varname>GEOMETRY_COLUMNS</varname> se transforma en una vista con la "
#~ "misma extructura  que versiones anteriores, pero leyendo desde el "
#~ "catalogo del sistema de la base de datos, su estructura es la siguiente:"

#~ msgid "The column meanings have not changed from prior versions and are:"
#~ msgstr ""
#~ "El significado de las columnas no ha cambiado desde versiones anteriores "
#~ "y es: "

#~ msgid ""
#~ "For backwards compability, you can still create a spatial table in two "
#~ "stages using the management functions."
#~ msgstr ""
#~ "Por compatibilidad con versiones anteriores, puedes crear tablas "
#~ "espaciales  en dos pasos utilizando las funciones de gestión."

#~ msgid "Create a normal non-spatial table."
#~ msgstr "Crear una tabla normal, no espacial."

#~ msgid ""
#~ "For example: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME "
#~ "varchar(25) )</command>"
#~ msgstr ""
#~ "Por ejemplo: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME "
#~ "varchar(25) )</command>"

#~ msgid ""
#~ "Add a spatial column to the table using the OpenGIS \"AddGeometryColumn\" "
#~ "function. Refer to <xref linkend=\"AddGeometryColumn\"/> for more details."
#~ msgstr ""
#~ "Añadir una columna espacial a la tabla utilizando la función "
#~ "\"AddGeometryColumn\". Para mas detallis ve a <xref linkend="
#~ "\"AddGeometryColumn\"/>"

#~ msgid ""
#~ "The syntax is: <programlisting>AddGeometryColumn(\n"
#~ "  &lt;schema_name&gt;,\n"
#~ "  &lt;table_name&gt;,\n"
#~ "  &lt;column_name&gt;,\n"
#~ "  &lt;srid&gt;,\n"
#~ "  &lt;type&gt;,\n"
#~ "  &lt;dimension&gt;\n"
#~ ")</programlisting> Or, using current schema:"
#~ msgstr ""
#~ "La sintaxis es: <programlisting>AddGeometryColumn(\n"
#~ "  &lt;schema_name&gt;,\n"
#~ "  &lt;table_name&gt;,\n"
#~ "  &lt;column_name&gt;,\n"
#~ "  &lt;srid&gt;,\n"
#~ "  &lt;type&gt;,\n"
#~ "  &lt;dimension&gt;\n"
#~ ")</programlisting> O, utilizando el esquema actual:"

#~ msgid ""
#~ "AddGeometryColumn(\n"
#~ "  &lt;table_name&gt;,\n"
#~ "  &lt;column_name&gt;,\n"
#~ "  &lt;srid&gt;,\n"
#~ "  &lt;type&gt;,\n"
#~ "  &lt;dimension&gt;\n"
#~ ")"
#~ msgstr ""
#~ "AddGeometryColumn(\n"
#~ "  &lt;table_name&gt;,\n"
#~ "  &lt;column_name&gt;,\n"
#~ "  &lt;srid&gt;,\n"
#~ "  &lt;type&gt;,\n"
#~ "  &lt;dimension&gt;\n"
#~ ")"

#~ msgid ""
#~ "Example1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', "
#~ "423, 'LINESTRING', 2)</command>"
#~ msgstr ""
#~ "Ejemplo 1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', "
#~ "423, 'LINESTRING', 2)</command>"

#~ msgid ""
#~ "Example2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, "
#~ "'LINESTRING', 2)</command>"
#~ msgstr ""
#~ "Ejemplo 2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, "
#~ "'LINESTRING', 2)</command>"

#~ msgid ""
#~ "Here is an example of SQL used to create a table and add a spatial column "
#~ "(assuming that an SRID of 128 exists already):"
#~ msgstr ""
#~ "Aqui tienes un ejemplo del comando SQL utilizado para crear una tabla y "
#~ "añadirle una columna espacial (asumiendo que un SRID de 128 existe ya):"

#~ msgid ""
#~ "CREATE TABLE parks (\n"
#~ "  park_id    INTEGER,\n"
#~ "  park_name  VARCHAR,\n"
#~ "  park_date  DATE,\n"
#~ "  park_type  VARCHAR\n"
#~ ");\n"
#~ "SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"
#~ msgstr ""
#~ "CREATE TABLE parks (\n"
#~ "  park_id    INTEGER,\n"
#~ "  park_name  VARCHAR,\n"
#~ "  park_date  DATE,\n"
#~ "  park_type  VARCHAR\n"
#~ ");\n"
#~ "SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"

#~ msgid ""
#~ "Here is another example, using the generic \"geometry\" type and the "
#~ "undefined SRID value of 0:"
#~ msgstr ""
#~ "Aqui tienes otro ejemplo, utilizando el tipo genérico \"geometry\" y el "
#~ "valor indefinido de SRID 0:"

#~ msgid ""
#~ "CREATE TABLE roads (\n"
#~ "  road_id INTEGER,\n"
#~ "  road_name VARCHAR\n"
#~ ");\n"
#~ "SELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"
#~ msgstr ""
#~ "CREATE TABLE roads (\n"
#~ "  road_id INTEGER,\n"
#~ "  road_name VARCHAR\n"
#~ ");\n"
#~ "SELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"

#, fuzzy
#~ msgid ""
#~ "The AddGeometryColumn() approach creates a geometry column of specified "
#~ "type. This type and dimension are queryable from the "
#~ "<varname>geometry_columns</varname> view. Starting with PostGIS 2.0, "
#~ "geometry_columns is no longer editable and all geometry columns are "
#~ "autoregistered."
#~ msgstr ""
#~ "El enfoque de AddGeometryColumn() crea una columna de geometria y además "
#~ "registra la nueva columna en la tabla geometry_columns. Si tu software "
#~ "utiliza geometry_columns, entonces cualquier columna de geometrías que "
#~ "necesites interrogar, debe estar registrada en esta vista. Desde la "
#~ "version PostGIS 2.0, geometry_columns no se puede editar y todas las "
#~ "columnas geométricas se registran de forma automática."

#~ msgid "&amp;&amp;"
#~ msgstr "&amp;&amp;"

#~ msgid ""
#~ "This operator tells whether the bounding box of one geometry intersects "
#~ "the bounding box of another."
#~ msgstr ""
#~ "Este operador indica si el límite de una geometría forma intersección con "
#~ "el límite de otra."

#~ msgid "ST_OrderingEquals"
#~ msgstr "ST_OrderingEquals"

#~ msgid ""
#~ "This operator is a little more naive, it only tests whether the bounding "
#~ "boxes of two geometries are the same."
#~ msgstr ""
#~ "Este operador es un poco mas \"inocente\", solo comprueba si los límites "
#~ "(bounding boxes) de dos geometrías son los mismos."

#~ msgid ""
#~ "The above query will use the bounding box of the polygon for comparison "
#~ "purposes."
#~ msgstr ""
#~ "La consulta anterior utiliza los limites (bounding box) del polígono para "
#~ "la comparación."

#~ msgid ""
#~ "For backward compatibility: write a 3-dimensional shape file when dumping "
#~ "from old (pre-1.0.0) postgis databases (the default is to write a 2-"
#~ "dimensional shape file in that case). Starting from postgis-1.0.0+, "
#~ "dimensions are fully encoded."
#~ msgstr ""
#~ "Por compatibilidad con versiones anteriores: escribir un archivo shape de "
#~ "3 dimensiones cuando consultamos desde bases de datos PostGIS antiguas "
#~ "(pre-1.0.0) (el valor por defecto es el de escribir un archivo de formas "
#~ "de 2 dimensiones en ese caso). A partir de postgis-1.0.0 +, dimensiones "
#~ "están completamente codificados."

#~ msgid ""
#~ "R-Trees break up data into rectangles, and sub-rectangles, and sub-sub "
#~ "rectangles, etc. R-Trees are used by some spatial databases to index GIS "
#~ "data, but the PostgreSQL R-Tree implementation is not as robust as the "
#~ "GiST implementation."
#~ msgstr ""
#~ "R-Trees divide los datos en rectángulos y sub-rectángulos, y sub-sub "
#~ "rectángulos, etc R-Tree se utiliza en algunas bases de datos espaciales "
#~ "para indexar datos GIS, pero la implementación PostgreSQL R-Tree no es "
#~ "tan robusta como la de GiST."

#~ msgid ""
#~ "Building a spatial index is a computationally intensive exercise: on "
#~ "tables of around 1 million rows, on a 300MHz Solaris machine, we have "
#~ "found building a GiST index takes about 1 hour. After building an index, "
#~ "it is important to force PostgreSQL to collect table statistics, which "
#~ "are used to optimize query plans:"
#~ msgstr ""
#~ "La construcción de un índice espacial es un ejercicio de cálculo "
#~ "intensivo: en tablas de alrededor de 1 millón de filas, en una máquina de "
#~ "300 MHz Solaris, hemos encontrado que la construcción de un índice de "
#~ "GiST dura aproximadamente 1 hora. Después de la construcción de un "
#~ "índice, es importante obligar a PostgreSQL recopilar las estadísticas de "
#~ "tabla que se utilizan para optimizar los planes de consulta:"

#~ msgid ""
#~ "VACUUM ANALYZE [table_name] [(column_name)];\n"
#~ "-- This is only needed for PostgreSQL 7.4 installations and below\n"
#~ "SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);"
#~ msgstr ""
#~ "VACUUM ANALYZE [table_name] [(column_name)];\n"
#~ "-- This is only needed for PostgreSQL 7.4 installations and below\n"
#~ "SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);"

#~ msgid ""
#~ "GiST indexes have two advantages over R-Tree indexes in PostgreSQL. "
#~ "Firstly, GiST indexes are \"null safe\", meaning they can index columns "
#~ "which include null values. Secondly, GiST indexes support the concept of "
#~ "\"lossiness\" which is important when dealing with GIS objects larger "
#~ "than the PostgreSQL 8K page size. Lossiness allows PostgreSQL to store "
#~ "only the \"important\" part of an object in an index -- in the case of "
#~ "GIS objects, just the bounding box. GIS objects larger than 8K will cause "
#~ "R-Tree indexes to fail in the process of being built."
#~ msgstr ""
#~ "Los índices GiST tienen dos ventajas respecto a los índices R-Tree en "
#~ "PostgreSQL. En primer lugar, los índices GiST son \"null safe\", lo que "
#~ "significa que puede indexar columnas que incluyen valores nulos. En "
#~ "segundo lugar, los índices GiST apoyan el concepto de \"capacidad de "
#~ "disipación\", que es importante cuando se trata de objetos GIS más "
#~ "grandes que el tamaño de página de 8K PostgreSQL. La capacidad de "
#~ "disipación permite a PostgreSQL almacenar sólo la parte \"importante\" de "
#~ "un objeto en un índice - en el caso de objetos SIG, sólo el cuadro "
#~ "delimitador (bounding box). Los objetos GIS mayores de 8 KB provocaran "
#~ "fallos en los índices R-Tree en el proceso de construcción."

#~ msgid ""
#~ "Firstly, make sure statistics are gathered about the number and "
#~ "distributions of values in a table, to provide the query planner with "
#~ "better information to make decisions around index usage. For PostgreSQL "
#~ "7.4 installations and below this is done by running "
#~ "<command>update_geometry_stats([table_name, column_name])</command> "
#~ "(compute distribution) and <command>VACUUM ANALYZE [table_name] "
#~ "[column_name]</command> (compute number of values). Starting with "
#~ "PostgreSQL 8.0 running <command>VACUUM ANALYZE</command> will do both "
#~ "operations. You should regularly vacuum your databases anyways -- many "
#~ "PostgreSQL DBAs have <command>VACUUM</command> run as an off-peak cron "
#~ "job on a regular basis."
#~ msgstr ""
#~ "En primer lugar, asegurate de que se recopilan estadísticas sobre el "
#~ "número y distribución de los valores de una tabla, para proporcionar al "
#~ "planeador de consultas una mejor información para tomar decisiones en "
#~ "torno a la utilización de índices. Para instalaciones de PostgreSQL 7.4 y "
#~ "menores, esto se hace ejecutando <command> update_geometry_stats \n"
#~ " ([table_name, column_name]) </command> (distribución de cálculo) y "
#~ "<command>VACUUM ANALYZE [table_name] [column_name]</command> (número de "
#~ "cómputo de valores). A partir de PostgreSQL 8.0, ejecutando el combado  "
#~ "<command> VACUUM ANALYZE </command> se ejecutaran ambas operaciones. "
#~ "Debes ejecutar el comando vacuum regularmente  en tus bases de datos de "
#~ "todos modos - muchos PostgreSQL DBAs  tienen  la opción de ejecutar "
#~ "<command>VACUUM </command> como una tarea de cron de menor actividad "
#~ "sobre una base regular."

#~ msgid ""
#~ "As of version 0.6, it should not be necessary to force the planner to use "
#~ "the index with <varname>ENABLE_SEQSCAN</varname>."
#~ msgstr ""
#~ "Desde la versión 0.6, no debería ser necesario forzar el planificador a "
#~ "utilizar el índice con <varname>ENABLE_SEQSCAN</varname>."

#~ msgid ""
#~ "SELECT the_geom\n"
#~ "FROM geom_table\n"
#~ "WHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, "
#~ "200100,312), 100)"
#~ msgstr ""
#~ "SELECT the_geom\n"
#~ "FROM geom_table\n"
#~ "WHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, "
#~ "200100,312), 100)"

#~ msgid "Change in Behavior"
#~ msgstr "Cambio en el Comportamiento"

#~ msgid ""
#~ "As of PostGIS 1.3.0, most of the Geometry Relationship Functions, with "
#~ "the notable exceptions of ST_Disjoint and ST_Relate, include implicit "
#~ "bounding box overlap operators."
#~ msgstr ""
#~ "A partir de PostGIS 1.3.0, la mayoría de las funciones de relaciones "
#~ "entre Geometría, con las notables excepciones de ST_Disjoint y ST_Relate, "
#~ "incluyen operadores de superposición de cajas delimitadoras o \"bounding "
#~ "boxes\" implícitas."

#~ msgid ""
#~ "Examples of the text representations (EWKT) of the extended spatial "
#~ "objects of the features are as follows. The * ones are new in this "
#~ "version of PostGIS:"
#~ msgstr ""
#~ "Aquí tienes algunos ejemplos de representaciones de texto (EWKT) de "
#~ "objetos espaciales extendidos. Los que llevan * son nuevos en esta "
#~ "version de PostGIS."

#~ msgid ""
#~ "However they may be registered as a generic geometry column if the column "
#~ "was not defined as a specific type during creation."
#~ msgstr ""
#~ "Sin embargo, pueden ser registradas como una columna de geometría "
#~ "genérica si la columna no se define como un tipo específico durante la "
#~ "creación."

#~ msgid ""
#~ "Dimensionally Extended Nine-Intersection Model (DE-9IM) by Christian "
#~ "Strobl"
#~ msgstr ""
#~ "Dimensionally Extended Nine-Intersection Model (DE-9IM) por Christian "
#~ "Strobl"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"

#~ msgid "Using SQL"
#~ msgstr "Utilizando SQL"
