# SOME DESCRIPTIVE TITLE.
#
# Translators:
# David Martinez Morata, 2013-2014
# David Mateos <territorio@terrativa.net>, 2014
# David Mateos <territorio@terrativa.net>, 2014
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2017-09-19 15:47+0000\n"
"PO-Revision-Date: 2014-10-15 16:44+0000\n"
"Last-Translator: Sandro Santilli <strk@kbt.io>\n"
"Language-Team: Spanish (http://www.transifex.com/projects/p/postgis-1/"
"language/es/)\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. Tag: title
#: using_postgis_dataman.xml:3
#, no-c-format
msgid "Using PostGIS: Data Management and Queries"
msgstr "Utilizando PostGIS: Gestión de Datos y Consultas"

#. Tag: title
#: using_postgis_dataman.xml:6
#, no-c-format
msgid "GIS Objects"
msgstr "Objetos SIG"

#. Tag: para
#: using_postgis_dataman.xml:8
#, no-c-format
msgid ""
"The GIS objects supported by PostGIS are a superset of the \"Simple Features"
"\" defined by the OpenGIS Consortium (OGC). As of version 0.9, PostGIS "
"supports all the objects and functions specified in the OGC \"Simple "
"Features for SQL\" specification."
msgstr ""
"Los objetos SIG soportados por PostGIS son una colección de \"Simple Features"
"\" definidas por el OpenGIS Consortium (OGC). A partir de la versión 0.9, "
"PostGIS soporta todos los objetos y funciones de la especificación \"Simple "
"Features for SQL\" del OGC."

#. Tag: para
#: using_postgis_dataman.xml:13
#, no-c-format
msgid ""
"PostGIS extends the standard with support for 3DZ,3DM and 4D coordinates."
msgstr ""
"PostGIS extiende el estándar con soporte para coordenadas  3DZ,3DM y 4D."

#. Tag: title
#: using_postgis_dataman.xml:17
#, no-c-format
msgid "OpenGIS WKB and WKT"
msgstr "OpenGIS WKB y WKT"

#. Tag: para
#: using_postgis_dataman.xml:19
#, no-c-format
msgid ""
"The OpenGIS specification defines two standard ways of expressing spatial "
"objects: the Well-Known Text (WKT) form and the Well-Known Binary (WKB) "
"form. Both WKT and WKB include information about the type of the object and "
"the coordinates which form the object."
msgstr ""
"La especificación OpenGIS define dos formas estándar de expresar objetos "
"espaciales: la forma Well-Known Text (WKT) y la forma Well-Known Binary "
"(WKB). Ambas WKT y WKB, incluyen información sobre el tipo de objeto y el "
"sistema de coordenadas del objeto."

#. Tag: para
#: using_postgis_dataman.xml:24
#, no-c-format
msgid ""
"Examples of the text representations (WKT) of the spatial objects of the "
"features are as follows:"
msgstr ""
"Algunos ejemplos de representaciones (WKT) de objetos espaciales de objetos "
"geográficos son de la siguiente manera:"

#. Tag: para
#: using_postgis_dataman.xml:29
#, no-c-format
msgid "POINT(0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:33
#, no-c-format
msgid "LINESTRING(0 0,1 1,1 2)"
msgstr "LINESTRING(0 0,1 1,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:37
#, no-c-format
msgid "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"
msgstr "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"

#. Tag: para
#: using_postgis_dataman.xml:41
#, fuzzy, no-c-format
msgid "MULTIPOINT((0 0),(1 2))"
msgstr "MULTIPOINT(0 0,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:45
#, no-c-format
msgid "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"
msgstr "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"

#. Tag: para
#: using_postgis_dataman.xml:49
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"
msgstr ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"

#. Tag: para
#: using_postgis_dataman.xml:54
#, no-c-format
msgid "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"
msgstr "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"

#. Tag: para
#: using_postgis_dataman.xml:58
#, no-c-format
msgid ""
"The OpenGIS specification also requires that the internal storage format of "
"spatial objects include a spatial referencing system identifier (SRID). The "
"SRID is required when creating spatial objects for insertion into the "
"database."
msgstr ""
"La especificación OpenGIS también requiere que el almacenamiento interno de "
"objetos espaciales incluya el sistema de referencia espacial (SRID). El SRID "
"es necesario al crear objetos espaciales para añadirlos a la base de datos."

#. Tag: para
#: using_postgis_dataman.xml:63 using_postgis_dataman.xml:151
#, no-c-format
msgid ""
"Input/Output of these formats are available using the following interfaces:"
msgstr ""
"La Entrada/Salida de estos formatos están disponibles utilizando las "
"interfaces siguientes:"

#. Tag: programlisting
#: using_postgis_dataman.xml:66
#, no-c-format
msgid ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"
msgstr ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"

#. Tag: para
#: using_postgis_dataman.xml:68
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert an OGC spatial "
"object would be:"
msgstr ""
"Por ejemplo un comando valido de inserción para crear e insertar un objeto "
"espacial OGC podría ser:"

#. Tag: programlisting
#: using_postgis_dataman.xml:71
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"

#. Tag: title
#: using_postgis_dataman.xml:75
#, no-c-format
msgid "PostGIS EWKB, EWKT and Canonical Forms"
msgstr "En PostGIS EWKB, EWKT y foma Canonica"

#. Tag: para
#: using_postgis_dataman.xml:77
#, no-c-format
msgid ""
"OGC formats only support 2d geometries, and the associated SRID is *never* "
"embedded in the input/output representations."
msgstr ""
"Los formatos OGC solo soportan geometrías 2D, y los SRID asociados nunca son "
"embebidos en las representaciones de entrada/salida."

#. Tag: para
#: using_postgis_dataman.xml:80
#, no-c-format
msgid ""
"PostGIS extended formats are currently superset of OGC one (every valid WKB/"
"WKT is a valid EWKB/EWKT) but this might vary in the future, specifically if "
"OGC comes out with a new format conflicting with our extensions. Thus you "
"SHOULD NOT rely on this feature!"
msgstr ""
"Los formatos extendidos de PostGIS son un superconjunto de los OGC "
"actualmente (todo WKB/WKT valido es un EWKB/EWKT valido) pero esto puede "
"variar en el futuro, especialmente si el OGC saca un nuevo formato que crea "
"conflictos con nuestras extensiones. ¡Por lo tanto NO DEBERIAS confiar en "
"esta característica!"

#. Tag: para
#: using_postgis_dataman.xml:85
#, no-c-format
msgid ""
"PostGIS EWKB/EWKT add 3dm,3dz,4d coordinates support and embedded SRID "
"information."
msgstr ""
"PostGIS EWKB/EWKT añade soporte a coordenadas 3dm, 3dz y 4d y a información "
"embebida del SRID."

#. Tag: para
#: using_postgis_dataman.xml:88
#, fuzzy, no-c-format
msgid ""
"Examples of the text representations (EWKT) of the extended spatial objects "
"of the features are as follows."
msgstr ""
"Algunos ejemplos de representaciones (WKT) de objetos espaciales de objetos "
"geográficos son de la siguiente manera:"

#. Tag: para
#: using_postgis_dataman.xml:93
#, no-c-format
msgid "POINT(0 0 0) -- XYZ"
msgstr "POINT(0 0 0) -- XYZ"

#. Tag: para
#: using_postgis_dataman.xml:97
#, no-c-format
msgid "SRID=32632;POINT(0 0) -- XY with SRID"
msgstr "SRID=32632;POINT(0 0) -- XY with SRID"

#. Tag: para
#: using_postgis_dataman.xml:101
#, no-c-format
msgid "POINTM(0 0 0) -- XYM"
msgstr "POINTM(0 0 0) -- XYM"

#. Tag: para
#: using_postgis_dataman.xml:105
#, no-c-format
msgid "POINT(0 0 0 0) -- XYZM"
msgstr "POINT(0 0 0 0) -- XYZM"

#. Tag: para
#: using_postgis_dataman.xml:109
#, no-c-format
msgid "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"
msgstr "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"

#. Tag: para
#: using_postgis_dataman.xml:113
#, no-c-format
msgid "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"
msgstr "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"

#. Tag: para
#: using_postgis_dataman.xml:118
#, no-c-format
msgid ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"
msgstr ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"

#. Tag: para
#: using_postgis_dataman.xml:123
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"
msgstr ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"

#. Tag: para
#: using_postgis_dataman.xml:128
#, no-c-format
msgid "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"
msgstr "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"

#. Tag: para
#: using_postgis_dataman.xml:132
#, no-c-format
msgid "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"
msgstr "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"

#. Tag: para
#: using_postgis_dataman.xml:136
#, no-c-format
msgid ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"
msgstr ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"

#. Tag: para
#: using_postgis_dataman.xml:142
#, no-c-format
msgid "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"
msgstr "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"

#. Tag: para
#: using_postgis_dataman.xml:146
#, no-c-format
msgid "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"
msgstr "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"

#. Tag: programlisting
#: using_postgis_dataman.xml:154
#, no-c-format
msgid ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"
msgstr ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"

#. Tag: para
#: using_postgis_dataman.xml:156
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert a PostGIS spatial "
"object would be:"
msgstr ""
"Por ejemplo, una consulta \"insert\" valida para crear e insertas un objeto "
"espacial PostGIS debería ser: "

#. Tag: programlisting
#: using_postgis_dataman.xml:159
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"

#. Tag: para
#: using_postgis_dataman.xml:161
#, no-c-format
msgid ""
"The \"canonical forms\" of a PostgreSQL type are the representations you get "
"with a simple query (without any function call) and the one which is "
"guaranteed to be accepted with a simple insert, update or copy. For the "
"postgis 'geometry' type these are:"
msgstr ""
"Las formas \"canónicas\" de un tipo PostgreSQL son las representaciones que "
"obtienes con una consulta simple (sin ninguna llamada a funciones) y la "
"única que esta garantizada en ser aceptada con un simple \"insert\", \"update"
"\" o \"copy\". para los tipos 'geómetra' de PostGIS son:"

#. Tag: programlisting
#: using_postgis_dataman.xml:164
#, no-c-format
msgid ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"
msgstr ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"

#. Tag: para
#: using_postgis_dataman.xml:166
#, no-c-format
msgid ""
"For example this statement reads EWKT and returns HEXEWKB in the process of "
"canonical ascii input/output:"
msgstr ""
"Por ejemplo, esta consulta lee EWKT y devuelve HEXEWKB en el proceso de "
"entrada/salida ascii canónico."

#. Tag: programlisting
#: using_postgis_dataman.xml:169
#, no-c-format
msgid ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"
msgstr ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"

#. Tag: title
#: using_postgis_dataman.xml:172
#, no-c-format
msgid "SQL-MM Part 3"
msgstr "SQL-MM Parte 3"

#. Tag: para
#: using_postgis_dataman.xml:174
#, no-c-format
msgid ""
"The SQL Multimedia Applications Spatial specification extends the simple "
"features for SQL spec by defining a number of circularly interpolated curves."
msgstr ""
"La especificación SQL Multimedia Applications Spatial extiende los objetos "
"simples para la especificación SQL definiendo un numero de curvas "
"interpoladas. "

#. Tag: para
#: using_postgis_dataman.xml:178
#, no-c-format
msgid ""
"The SQL-MM definitions include 3dm, 3dz and 4d coordinates, but do not allow "
"the embedding of SRID information."
msgstr ""
"Las definiciones SQL-MM incluyen coordenadas 3dm, 3dz y 4d, pero no permiten "
"integrar la información SRID."

#. Tag: para
#: using_postgis_dataman.xml:181
#, no-c-format
msgid ""
"The well-known text extensions are not yet fully supported. Examples of some "
"simple curved geometries are shown below:"
msgstr ""
"Las extensiones de well-know text no están aún completamente soportadas. A "
"continuación se muestran ejemplos de algunas geometrías simples curvadas:"

#. Tag: para
#: using_postgis_dataman.xml:186
#, no-c-format
msgid "CIRCULARSTRING(0 0, 1 1, 1 0)"
msgstr "CIRCULARSTRING(0 0, 1 1, 1 0)"

#. Tag: para
#: using_postgis_dataman.xml:187
#, no-c-format
msgid "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"
msgstr "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"

#. Tag: para
#: using_postgis_dataman.xml:188
#, fuzzy, no-c-format
msgid ""
"The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the "
"linear world. A single segment required three points, the start and end "
"points (first and third) and any other point on the arc. The exception to "
"this is for a closed circle, where the start and end points are the same. In "
"this case the second point MUST be the center of the arc, ie the opposite "
"side of the circle. To chain arcs together, the last point of the previous "
"arc becomes the first point of the next arc, just like in LINESTRING. This "
"means that a valid circular string must have an odd number of points greater "
"than 1."
msgstr ""
"CIRCULARSTRING es el tipo básico de curva, similar a LINESTRING en el mundo "
"lineal. Un segmento simple necesita tres puntos, los puntos de inicio y fin "
"(primero y tercero) y cualquier otro punto del arco. La excepción a esto es "
"para un círculo cerrado, donde el punto de inicio y fin son el mismo. En "
"este caso, el segundo punto DEBE ser el centro del arco, esto es el lado "
"opuesto del círculo. Para encadenar arcos juntos, el último punto del arco "
"previo, se convierte en el primero del siguiente, como ocurre con "
"LINESTRING. Esto quiere decir que una cadena circular válida debe tener un "
"número impar de puntos mayor que 1."

#. Tag: para
#: using_postgis_dataman.xml:201
#, no-c-format
msgid "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"
msgstr "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"

#. Tag: para
#: using_postgis_dataman.xml:202
#, no-c-format
msgid ""
"A compound curve is a single, continuous curve that has both curved "
"(circular) segments and linear segments. That means that in addition to "
"having well-formed components, the end point of every component (except the "
"last) must be coincident with the start point of the following component."
msgstr ""
"Una curva compuesta es una curva simple y continua, que tiene segmentos "
"curvos (circular) y segmentos lineales. Esto significa que ademas de tener "
"componentes bien formados, el punto final de cada componente (excepto el "
"ultimo) debe coincidir con el punto inicial del componente siguiente."

#. Tag: para
#: using_postgis_dataman.xml:210
#, no-c-format
msgid ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"
msgstr ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"

#. Tag: para
#: using_postgis_dataman.xml:212
#, no-c-format
msgid ""
"Example compound curve in a curve polygon: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"
msgstr ""
"Ejemplo de curva compuesta en un polígono curvo: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"

#. Tag: para
#: using_postgis_dataman.xml:216
#, no-c-format
msgid ""
"A CURVEPOLYGON is just like a polygon, with an outer ring and zero or more "
"inner rings. The difference is that a ring can take the form of a circular "
"string, linear string or compound string."
msgstr ""
"Un CURVEPOLYGON es como un poligono, con un anillo externo y cero o mas "
"anillos internos. La diferencia es que que este anillo puede tomar la forma "
"de una cadena circular, cadena lineal o una cadena de curva compuesta."

#. Tag: para
#: using_postgis_dataman.xml:220
#, no-c-format
msgid "As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon."
msgstr ""
"A partir de PostGIS 1.4, PostGIS soporta curvas compuestas en un polígono "
"curvo."

#. Tag: para
#: using_postgis_dataman.xml:224
#, no-c-format
msgid "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"
msgstr "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"

#. Tag: para
#: using_postgis_dataman.xml:225
#, no-c-format
msgid ""
"The MULTICURVE is a collection of curves, which can include linear strings, "
"circular strings or compound strings."
msgstr ""
"Una MULTICURVE es una colección de curvas, que puede incluir cadenas "
"lineales, cadenas curvas o curvas compuestas."

#. Tag: para
#: using_postgis_dataman.xml:230
#, no-c-format
msgid ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"
msgstr ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"

#. Tag: para
#: using_postgis_dataman.xml:233
#, no-c-format
msgid ""
"This is a collection of surfaces, which can be (linear) polygons or curve "
"polygons."
msgstr ""
"Esto es una colección de superficies, que pueden ser polígonos (lineales) o "
"polígonos curvos."

#. Tag: para
#: using_postgis_dataman.xml:239
#, no-c-format
msgid ""
"PostGIS prior to 1.4 does not support compound curves in a curve polygon, "
"but PostGIS 1.4 and above do support the use of Compound Curves in a Curve "
"Polygon."
msgstr ""
"Versiones anteriores a la 1.4 de PostGIS no soportan curvas compuestas en un "
"polígono curvo, pero PortGIS 1.4 y superiores soportan el uso de Curvas "
"Compuestas en Poligonos Curvos."

#. Tag: para
#: using_postgis_dataman.xml:245
#, no-c-format
msgid ""
"All floating point comparisons within the SQL-MM implementation are "
"performed to a specified tolerance, currently 1E-8."
msgstr ""
"Todas las comparaciones de coma flotante en la implementación SQL-MM se "
"desarrollan para una tolerancia específica, normalmente 1E-8."

#. Tag: title
#: using_postgis_dataman.xml:251
#, no-c-format
msgid "PostGIS Geography Type"
msgstr "Tipo Geography en PostGIS"

#. Tag: para
#: using_postgis_dataman.xml:253
#, no-c-format
msgid ""
"The geography type provides native support for spatial features represented "
"on \"geographic\" coordinates (sometimes called \"geodetic\" coordinates, or "
"\"lat/lon\", or \"lon/lat\"). Geographic coordinates are spherical "
"coordinates expressed in angular units (degrees)."
msgstr ""
"El tipo \"geography\" proporciona soporte nativo para objetos espaciales "
"representados por coordenadas geográficas ( a veces llamadas coordenadas "
"geodésicas, o \"lat/lon\", o \"lob/lat\"). Las coordenadas geográficas son "
"coordenadas esféricas expresadas en unidades angulares (grados)."

#. Tag: para
#: using_postgis_dataman.xml:255
#, no-c-format
msgid ""
"The basis for the PostGIS geometry type is a plane. The shortest path "
"between two points on the plane is a straight line. That means calculations "
"on geometries (areas, distances, lengths, intersections, etc) can be "
"calculated using cartesian mathematics and straight line vectors."
msgstr ""
"La base del tipo \"geometry\" de PostGIS es un plano. El camino mas corto "
"entre dos puntos en un plano es una linea recta. Esto significa que los "
"cálculos en geometrías (áreas, distancias, longitudes, intersecciones, etc) "
"pueden calcularse utilizando matemáticas cartesiana y vectores lineales."

#. Tag: para
#: using_postgis_dataman.xml:257
#, no-c-format
msgid ""
"The basis for the PostGIS geographic type is a sphere. The shortest path "
"between two points on the sphere is a great circle arc. That means that "
"calculations on geographies (areas, distances, lengths, intersections, etc) "
"must be calculated on the sphere, using more complicated mathematics. For "
"more accurate measurements, the calculations must take the actual spheroidal "
"shape of the world into account, and the mathematics becomes very "
"complicated indeed."
msgstr ""
"La base del tipo geografico de PostGIS es una esfera. El camino mas corto "
"entre dos puntos en la esfera es el arco de circunferencia mas corto que une "
"los dos puntos. esto significa que los cálculos geográficos (áreas, "
"distancias, longitudes, intersecciones, etc) deben calcularse en la esfera, "
"utilizando matemáticas mas complejas. Para medidas mas precisas, los "
"cálculos deben tomar la forma esferoidal actual del mundo en cuenta, y las "
"matemáticas se vuelven aun mas complejas."

#. Tag: para
#: using_postgis_dataman.xml:259
#, no-c-format
msgid ""
"Because the underlying mathematics is much more complicated, there are fewer "
"functions defined for the geography type than for the geometry type. Over "
"time, as new algorithms are added, the capabilities of the geography type "
"will expand."
msgstr ""
"Debido a que las matemáticas subyacentes son mas complejas, hay varias "
"funciones definidas para el tipo geográfico y no para el tipo geométrico. "
"Con el tiempo, conforme se añadan nuevos algoritmos, las capacidades del "
"tipo geográfico se irán expandiendo."

#. Tag: para
#: using_postgis_dataman.xml:262
#, no-c-format
msgid ""
"One restriction is that it only supports WGS 84 long lat (SRID:4326). It "
"uses a new data type called geography. None of the GEOS functions support "
"this new type. As a workaround one can convert back and forth between "
"geometry and geography types."
msgstr ""
"Una restricción es que sólo soporta longitud y latitud en WGS84 (SRID:4326). "
"Utiliza un nuevo tipo llamado \"geography\". Ninguna de las funciones de "
"GEOS soporta este nuevo tipo. Para solucionar este problema se puede "
"convertir entre los tipos de \"geometry\" y \"geography\"."

#. Tag: para
#: using_postgis_dataman.xml:266
#, no-c-format
msgid ""
"The new geography type uses the PostgreSQL 8.3+ typmod definition format so "
"that a table with a geography field can be added in a single step. All the "
"standard OGC formats except for curves are supported."
msgstr ""
"El nuevo tipo \"geography\" utiliza el formato de definición typmod de "
"PostgreSQL 8.3+ así se puede añadir una tabla con un campo geográfico de "
"forma sencilla. Todos los formatos OGC excepto la curva están soportados."

#. Tag: title
#: using_postgis_dataman.xml:270
#, no-c-format
msgid "Geography Basics"
msgstr "Bases del tipo \"Geography\""

#. Tag: para
#: using_postgis_dataman.xml:271
#, no-c-format
msgid ""
"The geography type only supports the simplest of simple features. Standard "
"geometry type data will autocast to geography if it is of SRID 4326. You can "
"also use the EWKT and EWKB conventions to insert data."
msgstr ""
"El tipo \"geography\" solo soporta el mas simple de los objetos simples. "
"Datos del tipo de geometría estándar serán moldeados al tipo \"geography\" "
"si esta en SRID 4326. También puedes emplear las convenciones EWKT y EWKB "
"para añadir datos."

#. Tag: para
#: using_postgis_dataman.xml:276
#, no-c-format
msgid "POINT: Creating a table with 2d point geometry:"
msgstr "PUNTO: Creando una tabla con una geometría puntual 2D:"

#. Tag: programlisting
#: using_postgis_dataman.xml:277
#, no-c-format
msgid ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:278
#, no-c-format
msgid "Creating a table with z coordinate point"
msgstr "Creando una tabla con un punto con coordenada z"

#. Tag: programlisting
#: using_postgis_dataman.xml:279
#, no-c-format
msgid ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINTZ,4326) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINTZ,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:282
#, no-c-format
msgid "LINESTRING"
msgstr "LINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:285
#, no-c-format
msgid "POLYGON"
msgstr "POLYGON"

#. Tag: para
#: using_postgis_dataman.xml:288
#, no-c-format
msgid "MULTIPOINT"
msgstr "MULTIPOINT"

#. Tag: para
#: using_postgis_dataman.xml:291
#, no-c-format
msgid "MULTILINESTRING"
msgstr "MULTILINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:294
#, no-c-format
msgid "MULTIPOLYGON"
msgstr "MULTIPOLYGON"

#. Tag: para
#: using_postgis_dataman.xml:297
#, no-c-format
msgid "GEOMETRYCOLLECTION"
msgstr "GEOMETRYCOLLECTION"

#. Tag: para
#: using_postgis_dataman.xml:301
#, no-c-format
msgid ""
"The new geography fields don't get registered in the "
"<varname>geometry_columns</varname>. They get registered in a new view "
"called geography_columns which is a view against the system catalogs so is "
"always automatically kept up to date without need for an AddGeom... like "
"function."
msgstr ""
"Los nuevos campos geográficos no estarán registrados en "
"<varname>geometry_columns</varname>. Estarán registrados en una nueva vista "
"llamada geography_columns que es una vista contra los catálogos del sistema, "
"así que siempre actualizara de forma automática sin necesidad de ninguna "
"función de tipo AddGeom..."

#. Tag: para
#: using_postgis_dataman.xml:305
#, no-c-format
msgid ""
"Now, check the \"geography_columns\" view and see that your table is listed."
msgstr ""
"Ahora, comprueba la vista  \"geography_columns\"  y mira si tu tabla está "
"listada"

#. Tag: para
#: using_postgis_dataman.xml:307
#, no-c-format
msgid ""
"You can create a new table with a GEOGRAPHY column using the CREATE TABLE "
"syntax. Unlike GEOMETRY, there is no need to run a separate "
"AddGeometryColumns() process to register the column in metadata."
msgstr ""
"Puedes crear una nueva tabla con una columna GEOGRAPHY usando la sintaxis de "
"CREATE TABLE. A diferencia de GEOMETRY, no hay necesidad de ejecutar un "
"proceso separado de AddGeometryColumns() para registrar la columna en los "
"metadatos."

#. Tag: programlisting
#: using_postgis_dataman.xml:311
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"
msgstr ""
"CREATE TABLE global_points ( \n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"

#. Tag: para
#: using_postgis_dataman.xml:314
#, no-c-format
msgid ""
"Note that the location column has type GEOGRAPHY and that geography type "
"supports two optional modifier: a type modifier that restricts the kind of "
"shapes and dimensions allowed in the column; an SRID modifier that restricts "
"the coordinate reference identifier to a particular number."
msgstr ""
"Se puede notar que la columna de localización es de tipo GEOGRAPHY y este "
"tipo geográfico soporta dos modificadores opcionales: un modificador de tipo "
"que restringe la clase de formas y dimensiones permitidas en la columna; y "
"un modificador SRID que restringe el identificador de las coordenadas de "
"referencia a un número particular."

#. Tag: para
#: using_postgis_dataman.xml:315
#, no-c-format
msgid ""
"Allowable values for the type modifier are: POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. The modifier also supports "
"dimensionality restrictions through suffixes: Z, M and ZM. So, for example a "
"modifier of 'LINESTRINGM' would only allow line strings with three "
"dimensions in, and would treat the third dimension as a measure. Similarly, "
"'POINTZM' would expect four dimensional data."
msgstr ""
"Valores permitdos para el modificador de tipo son: POINT, LINESTRING, "
"POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. El modificador también "
"acepta restricciones dimensionales a través de sufijos: Z, M Y ZM. Así, por "
"ejemplo, un modificador de  'LINESTRINGM'  permitirá sólo líneas con tres "
"dimensiones, y trataría la tercera dimensión como una medida. De forma "
"similar, 'POINTZM' esperará datos de cuatro dimensiones."

#. Tag: para
#: using_postgis_dataman.xml:317
#, no-c-format
msgid ""
"The SRID modifier is currently of limited use: only 4326 (WGS84) is allowed "
"as a value. If you do not specify an SRID, the a value 0 (undefined "
"spheroid) will be used, and all calculations will proceed using WGS84 "
"anyways."
msgstr ""
"El modificador SRID tiene un uso limitado actualmente: solo esta permitido "
"el valor 4326 (WGS84). Si no especificas un SRID, se utilizara el valor 0 "
"(esferoide indefinido), y todos los cálculos se harán utilizando el "
"esferoide WGS84 de todas formas."

#. Tag: para
#: using_postgis_dataman.xml:318
#, no-c-format
msgid ""
"In the future, alternate SRIDs will allow calculations on spheroids other "
"than WGS84."
msgstr ""
"En el futuro, SRID diferentes permitirán cálculos en esferoides diferentes "
"al WGS84."

#. Tag: para
#: using_postgis_dataman.xml:319
#, no-c-format
msgid ""
"Once you have created your table, you can see it in the GEOGRAPHY_COLUMNS "
"table:"
msgstr ""
"Una vez hayas creado tu tabla, podras verla en en la tabla GEOGRAPHY_COLUMNS:"

#. Tag: programlisting
#: using_postgis_dataman.xml:320
#, no-c-format
msgid ""
"-- See the contents of the metadata view\n"
"SELECT * FROM geography_columns;"
msgstr ""
"-- Ver el contenido de la vista de metadatos\n"
"SELECT * FROM geography_columns;"

#. Tag: para
#: using_postgis_dataman.xml:322
#, no-c-format
msgid ""
"You can insert data into the table the same as you would if it was using a "
"GEOMETRY column:"
msgstr ""
"Puedes añadir datos en la tabla de la misma forma que si fuera una columna "
"GEOMETRY:"

#. Tag: programlisting
#: using_postgis_dataman.xml:324
#, no-c-format
msgid ""
"-- Add some data into the test table\n"
"INSERT INTO global_points (name, location) VALUES ('Town', "
"ST_GeographyFromText('SRID=4326;POINT(-110 30)') );\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', "
"ST_GeographyFromText('SRID=4326;POINT(-109 29)') );\n"
"INSERT INTO global_points (name, location) VALUES ('London', "
"ST_GeographyFromText('SRID=4326;POINT(0 49)') );"
msgstr ""
"-- Añade algunos datos en la tabla de test\n"
"INSERT INTO global_points (name, location) VALUES ('Town', "
"ST_GeographyFromText('SRID=4326;POINT(-110 30)') );\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', "
"ST_GeographyFromText('SRID=4326;POINT(-109 29)') );\n"
"INSERT INTO global_points (name, location) VALUES ('London', "
"ST_GeographyFromText('SRID=4326;POINT(0 49)') );"

#. Tag: para
#: using_postgis_dataman.xml:326
#, no-c-format
msgid ""
"Creating an index works the same as GEOMETRY. PostGIS will note that the "
"column type is GEOGRAPHY and create an appropriate sphere-based index "
"instead of the usual planar index used for GEOMETRY."
msgstr ""
"Crear un indice es igual que para GEOMETRY. PostGIS detectará que el tipo de "
"columna es GEOGRAPHY y creara un indice basado en una esfera apropiado en "
"vez de el indice usual basado en plano utilizado para columnas GEOMETRY"

#. Tag: programlisting
#: using_postgis_dataman.xml:329
#, no-c-format
msgid ""
"-- Index the test table with a spherical index\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"
msgstr ""
"-- Crea un indice en la tabla de test con un indice esferico\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"

#. Tag: para
#: using_postgis_dataman.xml:332
#, no-c-format
msgid ""
"Query and measurement functions use units of meters. So distance parameters "
"should be expressed in meters, and return values should be expected in "
"meters (or square meters for areas)."
msgstr ""
"Las consultas y las funciones de medidas utilizan metros cho unidad. Asi que "
"los parámetros de distancia deben estar expresados en metros, y los valores "
"devueltos deben estar expresados en metros (o metros cuadrados para áreas)"

#. Tag: programlisting
#: using_postgis_dataman.xml:334
#, no-c-format
msgid ""
"-- Show a distance query and note, London is outside the 1000km tolerance\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, "
"ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);"
msgstr ""
"-- Muestra una consulta de distancia y observa que , Londres esta fuera de "
"la tolerancia de 1000km\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, "
"ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);"

#. Tag: para
#: using_postgis_dataman.xml:337
#, no-c-format
msgid ""
"You can see the power of GEOGRAPHY in action by calculating the how close a "
"plane flying from Seattle to London (LINESTRING(-122.33 47.606, 0.0 51.5)) "
"comes to Reykjavik (POINT(-21.96 64.15))."
msgstr ""
"Puedes observar la potencia de GEOGRAPHY en directo calculando como de "
"próximo, un avión volando de Seattle a Londres (LINESTRING(-122.33 47.606, "
"0.0 51.5)) viene a Reykjavik (POINT(-21.96 64.15))."

#. Tag: programlisting
#: using_postgis_dataman.xml:339
#, no-c-format
msgid ""
"-- Distance calculation using GEOGRAPHY (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)':: geography);"
msgstr ""
"-- Calculo de distancia utilizando GEOGRAPHY (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)':: geography);"

#. Tag: programlisting
#: using_postgis_dataman.xml:342
#, no-c-format
msgid ""
"-- Distance calculation using GEOMETRY (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)':: geometry);"
msgstr ""
"-- Calculo de distancia utilizando GEOMETRY (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)':: geometry);"

#. Tag: para
#: using_postgis_dataman.xml:345
#, no-c-format
msgid ""
"The GEOGRAPHY type calculates the true shortest distance over the sphere "
"between Reykjavik and the great circle flight path between Seattle and "
"London."
msgstr ""
"El tipo GEOGRAPHY calcula la distancia real mas corta sobre la esfera entre "
"Reykjavik y el camino circular mayor de vuelo entre Seattle y London."

#. Tag: para
#: using_postgis_dataman.xml:347
#, no-c-format
msgid ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> The GEOMETRY type calculates a meaningless cartesian distance "
"between Reykjavik and the straight line path from Seattle to London plotted "
"on a flat map of the world. The nominal units of the result might be called "
"\"degrees\", but the result doesn't correspond to any true angular "
"difference between the points, so even calling them \"degrees\" is "
"inaccurate."
msgstr ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> El tipo GEOMETRY calcula una distancia cartesiana sin sentido "
"entre Reykjavik y el camino recto desde Seattle a Londres dibujado en un "
"mapa plano del mundo. Las unidades nominales del resultado debe llamarse "
"\"grados\", pero el resultado no corresponde con ninguna diferencia angular "
"entre los puntos, así que incluso llamándolo \"grados\" es inexacta."

#. Tag: title
#: using_postgis_dataman.xml:351
#, no-c-format
msgid "When to use Geography Data type over Geometry data type"
msgstr "¿Cuando utilizar el tipo Geografico en vez de Geometrico?"

#. Tag: para
#: using_postgis_dataman.xml:352
#, no-c-format
msgid ""
"The new GEOGRAPHY type allows you to store data in longitude/latitude "
"coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY "
"than there are on GEOMETRY; those functions that are defined take more CPU "
"time to execute."
msgstr ""
"El nuevo tipo GEOGRAPHY te permite almacenar datos en coordenadas longitud/"
"latitud, pero con un coste: hay algunas funciones definidas en GEOGRAPHY que "
"están en GEOMETRY; estas funciones que están definidas toman mas tiempo en "
"la CPU a ejecutarse"

#. Tag: para
#: using_postgis_dataman.xml:353
#, no-c-format
msgid ""
"The type you choose should be conditioned on the expected working area of "
"the application you are building. Will your data span the globe or a large "
"continental area, or is it local to a state, county or municipality?"
msgstr ""
"El tipo que elijas debe estar condicionado por la extension del área de "
"trabajo de la aplicación que estas construyendo. ¿Tus datos se extienden por "
"el globo o una zona continental grande? ¿O es un estado, región o municipio?"

#. Tag: para
#: using_postgis_dataman.xml:355
#, no-c-format
msgid ""
"If your data is contained in a small area, you might find that choosing an "
"appropriate projection and using GEOMETRY is the best solution, in terms of "
"performance and functionality available."
msgstr ""
"Si tus datos están un área pequeña, la mejor solución seria elegir una "
"proyección adecuada y utilizando GEOMETRY, en términos de rendimiento y "
"funcionalidades disponibles."

#. Tag: para
#: using_postgis_dataman.xml:356
#, no-c-format
msgid ""
"If your data is global or covers a continental region, you may find that "
"GEOGRAPHY allows you to build a system without having to worry about "
"projection details. You store your data in longitude/latitude, and use the "
"functions that have been defined on GEOGRAPHY."
msgstr ""
"Si tus datos son globales o cubren una región continental, veras que "
"GEOGRAPHY te permite construir un sistema sin tener que preocuparte sobre "
"detalles de proyección. Almacenas tus datos en longitud/latitud, y utilizas "
"las funciones definidas en GEOGRAPHY."

#. Tag: para
#: using_postgis_dataman.xml:358
#, no-c-format
msgid ""
"If you don't understand projections, and you don't want to learn about them, "
"and you're prepared to accept the limitations in functionality available in "
"GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. "
"Simply load your data up as longitude/latitude and go from there."
msgstr ""
"Si no entiendes las proyecciones, y no quieres aprender sobre ellas, y estas "
"preparado a aceptar las funcionalidades limitadas disponibles en GEOGRAPHY, "
"entonces sera mas fácil para ti, utilizar GEOGRAPHY en lugar de GEOMETRY. "
"Simplemente carga tus datos como longitud/latitud y continua desde allí."

#. Tag: para
#: using_postgis_dataman.xml:361
#, no-c-format
msgid ""
"Refer to <xref linkend=\"PostGIS_TypeFunctionMatrix\"/> for compare between "
"what is supported for Geography vs. Geometry. For a brief listing and "
"description of Geography functions, refer to <xref linkend="
"\"PostGIS_GeographyFunctions\"/>"
msgstr ""
"Para tener una comparación entre lo que esta soportado entre Geography y "
"Geometry ve a  <xref linkend=\"PostGIS_TypeFunctionMatrix\"/>. Para obtener "
"una lista con la descripción de las funciones Geography ve a <xref linkend="
"\"PostGIS_GeographyFunctions\"/>"

#. Tag: title
#: using_postgis_dataman.xml:367
#, no-c-format
msgid "Geography Advanced FAQ"
msgstr "Preguntas frecuentes Avanzadas de Geography"

#. Tag: para
#: using_postgis_dataman.xml:371
#, no-c-format
msgid "Do you calculate on the sphere or the spheroid?"
msgstr "¿Se calcula en la esfera o en el esferoide?"

#. Tag: para
#: using_postgis_dataman.xml:375
#, no-c-format
msgid ""
"By default, all distance and area calculations are done on the spheroid. You "
"should find that the results of calculations in local areas match up will "
"with local planar results in good local projections. Over larger areas, the "
"spheroidal calculations will be more accurate than any calculation done on a "
"projected plane."
msgstr ""
"Por defecto, todos los cálculos de distancia y área están hechos sobre el "
"esferoide. Deberías ver que los resultados de los cálculos en áreas locales "
"deberán coincidir con los resultados en coordenadas locales planas con "
"proyecciones locales correctas. En grandes áreas, los cálculos esferoidales "
"serán mas precisas que cualquier calculo realizado en planas."

#. Tag: para
#: using_postgis_dataman.xml:378
#, no-c-format
msgid ""
"All the geography functions have the option of using a sphere calculation, "
"by setting a final boolean parameter to 'FALSE'. This will somewhat speed up "
"calculations, particularly for cases where the geometries are very simple."
msgstr ""
"Todas las funciones \"geography\" tienen la opción de utilizar el calculo "
"sobre la esfera, seleccionando el parámetro final boleano a 'FALSE'. Esto "
"puede acelerar los cálculos, particularmente en casos donde las geometrias "
"son muy simples."

#. Tag: para
#: using_postgis_dataman.xml:384
#, no-c-format
msgid "What about the date-line and the poles?"
msgstr "¿Que ocurre con los husos horarios y los polos?"

#. Tag: para
#: using_postgis_dataman.xml:388
#, no-c-format
msgid ""
"All the calculations have no conception of date-line or poles, the "
"coordinates are spherical (longitude/latitude) so a shape that crosses the "
"dateline is, from a calculation point of view, no different from any other "
"shape."
msgstr ""
"Todos los cálculos no tienen nociones de husos horarios o polos, las "
"coordenadas son esféricas(longitud/latitud) así que una forma que atraviesa "
"husos horarios no es, desde un punto de vista de los cálculos, a cualquier "
"otra forma."

#. Tag: para
#: using_postgis_dataman.xml:396
#, no-c-format
msgid "What is the longest arc you can process?"
msgstr "¿Cual es el arco mas largo que se pude procesar?"

#. Tag: para
#: using_postgis_dataman.xml:400
#, no-c-format
msgid ""
"We use great circle arcs as the \"interpolation line\" between two points. "
"That means any two points are actually joined up two ways, depending on "
"which direction you travel along the great circle. All our code assumes that "
"the points are joined by the *shorter* of the two paths along the great "
"circle. As a consequence, shapes that have arcs of more than 180 degrees "
"will not be correctly modelled."
msgstr ""
"Utilizamos grandes arcos de circulo como la \"linea de interpolación\" entre "
"dos puntos. Esto significa que actualmente, dos puntos se unen de dos "
"formas, dependiendo de la dirección del viaje sobre el arco. Todo nuestro "
"código asume que los puntos están unidos por el *mas corto* de los dos "
"caminos a traves del arco de circunferencia. Como consecuencia, las formas "
"que tienen arcos mayores de 180 grados no serán modeladas correctamente."

#. Tag: para
#: using_postgis_dataman.xml:407
#, no-c-format
msgid ""
"Why is it so slow to calculate the area of Europe / Russia / insert big "
"geographic region here ?"
msgstr ""
"¿ Por que es tan lento el calculo del area de Europa / Rusia / añade una "
"región geográfica grande aquí?"

#. Tag: para
#: using_postgis_dataman.xml:411
#, no-c-format
msgid ""
"Because the polygon is so darned huge! Big areas are bad for two reasons: "
"their bounds are huge, so the index tends to pull the feature no matter what "
"query you run; the number of vertices is huge, and tests (distance, "
"containment) have to traverse the vertex list at least once and sometimes N "
"times (with N being the number of vertices in the other candidate feature)."
msgstr ""
"¡Por que el poligono es condenadamente grande! Las grandes áreas son malas "
"por dos razones: Sus limites son grandes, así que el indice tiende a tirar "
"de la función sin importar la consulta que estes ejecutando; el numero de "
"vértices es grande, y los tests (distancia, de contención) tiene que "
"recorrer la lista de vértices al menos una vez y a veces N veces ( con N "
"igual al numero de vértices en el otro objeto candidato)."

#. Tag: para
#: using_postgis_dataman.xml:416
#, no-c-format
msgid ""
"As with GEOMETRY, we recommend that when you have very large polygons, but "
"are doing queries in small areas, you \"denormalize\" your geometric data "
"into smaller chunks so that the index can effectively subquery parts of the "
"object and so queries don't have to pull out the whole object every time. "
"Just because you *can* store all of Europe in one polygon doesn't mean you "
"*should*."
msgstr ""
"Como con GEOMETRY, recomendamos que cuando tengas polígonos muy grandes, "
"pero haces consultas en áreas pequeñas, deberías \"desnormalizar\" tus datos "
"geométricos en trozos pequeños así el indice puede hacer subconsultas "
"eficientes del objeto y las consultas no tienen que utilizar el objeto "
"entero cada vez. Solo por que *puedas* almacenar toda Europa en un polígono "
"no significa que *debas*."

#. Tag: title
#: using_postgis_dataman.xml:425
#, no-c-format
msgid "Using OpenGIS Standards"
msgstr "Utilizando estandares OpenGIS"

#. Tag: para
#: using_postgis_dataman.xml:427
#, no-c-format
msgid ""
"The OpenGIS \"Simple Features Specification for SQL\" defines standard GIS "
"object types, the functions required to manipulate them, and a set of meta-"
"data tables. In order to ensure that meta-data remain consistent, operations "
"such as creating and removing a spatial column are carried out through "
"special procedures defined by OpenGIS."
msgstr ""
"La especificación \"Simple Features Specification for SQL\"del OpenGIS, "
"define estándares del tipo de objetos GIS, las funciones necesarias para "
"manipularlos, y un conjunto de tablas de metadatos. Para asegurar que los "
"metadatos permanecen consistentes, operaciones como crear o borrar una "
"columna espacial están llevados a cabo a través de procedimientos especiales "
"definidos por el OpenGIS."

#. Tag: para
#: using_postgis_dataman.xml:433
#, no-c-format
msgid ""
"There are two OpenGIS meta-data tables: <varname>SPATIAL_REF_SYS</varname> "
"and <varname>GEOMETRY_COLUMNS</varname>. The <varname>SPATIAL_REF_SYS</"
"varname> table holds the numeric IDs and textual descriptions of coordinate "
"systems used in the spatial database."
msgstr ""
"Hay dos tablas de metadatos definidas por el OpenGIS: "
"<varname>SPATIAL_REF_SYS</varname> y <varname>GEOMETRY_COLUMNS</varname>. La "
"tabla <varname>SPATIAL_REF_SYS</varname> almacena los IDs numéricos y las "
"descripciones textuales de los sistemas de coordenadas utilizados en la base "
"de datos espaciales."

#. Tag: title
#: using_postgis_dataman.xml:440
#, no-c-format
msgid "The SPATIAL_REF_SYS Table and Spatial Reference Systems"
msgstr "La tabla SPATIAL_REF_SYS y los Sistemas de Referencia Espacial"

#. Tag: para
#: using_postgis_dataman.xml:442
#, no-c-format
msgid ""
"The spatial_ref_sys table is a PostGIS included and OGC compliant database "
"table that lists over 3000 known <ulink url=\"http://www.sharpgis.net/"
"post/2007/05/Spatial-references2c-coordinate-systems2c-projections2c-"
"datums2c-ellipsoids-e28093-confusing.aspx\">spatial reference systems</"
"ulink> and details needed to transform/reproject between them."
msgstr ""
"La tabla spatial_ref_sys es una tabla incluida en PostGIS y cumple con el "
"estafar OGC, que contiene una lista de unos 3000 <ulink url=\"http://www."
"sharpgis.net/post/2007/05/Spatial-references2c-coordinate-systems2c-"
"projections2c-datums2c-ellipsoids-e28093-confusing.aspx\">sistemas de "
"referencia espaciales</ulink>  conocidos y los detalles necesarios para "
"transformar/reproyectar entre ellos."

#. Tag: para
#: using_postgis_dataman.xml:446
#, no-c-format
msgid ""
"Although the PostGIS spatial_ref_sys table contains over 3000 of the more "
"commonly used spatial reference system definitions that can be handled by "
"the proj library, it does not contain all known to man and you can even "
"define your own custom projection if you are familiar with proj4 constructs. "
"Keep in mind that most spatial reference systems are regional and have no "
"meaning when used outside of the bounds they were intended for."
msgstr ""
"Aunque la tabla spatial_ref_sys de PostGIS contiene unas 3000 definiciones "
"de sistemas de referencia espaciales mas comunes, esto puede ser manejado "
"con la librería proj, no contiene todos los sistemas conocidos y puedes "
"definir tus propias proyecciones si estas familiarizado con el constructor "
"de proj4. Piensa que la mayoría de sistemas de referencia son regionales y "
"no tiene sentido utilizarlos fuera de los limites para los cuales fueron "
"definidos."

#. Tag: para
#: using_postgis_dataman.xml:449
#, no-c-format
msgid ""
"An excellent resource for finding spatial reference systems not defined in "
"the core set is <ulink url=\"http://spatialreference.org/\">http://"
"spatialreference.org/</ulink>"
msgstr ""
"Un recurso muy bueno para encontrar sistemas de referencia espaciales no "
"definidos en el núcleo de la librería es <ulink url=\"http://"
"spatialreference.org/\">http://spatialreference.org/</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:451
#, no-c-format
msgid ""
"Some of the more commonly used spatial reference systems are: <ulink url="
"\"http://spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD "
"83 Long Lat</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/"
"\">3395 - WGS 84 World Mercator</ulink>, <ulink url=\"http://"
"spatialreference.org/ref/epsg/2163/\">2163 - US National Atlas Equal Area</"
"ulink>, Spatial reference systems for each NAD 83, WGS 84 UTM zone - UTM "
"zones are one of the most ideal for measurement, but only cover 6-degree "
"regions."
msgstr ""
"Algunos de los sistemas de referencia espaciales mas comunes en Estados "
"Unidos son: <ulink url=\"http://spatialreference.org/ref/epsg/4326/\">4326 - "
"WGS 84 Long Lat </ulink>, <ulink url=\"http://spatialreference.org/ref/"
"epsg/4269/\">4269 - NAD 83 Long Lat (en Norte America )</ulink>, <ulink url="
"\"http://spatialreference.org/ref/epsg/3395/\">3395 - WGS 84 World Mercator</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/2163/\">2163 - US "
"National Atlas Equal Area (en Estados Unidos )</ulink>,Sistemas de "
"referencia espaciales para cada zona, NAD 83, WGS 84 UTM y UTM son de los "
"mas idóneos para medidas, pero solo cubren regiones de 6 grados."

#. Tag: para
#: using_postgis_dataman.xml:457
#, no-c-format
msgid ""
"Various US state plane spatial reference systems (meter or feet based) - "
"usually one or 2 exists per US state. Most of the meter ones are in the core "
"set, but many of the feet based ones or ESRI created ones you will need to "
"pull from <ulink url=\"http://spatialreference.org\">spatialreference.org</"
"ulink>."
msgstr ""
"Algunos sistemas de referencia espaciales planos de Estados Unidos (basados "
"en metros o pies) - normalmente existen uno o 2 por Estado de Estados "
"Unidos. La mayoría de los basados en metros están en el núcleo de "
"definiciones, pero algunos de los basados en pies o los creados por ESRI "
"deberás crearlos desde <ulink url=\"http://spatialreference.org"
"\">spatialreference.org</ulink>."

#. Tag: para
#: using_postgis_dataman.xml:461
#, no-c-format
msgid ""
"For details on determining which UTM zone to use for your area of interest, "
"check out the <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
"UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper function</"
"ulink>."
msgstr ""
"Para saber detalles sobre como determinar la zona UTM a utilizar en tu área "
"de interés, echalé un vistazo a la <ulink url=\"http://trac.osgeo.org/"
"postgis/wiki/UsersWikiplpgsqlfunctionsDistance\">función de ayuda utmzone "
"PostGIS plpgsql </ulink>."

#. Tag: para
#: using_postgis_dataman.xml:465
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> table definition is as follows:"
msgstr ""
"La definición de la tabla <varname>SPATIAL_REF_SYS</varname> es la siguiente:"

#. Tag: programlisting
#: using_postgis_dataman.xml:468
#, no-c-format
msgid ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"
msgstr ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"

#. Tag: para
#: using_postgis_dataman.xml:470
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> columns are as follows:"
msgstr "Las columnas <varname>SPATIAL_REF_SYS</varname> son como sigue:"

#. Tag: ulink
#: using_postgis_dataman.xml:475
#, no-c-format
msgid "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"
msgstr "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:478
#, no-c-format
msgid ""
"An integer value that uniquely identifies the Spatial Referencing System "
"(SRS) within the database."
msgstr ""
"Un valor entero único que identifica el Sistema de Referencia Espacial (SRS "
"de sus siglas en ingles) con la base de datos. "

#. Tag: term
#: using_postgis_dataman.xml:484
#, no-c-format
msgid "AUTH_NAME"
msgstr "AUTH_NAME"

#. Tag: para
#: using_postgis_dataman.xml:487
#, no-c-format
msgid ""
"The name of the standard or standards body that is being cited for this "
"reference system. For example, \"EPSG\" would be a valid <varname>AUTH_NAME</"
"varname>."
msgstr ""
"El nombre del estándar o estándares que es citado para este sistema de "
"referencia. Por ejemplo, \"EPSG\" seria un <varname>AUTH_NAME</varname> "
"valido."

#. Tag: term
#: using_postgis_dataman.xml:494
#, no-c-format
msgid "AUTH_SRID"
msgstr "AUTH_SRID"

#. Tag: para
#: using_postgis_dataman.xml:497
#, no-c-format
msgid ""
"The ID of the Spatial Reference System as defined by the Authority cited in "
"the <varname>AUTH_NAME</varname>. In the case of EPSG, this is where the "
"EPSG projection code would go."
msgstr ""
"El ID del Sistema de Referencia Espacial definido por el Autor citado en "
"<varname>AUTH_NAME</varname>. En el caso de EPSG, este es lugar donde deberá "
"ir el código de la proyección EPSG."

#. Tag: term
#: using_postgis_dataman.xml:504
#, no-c-format
msgid "SRTEXT"
msgstr "SRTEXT"

#. Tag: para
#: using_postgis_dataman.xml:507
#, no-c-format
msgid ""
"The Well-Known Text representation of the Spatial Reference System. An "
"example of a WKT SRS representation is:"
msgstr ""
"La representación Well-Known Text del Sistema de Referencia Espacial (SRS). "
"Un ejemplo de representación WKT SRS es:"

#. Tag: programlisting
#: using_postgis_dataman.xml:510
#, no-c-format
msgid ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"
msgstr ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"

#. Tag: para
#: using_postgis_dataman.xml:512
#, no-c-format
msgid ""
"For a listing of EPSG projection codes and their corresponding WKT "
"representations, see <ulink url=\"http://www.opengeospatial.org/\">http://"
"www.opengeospatial.org/</ulink>. For a discussion of WKT in general, see the "
"OpenGIS \"Coordinate Transformation Services Implementation Specification\" "
"at <ulink url=\"http://www.opengeospatial.org/standards\">http://www."
"opengeospatial.org/standards</ulink>. For information on the European "
"Petroleum Survey Group (EPSG) and their database of spatial reference "
"systems, see <ulink url=\"http://www.epsg.org/\">http://www.epsg.org</ulink>."
msgstr ""
"Para obtener una lista de los códigos EPSG y sus correspondientes "
"representaciones WKT, visita <ulink url=\"http://www.opengeospatial.org/"
"\">http://www.opengeospatial.org/</ulink>. Para obtener  información general "
"sobre WKT, visita el OpenGIS \"Coordinate Transformation Services "
"Implementation Specification\" en <ulink url=\"http://www.opengeospatial.org/"
"standards\">http://www.opengeospatial.org/standards</ulink>. Para obtener "
"información del European Petroleum Survey Group (EPSG) y su base de datos de "
"sistemas de referencia espacial, visita <ulink url=\"http://www.epsg.org/"
"\">http://www.epsg.org</ulink>."

#. Tag: term
#: using_postgis_dataman.xml:525
#, no-c-format
msgid "PROJ4TEXT"
msgstr "PROJ4TEXT"

#. Tag: para
#: using_postgis_dataman.xml:528
#, no-c-format
msgid ""
"PostGIS uses the Proj4 library to provide coordinate transformation "
"capabilities. The <varname>PROJ4TEXT</varname> column contains the Proj4 "
"coordinate definition string for a particular SRID. For example:"
msgstr ""
"PostGIS utiliza la libreria Proj4 para ejecutar transformaciones de "
"coordenadas. La columna <varname>PROJ4TEXT</varname> contiene la cadena de "
"definición de coordenadas Proj4 para un SRID particular. Por ejemplo:"

#. Tag: programlisting
#: using_postgis_dataman.xml:533
#, no-c-format
msgid "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"
msgstr "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"

#. Tag: para
#: using_postgis_dataman.xml:535
#, no-c-format
msgid ""
"For more information about, see the Proj4 web site at <ulink url=\"http://"
"trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. The "
"<filename>spatial_ref_sys.sql</filename> file contains both <varname>SRTEXT</"
"varname> and <varname>PROJ4TEXT</varname> definitions for all EPSG "
"projections."
msgstr ""
"Para obtener mas información, puedes visitar el sitio web de Proj4 en <ulink "
"url=\"http://trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. El "
"fichero <filename>spatial_ref_sys.sql</filename> contiene ambas definiciones "
"<varname>SRTEXT</varname> y <varname>PROJ4TEXT</varname> para todas las "
"proyecciones EPSG."

#. Tag: title
#: using_postgis_dataman.xml:546
#, no-c-format
msgid "The GEOMETRY_COLUMNS VIEW"
msgstr "La VISTA GEOMETRY_COLUMNS"

#. Tag: para
#: using_postgis_dataman.xml:548
#, no-c-format
msgid ""
"In versions of PostGIS prior to 2.0.0, geometry_columns was a table that "
"could be directly edited, and sometimes got out of synch with the actual "
"definition of the geometry columns. In PostGIS 2.0.0, "
"<varname>GEOMETRY_COLUMNS</varname> became a view with the same front-facing "
"structure as prior versions, but reading from database system catalogs Its "
"structure is as follows:"
msgstr ""
"En versiones anteriores a PostGIS 2.0.0, geometry_column era una tabla que "
"podía ser editada directamente, y a veces no estaba sincronizada con la "
"definición actual de las columnas geométricas. En PostGIS 2.0.0,"
"<varname>GEOMETRY_COLUMNS</varname> se transforma en una vista con la misma "
"extructura  que versiones anteriores, pero leyendo desde el catalogo del "
"sistema de la base de datos, su estructura es la siguiente:"

#. Tag: programlisting
#: using_postgis_dataman.xml:552
#, no-c-format
msgid "\\d geometry_columns"
msgstr "\\d geometry_columns"

#. Tag: screen
#: using_postgis_dataman.xml:553
#, no-c-format
msgid ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"
msgstr ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"

#. Tag: para
#: using_postgis_dataman.xml:555
#, no-c-format
msgid "The column meanings have not changed from prior versions and are:"
msgstr ""
"El significado de las columnas no ha cambiado desde versiones anteriores y "
"es: "

#. Tag: term
#: using_postgis_dataman.xml:559
#, no-c-format
msgid "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"
msgstr "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"

#. Tag: para
#: using_postgis_dataman.xml:562
#, no-c-format
msgid ""
"The fully qualified name of the feature table containing the geometry "
"column. Note that the terms \"catalog\" and \"schema\" are Oracle-ish. There "
"is not PostgreSQL analogue of \"catalog\" so that column is left blank -- "
"for \"schema\" the PostgreSQL schema name is used (<varname>public</varname> "
"is the default)."
msgstr ""
"El nombre completo de la tabla de entidad que contiene la columna de "
"geometría. Observa que los términos \"catalog\" y \"schema\" son como en "
"Oracle. No hay analogía en PostgreSQL para \"catalogo\" así que esta columna "
"esta en blanco -- para \"schema\" se usa el nombre de esquema de PostgreSQL  "
"(<varname>public</varname> es por defecto)."

#. Tag: term
#: using_postgis_dataman.xml:571
#, no-c-format
msgid "F_GEOMETRY_COLUMN"
msgstr "F_GEOMETRY_COLUMN"

#. Tag: para
#: using_postgis_dataman.xml:574
#, no-c-format
msgid "The name of the geometry column in the feature table."
msgstr ""
"El nombre de la columna de geometrías de la tabla de objetos espaciales."

#. Tag: term
#: using_postgis_dataman.xml:579
#, no-c-format
msgid "COORD_DIMENSION"
msgstr "COORD_DIMENSION"

#. Tag: para
#: using_postgis_dataman.xml:582
#, no-c-format
msgid "The spatial dimension (2, 3 or 4 dimensional) of the column."
msgstr "Dimension espacial (2, 3 o 4 dimensiones) de la columna."

#. Tag: term
#: using_postgis_dataman.xml:588
#, no-c-format
msgid "<term>SRID</term>"
msgstr "<term>SRID</term>"

#. Tag: para
#: using_postgis_dataman.xml:591
#, no-c-format
msgid ""
"The ID of the spatial reference system used for the coordinate geometry in "
"this table. It is a foreign key reference to the <varname>SPATIAL_REF_SYS</"
"varname>."
msgstr ""
"El ID del sistema de referencia espacial utilizado para las coordenadas de "
"las geometrías en la tabla. Es una clave foránea con referencia a la tabla "
"<varname>SPATIAL_REF_SYS</varname>."

#. Tag: term
#: using_postgis_dataman.xml:598
#, no-c-format
msgid "TYPE"
msgstr "TYPE"

#. Tag: para
#: using_postgis_dataman.xml:601
#, no-c-format
msgid ""
"The type of the spatial object. To restrict the spatial column to a single "
"type, use one of: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, "
"MULTIPOLYGON, GEOMETRYCOLLECTION or corresponding XYM versions POINTM, "
"LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, "
"GEOMETRYCOLLECTIONM. For heterogeneous (mixed-type) collections, you can use "
"\"GEOMETRY\" as the type."
msgstr ""
"El tipo de objeto espacial. Para restringir la columna espacial a un tipo "
"unico, utiliza uno de: POINT, LINESTRING, POLYGON, MULTIPOINT, "
"MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION o su version "
"correspondiente de XYM POINTM, LINESTRINGM, POLYGONM, MULTIPOINTM, "
"MULTILINESTRINGM, MULTIPOLYGONM, GEOMETRYCOLLECTIONM. Para colecciones "
"heterogéneas (tipos mixtos), puedes utilizar \"GEOMETRY\" como tipo."

#. Tag: para
#: using_postgis_dataman.xml:610
#, no-c-format
msgid ""
"This attribute is (probably) not part of the OpenGIS specification, but is "
"required for ensuring type homogeneity."
msgstr ""
"Este no es (probablemente) parte de la especificación OpenGIS, pero es "
"necesario para asegurar la homogeneidad de tipos. "

#. Tag: title
#: using_postgis_dataman.xml:620
#, no-c-format
msgid "Creating a Spatial Table"
msgstr "Crear una tabla espacial"

#. Tag: para
#: using_postgis_dataman.xml:622
#, no-c-format
msgid ""
"Creating a table with spatial data, can be done in one step. As shown in the "
"following example which creates a roads table with a 2D linestring geometry "
"column in WGS84 long lat"
msgstr ""
"Crear una tabla con datos espaciales se puede hacer en un solo paso. Como se "
"muestra en el siguiente ejemplo que crea una tabla de carreteras con una "
"columna de tipo lineal de 2D en WGS84 long lat."

#. Tag: programlisting
#: using_postgis_dataman.xml:624
#, fuzzy, no-c-format
msgid ""
"CREATE TABLE ROADS ( ID int4\n"
"                , ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) );"
msgstr ""
"CREATE TABLE ROADS ( ID int4\n"
"                  , ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:626
#, no-c-format
msgid ""
"We can add additional columns using standard ALTER TABLE command as we do in "
"this next example where we add a 3-D linestring."
msgstr ""
"Podemos añadir columnas adicionales utilizando el comando estándar ALTER "
"TABLE como se muestra en el siguiente ejemplo donde añadimos una columna de "
"lineas en 3D."

#. Tag: programlisting
#: using_postgis_dataman.xml:627
#, no-c-format
msgid "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"
msgstr "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"

#. Tag: para
#: using_postgis_dataman.xml:629
#, no-c-format
msgid ""
"For backwards compability, you can still create a spatial table in two "
"stages using the management functions."
msgstr ""
"Por compatibilidad con versiones anteriores, puedes crear tablas espaciales  "
"en dos pasos utilizando las funciones de gestión."

#. Tag: para
#: using_postgis_dataman.xml:633
#, no-c-format
msgid "Create a normal non-spatial table."
msgstr "Crear una tabla normal, no espacial."

#. Tag: para
#: using_postgis_dataman.xml:635
#, no-c-format
msgid ""
"For example: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME varchar(25) )</"
"command>"
msgstr ""
"Por ejemplo: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME varchar(25) )</"
"command>"

#. Tag: para
#: using_postgis_dataman.xml:640
#, no-c-format
msgid ""
"Add a spatial column to the table using the OpenGIS \"AddGeometryColumn\" "
"function. Refer to <xref linkend=\"AddGeometryColumn\"/> for more details."
msgstr ""
"Añadir una columna espacial a la tabla utilizando la función "
"\"AddGeometryColumn\". Para mas detallis ve a <xref linkend="
"\"AddGeometryColumn\"/>"

#. Tag: para
#: using_postgis_dataman.xml:643
#, no-c-format
msgid ""
"The syntax is: <programlisting>AddGeometryColumn(\n"
"  &lt;schema_name&gt;,\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")</programlisting> Or, using current schema:"
msgstr ""
"La sintaxis es: <programlisting>AddGeometryColumn(\n"
"  &lt;schema_name&gt;,\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")</programlisting> O, utilizando el esquema actual:"

#. Tag: programlisting
#: using_postgis_dataman.xml:643
#, no-c-format
msgid ""
"AddGeometryColumn(\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")"
msgstr ""
"AddGeometryColumn(\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")"

#. Tag: para
#: using_postgis_dataman.xml:645
#, no-c-format
msgid ""
"Example1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"
msgstr ""
"Ejemplo 1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"

#. Tag: para
#: using_postgis_dataman.xml:648
#, no-c-format
msgid ""
"Example2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"
msgstr ""
"Ejemplo 2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"

#. Tag: para
#: using_postgis_dataman.xml:653
#, no-c-format
msgid ""
"Here is an example of SQL used to create a table and add a spatial column "
"(assuming that an SRID of 128 exists already):"
msgstr ""
"Aqui tienes un ejemplo del comando SQL utilizado para crear una tabla y "
"añadirle una columna espacial (asumiendo que un SRID de 128 existe ya):"

#. Tag: programlisting
#: using_postgis_dataman.xml:656
#, no-c-format
msgid ""
"CREATE TABLE parks (\n"
"  park_id    INTEGER,\n"
"  park_name  VARCHAR,\n"
"  park_date  DATE,\n"
"  park_type  VARCHAR\n"
");\n"
"SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"
msgstr ""
"CREATE TABLE parks (\n"
"  park_id    INTEGER,\n"
"  park_name  VARCHAR,\n"
"  park_date  DATE,\n"
"  park_type  VARCHAR\n"
");\n"
"SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"

#. Tag: para
#: using_postgis_dataman.xml:658
#, no-c-format
msgid ""
"Here is another example, using the generic \"geometry\" type and the "
"undefined SRID value of 0:"
msgstr ""
"Aqui tienes otro ejemplo, utilizando el tipo genérico \"geometry\" y el "
"valor indefinido de SRID 0:"

#. Tag: programlisting
#: using_postgis_dataman.xml:661
#, no-c-format
msgid ""
"CREATE TABLE roads (\n"
"  road_id INTEGER,\n"
"  road_name VARCHAR\n"
");\n"
"SELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"
msgstr ""
"CREATE TABLE roads (\n"
"  road_id INTEGER,\n"
"  road_name VARCHAR\n"
");\n"
"SELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"

#. Tag: title
#: using_postgis_dataman.xml:665
#, no-c-format
msgid "Manually Registering Geometry Columns in geometry_columns"
msgstr ""
"Registrando la columna de geometrias de forma manual en la tabla "
"geometry_columns"

#. Tag: para
#: using_postgis_dataman.xml:666
#, fuzzy, no-c-format
msgid ""
"The AddGeometryColumn() approach creates a geometry column of specified "
"type. This type and dimension are queryable from the "
"<varname>geometry_columns</varname> view. Starting with PostGIS 2.0, "
"geometry_columns is no longer editable and all geometry columns are "
"autoregistered."
msgstr ""
"El enfoque de AddGeometryColumn() crea una columna de geometria y además "
"registra la nueva columna en la tabla geometry_columns. Si tu software "
"utiliza geometry_columns, entonces cualquier columna de geometrías que "
"necesites interrogar, debe estar registrada en esta vista. Desde la version "
"PostGIS 2.0, geometry_columns no se puede editar y todas las columnas "
"geométricas se registran de forma automática."

#. Tag: para
#: using_postgis_dataman.xml:669
#, no-c-format
msgid ""
"If your geometry columns were created as generic in a table or view and no "
"constraints applied, they will not have a dimension, type or srid in "
"geometry_columns views, but will still be listed."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:671
#, fuzzy, no-c-format
msgid ""
"Two of the cases where this may happen, but you can't use AddGeometryColumn, "
"is in the case of SQL Views and bulk inserts. For bulk insert case, you can "
"correct the registration in the geometry_columns table by constraining the "
"column or doing an alter table. For views, you could expose using a CAST "
"operation. Note in PostGIS 2.0+ if your column is typmod based, the creation "
"process would register it correctly, so no need to do anything. Also views "
"that have no spatial function applied to the geometry will register the same "
"as the underlying table geometry column."
msgstr ""
"Dos de los casos en lo que esto ocurre, pero no puedes utilizar "
"AddGeometryColumn, es el caso de vistas SQL e inserciones masivas. Para esto "
"casos, puedes corregir el registro en la tabla geometry_columns creando una "
"restricción en la columna. A saber que en PostGIS 2.0+, si tu columna esta "
"basada en typmod, el proceso de creación lo registrará correctamente, así "
"que no necesitas hacer nada."

#. Tag: programlisting
#: using_postgis_dataman.xml:678
#, fuzzy, no-c-format
msgid ""
"--Lets say you have a view created like this\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- For it to register correctly in PostGIS 2.0+\n"
"-- You need to cast the geometry\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- If you know the geometry type for sure is a 2D POLYGON then you could do\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"
msgstr ""
"--Imaginemos que tienes una vista creada de la siguiente manera\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"        \n"
"-- Para registrarla de forma correcta en  PostGIS 2.0+ \n"
"-- Necesitas hacer una conversión de tipos cast\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"        \n"
"-- Si sabes que el tipo de geometria de forma segura es 2D POLYGON entonces "
"puedes hacer\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"

#. Tag: programlisting
#: using_postgis_dataman.xml:679
#, fuzzy, no-c-format
msgid ""
"--Lets say you created a derivative table by doing a bulk insert\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"--Create 2d index on new table\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"\n"
"-- If your points are 3D points or 3M points,\n"
"-- then you might want to create an nd index instead of a 2d index\n"
"-- like so\n"
"CREATE INDEX my_special_pois_geom_gist_nd\n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"--To manually register this new table's geometry column in geometry_columns\n"
"-- Note that this approach will work for both PostGIS 2.0+ and PostGIS 1.4+\n"
"-- For PostGIS 2.0 it will also change the underlying structure of the table "
"to\n"
"-- to make the column typmod based.\n"
"-- For PostGIS prior to 2.0, this technique can also be used to register "
"views\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n"
"\n"
"--If you are using PostGIS 2.0 and for whatever reason, you\n"
"-- you need the old constraint based definition behavior\n"
"-- (such as case of inherited tables where all children do not have the same "
"type and srid)\n"
"-- set new optional  use_typmod argument to false\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"
msgstr ""
"--Supongamos que has creado una tabla derivada al hacer una inserción "
"masiva\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"--Creamos un indice 2d en la tabla nueva\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"  \n"
"-- Si tus puntos son 3D o 3M, \n"
"-- Entonces querrás crear un indice nd en vez de un indice 2d\n"
"-- de la siguiente manera\n"
"CREATE INDEX my_special_pois_geom_gist_nd \n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"--Para registrar de forma manual la columna geometrica de la nueva tabla en "
"tu tabla geometry_columns\n"
"-- Fijate que este método funcionara en ambas versiones PostGIS 2.0+ y "
"PostGIS 1.4+\n"
"-- Para PostGIS 2.0 también cambiará  la estructura subyacente de la tabla "
"para\n"
"-- hacer la columna basada en typmod.\n"
"-- Para PostGIS anterior a 2.0, también se puede utilizar para registrar "
"vistas\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass); \n"
"\n"
"--Si esta utilizando PostGIS 2.0 y por cualquier razón,\n"
"-- necesitas la definición basada en las antiguas restricciones \n"
"-- (como el caso de tablas heredadas donde todas las tablas dependientes no "
"tienen el mismo tipo y srid)\n"
"-- selecciona el nuevo argumento opcional  use_typmod como false\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"

#. Tag: para
#: using_postgis_dataman.xml:681
#, fuzzy, no-c-format
msgid ""
"Although the old-constraint based method is still supported, a constraint-"
"based geometry column used directly in a view, will not register correctly "
"in geometry_columns, as will a typmod one. In this example we define a "
"column using typmod and another using constraints."
msgstr ""
"Aunque el método antiguo basado en restricciones aún se puede utilizar, una "
"columna geométrica basada en el uso de restricciones utilizada directamente "
"en la vista, no se registrará correctamente en geometry_columns, al igual "
"que una typmod. En este ejemplo se define una columna utilizando typmod y "
"otro mediante restricciones."

#. Tag: programlisting
#: using_postgis_dataman.xml:684
#, no-c-format
msgid ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY\n"
"   , poi_name text, cat varchar(20)\n"
"   , geom geometry(POINT,4326) );\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"
msgstr ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY\n"
"   , poi_name text, cat varchar(20)\n"
"   , geom geometry(POINT,4326) );\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"

#. Tag: para
#: using_postgis_dataman.xml:685
#, no-c-format
msgid "If we run in psql"
msgstr "Si ejecutamos en psql"

#. Tag: programlisting
#: using_postgis_dataman.xml:686
#, no-c-format
msgid "\\d pois_ny;"
msgstr "\\d pois_ny;"

#. Tag: para
#: using_postgis_dataman.xml:687
#, no-c-format
msgid ""
"We observe they are defined differently -- one is typmod, one is constraint"
msgstr ""
"Vemos que están definidas de forma diferente -- una es typmod, la otra por "
"restricciones."

#. Tag: screen
#: using_postgis_dataman.xml:688
#, fuzzy, no-c-format
msgid ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"
msgstr ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text \n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"

#. Tag: para
#: using_postgis_dataman.xml:689
#, no-c-format
msgid "In geometry_columns, they both register correctly"
msgstr "En geometry_columns, ambas se registran de forma correcta"

#. Tag: programlisting
#: using_postgis_dataman.xml:690
#, fuzzy, no-c-format
msgid ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"
msgstr ""
"SELECT f_table_name, f_geometry_column, srid, type \n"
"        FROM geometry_columns \n"
"        WHERE f_table_name = 'pois_ny';"

#. Tag: screen
#: using_postgis_dataman.xml:691
#, no-c-format
msgid ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"

#. Tag: para
#: using_postgis_dataman.xml:692
#, no-c-format
msgid "However -- if we were to create a view like this"
msgstr "De todas formas -- si queremos crear una vista de la siguiente forma"

#. Tag: programlisting
#: using_postgis_dataman.xml:693
#, fuzzy, no-c-format
msgid ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"CREATE VIEW vw_pois_ny_parks AS \n"
"SELECT * \n"
"  FROM pois_ny \n"
"  WHERE cat='park';\n"
"  \n"
"SELECT f_table_name, f_geometry_column, srid, type \n"
"        FROM geometry_columns \n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: para
#: using_postgis_dataman.xml:694
#, no-c-format
msgid ""
"The typmod based geom view column registers correctly, but the constraint "
"based one does not."
msgstr ""
"La columna de la vista basada en typmos se registra de forma correcta, pero "
"la basada en restricciones no."

#. Tag: screen
#: using_postgis_dataman.xml:696
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"
msgstr ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"

#. Tag: para
#: using_postgis_dataman.xml:698
#, no-c-format
msgid ""
"This may change in future versions of PostGIS, but for now To force the "
"constraint based view column to register correctly, we need to do this:"
msgstr ""
"Esto puede cambiar en versiones futuras de PostGIS, pero por el momento, "
"para forzar a las vistas basadas en restricciones a registrarse de forma "
"correcta, debemos hacer lo siguiente:"

#. Tag: programlisting
#: using_postgis_dataman.xml:700
#, fuzzy, no-c-format
msgid ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT gid, poi_name, cat\n"
"  , geom\n"
"  , geom_2160::geometry(POINT,2160) As geom_2160\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS \n"
"SELECT gid, poi_name, cat\n"
"  , geom\n"
"  , geom_2160::geometry(POINT,2160) As geom_2160 \n"
"  FROM pois_ny \n"
"  WHERE cat='park';\n"
"SELECT f_table_name, f_geometry_column, srid, type \n"
"        FROM geometry_columns \n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: screen
#: using_postgis_dataman.xml:701
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"

#. Tag: title
#: using_postgis_dataman.xml:705
#, no-c-format
msgid "Ensuring OpenGIS compliancy of geometries"
msgstr "Asegurando la compatibilidad de geometrias con OpenGIS"

#. Tag: para
#: using_postgis_dataman.xml:707
#, no-c-format
msgid ""
"PostGIS is compliant with the Open Geospatial Consortium’s (OGC) OpenGIS "
"Specifications. As such, many PostGIS methods require, or more accurately, "
"assume that geometries that are operated on are both simple and valid. For "
"example, it does not make sense to calculate the area of a polygon that has "
"a hole defined outside of the polygon, or to construct a polygon from a non-"
"simple boundary line."
msgstr ""
"PostGIS es compatible con la especificación Open Geospatial Consortium’s "
"(OGC) OpenGIS Specifications. Como tal, muchos métodos PostGIS requieren, o "
"más exactamente, asume que las geometrías con las que se opera son a la vez "
"simples y válidas. Por ejemplo, no tiene sentido calcular el área de un "
"polígono que tiene un agujero definido fuera del polígono, o para la "
"construcción de un polígono a partir de una línea de límite no simple."

#. Tag: para
#: using_postgis_dataman.xml:714
#, no-c-format
msgid ""
"According to the OGC Specifications, a <emphasis>simple</emphasis> geometry "
"is one that has no anomalous geometric points, such as self intersection or "
"self tangency and primarily refers to 0 or 1-dimensional geometries (i.e. "
"<varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). Geometry validity, on "
"the other hand, primarily refers to 2-dimensional geometries (i.e. "
"<varname>[MULTI]POLYGON)</varname> and defines the set of assertions that "
"characterizes a valid polygon. The description of each geometric class "
"includes specific conditions that further detail geometric simplicity and "
"validity."
msgstr ""
"Según las especificaciones OGC, una geometría <emphasis>simple</emphasis>, "
"es aquella que no tiene puntos geométricos anómalos, con autointersección o "
"auto tangencia y principalmente se refiere a geometrías de 0 o 1 dimensiones "
"(i.e. <varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). La validez de "
"geometrias, por otro lado, se refiere a geometrias de dimension 2 (i.e. "
"<varname>[MULTI]POLYGON)</varname> y define el conjunto afirmaciones que "
"caracterizan un polígono valido. La descripción de cada clase de geometría "
"incluye condiciones especificas que simplemente detalles de simplicidad y "
"validez geométricas."

#. Tag: para
#: using_postgis_dataman.xml:724
#, no-c-format
msgid ""
"A <varname>POINT</varname> is inheritably <emphasis>simple</emphasis> as a 0-"
"dimensional geometry object."
msgstr ""
"Un <varname>POINT</varname> es hereditariamente <emphasis>simple</emphasis> "
"como un objeto de geometría 0-dimensional."

#. Tag: para
#: using_postgis_dataman.xml:727
#, no-c-format
msgid ""
"<varname>MULTIPOINT</varname>s are <emphasis>simple</emphasis> if no two "
"coordinates (<varname>POINT</varname>s) are equal (have identical coordinate "
"values)."
msgstr ""
"<varname>MULTIPOINT</varname>s son simples <emphasis>simple</emphasis> si "
"dos coordenadas (<varname>POINT</varname>s) no son iguales (tienen valores "
"de coordenadas identicos)."

#. Tag: para
#: using_postgis_dataman.xml:731
#, no-c-format
msgid ""
"A <varname>LINESTRING</varname> is <emphasis>simple</emphasis> if it does "
"not pass through the same <varname>POINT</varname> twice (except for the "
"endpoints, in which case it is referred to as a linear ring and additionally "
"considered closed)."
msgstr ""
"Una <varname>LINESTRING</varname> es <emphasis>simple</emphasis> si no pasa "
"dos veces por el mismo <varname>POINT</varname> (excepto para puntos "
"finales, en cuyo caso nos referimos como linear ring y considerado como "
"cerrado)."

#. Tag: emphasis
#: using_postgis_dataman.xml:746
#, no-c-format
msgid "<emphasis>(a)</emphasis>"
msgstr "<emphasis>(a)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:756
#, no-c-format
msgid "<emphasis>(b)</emphasis>"
msgstr "<emphasis>(b)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:768
#, no-c-format
msgid "<emphasis>(c)</emphasis>"
msgstr "<emphasis>(c)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:778
#, no-c-format
msgid "<emphasis>(d)</emphasis>"
msgstr "<emphasis>(d)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:788
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(a)</emphasis> and <emphasis role=\"bold\">(c)</"
"emphasis> are simple <varname>LINESTRING</varname>s, <emphasis role=\"bold"
"\">(b)</emphasis> and <emphasis role=\"bold\">(d)</emphasis> are not."
msgstr ""
"<emphasis role=\"bold\">(a)</emphasis> y <emphasis role=\"bold\">(c)</"
"emphasis>son <varname>LINESTRING</varname>s simples, <emphasis role=\"bold"
"\">(b)</emphasis> y <emphasis role=\"bold\">(d)</emphasis> no lo son."

#. Tag: para
#: using_postgis_dataman.xml:797
#, no-c-format
msgid ""
"A <varname>MULTILINESTRING</varname> is <emphasis>simple</emphasis> only if "
"all of its elements are simple and the only intersection between any two "
"elements occurs at <varname>POINT</varname>s that are on the boundaries of "
"both elements."
msgstr ""
"Una <varname>MULTILINESTRING</varname> es <emphasis>simple</emphasis> solo "
"si todos sus elementos son simples y las únicas intersecciones entre "
"cualquiera de sus elementos, se produce en <varname>POINT</varname>s que "
"están en los limites de ambos elementos."

#. Tag: emphasis
#: using_postgis_dataman.xml:812
#, no-c-format
msgid "<emphasis>(e)</emphasis>"
msgstr "<emphasis>(e)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:822
#, no-c-format
msgid "<emphasis>(f)</emphasis>"
msgstr "<emphasis>(f)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:832
#, no-c-format
msgid "<emphasis>(g)</emphasis>"
msgstr "<emphasis>(g)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:842
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(e)</emphasis> and <emphasis role=\"bold\">(f)</"
"emphasis> are simple <varname>MULTILINESTRING</varname>s, <emphasis role="
"\"bold\">(g)</emphasis> is not."
msgstr ""
"<emphasis role=\"bold\">(e)</emphasis> y <emphasis role=\"bold\">(f)</"
"emphasis> son <varname>MULTILINESTRING</varname>s simples, <emphasis role="
"\"bold\">(g)</emphasis> no lo es."

#. Tag: para
#: using_postgis_dataman.xml:851
#, no-c-format
msgid ""
"By definition, a <varname>POLYGON</varname> is always <emphasis>simple</"
"emphasis>. It is <emphasis>valid</emphasis> if no two rings in the boundary "
"(made up of an exterior ring and interior rings) cross. The boundary of a "
"<varname>POLYGON</varname> may intersect at a <varname>POINT</varname> but "
"only as a tangent (i.e. not on a line). A <varname>POLYGON</varname> may not "
"have cut lines or spikes and the interior rings must be contained entirely "
"within the exterior ring."
msgstr ""
"Por definición, un <varname>POLYGON</varname> siempre será <emphasis>simple</"
"emphasis>. Es <emphasis>valido</emphasis> si dos anillos del borde (formado "
"por un anillo exterior y los anillos interiores) no se cruzan. El borde de "
"un <varname>POLYGON</varname> debe intersectarse en un <varname>POINT</"
"varname> pero solo como tangente (i.e. no en una linea). Un "
"<varname>POLYGON</varname>no debe tener lineas de corte  o picos y los "
"anillos interiores deben estar contenidos por entero por el anillo exterior."

#. Tag: emphasis
#: using_postgis_dataman.xml:869
#, no-c-format
msgid "<emphasis>(h)</emphasis>"
msgstr "<emphasis>(h)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:879
#, no-c-format
msgid "<emphasis>(i)</emphasis>"
msgstr "<emphasis>(i)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:889
#, no-c-format
msgid "<emphasis>(j)</emphasis>"
msgstr "<emphasis>(j)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:901
#, no-c-format
msgid "<emphasis>(k)</emphasis>"
msgstr "<emphasis>(k)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:911
#, no-c-format
msgid "<emphasis>(l)</emphasis>"
msgstr "<emphasis>(l)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:921
#, no-c-format
msgid "<emphasis>(m)</emphasis>"
msgstr "<emphasis>(m)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:930
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(h)</emphasis> and <emphasis role=\"bold\">(i)</"
"emphasis> are valid <varname>POLYGON</varname>s, <emphasis role=\"bold\">(j-"
"m)</emphasis> cannot be represented as single <varname>POLYGON</varname>s, "
"but <emphasis role=\"bold\">(j)</emphasis> and <emphasis role=\"bold\">(m)</"
"emphasis> could be represented as a valid <varname>MULTIPOLYGON</varname>."
msgstr ""
"<emphasis role=\"bold\">(h)</emphasis> y <emphasis role=\"bold\">(i)</"
"emphasis> son <varname>POLYGON</varname>s validos, <emphasis role=\"bold"
"\">(j-m)</emphasis> no se pueden representar como <varname>POLYGON</"
"varname>s simples, pero <emphasis role=\"bold\">(j)</emphasis> y <emphasis "
"role=\"bold\">(m)</emphasis> pueden representarse como un "
"<varname>MULTIPOLYGON</varname> valido."

#. Tag: para
#: using_postgis_dataman.xml:942
#, no-c-format
msgid ""
"A <varname>MULTIPOLYGON</varname> is <emphasis>valid</emphasis> if and only "
"if all of its elements are valid and the interiors of no two elements "
"intersect. The boundaries of any two elements may touch, but only at a "
"finite number of <varname>POINT</varname>s."
msgstr ""
"Un <varname>MULTIPOLYGON</varname> es <emphasis>válido</emphasis> si y sólo "
"si todos sus elementos son válidos y no se producen intersecciones entre los "
"interiores de ningún par de elementos. Los límietes de cualquiera de los dos "
"elementos pueden tocarse, pero sólo en un número finito de <varname>POINT</"
"varname>s."

#. Tag: emphasis
#: using_postgis_dataman.xml:957
#, no-c-format
msgid "<emphasis>(n)</emphasis>"
msgstr "<emphasis>(n)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:967
#, no-c-format
msgid "<emphasis>(o)</emphasis>"
msgstr "<emphasis>(o)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:977
#, no-c-format
msgid "<emphasis>(p)</emphasis>"
msgstr "<emphasis>(p)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:986
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(n)</emphasis> and <emphasis role=\"bold\">(o)</"
"emphasis> are not valid <varname>MULTIPOLYGON</varname>s. <emphasis role="
"\"bold\">(p)</emphasis>, however, is valid."
msgstr ""
"<emphasis role=\"bold\">(n)</emphasis> y <emphasis role=\"bold\">(o)</"
"emphasis> no son  <varname>MULTIPOLYGON</varname>s validos. <emphasis role="
"\"bold\">(p)</emphasis>, sin embargo, es valido."

#. Tag: para
#: using_postgis_dataman.xml:995
#, no-c-format
msgid ""
"Most of the functions implemented by the GEOS library rely on the assumption "
"that your geometries are valid as specified by the OpenGIS Simple Feature "
"Specification. To check simplicity or validity of geometries you can use the "
"<link linkend=\"ST_IsSimple\">ST_IsSimple()</link> and <link linkend="
"\"ST_IsValid\">ST_IsValid()</link>"
msgstr ""
"La mayoría de las funciones implementadas por la biblioteca GEOS dependen de "
"la asunción de que las geometrías son válidad según lo especificado en la "
"OpenGIS Simple Feature Specification. Para comprobar la simplicidad o "
"validez de geometrías se puede usar <link linkend=\"ST_IsSimple"
"\">ST_IsSimple()</link> and <link linkend=\"ST_IsValid\">ST_IsValid()</link>"

#. Tag: programlisting
#: using_postgis_dataman.xml:1001
#, no-c-format
msgid ""
"-- Typically, it doesn't make sense to check\n"
"-- for validity on linear features since it will always return TRUE.\n"
"-- But in this example, PostGIS extends the definition of the OGC IsValid\n"
"-- by returning false if a LineString has less than 2 *distinct* vertices.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"
msgstr ""
"--Normalmente, no tiene sentido hacer la comprobación\n"
"-- de validez o elementos lineales, ya que siempre devolverá TRUE.\n"
"-- Pero en este ejemplo, PostGIS extiende la deficinción del IsValid de OGC\n"
"--devolviendo FALSE si una LineString tiene menos de 2 vértices "
"*distintos*.\n"
"gisdb=# SELECT\n"
"ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
"st_isvalid | st_isvalid\n"
"------------+-----------\n"
"t | f"

#. Tag: para
#: using_postgis_dataman.xml:1003
#, no-c-format
msgid ""
"By default, PostGIS does not apply this validity check on geometry input, "
"because testing for validity needs lots of CPU time for complex geometries, "
"especially polygons. If you do not trust your data sources, you can manually "
"enforce such a check to your tables by adding a check constraint:"
msgstr ""
"Por defecto, PostGIS no comprueba la validez en las geometrías entrantes, "
"porque los test de validez necesitan gran cantidad de tiempo de CPU para "
"geometrías complejas, en especial polígonos. Si no se está seguro de la "
"fuente de datos se puede forzar manualmente a realizar la comprobación de "
"las tablas añadiendo una restricción de comprobación: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1009
#, no-c-format
msgid ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"
msgstr ""
"ALTER TABLE mytable\n"
"ADD CONSTRAINT geometry_valid_check\n"
"CHECK (ST_IsValid(the_geom));"

#. Tag: para
#: using_postgis_dataman.xml:1011
#, no-c-format
msgid ""
"If you encounter any strange error messages such as \"GEOS Intersection() "
"threw an error!\" or \"JTS Intersection() threw an error!\" when calling "
"PostGIS functions with valid input geometries, you likely found an error in "
"either PostGIS or one of the libraries it uses, and you should contact the "
"PostGIS developers. The same is true if a PostGIS function returns an "
"invalid geometry for valid input."
msgstr ""
"Si eincuentras algún mensaje de error extraño como  \"GEOS Intersection() "
"threw an error!\" o \"JTS Intersection() threw an error!\" al llamar a las "
"funciones de  PostGIS con geometrías de entrada válidas, seguramente se deba "
"a algún error bien en  PostGIS o en una de las bibliotecas que usa, y "
"deberías contactar con el equipo de desarrollo de PostGIS. Lo mismo es "
"aplicable si una función de PostGIS devuelve una geometría inválida a partir "
"de una entrada válida. "

#. Tag: para
#: using_postgis_dataman.xml:1019
#, no-c-format
msgid ""
"Strictly compliant OGC geometries cannot have Z or M values. The <link "
"linkend=\"ST_IsValid\">ST_IsValid()</link> function won't consider higher "
"dimensioned geometries invalid! Invocations of <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> will add a constraint "
"checking geometry dimensions, so it is enough to specify 2 there."
msgstr ""
"Geometrías estrictamente compatibles con OGC no pueden tener valores Z o M."
"¡La función <link linkend=\"ST_IsValid\">ST_IsValid()</link> no considerará "
"invalidas las geometrías con mas dimensiones! Llamadas a <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> añadirá restricciones al "
"comprobar las dimensiones de las geometrías, así que es suficiente con "
"especificar 2."

#. Tag: title
#: using_postgis_dataman.xml:1029
#, no-c-format
msgid "Dimensionally Extended 9 Intersection Model (DE-9IM)"
msgstr "Modelo de intersección 9 dimensionalmente extendido(DE-9IM)"

#. Tag: para
#: using_postgis_dataman.xml:1031
#, no-c-format
msgid ""
"It is sometimes the case that the typical spatial predicates (<xref linkend="
"\"ST_Contains\"/>, <xref linkend=\"ST_Crosses\"/>, <xref linkend="
"\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>, ...) are insufficient "
"in and of themselves to adequately provide that desired spatial filter."
msgstr ""
"A veces se da el caso que los predicados espaciales típicos (<xref linkend="
"\"ST_Contains\"/>, <xref linkend=\"ST_Crosses\"/>, <xref linkend="
"\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>, ...) son insuficientes "
"en si mismos para proveer el filtro espacial deseado."

#. Tag: para
#: using_postgis_dataman.xml:1043
#, no-c-format
msgid ""
"For example, consider a linear dataset representing a road network. It may "
"be the task of a GIS analyst to identify all road segments that cross each "
"other, not at a point, but on a line, perhaps invalidating some business "
"rule. In this case, <xref linkend=\"ST_Crosses\"/> does not adequately "
"provide the necessary spatial filter since, for linear features, it returns "
"<varname>true</varname> only where they cross at a point."
msgstr ""
"Por ejemplo, considera un conjunto de datos lineales representando una red "
"de transportes. Es tarea del analista SIG identificar todos los segmentos de "
"carreteras que se intersectan con otros, no en un punto, pero en una linea, "
"quizás invalidando algunas reglas. En este caso,  <xref linkend=\"ST_Crosses"
"\"/> no nos proporcionara el filtro espacial adecuado ya que , para "
"elementos lineales, devolverá <varname>true</varname> solo en el caso de "
"intersección en un punto."

#. Tag: para
#: using_postgis_dataman.xml:1050
#, no-c-format
msgid ""
"One two-step solution might be to first perform the actual intersection "
"(<xref linkend=\"ST_Intersection\"/>) of pairs of road segments that "
"spatially intersect (<xref linkend=\"ST_Intersects\"/>), and then compare "
"the intersection's <xref linkend=\"ST_GeometryType\"/> with "
"'<varname>LINESTRING</varname>' (properly dealing with cases that return "
"<varname>GEOMETRYCOLLECTION</varname>s of <varname>[MULTI]POINT</varname>s, "
"<varname>[MULTI]LINESTRING</varname>s, etc.)."
msgstr ""
"Una solución en dos pasos podría ser, primero hacer una consulta de las "
"intersecciones (<xref linkend=\"ST_Intersection\"/>) de los pares de vías de "
"comunicación que se intersectan espacialmente (<xref linkend=\"ST_Intersects"
"\"/>), y entonces comparar las intersecciones <xref linkend=\"ST_GeometryType"
"\"/> con '<varname>LINESTRING</varname>' (gestionando correctamente los "
"casos que devuelvan <varname>GEOMETRYCOLLECTION</varname> de "
"<varname>[MULTI]POINT</varname>s, <varname>[MULTI]LINESTRING</varname>s, "
"etc.)."

#. Tag: para
#: using_postgis_dataman.xml:1058
#, no-c-format
msgid "A more elegant / faster solution may indeed be desirable."
msgstr "Una solución mas elegante/rápida  de hecho puede ser deseable."

#. Tag: para
#: using_postgis_dataman.xml:1072
#, no-c-format
msgid ""
"A second [theoretical] example may be that of a GIS analyst trying to locate "
"all wharfs or docks that intersect a lake's boundary on a line and where "
"only one end of the wharf is up on shore. In other words, where a wharf is "
"within, but not completely within a lake, intersecting the boundary of a "
"lake on a line, and where the wharf's endpoints are both completely within "
"and on the boundary of the lake. The analyst may need to use a combination "
"of spatial predicates to isolate the sought after features:"
msgstr ""
"Un [teórico] segundo ejemplo puede ser el de un analista SIG intentando "
"localizar todos los muelles que intersectan los limites de un lago en una "
"linea y donde solo un extremo del muelle este en la orilla. En otras "
"palabras, cuando el muelle este contenido , pero no completamente en el "
"lago, intersectando el borde del lago en una linea, y donde los puntos "
"finales del muelle estén completamente en el borde del lago. El analista "
"necesitará utilizar una combinación de predicados espaciales para aislar el "
"problema:"

#. Tag: para
#: using_postgis_dataman.xml:1083
#, no-c-format
msgid "(lake, wharf) = TRUE"
msgstr "(lake, wharf) = TRUE"

#. Tag: para
#: using_postgis_dataman.xml:1087
#, no-c-format
msgid "(lake, wharf) = FALSE"
msgstr "(lake, wharf) = FALSE"

#. Tag: para
#: using_postgis_dataman.xml:1091
#, no-c-format
msgid "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"
msgstr "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"

#. Tag: para
#: using_postgis_dataman.xml:1096
#, no-c-format
msgid ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"
msgstr ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"

#. Tag: para
#: using_postgis_dataman.xml:1099
#, no-c-format
msgid "... (needless to say, this could get quite complicated)"
msgstr "... (ni que decir tiene que esto podría llegar a ser muy complicado)"

#. Tag: para
#: using_postgis_dataman.xml:1108
#, no-c-format
msgid ""
"So enters the Dimensionally Extended 9 Intersection Model, or DE-9IM for "
"short."
msgstr ""
"Así que introducimos el Modelo de Intersección 9 Dimensionalmente Extendido, "
"o DE-9IM para abreviar."

#. Tag: title
#: using_postgis_dataman.xml:1112
#, no-c-format
msgid "Theory"
msgstr "Teoria"

#. Tag: para
#: using_postgis_dataman.xml:1114
#, no-c-format
msgid ""
"According to the <ulink url=\"http://www.opengeospatial.org/standards/sfs"
"\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, "
"\"the basic approach to comparing two geometries is to make pair-wise tests "
"of the intersections between the Interiors, Boundaries and Exteriors of the "
"two geometries and to classify the relationship between the two geometries "
"based on the entries in the resulting 'intersection' matrix.\""
msgstr ""
"Según la especificación <ulink url=\"http://www.opengeospatial.org/standards/"
"sfs\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, "
"\"El enfoque básico para comparar dos geometrías es hacer un test por pares "
"de la intersección entre los interiores, bordes y exteriores de las dos "
"geometrías y clasificar las relaciones entre las dos geometrías basandose en "
"las entradas de la 'matriz de intersección' resultante.\""

#. Tag: glossterm
#: using_postgis_dataman.xml:1125
#, no-c-format
msgid "<glossterm>Boundary</glossterm>"
msgstr "<glossterm>Borde</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1128
#, no-c-format
msgid ""
"The boundary of a geometry is the set of geometries of the next lower "
"dimension. For <varname>POINT</varname>s, which have a dimension of 0, the "
"boundary is the empty set. The boundary of a <varname>LINESTRING</varname> "
"are the two endpoints. For <varname>POLYGON</varname>s, the boundary is the "
"linework that make up the exterior and interior rings."
msgstr ""
"El borde de una geometría es el conjunto de geometrias de la dimension menor "
"siguiente. Para <varname>POINT</varname>s, que tienen dimension 0, el borde "
"es un conjunto vacío. El borde para un <varname>LINESTRING</varname> son los "
"dos puntos de los extremos. Para <varname>POLYGON</varname>s, el borde son "
"las lineas que delimitan los anillos exteriores e interiores."

#. Tag: glossterm
#: using_postgis_dataman.xml:1139
#, no-c-format
msgid "<glossterm>Interior</glossterm>"
msgstr "<glossterm>Interior</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1142
#, no-c-format
msgid ""
"The interior of a geometry are those points of a geometry that are left when "
"the boundary is removed. For <varname>POINT</varname>s, the interior is the "
"<varname>POINT</varname> itself. The interior of a <varname>LINESTRING</"
"varname> are the set of real points between the endpoints. For "
"<varname>POLYGON</varname>s, the interior is the areal surface inside the "
"polygon."
msgstr ""
"El interior de una geometría son los puntos de la geometría que quedan "
"cuando el borde es eliminado. Para <varname>POINT</varname>s, el interior es "
"el propio <varname>POINT</varname>. El interior de una <varname>LINESTRING</"
"varname> es el conjunto de puntos reales entre los puntos de los extremos. "
"Para <varname>POLYGON</varname>s, el interior es una superficie real dentro "
"del polígono. "

#. Tag: glossterm
#: using_postgis_dataman.xml:1153
#, no-c-format
msgid "<glossterm>Exterior</glossterm>"
msgstr "<glossterm>Exterior</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1156
#, no-c-format
msgid ""
"The exterior of a geometry is the universe, an areal surface, not on the "
"interior or boundary of the geometry."
msgstr ""
"El Exterior de una geometría es el universo, una superficie real, que no se "
"encuentra en el interior o en el borde de la geometría."

#. Tag: para
#: using_postgis_dataman.xml:1163
#, no-c-format
msgid ""
"Given geometry <emphasis>a</emphasis>, where the <emphasis>I(a)</emphasis>, "
"<emphasis>B(a)</emphasis>, and <emphasis>E(a)</emphasis> are the "
"<emphasis>Interior</emphasis>, <emphasis>Boundary</emphasis>, and "
"<emphasis>Exterior</emphasis> of a, the mathematical representation of the "
"matrix is:"
msgstr ""
"Dada una geometria <emphasis>a</emphasis>, donde <emphasis>I(a)</emphasis>, "
"<emphasis>B(a)</emphasis>, y <emphasis>E(a)</emphasis> son el "
"<emphasis>Interior</emphasis>, <emphasis>Borde</emphasis>, y "
"<emphasis>Exterior</emphasis> de a, la representación matemática de la "
"matriz es:"

#. Tag: emphasis
#: using_postgis_dataman.xml:1175 using_postgis_dataman.xml:1185
#: using_postgis_dataman.xml:1269 using_postgis_dataman.xml:1282
#, no-c-format
msgid "<emphasis role=\"bold\">Interior</emphasis>"
msgstr "<emphasis role=\"bold\">Interior</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1177 using_postgis_dataman.xml:1191
#: using_postgis_dataman.xml:1272 using_postgis_dataman.xml:1305
#, no-c-format
msgid "<emphasis role=\"bold\">Boundary</emphasis>"
msgstr "<emphasis role=\"bold\">Borde</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1179 using_postgis_dataman.xml:1197
#: using_postgis_dataman.xml:1275 using_postgis_dataman.xml:1328
#, no-c-format
msgid "<emphasis role=\"bold\">Exterior</emphasis>"
msgstr "<emphasis role=\"bold\">Exterior</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1186
#, no-c-format
msgid "dim( I(a) ∩ I(b) )"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1187
#, no-c-format
msgid "dim( I(a) ∩ B(b) )"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1188
#, no-c-format
msgid "dim( I(a) ∩ E(b) )"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1192
#, no-c-format
msgid "dim( B(a) ∩ I(b) )"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1193
#, no-c-format
msgid "dim( B(a) ∩ B(b) )"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1194
#, no-c-format
msgid "dim( B(a) ∩ E(b) )"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1198
#, no-c-format
msgid "dim( E(a) ∩ I(b) )"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1199
#, no-c-format
msgid "dim( E(a) ∩ B(b) )"
msgstr ""

#. Tag: emphasis
#: using_postgis_dataman.xml:1200
#, no-c-format
msgid "dim( E(a) ∩ E(b) )"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1207
#, no-c-format
msgid ""
"Where <emphasis>dim(a)</emphasis> is the dimension of <emphasis>a</emphasis> "
"as specified by <xref linkend=\"ST_Dimension\"/> but has the domain of "
"<literal>{0,1,2,T,F,*}</literal>"
msgstr ""
"Donde <emphasis>dim(a)</emphasis> representa la dimensión de  <emphasis>a</"
"emphasis> como se especifica en  <xref linkend=\"ST_Dimension\"/> pero tiene "
"un dominio de <literal>{0,1,2,T,F,*}</literal>"

#. Tag: para
#: using_postgis_dataman.xml:1214
#, no-c-format
msgid "<literal>0</literal> =&gt; point"
msgstr "<literal>0</literal> =&gt; punto"

#. Tag: para
#: using_postgis_dataman.xml:1218
#, no-c-format
msgid "<literal>1</literal> =&gt; line"
msgstr "<literal>1</literal> =&gt; linea"

#. Tag: para
#: using_postgis_dataman.xml:1222
#, no-c-format
msgid "<literal>2</literal> =&gt; area"
msgstr "<literal>2</literal> =&gt; area"

#. Tag: para
#: using_postgis_dataman.xml:1226
#, no-c-format
msgid "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"
msgstr "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"

#. Tag: para
#: using_postgis_dataman.xml:1231
#, no-c-format
msgid "<literal>F</literal> =&gt; empty set"
msgstr "<literal>F</literal> =&gt; empty set"

#. Tag: para
#: using_postgis_dataman.xml:1235
#, no-c-format
msgid "<literal>*</literal> =&gt; don't care"
msgstr "<literal>*</literal> =&gt; no importa que valor"

#. Tag: para
#: using_postgis_dataman.xml:1239
#, no-c-format
msgid "Visually, for two overlapping polygonal geometries, this looks like:"
msgstr ""
"Visualmente, para dos geometriías que se superponen, debera parecerse a:"

#. Tag: para
#: using_postgis_dataman.xml:1286 using_postgis_dataman.xml:1298
#: using_postgis_dataman.xml:1332 using_postgis_dataman.xml:1344
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1292 using_postgis_dataman.xml:1309
#: using_postgis_dataman.xml:1321 using_postgis_dataman.xml:1338
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1315
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1356
#, no-c-format
msgid ""
"Read from left to right and from top to bottom, the dimensional matrix is "
"represented, '<emphasis role=\"bold\">212101212</emphasis>'."
msgstr ""
"Si leemos la matriz de izquierda a derecha y de arriba a bajo, la matriz "
"dimensional esta representada por, '<emphasis role=\"bold\">212101212</"
"emphasis>'."

#. Tag: para
#: using_postgis_dataman.xml:1359
#, no-c-format
msgid ""
"A relate matrix that would therefore represent our first example of two "
"lines that intersect on a line would be: '<emphasis role=\"bold\">1*1***1**</"
"emphasis>'"
msgstr ""
"Una matriz que representaría el ejemplo anterior de las dos lineas que se "
"interceptan en una linea seria: '<emphasis role=\"bold\">1*1***1**</"
"emphasis>'"

#. Tag: programlisting
#: using_postgis_dataman.xml:1363
#, fuzzy, no-c-format
msgid ""
"-- Identify road segments that cross on a line\n"
"SELECT a.id\n"
"FROM roads a, roads b\n"
"WHERE a.id != b.id\n"
"AND a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '1*1***1**');"
msgstr ""
"-- Identificar los segmentos de lineas que se cruzan en una linea\n"
"SELECT a.id\n"
"FROM roads a, roads b\n"
"WHERE a.id != b.id \n"
"AND a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '1*1***1**');"

#. Tag: para
#: using_postgis_dataman.xml:1365
#, no-c-format
msgid ""
"A relate matrix that represents the second example of wharfs partly on the "
"lake's shoreline would be '<emphasis role=\"bold\">102101FF2</emphasis>'"
msgstr ""
"La matriz que representaría el segundo ejemplo de los muelles en los lagos "
"seria: '<emphasis role=\"bold\">102101FF2</emphasis>'"

#. Tag: programlisting
#: using_postgis_dataman.xml:1369
#, no-c-format
msgid ""
"-- Identify wharfs partly on a lake's shoreline\n"
"SELECT a.lake_id, b.wharf_id\n"
"FROM lakes a, wharfs b\n"
"WHERE a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '102101FF2');"
msgstr ""
"-- Identificar los muelles que están parcialmente en la orilla del lago\n"
"SELECT a.lake_id, b.wharf_id\n"
"FROM lakes a, wharfs b\n"
"WHERE a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '102101FF2');"

#. Tag: para
#: using_postgis_dataman.xml:1371
#, no-c-format
msgid "For more information or reading, see:"
msgstr "Para mas información o documentación, visita:"

#. Tag: para
#: using_postgis_dataman.xml:1375
#, no-c-format
msgid ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink> (version 1.1, section "
"2.1.13.2)"
msgstr ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink> (versión 1.1, sección "
"2.1.13.2)"

#. Tag: ulink
#: using_postgis_dataman.xml:1380
#, fuzzy, no-c-format
msgid "Dimensionally Extended Nine-Intersection Model (DE-9IM)"
msgstr "Modelo de intersección 9 dimensionalmente extendido(DE-9IM)"

#. Tag: ulink
#: using_postgis_dataman.xml:1384
#, no-c-format
msgid "GeoTools: Point Set Theory and the DE-9IM Matrix"
msgstr "GeoTools: Point Set Theory and the DE-9IM Matrix"

#. Tag: para
#: using_postgis_dataman.xml:1387
#, no-c-format
msgid "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"
msgstr "<emphasis>Encyclopedia of GIS</emphasis> por Hui Xiong"

#. Tag: title
#: using_postgis_dataman.xml:1397
#, fuzzy, no-c-format
msgid "Loading GIS (Vector) Data"
msgstr "Cargando Datos SIG"

#. Tag: para
#: using_postgis_dataman.xml:1399
#, no-c-format
msgid ""
"Once you have created a spatial table, you are ready to upload GIS data to "
"the database. Currently, there are two ways to get data into a PostGIS/"
"PostgreSQL database: using formatted SQL statements or using the Shape file "
"loader/dumper."
msgstr ""
"Una vez creada la tabla espacial, estas listo para cargar datos SIG en la "
"base de datos. Actualmente, existen dos formas de poner los datos en una "
"base de datos PostGIS/PostgreSQL: utilizando sentencias SQL formateadas, o "
"utilizando el cargador de ficheros Shape."

#. Tag: title
#: using_postgis_dataman.xml:1405
#, fuzzy, no-c-format
msgid "Loading Data Using SQL"
msgstr "Cargando Datos SIG"

#. Tag: para
#: using_postgis_dataman.xml:1407
#, no-c-format
msgid ""
"If you can convert your data to a text representation, then using formatted "
"SQL might be the easiest way to get your data into PostGIS. As with Oracle "
"and other SQL databases, data can be bulk loaded by piping a large text file "
"full of SQL \"INSERT\" statements into the SQL terminal monitor."
msgstr ""
"Si puedes convertir tus datos en una representación de texto, entonces "
"utilizar SQL formateado debería ser la forma mas sencilla de cargar tus "
"datos en PostGIS. Asi como en Oracle o otras bases de datos SQL, los datos "
"pueden ser cargados en masa mediante la canalización de un fichero de texto "
"grande, lleno de sentencias SQL \"INSERT\" en el terminal SQL."

#. Tag: para
#: using_postgis_dataman.xml:1413
#, no-c-format
msgid ""
"A data upload file (<filename>roads.sql</filename> for example) might look "
"like this:"
msgstr ""
"Un fichero de carga (<filename>roads.sql</filename> por ejemplo) debería "
"parecerse a esto:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1416
#, no-c-format
msgid ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 "
"243242)',-1),'Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 "
"244817)',-1),'Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 "
"229814)',-1),'Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 "
"259122)',-1),'Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 "
"228134)',-1),'Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 "
"268322)',-1),'Dave Cres');\n"
"COMMIT;"
msgstr ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 "
"243242)',-1),'Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 "
"244817)',-1),'Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 "
"229814)',-1),'Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 "
"259122)',-1),'Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 "
"228134)',-1),'Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 "
"268322)',-1),'Dave Cres');\n"
"COMMIT;"

#. Tag: para
#: using_postgis_dataman.xml:1418
#, no-c-format
msgid ""
"The data file can be piped into PostgreSQL very easily using the \"psql\" "
"SQL terminal monitor:"
msgstr ""
"El fichero de datos puede canalizarse en PostgreSQL de manera sencilla con "
"el terminar de comandos SQL \"psql\":"

#. Tag: programlisting
#: using_postgis_dataman.xml:1421
#, no-c-format
msgid "psql -d [database] -f roads.sql"
msgstr "psql -d [database] -f roads.sql"

#. Tag: title
#: using_postgis_dataman.xml:1425
#, no-c-format
msgid "shp2pgsql: Using the ESRI Shapefile Loader"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1427
#, no-c-format
msgid ""
"The <filename>shp2pgsql</filename> data loader converts ESRI Shape files "
"into SQL suitable for insertion into a PostGIS/PostgreSQL database either in "
"geometry or geography format. The loader has several operating modes "
"distinguished by command line flags:"
msgstr ""
"El cargador de datos Shape <filename>shp2pgsql</filename> convierte fichero "
"Shape de ESRI en comandos SQL para la inserción en bases de datos PostGIS/"
"PostgreSQL en formatos geometry o geography. El cargador tiene diferentes "
"modos de operar según las opciones escritas en el comando:"

#. Tag: para
#: using_postgis_dataman.xml:1432
#, no-c-format
msgid ""
"In addition to the shp2pgsql command-line loader, there is an "
"<filename>shp2pgsql-gui</filename> graphical interface with most of the "
"options as the command-line loader, but may be easier to use for one-off non-"
"scripted loading or if you are new to PostGIS. It can also be configured as "
"a plugin to PgAdminIII."
msgstr ""
"Ademas del cargador por linea de comandos shp2pgsql, existe una interfaz "
"gráfica llamada <filename>shp2pgsql-gui</filename>, con la mayoría de las "
"opciones del cargador por linea de comandos, pero puede ser mas sencillo de "
"utilizar para aquellas que no estén en scripts o ficheros único o si eres "
"nuevo en PostGIS. También se puede configurara como un plugin de PgAdminIII."

#. Tag: term
#: using_postgis_dataman.xml:1439
#, no-c-format
msgid "(c|a|d|p) These are mutually exclusive options:"
msgstr "(c|a|d|p) Estas opciones son exclusivas entre ellas:"

#. Tag: term
#: using_postgis_dataman.xml:1444
#, no-c-format
msgid "<term>-c</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1446
#, no-c-format
msgid ""
"Creates a new table and populates it from the shapefile. <emphasis>This is "
"the default mode.</emphasis>"
msgstr ""
"Crea una nueva tabla y la rellena desde el shapefile. <emphasis>Esta es la "
"opción por defecto.</emphasis>"

#. Tag: term
#: using_postgis_dataman.xml:1454
#, no-c-format
msgid "<term>-a</term>"
msgstr "<term>-a</term>"

#. Tag: para
#: using_postgis_dataman.xml:1456
#, no-c-format
msgid ""
"Appends data from the Shape file into the database table. Note that to use "
"this option to load multiple files, the files must have the same attributes "
"and same data types."
msgstr ""
"Añade los datos del shapefile en la tabla de la base de datos. Observa que "
"para utilizar esta opción para cargar varios ficheros, los ficheros deben "
"tener los mismos atributos y los mismos tipos de datos."

#. Tag: term
#: using_postgis_dataman.xml:1465 using_postgis_dataman.xml:1854
#, no-c-format
msgid "<term>-d</term>"
msgstr "<term>-d</term>"

#. Tag: para
#: using_postgis_dataman.xml:1467
#, no-c-format
msgid ""
"Drops the database table before creating a new table with the data in the "
"Shape file."
msgstr ""
"Borra la tabla de la base de datos antes de crear una nueva tabla con los "
"datos del shapefile en su interior."

#. Tag: term
#: using_postgis_dataman.xml:1475
#, no-c-format
msgid "<term>-p</term>"
msgstr "<term>-p</term>"

#. Tag: para
#: using_postgis_dataman.xml:1477
#, no-c-format
msgid ""
"Only produces the table creation SQL code, without adding any actual data. "
"This can be used if you need to completely separate the table creation and "
"data loading steps."
msgstr ""
"Solo produce el código del comando SQL de creación de la tabla, sin añadir "
"ningún dato. Esto puede utilizarse si necesitas separar completamente los "
"pasos de creación de la tabla y de carga de datos"

#. Tag: term
#: using_postgis_dataman.xml:1490
#, no-c-format
msgid "<term>-?</term>"
msgstr "<term>-?</term>"

#. Tag: para
#: using_postgis_dataman.xml:1492
#, no-c-format
msgid "Display help screen."
msgstr "Muestra la ayuda en pantalla."

#. Tag: term
#: using_postgis_dataman.xml:1499
#, no-c-format
msgid "<term>-D</term>"
msgstr "<term>-D</term>"

#. Tag: para
#: using_postgis_dataman.xml:1501
#, no-c-format
msgid ""
"Use the PostgreSQL \"dump\" format for the output data. This can be combined "
"with -a, -c and -d. It is much faster to load than the default \"insert\" "
"SQL format. Use this for very large data sets."
msgstr ""
"Utiliza el formato \"dump\" de PostgreSQL en la salida de datos. Esto puede "
"combinarse con -a, -c, y -d. Es mucho mas rápido cargar este fichero \"dump"
"\" que utilizando en comando SQL \"INSERT\" por defecto. Utiliza esto ara "
"grandes conjuntos de datos."

#. Tag: term
#: using_postgis_dataman.xml:1510
#, no-c-format
msgid "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"
msgstr "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1512
#, no-c-format
msgid ""
"Creates and populates the geometry tables with the specified SRID. "
"Optionally specifies that the input shapefile uses the given FROM_SRID, in "
"which case the geometries will be reprojected to the target SRID. FROM_SRID "
"cannot be specified with -D."
msgstr ""
"Crea y rellena las tablas geométricas con el SRID especificado. "
"Opcionalmente especifica que el fichero shapefile utiliza el dado en "
"FROM_SRID, en tal caso las geometrías se reproyectarán  al SRID destino. "
"FROM_SRID no puede espeficarse con -D "

#. Tag: term
#: using_postgis_dataman.xml:1523
#, no-c-format
msgid "<term>-k</term>"
msgstr "<term>-k</term>"

#. Tag: para
#: using_postgis_dataman.xml:1525
#, no-c-format
msgid ""
"Keep identifiers' case (column, schema and attributes). Note that attributes "
"in Shapefile are all UPPERCASE."
msgstr ""
"Mantiene las mayúsculas en los identificadores (columnas, esquemas y "
"atributos). Observa que los atributos en los shapefiles están siempre en "
"MAYÚSCULAS."

#. Tag: term
#: using_postgis_dataman.xml:1533
#, no-c-format
msgid "<term>-i</term>"
msgstr "<term>-i</term>"

#. Tag: para
#: using_postgis_dataman.xml:1535
#, no-c-format
msgid ""
"Coerce all integers to standard 32-bit integers, do not create 64-bit "
"bigints, even if the DBF header signature appears to warrant it."
msgstr ""
"Fuerza la creación de enteros a enteros estándar de 32-bits, no crea enteros "
"bigint de 64-bits, aunque la firma de la cabecera del DBF parezca que lo "
"garantiza."

#. Tag: term
#: using_postgis_dataman.xml:1543
#, no-c-format
msgid "<term>-I</term>"
msgstr "<term>-I</term>"

#. Tag: para
#: using_postgis_dataman.xml:1545
#, no-c-format
msgid "Create a GiST index on the geometry column."
msgstr "Crea un indice GiST de la columna de geometrias."

#. Tag: term
#: using_postgis_dataman.xml:1552
#, fuzzy, no-c-format
msgid "<term>-m</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1554
#, no-c-format
msgid ""
"-m <filename>a_file_name</filename> Specify a file containing a set of "
"mappings of (long) column names to 10 character DBF column names. The "
"content of the file is one or more lines of two names separated by white "
"space and no trailing or leading space. For example:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1559
#, no-c-format
msgid ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"
msgstr ""

#. Tag: term
#: using_postgis_dataman.xml:1565
#, no-c-format
msgid "<term>-S</term>"
msgstr "<term>-S</term>"

#. Tag: para
#: using_postgis_dataman.xml:1567
#, no-c-format
msgid ""
"Generate simple geometries instead of MULTI geometries. Will only succeed if "
"all the geometries are actually single (I.E. a MULTIPOLYGON with a single "
"shell, or or a MULTIPOINT with a single vertex)."
msgstr ""
"Genera geometrías simples en lugar de MULTI geometrías. Solo funcionará si "
"todas las geometrias son actualmente simples (I.E. un MULTIPOLYGON con una "
"única capa, o un MULTIPOINT con un único vértice). "

#. Tag: term
#: using_postgis_dataman.xml:1576
#, no-c-format
msgid "-t &lt;dimensionality&gt;"
msgstr "-t &lt;dimensionality&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1578
#, no-c-format
msgid ""
"Force the output geometry to have the specified dimensionality. Use the "
"following strings to indicate the dimensionality: 2D, 3DZ, 3DM, 4D."
msgstr ""
"Fuerza a que la geometría de salida tenga la dimensión especificada. Utiliza "
"las siguientes cadenas para indicar la dimensión: 2D, 3DZ, 3DM, 4D."

#. Tag: para
#: using_postgis_dataman.xml:1582
#, no-c-format
msgid ""
"If the input has fewer dimensions that specified, the output will have those "
"dimensions filled in with zeroes. If the input has more dimensions that "
"specified, the unwanted dimensions will be stripped."
msgstr ""
"Si la entrada tiene menos dimensiones de las especificadas, la salida tendrá "
"estas dimensiones rellenas con ceros. Si la entrada tiene mas dimensiones de "
"las especificadas, las dimensiones no deseadas se eliminarán."

#. Tag: term
#: using_postgis_dataman.xml:1591
#, no-c-format
msgid "<term>-w</term>"
msgstr "<term>-w</term>"

#. Tag: para
#: using_postgis_dataman.xml:1593
#, no-c-format
msgid ""
"Output WKT format, instead of WKB. Note that this can introduce coordinate "
"drifts due to loss of precision."
msgstr ""
"Salida en formato WKT, en vez de WKB. Observa que esto puede introducir "
"derivas en las coordenadas debido a la perdida de precisión."

#. Tag: term
#: using_postgis_dataman.xml:1601
#, no-c-format
msgid "<term>-e</term>"
msgstr "<term>-e</term>"

#. Tag: para
#: using_postgis_dataman.xml:1603
#, no-c-format
msgid ""
"Execute each statement on its own, without using a transaction. This allows "
"loading of the majority of good data when there are some bad geometries that "
"generate errors. Note that this cannot be used with the -D flag as the \"dump"
"\" format always uses a transaction."
msgstr ""
"Ejecuta cada sentencia una por una, sin utilizar una transacción. Esto "
"permite cargar la mayoría de datos correctos cuando existen algunas "
"geometrías no validas que generan errores. Observa que esta opción no se "
"puede utilizar con -D ya que el formato \"dump\" siempre utiliza "
"transacciones."

#. Tag: term
#: using_postgis_dataman.xml:1613
#, no-c-format
msgid "-W &lt;encoding&gt;"
msgstr "-W &lt;encoding&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1615
#, no-c-format
msgid ""
"Specify encoding of the input data (dbf file). When used, all attributes of "
"the dbf are converted from the specified encoding to UTF8. The resulting SQL "
"output will contain a <code>SET CLIENT_ENCODING to UTF8</code> command, so "
"that the backend will be able to reconvert from UTF8 to whatever encoding "
"the database is configured to use internally."
msgstr ""
"Especifica la codificación de los datos de entrada (fichero dbf). Cuando se "
"utiliza, todos los atributos del fichero dbf son convertidos desde la "
"codificación especificada a UTF8. La salida SQL resultante contendrá un "
"comando <code>SET CLIENT_ENCODING to UTF8</code>, así que el backend sera "
"capaz de reconvertir desde UTF8 a cualquier codificación que este "
"configurada en la base de datos para uso interno."

#. Tag: term
#: using_postgis_dataman.xml:1625
#, no-c-format
msgid "-N &lt;policy&gt;"
msgstr "-N &lt;policy&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1627
#, no-c-format
msgid "NULL geometries handling policy (insert*,skip,abort)"
msgstr "Políticas de gestión de geometrías NULL (insert*, skip, abort)"

#. Tag: term
#: using_postgis_dataman.xml:1633
#, no-c-format
msgid "<term>-n</term>"
msgstr "<term>-n</term>"

#. Tag: para
#: using_postgis_dataman.xml:1635
#, no-c-format
msgid ""
"-n Only import DBF file. If your data has no corresponding shapefile, it "
"will automatically switch to this mode and load just the dbf. So setting "
"this flag is only needed if you have a full shapefile set, and you only want "
"the attribute data and no geometry."
msgstr ""
"-n solo importa los ficheros dbf. Si tus datos no tienen shapefiles "
"correspondientes, se cambiara de forma automática a este modo y se cargara "
"únicamente el dbf. Así que esta opción solo se necesita si lo unifico que "
"quieres cargar son los atributos y no las geometrías."

#. Tag: term
#: using_postgis_dataman.xml:1643
#, no-c-format
msgid "<term>-G</term>"
msgstr "<term>-G</term>"

#. Tag: para
#: using_postgis_dataman.xml:1645
#, no-c-format
msgid ""
"Use geography type instead of geometry (requires lon/lat data) in WGS84 long "
"lat (SRID=4326)"
msgstr ""
"Utiliza el tipo \"geography\" en lugar del tipo \"geometry\" (requiere datos "
"en lon/lat) en WGS84 long lat (SRID=4326)"

#. Tag: term
#: using_postgis_dataman.xml:1651
#, no-c-format
msgid "-T &lt;tablespace&gt;"
msgstr "-T &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1653
#, no-c-format
msgid ""
"Specify the tablespace for the new table. Indexes will still use the default "
"tablespace unless the -X parameter is also used. The PostgreSQL "
"documentation has a good description on when to use custom tablespaces."
msgstr ""
"Especifica el \"tablespace\" para la nueva tabla.Los indices seguirán "
"utilizando el \"tablespace\" por defecto a menos que el parámetro -X este en "
"uso. La documentación de PostgreSQL tiene una buena descripción de los "
"\"tablespaces\" personalizados."

#. Tag: term
#: using_postgis_dataman.xml:1661
#, no-c-format
msgid "-X &lt;tablespace&gt;"
msgstr "-X &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1663
#, no-c-format
msgid ""
"Specify the tablespace for the new table's indexes. This applies to the "
"primary key index, and the GIST spatial index if -I is also used."
msgstr ""
"Especifica el \"tablespace\" para los indices de la nueva tabla. Esto se "
"aplica a los indices de clave primaria y a los indices espaciales GiST si se "
"usa también la opción -l."

#. Tag: para
#: using_postgis_dataman.xml:1671
#, no-c-format
msgid ""
"An example session using the loader to create an input file and uploading it "
"might look like this:"
msgstr ""
"Un ejemplo de sesión utilizando el cargador para crear un fichero de entrada "
"y cargarlo debe parecerse a esto:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1676
#, no-c-format
msgid ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"
msgstr ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"

#. Tag: para
#: using_postgis_dataman.xml:1678
#, no-c-format
msgid "A conversion and upload can be done all in one step using UNIX pipes:"
msgstr ""
"Una conversion y carga puede hacerse en un solo paso utilizando el símbolo "
"tubería en sistemas UNIX:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1682
#, no-c-format
msgid "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"
msgstr "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"

#. Tag: title
#: using_postgis_dataman.xml:1687
#, no-c-format
msgid "Retrieving GIS Data"
msgstr "Recuperando datos SIG"

#. Tag: para
#: using_postgis_dataman.xml:1689
#, no-c-format
msgid ""
"Data can be extracted from the database using either SQL or the Shape file "
"loader/dumper. In the section on SQL we will discuss some of the operators "
"available to do comparisons and queries on spatial tables."
msgstr ""
"Los datos se pueden extraer de la base de datos utilizando SQL o el cargador/"
"dumper de ficheros Shape. En la sección SQL hablaremos de algunos de los "
"operadores disponibles para hacer comparaciones y consultas en tablas "
"espaciales."

#. Tag: title
#: using_postgis_dataman.xml:1695
#, no-c-format
msgid "Using SQL to Retrieve Data"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1697
#, no-c-format
msgid ""
"The most straightforward means of pulling data out of the database is to use "
"a SQL select query to reduce the number of RECORDS and COLUMNS returned and "
"dump the resulting columns into a parsable text file:"
msgstr ""
"El medio más directo para hacer una extracción de datos de la base de datos "
"es utilizar una consulta de selección SQL para reducir el número de "
"registros y columnas devueltas y volcar las columnas resultantes en un "
"archivo de texto analizable:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1702
#, no-c-format
msgid ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"
msgstr ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"

#. Tag: para
#: using_postgis_dataman.xml:1704
#, no-c-format
msgid ""
"However, there will be times when some kind of restriction is necessary to "
"cut down the number of fields returned. In the case of attribute-based "
"restrictions, just use the same SQL syntax as normal with a non-spatial "
"table. In the case of spatial restrictions, the following operators are "
"available/useful:"
msgstr ""
"Sin embargo, habrá ocasiones que debido a algún tipo de restricción será "
"necesario reducir el número de campos que se devuelven . En el caso de "
"restricciones basadas en los atributos, sólo tienes que utilizar la misma "
"sintaxis SQL de forma normal como con una tabla no espacial. En el caso de "
"restricciones espaciales, están disponibles los siguientes operadores:"

#. Tag: term
#: using_postgis_dataman.xml:1712
#, no-c-format
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#. Tag: para
#: using_postgis_dataman.xml:1715
#, no-c-format
msgid ""
"This operator tells whether the bounding box of one geometry intersects the "
"bounding box of another."
msgstr ""
"Este operador indica si el límite de una geometría forma intersección con el "
"límite de otra."

#. Tag: term
#: using_postgis_dataman.xml:1721
#, no-c-format
msgid "ST_OrderingEquals"
msgstr "ST_OrderingEquals"

#. Tag: para
#: using_postgis_dataman.xml:1724
#, no-c-format
msgid ""
"This tests whether two geometries are geometrically identical. For example, "
"if 'POLYGON((0 0,1 1,1 0,0 0))' is the same as 'POLYGON((0 0,1 1,1 0,0 "
"0))' (it is)."
msgstr ""
"Este test comprueba si dos geometrías son geométricamente idénticas. Por "
"ejemplo, si 'POLYGON((0 0,1 1,1 0,0 0))' es la misma que 'POLYGON((0 0,1 1,1 "
"0,0 0))' (si que lo es)."

#. Tag: term
#: using_postgis_dataman.xml:1731
#, no-c-format
msgid "<term>=</term>"
msgstr "<term>=</term>"

#. Tag: para
#: using_postgis_dataman.xml:1734
#, no-c-format
msgid ""
"This operator is a little more naive, it only tests whether the bounding "
"boxes of two geometries are the same."
msgstr ""
"Este operador es un poco mas \"inocente\", solo comprueba si los límites "
"(bounding boxes) de dos geometrías son los mismos."

#. Tag: para
#: using_postgis_dataman.xml:1740
#, no-c-format
msgid ""
"Next, you can use these operators in queries. Note that when specifying "
"geometries and boxes on the SQL command line, you must explicitly turn the "
"string representations into geometries by using the \"ST_GeomFromText()\" "
"function. The 312 is a fictitious spatial reference system that matches our "
"data. So, for example:"
msgstr ""
"A continuación, puedes utilizar estos operadores en las consultas. Ten en "
"cuenta que al especificar geometrías y cajas en la línea de comandos SQL, "
"debes activar de forma explícita las representaciones de cadena en "
"geometrías utilizando la función \"ST_GeomFromText ()\". El 312 es un "
"sistema de referencia espacial ficticio que coincide con nuestros datos. Así "
"que, por ejemplo:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1746
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE ST_OrderingEquals(roads_geom , ST_GeomFromText('LINESTRING(191232 "
"243118,191108 243242)',312) ) ;"
msgstr ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE ST_OrderingEquals(roads_geom , ST_GeomFromText('LINESTRING(191232 "
"243118,191108 243242)',312) ) ;"

#. Tag: para
#: using_postgis_dataman.xml:1748
#, no-c-format
msgid ""
"The above query would return the single record from the \"ROADS_GEOM\" table "
"in which the geometry was equal to that value."
msgstr ""
"La consulta anterior deberá devolver el único registro de la tabla "
"\"ROADS_GEOM\" cuya geometría era igual a este valor."

#. Tag: para
#: using_postgis_dataman.xml:1751
#, no-c-format
msgid ""
"When using the \"&amp;&amp;\" operator, you can specify either a BOX3D as "
"the comparison feature or a GEOMETRY. When you specify a GEOMETRY, however, "
"its bounding box will be used for the comparison."
msgstr ""
"Cuando utilizamos el operador \"&amp;&amp;\", puedes especificar ya sea un "
"BOX3D como la función de comparación o una GEOMETRY. Cuando se especifica "
"una geometría, sin embargo, se utiliza para la comparación su cuadro "
"delimitador (bounding box)."

#. Tag: programlisting
#: using_postgis_dataman.xml:1756
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))',312);"
msgstr ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))',312);"

#. Tag: para
#: using_postgis_dataman.xml:1758
#, no-c-format
msgid ""
"The above query will use the bounding box of the polygon for comparison "
"purposes."
msgstr ""
"La consulta anterior utiliza los limites (bounding box) del polígono para la "
"comparación."

#. Tag: para
#: using_postgis_dataman.xml:1761
#, no-c-format
msgid ""
"The most common spatial query will probably be a \"frame-based\" query, used "
"by client software, like data browsers and web mappers, to grab a \"map frame"
"\" worth of data for display. Using a \"BOX3D\" object for the frame, such a "
"query looks like this:"
msgstr ""
"La consulta espacial más común probablemente será una consulta \"basada en "
"cuadros\", utilizada por el software cliente, como navegadores de datos o "
"aplicaciones webmapping, para tomar un valor del \"marco del mapa \" de los "
"datos para su visualización. La consulta para el uso de un objeto \"BOX3D\" "
"para el marco, se parece a esto:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1766
#, no-c-format
msgid ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"
msgstr ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"

#. Tag: para
#: using_postgis_dataman.xml:1768
#, no-c-format
msgid ""
"Note the use of the SRID 312, to specify the projection of the envelope."
msgstr ""
"Observa el uso del SRID 123, para espeficar la proyección de la envolvente."

#. Tag: title
#: using_postgis_dataman.xml:1772
#, no-c-format
msgid "Using the Dumper"
msgstr "Uso del Dumper"

#. Tag: para
#: using_postgis_dataman.xml:1774
#, no-c-format
msgid ""
"The <filename>pgsql2shp</filename> table dumper connects directly to the "
"database and converts a table (possibly defined by a query) into a shape "
"file. The basic syntax is:"
msgstr ""
"El comando dump de las tablas <filename>pgsql2shp</filename> conecta "
"directamente con la base de datos y convierte la tabla (posiblemente "
"definido por una consulta) en un fichero shape. La sintaxis básica es:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1778
#, no-c-format
msgid ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"
msgstr ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"

#. Tag: programlisting
#: using_postgis_dataman.xml:1780
#, no-c-format
msgid "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"
msgstr "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1782
#, no-c-format
msgid "The commandline options are:"
msgstr "Las opciones del comando son:"

#. Tag: term
#: using_postgis_dataman.xml:1786
#, no-c-format
msgid "-f &lt;filename&gt;"
msgstr "-f &lt;filename&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1789
#, no-c-format
msgid "Write the output to a particular filename."
msgstr "Escribe la salida en un fichero con un nombre particular"

#. Tag: term
#: using_postgis_dataman.xml:1794
#, no-c-format
msgid "-h &lt;host&gt;"
msgstr "-h &lt;host&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1797
#, no-c-format
msgid "The database host to connect to."
msgstr "Especifica el servidor al que conectarse."

#. Tag: term
#: using_postgis_dataman.xml:1802
#, no-c-format
msgid "-p &lt;port&gt;"
msgstr "-p &lt;port&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1805
#, no-c-format
msgid "The port to connect to on the database host."
msgstr ""
"Especifica el puerto del servidor de la base de datos al que conectarse."

#. Tag: term
#: using_postgis_dataman.xml:1810
#, no-c-format
msgid "-P &lt;password&gt;"
msgstr "-P &lt;password&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1813
#, no-c-format
msgid "The password to use when connecting to the database."
msgstr "La contraseña a utilizar en la conexión de la base de datos."

#. Tag: term
#: using_postgis_dataman.xml:1818
#, no-c-format
msgid "-u &lt;user&gt;"
msgstr "-u &lt;user&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1821
#, no-c-format
msgid "The username to use when connecting to the database."
msgstr "El nombre del usuario a utilizar en la conexión a la base de datos."

#. Tag: term
#: using_postgis_dataman.xml:1826
#, no-c-format
msgid "-g &lt;geometry column&gt;"
msgstr "-g &lt;geometry column&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1829
#, no-c-format
msgid ""
"In the case of tables with multiple geometry columns, the geometry column to "
"use when writing the shape file."
msgstr ""
"En el caso que las tablas tengan varias columnas de geometrías, la columna "
"de geometrías a utilizar cuando se escriba el fichero shape."

#. Tag: term
#: using_postgis_dataman.xml:1835
#, no-c-format
msgid "<term>-b</term>"
msgstr "<term>-b</term>"

#. Tag: para
#: using_postgis_dataman.xml:1838
#, no-c-format
msgid ""
"Use a binary cursor. This will make the operation faster, but will not work "
"if any NON-geometry attribute in the table lacks a cast to text."
msgstr ""
"Utiliza un cursor binario. Esto hada las operaciones mas rápido, pero no "
"funcionará si algún atributo NO-geométrico de la tabla carece de conversion "
"a texto."

#. Tag: term
#: using_postgis_dataman.xml:1845
#, no-c-format
msgid "<term>-r</term>"
msgstr "<term>-r</term>"

#. Tag: para
#: using_postgis_dataman.xml:1848
#, no-c-format
msgid ""
"Raw mode. Do not drop the <varname>gid</varname> field, or escape column "
"names."
msgstr ""
"Modo Raw. No suprime el campo <varname>gid</varname>, o omite los nombres de "
"las columnas."

#. Tag: para
#: using_postgis_dataman.xml:1857
#, no-c-format
msgid ""
"For backward compatibility: write a 3-dimensional shape file when dumping "
"from old (pre-1.0.0) postgis databases (the default is to write a 2-"
"dimensional shape file in that case). Starting from postgis-1.0.0+, "
"dimensions are fully encoded."
msgstr ""
"Por compatibilidad con versiones anteriores: escribir un archivo shape de 3 "
"dimensiones cuando consultamos desde bases de datos PostGIS antiguas "
"(pre-1.0.0) (el valor por defecto es el de escribir un archivo de formas de "
"2 dimensiones en ese caso). A partir de postgis-1.0.0 +, dimensiones están "
"completamente codificados."

#. Tag: term
#: using_postgis_dataman.xml:1865
#, no-c-format
msgid "-m <varname>filename</varname>"
msgstr "-m <varname>filename</varname>"

#. Tag: para
#: using_postgis_dataman.xml:1867
#, no-c-format
msgid ""
"Remap identifiers to ten character names. The content of the file is lines "
"of two symbols separated by a single white space and no trailing or leading "
"space: VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."
msgstr ""
"Reasignar los identificadores de diez nombres de los personajes. El "
"contenido del archivo son líneas de dos símbolos separados por un único "
"espacio en blanco y sin espacios al final, o al inicio: VERYLONGSYMBOL "
"SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."

#. Tag: title
#: using_postgis_dataman.xml:1880
#, no-c-format
msgid "Building Indexes"
msgstr "Contruir Indices"

#. Tag: para
#: using_postgis_dataman.xml:1882
#, no-c-format
msgid ""
"Indexes are what make using a spatial database for large data sets possible. "
"Without indexing, any search for a feature would require a \"sequential scan"
"\" of every record in the database. Indexing speeds up searching by "
"organizing the data into a search tree which can be quickly traversed to "
"find a particular record. PostgreSQL supports three kinds of indexes by "
"default: B-Tree indexes, R-Tree indexes, and GiST indexes."
msgstr ""
"Los índices son los que hacen posible el uso de una base de datos espacial "
"para conjuntos de datos muy grandes. Sin indexación, cualquier búsqueda de "
"una característica requeriría un \"recorrido secuencial\" de cada registro "
"en la base de datos. La Indexación acelera la búsqueda mediante la "
"organización de los datos en un árbol de búsqueda que puede ser recorrido "
"con rapidez para encontrar un registro en particular. PostgreSQL soporta "
"tres tipos de índices por defecto: índices B-Tree, índices R-Tree, e índices "
"GIST."

#. Tag: para
#: using_postgis_dataman.xml:1892
#, no-c-format
msgid ""
"B-Trees are used for data which can be sorted along one axis; for example, "
"numbers, letters, dates. GIS data cannot be rationally sorted along one axis "
"(which is greater, (0,0) or (0,1) or (1,0)?) so B-Tree indexing is of no use "
"for us."
msgstr ""
"B-Trees se utiliza para datos que pueden ser ordenados a lo largo de un eje, "
"por ejemplo, números, letras, fechas.Los datos SIG no pueden ser "
"racionalmente ordenados a lo largo de un eje (¿cual es mayor? ¿(0,0) o (0,1) "
"o (1,0)?) así que los indices B-Tree no son de ninguna utilidad para "
"nosotros."

#. Tag: para
#: using_postgis_dataman.xml:1899
#, no-c-format
msgid ""
"R-Trees break up data into rectangles, and sub-rectangles, and sub-sub "
"rectangles, etc. R-Trees are used by some spatial databases to index GIS "
"data, but the PostgreSQL R-Tree implementation is not as robust as the GiST "
"implementation."
msgstr ""
"R-Trees divide los datos en rectángulos y sub-rectángulos, y sub-sub "
"rectángulos, etc R-Tree se utiliza en algunas bases de datos espaciales para "
"indexar datos GIS, pero la implementación PostgreSQL R-Tree no es tan "
"robusta como la de GiST."

#. Tag: para
#: using_postgis_dataman.xml:1906
#, no-c-format
msgid ""
"GiST (Generalized Search Trees) indexes break up data into \"things to one "
"side\", \"things which overlap\", \"things which are inside\" and can be "
"used on a wide range of data-types, including GIS data. PostGIS uses an R-"
"Tree index implemented on top of GiST to index GIS data."
msgstr ""
"Los indices GiST (Generalized Search Trees o Arbol de búsquedas "
"generalizado) dividen los datos en \"cosas a un lado\", \"cosas que se "
"solapan\", \"cosas que están dentro\" y se pueden utilizar en una amplia "
"gama de tipos de datos, incluyendo los datos SIG. PostGIS utiliza un índice "
"R-Tree implementado sobre GiST para indexar datos GIS."

#. Tag: title
#: using_postgis_dataman.xml:1915
#, no-c-format
msgid "GiST Indexes"
msgstr "Indices GiST"

#. Tag: para
#: using_postgis_dataman.xml:1917
#, no-c-format
msgid ""
"GiST stands for \"Generalized Search Tree\" and is a generic form of "
"indexing. In addition to GIS indexing, GiST is used to speed up searches on "
"all kinds of irregular data structures (integer arrays, spectral data, etc) "
"which are not amenable to normal B-Tree indexing."
msgstr ""
"GiST significa \"Generalized Search Tree\" de sus siglas en inglés o \"Arbol "
"de Búsqueda Generalizado\" y es una forma genérica de indexación. Además de "
"la indexación de datos SIG, GiST se utiliza para acelerar las búsquedas en "
"todo tipo de estructuras irregulares de datos (arrays de enteros, datos "
"espectrales, etc) que no son susceptibles de indexación por árbol normal."

#. Tag: para
#: using_postgis_dataman.xml:1922
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields)."
msgstr ""
"Una vez que una tabla de datos GIS supera unos pocos miles de filas, tendrás "
"que construir un índice para acelerar las búsquedas espaciales de los datos "
"(a menos que todas las búsquedas se basen en atributos, en cuyo caso querrás "
"construir un índice normal en los campos de atributo)."

#. Tag: para
#: using_postgis_dataman.xml:1927
#, no-c-format
msgid ""
"The syntax for building a GiST index on a \"geometry\" column is as follows:"
msgstr ""
"La sintaxis para la creación de un indice GiST en una columna \"geometry\" "
"es como sigue:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1930
#, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1931
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get the an n-dimensional "
"index supported in PostGIS 2.0+ for the geometry type, you can create one "
"using this syntax"
msgstr ""
"La sintaxis anterior siempre construirá un índice 2D. Para obtener el índice "
"de dimensión n soportado en PostGIS 2.0 + para el tipo geometría, puedes "
"crearlo utilizando esta sintaxis"

#. Tag: programlisting
#: using_postgis_dataman.xml:1932
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1934
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive exercise: on tables "
"of around 1 million rows, on a 300MHz Solaris machine, we have found "
"building a GiST index takes about 1 hour. After building an index, it is "
"important to force PostgreSQL to collect table statistics, which are used to "
"optimize query plans:"
msgstr ""
"La construcción de un índice espacial es un ejercicio de cálculo intensivo: "
"en tablas de alrededor de 1 millón de filas, en una máquina de 300 MHz "
"Solaris, hemos encontrado que la construcción de un índice de GiST dura "
"aproximadamente 1 hora. Después de la construcción de un índice, es "
"importante obligar a PostgreSQL recopilar las estadísticas de tabla que se "
"utilizan para optimizar los planes de consulta:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1940 using_postgis_dataman.xml:2023
#, no-c-format
msgid ""
"VACUUM ANALYZE [table_name] [(column_name)];\n"
"-- This is only needed for PostgreSQL 7.4 installations and below\n"
"SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);"
msgstr ""
"VACUUM ANALYZE [table_name] [(column_name)];\n"
"-- This is only needed for PostgreSQL 7.4 installations and below\n"
"SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);"

#. Tag: para
#: using_postgis_dataman.xml:1942
#, no-c-format
msgid ""
"GiST indexes have two advantages over R-Tree indexes in PostgreSQL. Firstly, "
"GiST indexes are \"null safe\", meaning they can index columns which include "
"null values. Secondly, GiST indexes support the concept of \"lossiness\" "
"which is important when dealing with GIS objects larger than the PostgreSQL "
"8K page size. Lossiness allows PostgreSQL to store only the \"important\" "
"part of an object in an index -- in the case of GIS objects, just the "
"bounding box. GIS objects larger than 8K will cause R-Tree indexes to fail "
"in the process of being built."
msgstr ""
"Los índices GiST tienen dos ventajas respecto a los índices R-Tree en "
"PostgreSQL. En primer lugar, los índices GiST son \"null safe\", lo que "
"significa que puede indexar columnas que incluyen valores nulos. En segundo "
"lugar, los índices GiST apoyan el concepto de \"capacidad de disipación\", "
"que es importante cuando se trata de objetos GIS más grandes que el tamaño "
"de página de 8K PostgreSQL. La capacidad de disipación permite a PostgreSQL "
"almacenar sólo la parte \"importante\" de un objeto en un índice - en el "
"caso de objetos SIG, sólo el cuadro delimitador (bounding box). Los objetos "
"GIS mayores de 8 KB provocaran fallos en los índices R-Tree en el proceso de "
"construcción."

#. Tag: title
#: using_postgis_dataman.xml:1954
#, fuzzy, no-c-format
msgid "BRIN Indexes"
msgstr "Indices GiST"

#. Tag: para
#: using_postgis_dataman.xml:1956
#, no-c-format
msgid ""
"BRIN stands for \"Block Range Index\" and is a generic form of indexing that "
"has been introduced in PostgreSQL 9.5. BRIN is a lossy kind of index, and "
"its main usage is to provide a compromise for both read and write "
"performance. Its primary goal is to handle very large tables for which some "
"of the columns have some natural correlation with their physical location "
"within the table. In addition to GIS indexing, BRIN is used to speed up "
"searches on various kinds of regular or irregular data structures (integer, "
"arrays etc)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1965
#, fuzzy, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields). GiST indexes are really performant as long as their "
"size doesn't exceed the amount of RAM available for the database, and as "
"long as you can afford the storage size, and the penalty in write workload. "
"Otherwise, BRIN index can be considered as an alternative."
msgstr ""
"Una vez que una tabla de datos GIS supera unos pocos miles de filas, tendrás "
"que construir un índice para acelerar las búsquedas espaciales de los datos "
"(a menos que todas las búsquedas se basen en atributos, en cuyo caso querrás "
"construir un índice normal en los campos de atributo)."

#. Tag: para
#: using_postgis_dataman.xml:1974
#, no-c-format
msgid ""
"The idea of a BRIN index is to store only the bouding box englobing all the "
"geometries contained in all the rows in a set of table blocks, called a "
"range. Obviously, this indexing method will only be efficient if the data is "
"physically ordered in a way where the resulting bouding boxes for block "
"ranges will be mutually exclusive. The resulting index will be really small, "
"but will be less efficient than a GiST index in many cases."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1982
#, no-c-format
msgid ""
"Building a BRIN index is way less intensive than building a GiST index. It's "
"quite common to build a BRIN index in more than ten time less than a GiST "
"index would have required. As a BRIN index only store one bouding box for "
"one to many table blocks, it's pretty common to consume up to a thousand "
"time less disk space for this kind of indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1988
#, no-c-format
msgid ""
"You can choose the number of blocks to summarize in a range. If you decrease "
"this number, the index will be bigger but will probably help to get better "
"performance."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1992
#, fuzzy, no-c-format
msgid ""
"The syntax for building a BRIN index on a \"geometry\" column is as follows:"
msgstr ""
"La sintaxis para la creación de un indice GiST en una columna \"geometry\" "
"es como sigue:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1995
#, fuzzy, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1996
#, fuzzy, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get a 3d-dimensional "
"index, you can create one using this syntax"
msgstr ""
"La sintaxis anterior siempre construirá un índice 2D. Para obtener el índice "
"de dimensión n soportado en PostGIS 2.0 + para el tipo geometría, puedes "
"crearlo utilizando esta sintaxis"

#. Tag: programlisting
#: using_postgis_dataman.xml:1997
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_3d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1998
#, no-c-format
msgid "You can also get a 4d-dimensional index using the 4d operator class"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1999
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_4d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:2000
#, no-c-format
msgid ""
"These above syntaxes will use the default number or block in a range, which "
"is 128. To specify the number of blocks you want to summarise in a range, "
"you can create one using this syntax"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:2001
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] ) WITH "
"(pages_per_range = [number]);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:2002
#, no-c-format
msgid ""
"Also, keep in mind that a BRIN index will only store one index value for a "
"large number of rows. If your table stores geometries with a mixed number of "
"dimensions, it's likely that the resulting index will have poor performance. "
"You can avoid this drop of performance by choosing the operator class whith "
"the least number of dimensions of the stored geometries"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2010
#, fuzzy, no-c-format
msgid ""
"Also the \"geography\" datatype is supported for BRIN indexing. The syntax "
"for building a BRIN index on a \"geography\" column is as follows:"
msgstr ""
"La sintaxis para la creación de un indice GiST en una columna \"geometry\" "
"es como sigue:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2013
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geographyfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:2014
#, fuzzy, no-c-format
msgid ""
"The above syntax will always build a 2D-index for geospatial objects on the "
"spheroid."
msgstr ""
"La sintaxis anterior siempre construirá un índice 2D. Para obtener el índice "
"de dimensión n soportado en PostGIS 2.0 + para el tipo geometría, puedes "
"crearlo utilizando esta sintaxis"

#. Tag: para
#: using_postgis_dataman.xml:2016
#, no-c-format
msgid ""
"Currently, just the \"inclusion support\" is considered here, meaning that "
"just <varname>&amp;&amp;</varname>, <varname>~</varname> and <varname>@</"
"varname> operators can be used for the 2D cases (both for \"geometry\" and "
"for \"geography\"), and just the <varname>&amp;&amp;&amp;</varname> operator "
"can be used for the 3D geometries. There is no support for kNN searches at "
"the moment."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2027
#, no-c-format
msgid "Using Indexes"
msgstr "Utilizando Indices"

#. Tag: para
#: using_postgis_dataman.xml:2029
#, no-c-format
msgid ""
"Ordinarily, indexes invisibly speed up data access: once the index is built, "
"the query planner transparently decides when to use index information to "
"speed up a query plan. Unfortunately, the PostgreSQL query planner does not "
"optimize the use of GiST indexes well, so sometimes searches which should "
"use a spatial index instead default to a sequence scan of the whole table."
msgstr ""
"Por lo general, los índices aceleran el acceso de datos de forma invisible: "
"una vez construido el índice, el optimizador de consultas decide de manera "
"transparente cuándo utilizar la información del índice para acelerar un plan "
"de consulta. Por desgracia, el planeador de consultas de PostgreSQL no "
"optimiza el uso de índices GiST bien, así que a veces las búsquedas que "
"deben utilizar un índice espacial en lugar del indice por defecto, explora "
"toda la tabla de forma secuencia."

#. Tag: para
#: using_postgis_dataman.xml:2036
#, no-c-format
msgid ""
"If you find your spatial indexes are not being used (or your attribute "
"indexes, for that matter) there are a couple things you can do:"
msgstr ""
"Si observas que los indices espaciales no se están utilizando (o tus indices "
"de atributos, en su defecto) hay un par de cosas que puedes hacer:"

#. Tag: para
#: using_postgis_dataman.xml:2042
#, no-c-format
msgid ""
"Firstly, make sure statistics are gathered about the number and "
"distributions of values in a table, to provide the query planner with better "
"information to make decisions around index usage. For PostgreSQL 7.4 "
"installations and below this is done by running "
"<command>update_geometry_stats([table_name, column_name])</command> (compute "
"distribution) and <command>VACUUM ANALYZE [table_name] [column_name]</"
"command> (compute number of values). Starting with PostgreSQL 8.0 running "
"<command>VACUUM ANALYZE</command> will do both operations. You should "
"regularly vacuum your databases anyways -- many PostgreSQL DBAs have "
"<command>VACUUM</command> run as an off-peak cron job on a regular basis."
msgstr ""
"En primer lugar, asegurate de que se recopilan estadísticas sobre el número "
"y distribución de los valores de una tabla, para proporcionar al planeador "
"de consultas una mejor información para tomar decisiones en torno a la "
"utilización de índices. Para instalaciones de PostgreSQL 7.4 y menores, esto "
"se hace ejecutando <command> update_geometry_stats \n"
" ([table_name, column_name]) </command> (distribución de cálculo) y "
"<command>VACUUM ANALYZE [table_name] [column_name]</command> (número de "
"cómputo de valores). A partir de PostgreSQL 8.0, ejecutando el combado  "
"<command> VACUUM ANALYZE </command> se ejecutaran ambas operaciones. Debes "
"ejecutar el comando vacuum regularmente  en tus bases de datos de todos "
"modos - muchos PostgreSQL DBAs  tienen  la opción de ejecutar "
"<command>VACUUM </command> como una tarea de cron de menor actividad sobre "
"una base regular."

#. Tag: para
#: using_postgis_dataman.xml:2056
#, no-c-format
msgid ""
"If vacuuming does not work, you can force the planner to use the index "
"information by using the <command>SET ENABLE_SEQSCAN=OFF</command> command. "
"You should only use this command sparingly, and only on spatially indexed "
"queries: generally speaking, the planner knows better than you do about when "
"to use normal B-Tree indexes. Once you have run your query, you should "
"consider setting <varname>ENABLE_SEQSCAN</varname> back on, so that other "
"queries will utilize the planner as normal."
msgstr ""
"Si ejecutando vacuum no funciona, se puede forzar al planificador para "
"utilizar la información de índice utilizando el comando <command>SET "
"ENABLE_SEQSCAN=OFF</command>. Debes utilizar este comando con moderación y "
"sólo en consultas sobre datos indexados espacialmente: en términos "
"generales, el planificador sabe más que tu acerca de cuándo utilizar los "
"índices de B-Tree normales. Una vez que hayas ejecutado la consulta, debes "
"considerar el restablecimiento de la variable <varname>ENABLE_SEQSCAN</"
"varname> de nuevo, de manera que las demás consultas utilizarán el "
"planificador de la forma habitual."

#. Tag: para
#: using_postgis_dataman.xml:2066
#, no-c-format
msgid ""
"As of version 0.6, it should not be necessary to force the planner to use "
"the index with <varname>ENABLE_SEQSCAN</varname>."
msgstr ""
"Desde la versión 0.6, no debería ser necesario forzar el planificador a "
"utilizar el índice con <varname>ENABLE_SEQSCAN</varname>."

#. Tag: para
#: using_postgis_dataman.xml:2073
#, no-c-format
msgid ""
"If you find the planner wrong about the cost of sequential vs index scans "
"try reducing the value of random_page_cost in postgresql.conf or using SET "
"random_page_cost=#. Default value for the parameter is 4, try setting it to "
"1 or 2. Decrementing the value makes the planner more inclined of using "
"Index scans."
msgstr ""
"Si ves que el planificador se equivoca sobre el costo de exploraciones "
"secuenciales vs índices, intenta reducir el valor de random_page_cost en "
"postgresql.conf o usando SET random_page_cost = #. El valor por defecto para "
"el parámetro es de 4, prueba a ajustarlo a 1 o 2. Disminuyendo el valor, "
"haces que el planificador se incline mas por utilizar exploraciones con "
"índice."

#. Tag: title
#: using_postgis_dataman.xml:2084
#, no-c-format
msgid "Complex Queries"
msgstr "Consultas Complejas"

#. Tag: para
#: using_postgis_dataman.xml:2086
#, fuzzy, no-c-format
msgid ""
"The <emphasis>raison d'etre</emphasis> of spatial database functionality is "
"performing queries inside the database which would ordinarily require "
"desktop GIS functionality. Using PostGIS effectively requires knowing what "
"spatial functions are available, and ensuring that appropriate indexes are "
"in place to provide good performance. The SRID of 312 used in these examples "
"is purely for demonstration. You should be using a REAL SRID listed in the "
"the spatial_ref_sys table and one that matches the projection of your data. "
"If your data has no spatial reference system specified, you should be "
"THINKING very thoughtfully why it doesn't and maybe it should."
msgstr ""
"La <emphasis> razón de ser </emphasis > de la funcionalidad de base de datos "
"espaciales es la de realizar consultas dentro de la base de datos que "
"normalmente requieren la funcionalidad GIS de escritorio. Usando PostGIS de "
"forma eficiente requiere saber que funciones espaciales están disponibles, y "
"asegurar que los índices adecuados estén en su lugar para proporcionar un "
"buen rendimiento. El SRID 312 utilizado en estos ejemplos es únicamente para "
"la demostración . Debes estar utilizando un SRID VERDADERO de los enumerados "
"en la tabla spatial_ref_sys y uno que coincida con la proyección de tus "
"datos. Si los datos no tiene ningún sistema de referencia espacial "
"especificado, debes pensar muy cuidadosamente por qué no lo hace y tal vez "
"debería. Si el motivo se debe a que estás modelando algo que no tiene un "
"sistema de referencia espacial geográfico definido,  como la parte interna "
"de una molécula o una buena ubicación en Marte para el transporte de la raza "
"humana en caso de un holocausto nuclear, entonces simplemente deja de lado "
"el SRID o inventa uno e insertarlo en la tabla <varname>spatial_ref_sys</"
"varname >."

#. Tag: para
#: using_postgis_dataman.xml:2094
#, no-c-format
msgid ""
"If your reason is because you are modeling something that doesn't have a "
"geographic spatial reference system defined such as the internals of a "
"molecule or the floorplan of a not yet built amusement park then that's "
"fine. If the location of the amusement park has been planned however, then "
"it would make sense to use a suitable planar coordinate system for that "
"location if nothing more than to ensure the amusement part is not "
"trespassing on already existing structures."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2098
#, no-c-format
msgid ""
"Even in the case where you are planning a Mars expedition to transport the "
"human race in the event of a nuclear holocaust and you want to map out the "
"Mars planet for rehabitation, you can use a non-earthly coordinate system "
"such as <ulink url=\"http://spatialreference.org/ref/iau2000/mars-2000/"
"\">Mars 2000</ulink> make one up and insert it in the "
"<varname>spatial_ref_sys</varname> table. Though this Mars coordinate system "
"is a non-planar one (it's in degrees spheroidal), you can use it with the "
"geography type to have your length and proximity measurements in meters "
"instead of degrees."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2104
#, no-c-format
msgid "Taking Advantage of Indexes"
msgstr "Aprovechando los Indices"

#. Tag: para
#: using_postgis_dataman.xml:2106
#, no-c-format
msgid ""
"When constructing a query it is important to remember that only the bounding-"
"box-based operators such as &amp;&amp; can take advantage of the GiST "
"spatial index. Functions such as <varname>ST_Distance()</varname> cannot use "
"the index to optimize their operation. For example, the following query "
"would be quite slow on a large table:"
msgstr ""
"Conuando construyes una consulta, es importante recordar que solo los "
"operadores basados en cajas (bounding box) como &amp;&amp; pueden aprovechar "
"los indices espaciales GiST. funciones como <varname>ST_Distance()</varname> "
"no pueden utilizar el indice para optimizar las operaciones. Por ejemplo, la "
"consulta siguiente sera algo lenta en una tabla grande:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2113
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) "
"&lt; 100"
msgstr ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) "
"&lt; 100"

#. Tag: para
#: using_postgis_dataman.xml:2115
#, no-c-format
msgid ""
"This query is selecting all the geometries in geom_table which are within "
"100 units of the point (100000, 200000). It will be slow because it is "
"calculating the distance between each point in the table and our specified "
"point, ie. one <varname>ST_Distance()</varname> calculation for each row in "
"the table. We can avoid this by using the &amp;&amp; operator to reduce the "
"number of distance calculations required:"
msgstr ""
"Esta consulta es la selección de todas las geometrías en geom_table que "
"están a menos de 100 unidades del punto (100000, 200000). La consulta será "
"lenta porque está calculando la distancia entre cada punto en la tabla y "
"nuestro punto especificado, es decir, un cálculo <varname> ST_Distance() </"
"varname> para cada fila de la tabla. Podemos evitar esto mediante el "
"operador &amp;&amp; para reducir el número de cálculos de distancia "
"requeridos:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2122
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, "
"200100,312), 100)"
msgstr ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, "
"200100,312), 100)"

#. Tag: para
#: using_postgis_dataman.xml:2124
#, no-c-format
msgid ""
"This query selects the same geometries, but it does it in a more efficient "
"way. Assuming there is a GiST index on the_geom, the query planner will "
"recognize that it can use the index to reduce the number of rows before "
"calculating the result of the <varname>ST_distance()</varname> function. "
"Notice that the <varname>ST_MakeEnvelope</varname> geometry which is used in "
"the &amp;&amp; operation is a 200 unit square box centered on the original "
"point - this is our \"query box\". The &amp;&amp; operator uses the index to "
"quickly reduce the result set down to only those geometries which have "
"bounding boxes that overlap the \"query box\". Assuming that our query box "
"is much smaller than the extents of the entire geometry table, this will "
"drastically reduce the number of distance calculations that need to be done."
msgstr ""
"Esta consulta selecciona las mismas geometrías, pero lo hace de una manera "
"más eficiente. Suponiendo que hay un índice GiST en the_geom, el "
"planificador de consultas reconocerá que se puede utilizar el índice para "
"reducir el número de filas antes de calcular el resultado de la función "
"<varname>ST_Distance()</varname>. Fijate como la geometría de "
"<varname>ST_MakeEnvelope</varname> que se utiliza en la operación &amp;"
"&amp;, es una caja cuadrada de 200 unidades centrada en el punto de origen - "
"esta es nuestra \"caja de búsqueda\" o \"query box\". El operador &amp;&amp; "
"utiliza el índice para reducir rápidamente el conjunto de resultados a sólo "
"aquellas geometrías que tienen su caja o \"bounding box\" que se superponen "
"a la \"caja de búsqueda\". Suponiendo que nuestra caja de consulta es mucho "
"más pequeña que la extensión de toda la tabla de geometría, esto reducirá "
"drásticamente el número de cálculos de distancia que hay que hacer."

#. Tag: title
#: using_postgis_dataman.xml:2138
#, no-c-format
msgid "Change in Behavior"
msgstr "Cambio en el Comportamiento"

#. Tag: para
#: using_postgis_dataman.xml:2140
#, no-c-format
msgid ""
"As of PostGIS 1.3.0, most of the Geometry Relationship Functions, with the "
"notable exceptions of ST_Disjoint and ST_Relate, include implicit bounding "
"box overlap operators."
msgstr ""
"A partir de PostGIS 1.3.0, la mayoría de las funciones de relaciones entre "
"Geometría, con las notables excepciones de ST_Disjoint y ST_Relate, incluyen "
"operadores de superposición de cajas delimitadoras o \"bounding boxes\" "
"implícitas."

#. Tag: title
#: using_postgis_dataman.xml:2147
#, no-c-format
msgid "Examples of Spatial SQL"
msgstr "Ejemplos de consultas espaciales SQL"

#. Tag: para
#: using_postgis_dataman.xml:2149
#, no-c-format
msgid ""
"The examples in this section will make use of two tables, a table of linear "
"roads, and a table of polygonal municipality boundaries. The table "
"definitions for the <varname>bc_roads</varname> table is:"
msgstr ""
"Los ejemplos en esta sección utilizan dos tablas, una tabla de vías de "
"comunicación lineales, y una tabla de polígonos con limites municipales. La "
"definición de la tabla <varname>bc_roads</varname> es:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2153
#, no-c-format
msgid ""
"Column      | Type              | Description\n"
"------------+-------------------+-------------------\n"
"gid         | integer           | Unique ID\n"
"name        | character varying | Road Name\n"
"the_geom    | geometry          | Location Geometry (Linestring)"
msgstr ""
"Column      | Type              | Description\n"
"------------+-------------------+-------------------\n"
"gid         | integer           | Unique ID\n"
"name        | character varying | Road Name\n"
"the_geom    | geometry          | Location Geometry (Linestring)"

#. Tag: para
#: using_postgis_dataman.xml:2155
#, no-c-format
msgid ""
"The table definition for the <varname>bc_municipality</varname> table is:"
msgstr "La definición de la tabla <varname>bc_municipality</varname> es:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2158
#, no-c-format
msgid ""
"Column     | Type              | Description\n"
"-----------+-------------------+-------------------\n"
"gid        | integer           | Unique ID\n"
"code       | integer           | Unique ID\n"
"name       | character varying | City / Town Name\n"
"the_geom   | geometry          | Location Geometry (Polygon)"
msgstr ""
"Column     | Type              | Description\n"
"-----------+-------------------+-------------------\n"
"gid        | integer           | Unique ID\n"
"code       | integer           | Unique ID\n"
"name       | character varying | City / Town Name\n"
"the_geom   | geometry          | Location Geometry (Polygon)"

#. Tag: para
#: using_postgis_dataman.xml:2163
#, no-c-format
msgid "What is the total length of all roads, expressed in kilometers?"
msgstr ""
"¿Cual es la longitud total de todas las carreteras expresadas en kilómetros?"

#. Tag: para
#: using_postgis_dataman.xml:2168
#, no-c-format
msgid "You can answer this question with a very simple piece of SQL:"
msgstr "Puedes contestar a esta pregunta con una consulta SQL muy simple:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2171
#, no-c-format
msgid ""
"SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
"\n"
"km_roads\n"
"------------------\n"
"70842.1243039643\n"
"(1 row)"
msgstr ""
"SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
"\n"
"km_roads\n"
"------------------\n"
"70842.1243039643\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2177
#, no-c-format
msgid "How large is the city of Prince George, in hectares?"
msgstr "¿Cual es la superficie de la ciudad Prince George en hectáreas?"

#. Tag: para
#: using_postgis_dataman.xml:2181
#, no-c-format
msgid ""
"This query combines an attribute condition (on the municipality name) with a "
"spatial calculation (of the area):"
msgstr ""
"Esta consulta combina una condición de atributo (en el nombre del municipio) "
"con un calculo espacial (del area):"

#. Tag: programlisting
#: using_postgis_dataman.xml:2185
#, no-c-format
msgid ""
"SELECT\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM bc_municipality\n"
"WHERE name = 'PRINCE GEORGE';\n"
"\n"
"hectares\n"
"------------------\n"
"32657.9103824927\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM bc_municipality\n"
"WHERE name = 'PRINCE GEORGE';\n"
"\n"
"hectares\n"
"------------------\n"
"32657.9103824927\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2191
#, no-c-format
msgid "What is the largest municipality in the province, by area?"
msgstr "¿Cual es el municipio con mayor superficie de la provincia?"

#. Tag: para
#: using_postgis_dataman.xml:2196
#, no-c-format
msgid ""
"This query brings a spatial measurement into the query condition. There are "
"several ways of approaching this problem, but the most efficient is below:"
msgstr ""
"Esta consulta incluye un calculo espacial en la condición de la consulta. "
"Hay varias formas de plantear el problema, pero la mas eficiente es la "
"siguiente:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2200
#, no-c-format
msgid ""
"SELECT\n"
"  name,\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM\n"
"  bc_municipality\n"
"ORDER BY hectares DESC\n"
"LIMIT 1;\n"
"\n"
"name           | hectares\n"
"---------------+-----------------\n"
"TUMBLER RIDGE  | 155020.02556131\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  name,\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM\n"
"  bc_municipality\n"
"ORDER BY hectares DESC\n"
"LIMIT 1;\n"
"\n"
"name           | hectares\n"
"---------------+-----------------\n"
"TUMBLER RIDGE  | 155020.02556131\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2202
#, no-c-format
msgid ""
"Note that in order to answer this query we have to calculate the area of "
"every polygon. If we were doing this a lot it would make sense to add an "
"area column to the table that we could separately index for performance. By "
"ordering the results in a descending direction, and them using the "
"PostgreSQL \"LIMIT\" command we can easily pick off the largest value "
"without using an aggregate function like max()."
msgstr ""
"Observa que para responder a esta consulta debemos calcular el area de todos "
"los polígonos. Si estuviéramos haciendo esto mucho tendría sentido crear una "
"columna de area en la tabla que podríamos indexar por motivos de "
"rendimiento. Ordenar el resultado de forma descendente, y utilizando el "
"comando \"LIMIT\" de PostgreSQL podemos extraer el valor mas grande de forma "
"sencilla sin utilizar una función agregada como max()."

#. Tag: para
#: using_postgis_dataman.xml:2214
#, no-c-format
msgid "What is the length of roads fully contained within each municipality?"
msgstr ""
"¿Cuál es la longitud de las carreteras contenidas por completo dentro de "
"cada municipio?"

#. Tag: para
#: using_postgis_dataman.xml:2219
#, no-c-format
msgid ""
"This is an example of a \"spatial join\", because we are bringing together "
"data from two tables (doing a join) but using a spatial interaction "
"condition (\"contained\") as the join condition rather than the usual "
"relational approach of joining on a common key:"
msgstr ""
"Este es un ejemplo de \"unión espacial\", ya que estamos utilizando datos de "
"dos tablas (haciendo una unión) pero utilizando una condición de interacción "
"espacial (\"contained\") como la condición de unión en lugar del enfoque "
"relacional habitual de unión de  la clave primaria:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2225
#, no-c-format
msgid ""
"SELECT\n"
"  m.name,\n"
"  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  ST_Contains(m.the_geom,r.the_geom)\n"
"GROUP BY m.name\n"
"ORDER BY roads_km;\n"
"\n"
"name                        | roads_km\n"
"----------------------------+------------------\n"
"SURREY                      | 1539.47553551242\n"
"VANCOUVER                   | 1450.33093486576\n"
"LANGLEY DISTRICT            | 833.793392535662\n"
"BURNABY                     | 773.769091404338\n"
"PRINCE GEORGE               | 694.37554369147\n"
"..."
msgstr ""
"SELECT\n"
"  m.name,\n"
"  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  ST_Contains(m.the_geom,r.the_geom)\n"
"GROUP BY m.name\n"
"ORDER BY roads_km;\n"
"\n"
"name                        | roads_km\n"
"----------------------------+------------------\n"
"SURREY                      | 1539.47553551242\n"
"VANCOUVER                   | 1450.33093486576\n"
"LANGLEY DISTRICT            | 833.793392535662\n"
"BURNABY                     | 773.769091404338\n"
"PRINCE GEORGE               | 694.37554369147\n"
"..."

#. Tag: para
#: using_postgis_dataman.xml:2227
#, no-c-format
msgid ""
"This query takes a while, because every road in the table is summarized into "
"the final result (about 250K roads for our particular example table). For "
"smaller overlays (several thousand records on several hundred) the response "
"can be very fast."
msgstr ""
"Esta consulta toma un tiempo, ya que todas las carreteras de la tabla se "
"resume en el resultado final (unas 250k carreteras para nuestra tabla del "
"ejemplo). Para superposiciones mas pequeñas (de algunos cientos o miles de "
"registros) la respuesta puede ser muy rápida."

#. Tag: para
#: using_postgis_dataman.xml:2236
#, no-c-format
msgid "Create a new table with all the roads within the city of Prince George."
msgstr "Crear una tabla con todas las carreteras de la ciudad Prince George."

#. Tag: para
#: using_postgis_dataman.xml:2241
#, no-c-format
msgid ""
"This is an example of an \"overlay\", which takes in two tables and outputs "
"a new table that consists of spatially clipped or cut resultants. Unlike the "
"\"spatial join\" demonstrated above, this query actually creates new "
"geometries. An overlay is like a turbo-charged spatial join, and is useful "
"for more exact analysis work:"
msgstr ""
"Este es un ejemplo de \"superposición\", que tomo dos tablas y extrae una "
"tabla nueva que contiene un resultado de un recorte espacial. A diferencia "
"de la \"Unión espacial\" del ejemplo anterior, esta consulta en realidad "
"crea nuevas geometrías. Una superposición es como una unión espacial \"turbo-"
"cargada\", y es útil para un trabajo de análisis mas exacto:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2248
#, no-c-format
msgid ""
"CREATE TABLE pg_roads as\n"
"SELECT\n"
"  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
"  ST_Length(r.the_geom) AS rd_orig_length,\n"
"  r.*\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);"
msgstr ""
"CREATE TABLE pg_roads as\n"
"SELECT\n"
"  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
"  ST_Length(r.the_geom) AS rd_orig_length,\n"
"  r.*\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);"

#. Tag: para
#: using_postgis_dataman.xml:2254
#, no-c-format
msgid "What is the length in kilometers of \"Douglas St\" in Victoria?"
msgstr "¿Cual es la longitud en kilómetros de \"Douglas St\" en Victoria?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2259
#, no-c-format
msgid ""
"SELECT\n"
"  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
"FROM\n"
"  bc_roads r,\n"
"  bc_municipality m\n"
"WHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA'\n"
"        AND ST_Contains(m.the_geom, r.the_geom) ;\n"
"\n"
"kilometers\n"
"------------------\n"
"4.89151904172838\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
"FROM\n"
"  bc_roads r,\n"
"  bc_municipality m\n"
"WHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA'\n"
"        AND ST_Contains(m.the_geom, r.the_geom) ;\n"
"\n"
"kilometers\n"
"------------------\n"
"4.89151904172838\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2265
#, no-c-format
msgid "What is the largest municipality polygon that has a hole?"
msgstr "¿Cual es el polígono de municipios mas grande que tiene un agujero?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2270
#, no-c-format
msgid ""
"SELECT gid, name, ST_Area(the_geom) AS area\n"
"FROM bc_municipality\n"
"WHERE ST_NRings(the_geom) &gt; 1\n"
"ORDER BY area DESC LIMIT 1;\n"
"\n"
"gid  | name         | area\n"
"-----+--------------+------------------\n"
"12   | SPALLUMCHEEN | 257374619.430216\n"
"(1 row)"
msgstr ""
"SELECT gid, name, ST_Area(the_geom) AS area\n"
"FROM bc_municipality\n"
"WHERE ST_NRings(the_geom) &gt; 1\n"
"ORDER BY area DESC LIMIT 1;\n"
"\n"
"gid  | name         | area\n"
"-----+--------------+------------------\n"
"12   | SPALLUMCHEEN | 257374619.430216\n"
"(1 row)"

#~ msgid ""
#~ "Examples of the text representations (EWKT) of the extended spatial "
#~ "objects of the features are as follows. The * ones are new in this "
#~ "version of PostGIS:"
#~ msgstr ""
#~ "Aquí tienes algunos ejemplos de representaciones de texto (EWKT) de "
#~ "objetos espaciales extendidos. Los que llevan * son nuevos en esta "
#~ "version de PostGIS."

#~ msgid ""
#~ "However they may be registered as a generic geometry column if the column "
#~ "was not defined as a specific type during creation."
#~ msgstr ""
#~ "Sin embargo, pueden ser registradas como una columna de geometría "
#~ "genérica si la columna no se define como un tipo específico durante la "
#~ "creación."

#~ msgid ""
#~ "Dimensionally Extended Nine-Intersection Model (DE-9IM) by Christian "
#~ "Strobl"
#~ msgstr ""
#~ "Dimensionally Extended Nine-Intersection Model (DE-9IM) por Christian "
#~ "Strobl"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( I(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( B(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">I(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">B(b) )</mml:mtext>"

#~ msgid ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"
#~ msgstr ""
#~ "<mml:mtext mathvariant=\"italic\">dim( E(a)</mml:mtext> <mml:mo>∩</mml:"
#~ "mo> <mml:mtext mathvariant=\"italic\">E(b) )</mml:mtext>"

#~ msgid "Using SQL"
#~ msgstr "Utilizando SQL"

#~ msgid "Using the Loader"
#~ msgstr "Utilizando el cargador de ficheros Shape"
