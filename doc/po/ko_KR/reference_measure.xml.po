# SOME DESCRIPTIVE TITLE.
#
# Translators:
# Kwon.Yongchan <ruvyn@naver.com>, 2016
# Kwon.Yongchan <ruvyn@naver.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2020-12-15 04:51+0000\n"
"PO-Revision-Date: 2018-07-23 18:01+0000\n"
"Last-Translator: Kwon.Yongchan <ruvyn@naver.com>\n"
"Language-Team: Korean (Korea) (http://www.transifex.com/postgis/postgis/"
"language/ko_KR/)\n"
"Language: ko_KR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. Tag: para
#: reference_measure.xml:5
#, no-c-format
msgid ""
"These functions compute measurements of distance, area and angles. There are "
"also functions to compute geometry values determined by measurements."
msgstr ""

#. Tag: title
#: reference_measure.xml:10
#, no-c-format
msgid "Measurement Functions"
msgstr ""

#. Tag: refname
#: reference_measure.xml:14
#, no-c-format
msgid "ST_Area"
msgstr "ST_Area"

#. Tag: refpurpose
#: reference_measure.xml:16
#, fuzzy, no-c-format
msgid "Returns the area of a polygonal geometry."
msgstr "도형의 기하학적 중심을 반환합니다."

#. Tag: funcsynopsis
#: reference_measure.xml:20
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Area</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Area</function></"
"funcdef> <paramdef><type>geography </type><parameter>geog</parameter></"
"paramdef> <paramdef choice=\"opt\"><type>boolean </"
"type><parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_Area</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Area</function></"
"funcdef> <paramdef><type>geography </type><parameter>geog</parameter></"
"paramdef> <paramdef choice=\"opt\"><type>boolean </"
"type><parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"

#. Tag: title
#: reference_measure.xml:34 reference_measure.xml:97 reference_measure.xml:173
#: reference_measure.xml:217 reference_measure.xml:291
#: reference_measure.xml:372 reference_measure.xml:448
#: reference_measure.xml:497 reference_measure.xml:544
#: reference_measure.xml:600 reference_measure.xml:672
#: reference_measure.xml:737 reference_measure.xml:794
#: reference_measure.xml:826 reference_measure.xml:869
#: reference_measure.xml:923 reference_measure.xml:1018
#: reference_measure.xml:1085 reference_measure.xml:1137
#: reference_measure.xml:1179 reference_measure.xml:1253
#: reference_measure.xml:1300 reference_measure.xml:1351
#: reference_measure.xml:1386 reference_measure.xml:1432
#: reference_measure.xml:1488 reference_measure.xml:1565
#, no-c-format
msgid "Description"
msgstr "설명"

#. Tag: para
#: reference_measure.xml:36
#, fuzzy, no-c-format
msgid ""
"Returns the area of a polygonal geometry. For geometry types a 2D Cartesian "
"(planar) area is computed, with units specified by the SRID. For geography "
"types by default area is determined on a spheroid with units in square "
"meters. To compute the area using the faster but less accurate spherical "
"model use <varname>ST_Area(geog,false)</varname>."
msgstr ""
"도형이 폴리곤이나 멀티폴리곤일 경우 표면의 면적을 - ST_Surface 또는 "
"ST_MultiSurface 함수의 면적 측정값을 - 반환합니다. 도형 유형의 경우, SRID가 "
"지정한 단위로 2차원 데카르트 면적을 구합니다. 지리형 유형의 경우, 평방미터 단"
"위로 곡면(curved surface)의 면적을 구합니다. 구체의 면적에 대해 덜 정확하지"
"만 더 빠르게 측정하려면, ST_Area(geog,false) 함수를 이용하십시오."

#. Tag: para
#: reference_measure.xml:41
#, no-c-format
msgid "Enhanced: 2.0.0 - support for 2D polyhedral surfaces was introduced."
msgstr ""
"개선 사항: 2.0.0 버전부터 2차원 다면체 표면(polyhedral surface)을 지원합니다."

#. Tag: para
#: reference_measure.xml:42 reference_measure.xml:389
#, no-c-format
msgid ""
"Enhanced: 2.2.0 - measurement on spheroid performed with GeographicLib for "
"improved accuracy and robustness. Requires Proj &gt;= 4.9.0 to take "
"advantage of the new feature."
msgstr ""
"개선 사항: 2.2.0 버전부터 회전타원체 측정시 정확도와 강력함을 향상시키기 위"
"해 GeographicLib을 이용합니다. 이 새 기능의 장점을 취하려면 Proj 4.9.0 이상 "
"버전이 필요합니다."

#. Tag: para
#: reference_measure.xml:43 reference_measure.xml:390
#, no-c-format
msgid "Changed: 3.0.0 - does not depend on SFCGAL anymore."
msgstr ""

#. Tag: para
#: reference_measure.xml:44 reference_measure.xml:382
#, no-c-format
msgid "&sfs_compliant;"
msgstr "&sfs_compliant;"

#. Tag: para
#: reference_measure.xml:45
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 8.1.2, 9.5.3"
msgstr "&sqlmm_compliant; SQL-MM 3: 8.1.2, 9.5.3"

#. Tag: para
#: reference_measure.xml:46 reference_measure.xml:298 reference_measure.xml:455
#: reference_measure.xml:1030 reference_measure.xml:1144
#: reference_measure.xml:1581
#, no-c-format
msgid "&P_support;"
msgstr "&P_support;"

#. Tag: para
#: reference_measure.xml:47
#, no-c-format
msgid ""
"For polyhedral surfaces, only supports 2D polyhedral surfaces (not 2.5D). "
"For 2.5D, may give a non-zero answer, but only for the faces that sit "
"completely in XY plane."
msgstr ""
"다면체 표면의 경우, (2.5차원이 아니라) 2차원 다면체 표면만 지원합니다. 2.5차"
"원일 경우 0이 아닌(non-zero) 답을 내놓을 수도 있지만, XY 평면상에 완벽하게 놓"
"이는 면들의 면적만 반환하는 것입니다."

#. Tag: title
#: reference_measure.xml:52 reference_measure.xml:113 reference_measure.xml:188
#: reference_measure.xml:227 reference_measure.xml:304
#: reference_measure.xml:464 reference_measure.xml:511
#: reference_measure.xml:561 reference_measure.xml:626
#: reference_measure.xml:701 reference_measure.xml:836
#: reference_measure.xml:886 reference_measure.xml:936
#: reference_measure.xml:1034 reference_measure.xml:1099
#: reference_measure.xml:1151 reference_measure.xml:1220
#: reference_measure.xml:1265 reference_measure.xml:1396
#: reference_measure.xml:1504 reference_measure.xml:1585
#, no-c-format
msgid "Examples"
msgstr "예시"

#. Tag: para
#: reference_measure.xml:53
#, no-c-format
msgid ""
"Return area in square feet for a plot of Massachusetts land and multiply by "
"conversion to get square meters. Note this is in square feet because "
"EPSG:2249 is Massachusetts State Plane Feet"
msgstr ""
"매사추세츠 토지의 부지(plot)에 대해 평방피트 단위로 면적을 반환하고, 이에 환"
"산값을 곱해서 평방미터 면적을 구합니다. EPSG:2249가 매사추세츠 주 피트 단위 "
"평면이기 때문에 평방피트 단위의 값을 반환한다는 점에 주의하십시오."

#. Tag: programlisting
#: reference_measure.xml:56
#, no-c-format
msgid ""
"select ST_Area(geom) sqft,\n"
"    ST_Area(geom) * 0.3048 ^ 2 sqm\n"
"from (\n"
"         select 'SRID=2249;POLYGON((743238 2967416,743238 2967450,\n"
"                                 743265 2967450,743265.625 2967416,743238 "
"2967416))' :: geometry geom\n"
"     ) subquery;\n"
"┌─────────┬─────────────┐\n"
"│  sqft   │     sqm     │\n"
"├─────────┼─────────────┤\n"
"│ 928.625 │ 86.27208552 │\n"
"└─────────┴─────────────┘"
msgstr ""

#. Tag: para
#: reference_measure.xml:57
#, no-c-format
msgid ""
"Return area square feet and transform to Massachusetts state plane meters "
"(EPSG:26986) to get square meters. Note this is in square feet because 2249 "
"is Massachusetts State Plane Feet and transformed area is in square meters "
"since EPSG:26986 is state plane Massachusetts meters"
msgstr ""
"평방피트 면적을 반환하며, 평방미터 값을 구하려면 매사추세츠 주 미터 단위 평면"
"((EPSG:26986))으로 변환해야 합니다. EPSG:2249가 매사추세츠 주 피트 단위 평면"
"이기 때문에 평방피트 단위의 값을 반환하고 EPSG:26986이 매사추세츠 주 미터 단"
"위 평면이기 때문에 변환된 면적이 평방미터 단위가 된다는 점에 주의하십시오."

#. Tag: programlisting
#: reference_measure.xml:60
#, no-c-format
msgid ""
"select ST_Area(geom) sqft,\n"
"    ST_Area(ST_Transform(geom, 26986)) As sqm\n"
"from (\n"
"         select\n"
"             'SRID=2249;POLYGON((743238 2967416,743238 2967450,\n"
"             743265 2967450,743265.625 2967416,743238 2967416))' :: geometry "
"geom\n"
"     ) subquery;\n"
"┌─────────┬─────────────────┐\n"
"│  sqft   │       sqm       │\n"
"├─────────┼─────────────────┤\n"
"│ 928.625 │ 86.272430607008 │\n"
"└─────────┴─────────────────┘"
msgstr ""

#. Tag: para
#: reference_measure.xml:62
#, no-c-format
msgid ""
"Return area square feet and square meters using geography data type. Note "
"that we transform to our geometry to geography (before you can do that make "
"sure your geometry is in WGS 84 long lat 4326). Geography always measures in "
"meters. This is just for demonstration to compare. Normally your table will "
"be stored in geography data type already."
msgstr ""
"지리형 데이터 유형을 이용해서 평방피트 및 평방미터 면적을 반환합니다. 도형을 "
"지리형으로 변환시킨다는 점에 주의하십시오(변환하기 전에 사용자 도형의 투영체"
"가 WGS84 4326 경위도 좌표계인지 확인해야 합니다). 지리형은 항상 미터 단위로 "
"측정됩니다. 이 예시는 그저 비교해보기 위한 보여주기에 불과합니다. 일반적으로 "
"이미 사용자 테이블에 지리형 데이터 유형으로 저장되어 있을 겁니다."

#. Tag: programlisting
#: reference_measure.xml:65
#, no-c-format
msgid ""
"select ST_Area(geog) / 0.3048 ^ 2 sqft_spheroid,\n"
"    ST_Area(geog, false) / 0.3048 ^ 2 sqft_sphere,\n"
"    ST_Area(geog) sqm_spheroid\n"
"from (\n"
"         select ST_Transform(\n"
"                    'SRID=2249;POLYGON((743238 2967416,743238 2967450,743265 "
"2967450,743265.625 2967416,743238 2967416))'::geometry,\n"
"                    4326\n"
"             ) :: geography geog\n"
"     ) as subquery;\n"
"┌──────────────────┬──────────────────┬──────────────────┐\n"
"│  sqft_spheroid   │   sqft_sphere    │   sqm_spheroid   │\n"
"├──────────────────┼──────────────────┼──────────────────┤\n"
"│ 928.684405784452 │ 927.049336105925 │ 86.2776044979692 │\n"
"└──────────────────┴──────────────────┴──────────────────┘"
msgstr ""

#. Tag: para
#: reference_measure.xml:67
#, no-c-format
msgid "If your data is in geography already:"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:68
#, no-c-format
msgid ""
"select ST_Area(geog) / 0.3048 ^ 2 sqft,\n"
"    ST_Area(the_geog) sqm\n"
"from somegeogtable;"
msgstr ""

#. Tag: title
#: reference_measure.xml:71 reference_measure.xml:144 reference_measure.xml:262
#: reference_measure.xml:330 reference_measure.xml:419
#: reference_measure.xml:471 reference_measure.xml:518
#: reference_measure.xml:568 reference_measure.xml:632
#: reference_measure.xml:711 reference_measure.xml:772
#: reference_measure.xml:803 reference_measure.xml:845
#: reference_measure.xml:893 reference_measure.xml:990
#: reference_measure.xml:1060 reference_measure.xml:1110
#: reference_measure.xml:1157 reference_measure.xml:1226
#: reference_measure.xml:1270 reference_measure.xml:1328
#: reference_measure.xml:1363 reference_measure.xml:1403
#: reference_measure.xml:1459 reference_measure.xml:1538
#: reference_measure.xml:1611
#, no-c-format
msgid "See Also"
msgstr "참고"

#. Tag: para
#: reference_measure.xml:72
#, fuzzy, no-c-format
msgid ""
", <xref linkend=\"ST_GeomFromText\"/>, <xref linkend=\"ST_GeographyFromText"
"\"/>, <xref linkend=\"ST_SetSRID\"/>, <xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_GeomFromEWKT\"/>, <xref linkend=\"ST_Length_Spheroid\"/"
">, <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_measure.xml:78
#, no-c-format
msgid "ST_Azimuth"
msgstr "ST_Azimuth"

#. Tag: refpurpose
#: reference_measure.xml:80
#, no-c-format
msgid ""
"Returns the north-based azimuth as the angle in radians measured clockwise "
"from the vertical on pointA to pointB."
msgstr ""
"포인트 A와 포인트 B를 잇는 선의 각도를, 포인트 A에 그은 수직선을 기준으로 시"
"계 방향으로 라디안 단위로 각도를 측정해서 북극 기준(north-based) 방위각"
"(azimuth)을 반환합니다."

#. Tag: funcsynopsis
#: reference_measure.xml:83
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Azimuth</function></funcdef> "
"<paramdef><type>geometry </type><parameter>pointA</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>pointB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Azimuth</"
"function></funcdef> <paramdef><type>geography </type><parameter>pointA</"
"parameter></paramdef> <paramdef><type>geography </type><parameter>pointB</"
"parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_Azimuth</function></funcdef> "
"<paramdef><type>geometry </type><parameter>pointA</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>pointB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Azimuth</"
"function></funcdef> <paramdef><type>geography </type><parameter>pointA</"
"parameter></paramdef> <paramdef><type>geography </type><parameter>pointB</"
"parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_measure.xml:99
#, no-c-format
msgid ""
"Returns the azimuth in radians of the segment defined by the given point "
"geometries, or NULL if the two points are coincident. The azimuth is angle "
"is referenced from north, and is positive clockwise: North = 0; East = "
"&#x03C0;/2; South = &#x03C0;; West = 3&#x03C0;/2."
msgstr ""
"주어진 포인트 도형으로 정의된 구간의 라디안 단위로 방위각을 반환합니다. 두 포"
"인트가 일치하는 경우 NULL을 반환합니다. 방위각이란 북쪽을 기준으로, 시계 방향"
"으로 양수인 각도를 말합니다. North = 0; East = &#x03C0;/2; South = &#x03C0;; "
"West = 3&#x03C0;/2"

#. Tag: para
#: reference_measure.xml:101
#, no-c-format
msgid ""
"For the geography type, the forward azimuth is solved as part of the inverse "
"geodesic problem."
msgstr ""
"지리형 유형의 경우, 측지 역 문제(geodesic inverse problem)의 일부로 전방 방위"
"각(forward azimuth)을 구합니다."

#. Tag: para
#: reference_measure.xml:102
#, no-c-format
msgid ""
"The azimuth is mathematical concept defined as the angle between a reference "
"plane and a point, with angular units in radians. Units can be converted to "
"degrees using a built-in PostgreSQL function degrees(), as shown in the "
"example."
msgstr ""
"방위각은 참조 평면과 포인트 사이의 라디안 단위의 각도로 정의되는 수학적 개념"
"입니다. PostgreSQL 내장 함수인 degrees()를 써서 라디안 단위를 도 단위로 변환"
"할 수 있습니다. 예시 코드를 확인해보십시오."

#. Tag: para
#: reference_measure.xml:105
#, no-c-format
msgid "Availability: 1.1.0"
msgstr "1.1.0 버전부터 사용할 수 있습니다."

#. Tag: para
#: reference_measure.xml:106
#, no-c-format
msgid "Enhanced: 2.0.0 support for geography was introduced."
msgstr "개선 사항: 2.0.0 버전부터 지리형을 지원합니다."

#. Tag: para
#: reference_measure.xml:107
#, no-c-format
msgid ""
"Enhanced: 2.2.0 measurement on spheroid performed with GeographicLib for "
"improved accuracy and robustness. Requires Proj &gt;= 4.9.0 to take "
"advantage of the new feature."
msgstr ""
"개선 사항: 2.2.0 버전부터 회전타원체 측정시 정확도와 강력함을 향상시키기 위"
"해 GeographicLib을 이용합니다. 이 새 기능의 장점을 취하려면 Proj 4.9.0 이상 "
"버전이 필요합니다."

#. Tag: para
#: reference_measure.xml:108
#, no-c-format
msgid ""
"Azimuth is especially useful in conjunction with ST_Translate for shifting "
"an object along its perpendicular axis. See upgis_lineshift <ulink url="
"\"http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctions"
"\">Plpgsqlfunctions PostGIS wiki section</ulink> for example of this."
msgstr ""
"객체를 해당 객체의 수직축을 따라 이동시키기 위해 ST_Translate 함수와 방위각"
"을 함께 이용할 때 방위각이 특히 유용합니다. 이런 내용의 예시를 보려면 <ulink "
"url=\"http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctions"
"\">Plpgsqlfunctions PostGIS wiki section</ulink> 의 upgis_lineshift 단원을 살"
"펴보십시오."

#. Tag: para
#: reference_measure.xml:114 reference_measure.xml:189
#, no-c-format
msgid "Geometry Azimuth in degrees"
msgstr "도 단위의 도형 방위각"

#. Tag: programlisting
#: reference_measure.xml:115
#, no-c-format
msgid ""
"SELECT degrees(ST_Azimuth(ST_Point(25, 45), ST_Point(75, 100))) AS degA_B,\n"
"            degrees(ST_Azimuth(ST_Point(75, 100), ST_Point(25, 45))) AS "
"degB_A;\n"
"\n"
"      dega_b       |     degb_a\n"
"------------------+------------------\n"
" 42.2736890060937 | 222.273689006094"
msgstr ""
"SELECT degrees(ST_Azimuth(ST_Point(25, 45), ST_Point(75, 100))) AS degA_B,\n"
"            degrees(ST_Azimuth(ST_Point(75, 100), ST_Point(25, 45))) AS "
"degB_A;\n"
"\n"
"      dega_b       |     degb_a\n"
"------------------+------------------\n"
" 42.2736890060937 | 222.273689006094"

#. Tag: para
#: reference_measure.xml:125
#, no-c-format
msgid ""
"Green: the start Point(25,45) with its vertical. Yellow: degA_B as the path "
"to travel (azimuth)."
msgstr ""
"초록색: 시작점 Point(25,45)와 그 수직선\n"
"노란색: degA_B의 궤적 경로(방위각)"

#. Tag: para
#: reference_measure.xml:134
#, no-c-format
msgid ""
"Green: the start Point(75,100) with its vertical. Yellow: degB_A as the path "
"to travel (azimuth)."
msgstr ""
"초록색: 시작점 Point(75,100)와 그 수직선\n"
"노란색: degB_A의 궤적 경로(방위각)"

#. Tag: para
#: reference_measure.xml:145
#, no-c-format
msgid ""
", <xref linkend=\"ST_Translate\"/>, <xref linkend=\"ST_Project\"/>, <ulink "
"url=\"http://www.postgresql.org/docs/current/interactive/functions-math.html"
"\">PostgreSQL Math Functions</ulink>"
msgstr ""
", <xref linkend=\"ST_Translate\"/>, <xref linkend=\"ST_Project\"/>, <ulink "
"url=\"http://www.postgresql.org/docs/current/interactive/functions-math.html"
"\">PostgreSQL Math Functions</ulink>"

#. Tag: refname
#: reference_measure.xml:152
#, no-c-format
msgid "ST_Angle"
msgstr ""

#. Tag: refpurpose
#: reference_measure.xml:154
#, no-c-format
msgid ""
"Returns the angle between 3 points, or between 2 vectors (4 points or 2 "
"lines)."
msgstr ""

#. Tag: funcsynopsis
#: reference_measure.xml:157
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Angle</function></funcdef> "
"<paramdef><type>geometry </type><parameter>point1</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>point2</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>point3</parameter></paramdef> "
"<paramdef choice=\"opt\"><type>geometry </type><parameter>point4</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_Angle</function></funcdef> <paramdef><type>geometry </"
"type><parameter>line1</parameter></paramdef> <paramdef><type>geometry </"
"type><parameter>line2</parameter></paramdef> </funcprototype>"
msgstr ""

#. Tag: para
#: reference_measure.xml:175
#, no-c-format
msgid ""
"For 3 points, computes the angle measured clockwise of P1P2P3. If input are "
"2 lines, get first and last point of the lines as 4 points. For 4 points,"
"compute the angle measured clockwise of P1P2,P3P4. Results are always "
"positive, between 0 and 2*Pi radians. Uses azimuth of pairs or points."
msgstr ""

#. Tag: para
#: reference_measure.xml:182
#, no-c-format
msgid "ST_Angle(P1,P2,P3) = ST_Angle(P2,P1,P2,P3)"
msgstr ""

#. Tag: para
#: reference_measure.xml:183
#, no-c-format
msgid ""
"Result is in radian and can be converted to degrees using a built-in "
"PostgreSQL function degrees(), as shown in the example."
msgstr ""

#. Tag: para
#: reference_measure.xml:184
#, no-c-format
msgid "Availability: 2.5.0"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:190
#, no-c-format
msgid ""
"WITH rand AS (\n"
"                SELECT s, random() * 2 * PI() AS rad1\n"
"                        , random() * 2 * PI() AS rad2\n"
"                FROM  generate_series(1,2,2) AS s\n"
"        )\n"
"         , points AS (\n"
"                SELECT s, rad1,rad2, ST_MakePoint(cos1+s,sin1+s) as p1, "
"ST_MakePoint(s,s) AS p2, ST_MakePoint(cos2+s,sin2+s) as p3\n"
"                FROM rand\n"
"                        ,cos(rad1) cos1, sin(rad1) sin1\n"
"                        ,cos(rad2) cos2, sin(rad2) sin2\n"
"        )\n"
"        SELECT s, ST_AsText(ST_SnapToGrid(ST_MakeLine(ARRAY[p1,p2,"
"p3]),0.001)) AS line\n"
"                , degrees(ST_Angle(p1,p2,p3)) as computed_angle\n"
"                , round(degrees(2*PI()-rad2 -2*PI()+rad1+2*PI()))::int%360 "
"AS reference\n"
"                , round(degrees(2*PI()-rad2 -2*PI()+rad1+2*PI()))::int%360 "
"AS reference\n"
"        FROM points ;\n"
"\n"
"1 | line | computed_angle | reference\n"
"------------------+------------------\n"
"1 | LINESTRING(1.511 1.86,1 1,0.896 0.005) | 155.27033848688 | 155"
msgstr ""

#. Tag: refname
#: reference_measure.xml:196
#, no-c-format
msgid "ST_ClosestPoint"
msgstr "ST_ClosestPoint"

#. Tag: refpurpose
#: reference_measure.xml:198
#, fuzzy, no-c-format
msgid ""
"Returns the 2D point on g1 that is closest to g2. This is the first point of "
"the shortest line."
msgstr ""
"g2에 가장 가까운 g1 상에 있는 3차원 포인트를 반환합니다. 해당 포인트는 3D 최"
"단 라인의 첫 번째 포인트입니다."

#. Tag: funcprototype
#: reference_measure.xml:204
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_ClosestPoint</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_ClosestPoint</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:219
#, fuzzy, no-c-format
msgid ""
"Returns the 2-dimensional point on g1 that is closest to g2. This is the "
"first point of the shortest line."
msgstr ""
"g2에 가장 가까운 g1 상에 있는 3차원 포인트를 반환합니다. 해당 포인트는 3D 최"
"단 라인의 첫 번째 포인트입니다."

#. Tag: para
#: reference_measure.xml:222
#, no-c-format
msgid ""
"If you have a 3D Geometry, you may prefer to use <xref linkend="
"\"ST_3DClosestPoint\"/>."
msgstr ""
"3차원 도형의 경우엔 <xref linkend=\"ST_3DClosestPoint\"/> 함수를 이용하는 편"
"이 좋습니다."

#. Tag: para
#: reference_measure.xml:223 reference_measure.xml:696
#: reference_measure.xml:931 reference_measure.xml:1096
#: reference_measure.xml:1500
#, no-c-format
msgid "Availability: 1.5.0"
msgstr "1.5.0 버전부터 사용할 수 있습니다."

#. Tag: para
#: reference_measure.xml:237
#, no-c-format
msgid ""
"Closest between point and linestring is the point itself, but closest point "
"between a linestring and point is the point on line string that is closest."
msgstr ""
"포인트와 라인스트링 사이의 최근접점은 해당 포인트 자체이지만, 라인스트링과 포"
"인트 사이의 최근접점은 라인 상에 있는 가장 가까운 포인트입니다."

#. Tag: programlisting
#: reference_measure.xml:241
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_ClosestPoint(pt,line)) AS cp_pt_line,\n"
"        ST_AsText(ST_ClosestPoint(line,pt)) As cp_line_pt\n"
"FROM (SELECT 'POINT(100 100)'::geometry As pt,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry As "
"line\n"
"        ) As foo;\n"
"\n"
"\n"
"   cp_pt_line   |                cp_line_pt\n"
"----------------+------------------------------------------\n"
" POINT(100 100) | POINT(73.0769230769231 115.384615384615)"
msgstr ""
"SELECT ST_AsText(ST_ClosestPoint(pt,line)) AS cp_pt_line,\n"
"        ST_AsText(ST_ClosestPoint(line,pt)) As cp_line_pt\n"
"FROM (SELECT 'POINT(100 100)'::geometry As pt,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry As "
"line\n"
"        ) As foo;\n"
"\n"
"\n"
"   cp_pt_line   |                cp_line_pt\n"
"----------------+------------------------------------------\n"
" POINT(100 100) | POINT(73.0769230769231 115.384615384615)"

#. Tag: para
#: reference_measure.xml:249
#, no-c-format
msgid "closest point on polygon A to polygon B"
msgstr "폴리곤 B에 가장 가까운 폴리곤 A 상의 포인트"

#. Tag: programlisting
#: reference_measure.xml:252
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"                ST_ClosestPoint(\n"
"                        ST_GeomFromText('POLYGON((175 150, 20 40, 50 60, 125 "
"100, 175 150))'),\n"
"                        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                        )\n"
"                ) As ptwkt;\n"
"\n"
"                  ptwkt\n"
"------------------------------------------\n"
" POINT(140.752120669087 125.695053378061)"
msgstr ""
"SELECT ST_AsText(\n"
"                ST_ClosestPoint(\n"
"                        ST_GeomFromText('POLYGON((175 150, 20 40, 50 60, 125 "
"100, 175 150))'),\n"
"                        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                        )\n"
"                ) As ptwkt;\n"
"\n"
"                  ptwkt\n"
"------------------------------------------\n"
" POINT(140.752120669087 125.695053378061)"

#. Tag: para
#: reference_measure.xml:264
#, no-c-format
msgid ""
",<xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_MaxDistance\"/>"
msgstr ""
",<xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_MaxDistance\"/>"

#. Tag: refname
#: reference_measure.xml:270
#, no-c-format
msgid "ST_3DClosestPoint"
msgstr "ST_3DClosestPoint"

#. Tag: refpurpose
#: reference_measure.xml:272
#, fuzzy, no-c-format
msgid ""
"Returns the 3D point on g1 that is closest to g2. This is the first point of "
"the 3D shortest line."
msgstr ""
"g2에 가장 가까운 g1 상에 있는 3차원 포인트를 반환합니다. 해당 포인트는 3D 최"
"단 라인의 첫 번째 포인트입니다."

#. Tag: funcprototype
#: reference_measure.xml:278
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_3DClosestPoint</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_3DClosestPoint</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:293
#, no-c-format
msgid ""
"Returns the 3-dimensional point on g1 that is closest to g2. This is the "
"first point of the 3D shortest line. The 3D length of the 3D shortest line "
"is the 3D distance."
msgstr ""
"g2에 가장 가까운 g1 상에 있는 3차원 포인트를 반환합니다. 해당 포인트는 3D 최"
"단 라인의 첫 번째 포인트입니다. 3D 최단 라인의 3D 길이가 3D 거리입니다."

#. Tag: para
#: reference_measure.xml:296 reference_measure.xml:453
#: reference_measure.xml:830 reference_measure.xml:882
#: reference_measure.xml:1028 reference_measure.xml:1142
#: reference_measure.xml:1390 reference_measure.xml:1579
#, no-c-format
msgid "&Z_support;"
msgstr "&Z_support;"

#. Tag: para
#: reference_measure.xml:299 reference_measure.xml:458
#: reference_measure.xml:1026 reference_measure.xml:1146
#: reference_measure.xml:1447 reference_measure.xml:1577
#, no-c-format
msgid "Availability: 2.0.0"
msgstr "2.0.0 버전부터 사용할 수 있습니다."

#. Tag: para
#: reference_measure.xml:300 reference_measure.xml:1027
#: reference_measure.xml:1578
#, no-c-format
msgid ""
"Changed: 2.2.0 - if 2 2D geometries are input, a 2D point is returned "
"(instead of old behavior assuming 0 for missing Z). In case of 2D and 3D, Z "
"is no longer assumed to be 0 for missing Z."
msgstr ""
"변경 사항: 2.2.0 버전부터 2D 도형 두 개를 입력할 경우, (존재하지 않는 Z을 0으"
"로 가정하는 예전 습성 대신) 2D 포인트를 반환합니다. 2D 및 3D의 경우, 더 이상 "
"Z가 없을 때 Z를 0으로 가정하지 않습니다."

#. Tag: para
#: reference_measure.xml:309
#, no-c-format
msgid "linestring and point -- both 3d and 2d closest point"
msgstr "라인스트링과 포인트 -- 3D, 2D 모두의 최근접점(closest point)"

#. Tag: programlisting
#: reference_measure.xml:310
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(line,pt)) AS cp3d_line_pt,\n"
"                ST_AsEWKT(ST_ClosestPoint(line,pt)) As cp2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
" cp3d_line_pt                                                |               "
"cp2d_line_pt\n"
"-----------------------------------------------------------"
"+------------------------------------------\n"
" POINT(54.6993798867619 128.935022917228 11.5475869506606) | "
"POINT(73.0769230769231 115.384615384615)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(line,pt)) AS cp3d_line_pt,\n"
"                ST_AsEWKT(ST_ClosestPoint(line,pt)) As cp2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
" cp3d_line_pt                                                |               "
"cp2d_line_pt\n"
"-----------------------------------------------------------"
"+------------------------------------------\n"
" POINT(54.6993798867619 128.935022917228 11.5475869506606) | "
"POINT(73.0769230769231 115.384615384615)"

#. Tag: para
#: reference_measure.xml:314
#, no-c-format
msgid "linestring and multipoint -- both 3d and 2d closest point"
msgstr "라인스트링과 멀티포인트 -- 3D, 2D 모두의 최근접점(closest point)"

#. Tag: programlisting
#: reference_measure.xml:315
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(line,pt)) AS cp3d_line_pt,\n"
"                ST_AsEWKT(ST_ClosestPoint(line,pt)) As cp2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"                       cp3d_line_pt                        | cp2d_line_pt\n"
"-----------------------------------------------------------+--------------\n"
" POINT(54.6993798867619 128.935022917228 11.5475869506606) | POINT(50 75)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(line,pt)) AS cp3d_line_pt,\n"
"                ST_AsEWKT(ST_ClosestPoint(line,pt)) As cp2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"                       cp3d_line_pt                        | cp2d_line_pt\n"
"-----------------------------------------------------------+--------------\n"
" POINT(54.6993798867619 128.935022917228 11.5475869506606) | POINT(50 75)"

#. Tag: para
#: reference_measure.xml:319
#, no-c-format
msgid "Multilinestring and polygon both 3d and 2d closest point"
msgstr "멀티라인스트링과 폴리곤 -- 3D, 2D 모두의 최근접점(closest point)"

#. Tag: programlisting
#: reference_measure.xml:320
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(poly, mline)) As cp3d,\n"
"    ST_AsEWKT(ST_ClosestPoint(poly, mline)) As cp2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"                   cp3d                    |     cp2d\n"
"-------------------------------------------+--------------\n"
" POINT(39.993580415989 54.1889925532825 5) | POINT(20 40)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(poly, mline)) As cp3d,\n"
"    ST_AsEWKT(ST_ClosestPoint(poly, mline)) As cp2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"                   cp3d                    |     cp2d\n"
"-------------------------------------------+--------------\n"
" POINT(39.993580415989 54.1889925532825 5) | POINT(20 40)"

#. Tag: para
#: reference_measure.xml:332
#, no-c-format
msgid ""
", <xref linkend=\"ST_ClosestPoint\"/>, <xref linkend=\"ST_3DDistance\"/>, "
"<xref linkend=\"ST_3DShortestLine\"/>"
msgstr ""
", <xref linkend=\"ST_ClosestPoint\"/>, <xref linkend=\"ST_3DDistance\"/>, "
"<xref linkend=\"ST_3DShortestLine\"/>"

#. Tag: refname
#: reference_measure.xml:338
#, no-c-format
msgid "ST_Distance"
msgstr "ST_Distance"

#. Tag: refpurpose
#: reference_measure.xml:340
#, fuzzy, no-c-format
msgid "Returns the distance between two geometry or geography values."
msgstr "두 도형 사이의 3차원 최장(longest) 라인을 반환합니다."

#. Tag: funcsynopsis
#: reference_measure.xml:343
#, fuzzy, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Distance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Distance</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geog1</"
"parameter></paramdef> <paramdef><type>geography </type> <parameter>geog2</"
"parameter></paramdef> <paramdef choice=\"opt\"><type>boolean </type> "
"<parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_HausdorffDistance</function></"
"funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_HausdorffDistance</function></funcdef> <paramdef><type>geometry "
"</type> <parameter>g1</parameter></paramdef> <paramdef><type>geometry </"
"type> <parameter>g2</parameter></paramdef> <paramdef><type>float</type> "
"<parameter>densifyFrac</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_measure.xml:374
#, fuzzy, no-c-format
msgid ""
"For <xref linkend=\"geometry\"/> types returns the minimum 2D Cartesian "
"(planar) distance between two geometries, in projected units (spatial ref "
"units)."
msgstr ""
"도형 유형에 대해, 두 도형 사이의 3차원 데카르트 최단 거리를 두 도형의 투영 단"
"위(SRS 단위)로 반환합니다."

#. Tag: para
#: reference_measure.xml:377
#, no-c-format
msgid ""
"For <xref linkend=\"geography\"/> types defaults to return the minimum "
"geodesic distance between two geographies in meters, compute on the spheroid "
"determined by the SRID. If <varname>use_spheroid</varname> is false, a "
"faster spherical calculation is used."
msgstr ""

#. Tag: para
#: reference_measure.xml:383
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.23"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.23"

#. Tag: para
#: reference_measure.xml:384
#, no-c-format
msgid "&curve_support;"
msgstr "&curve_support;"

#. Tag: para
#: reference_measure.xml:386
#, no-c-format
msgid ""
"Availability: 1.5.0 geography support was introduced in 1.5. Speed "
"improvements for planar to better handle large or many vertex geometries"
msgstr ""
"1.5.0 버전부터 지리형을 지원합니다. 대용량 또는 수많은 꼭짓점을 가진 도형을 "
"더 잘 처리하기 위해 평면에 대한 속도를 향상시켰습니다."

#. Tag: para
#: reference_measure.xml:387
#, no-c-format
msgid ""
"Enhanced: 2.1.0 improved speed for geography. See <ulink url=\"http://"
"boundlessgeo.com/2012/07/making-geography-faster/\">Making Geography faster</"
"ulink> for details."
msgstr ""
"개선 사항: 2.1.0 버전부터 지리형에 대한 속도가 향상됐습니다. 자세한 내용은 "
"<ulink url=\"http://boundlessgeo.com/2012/07/making-geography-faster/"
"\">Making Geography faster</ulink> 를 참조하십시오."

#. Tag: para
#: reference_measure.xml:388
#, no-c-format
msgid "Enhanced: 2.1.0 - support for curved geometries was introduced."
msgstr "개선 사항: 2.1.0 버전부터 만곡 도형을 지원하기 시작했습니다."

#. Tag: title
#: reference_measure.xml:394
#, no-c-format
msgid "Basic Geometry Examples"
msgstr "기본 도형 예시"

#. Tag: para
#: reference_measure.xml:396
#, no-c-format
msgid ""
"Geometry example - units in planar degrees 4326 is WGS 84 long lat, units "
"are degrees."
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:397
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                'SRID=4326;POINT(-72.1235 42.3521)'::geometry,\n"
"                'SRID=4326;LINESTRING(-72.1260 42.45, -72.123 42.1546)'::"
"geometry\n"
"        );\n"
"st_distance\n"
"-----------------\n"
"0.00150567726382282"
msgstr ""
"SELECT ST_AsText(\n"
"        ST_LongestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As lline;\n"
"\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(100 100,98 190)"

#. Tag: para
#: reference_measure.xml:399
#, no-c-format
msgid ""
"Geometry example - units in meters (SRID: 3857, proportional to pixels on "
"popular web maps). Although the value is off, nearby ones can be compared "
"correctly, which makes it a good choice for algorithms like KNN or KMeans."
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:402
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry, 3857),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry, 3857)\n"
"                );\n"
"st_distance\n"
"-----------------\n"
"167.441410065196"
msgstr ""
"SELECT ST_Intersects(\n"
"                ST_GeographyFromText('SRID=4326;LINESTRING(-43.23456 "
"72.4567,-43.23456 72.4568)'),\n"
"                ST_GeographyFromText('SRID=4326;POINT(-43.23456 "
"72.4567772)')\n"
"                );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: para
#: reference_measure.xml:404
#, no-c-format
msgid ""
"Geometry example - units in meters (SRID: 3857 as above, but corrected by "
"cos(lat) to account for distortion)"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:405
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry, 3857),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry, 3857)\n"
"                ) * cosd(42.3521);\n"
"st_distance\n"
"-----------------\n"
"123.742351254151"
msgstr ""
"SELECT ST_Intersects(\n"
"                ST_GeographyFromText('SRID=4326;LINESTRING(-43.23456 "
"72.4567,-43.23456 72.4568)'),\n"
"                ST_GeographyFromText('SRID=4326;POINT(-43.23456 "
"72.4567772)')\n"
"                );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: para
#: reference_measure.xml:407
#, no-c-format
msgid ""
"Geometry example - units in meters (SRID: 26986 Massachusetts state plane "
"meters) (most accurate for Massachusetts)"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:408
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry, 26986),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry, 26986)\n"
"                );\n"
"st_distance\n"
"-----------------\n"
"123.797937878454"
msgstr ""
"SELECT ST_Intersects(\n"
"                ST_GeographyFromText('SRID=4326;LINESTRING(-43.23456 "
"72.4567,-43.23456 72.4568)'),\n"
"                ST_GeographyFromText('SRID=4326;POINT(-43.23456 "
"72.4567772)')\n"
"                );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: para
#: reference_measure.xml:410
#, no-c-format
msgid ""
"Geometry example - units in meters (SRID: 2163 US National Atlas Equal area) "
"(least accurate)"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:411
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry, 2163),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry, 2163)\n"
"                );\n"
"\n"
"st_distance\n"
"------------------\n"
"126.664256056812"
msgstr ""
"SELECT ST_Intersects(\n"
"                ST_GeographyFromText('SRID=4326;LINESTRING(-43.23456 "
"72.4567,-43.23456 72.4568)'),\n"
"                ST_GeographyFromText('SRID=4326;POINT(-43.23456 "
"72.4567772)')\n"
"                );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: title
#: reference_measure.xml:414 reference_measure.xml:767
#, no-c-format
msgid "Geography Examples"
msgstr "지리형 예시"

#. Tag: para
#: reference_measure.xml:415
#, no-c-format
msgid ""
"Same as geometry example but note units in meters - use sphere for slightly "
"faster and less accurate computation."
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:416
#, no-c-format
msgid ""
"SELECT ST_Distance(gg1, gg2) As spheroid_dist, ST_Distance(gg1, gg2, false) "
"As sphere_dist\n"
"FROM (SELECT\n"
"        'SRID=4326;POINT(-72.1235 42.3521)'::geography as gg1,\n"
"        'SRID=4326;LINESTRING(-72.1260 42.45, -72.123 42.1546)'::geography "
"as gg2\n"
"        ) As foo  ;\n"
"\n"
"  spheroid_dist   |   sphere_dist\n"
"------------------+------------------\n"
" 123.802076746848 | 123.475736916397"
msgstr ""

#. Tag: para
#: reference_measure.xml:421
#, no-c-format
msgid ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DistanceSphere\"/>, "
"<xref linkend=\"ST_Distance_Spheroid\"/>, <xref linkend=\"ST_MaxDistance\"/"
">, <xref linkend=\"ST_HausdorffDistance\"/>, <xref linkend="
"\"ST_FrechetDistance\"/>, <xref linkend=\"ST_Transform\"/>"
msgstr ""

#. Tag: refname
#: reference_measure.xml:428
#, no-c-format
msgid "ST_3DDistance"
msgstr "ST_3DDistance"

#. Tag: refpurpose
#: reference_measure.xml:430
#, fuzzy, no-c-format
msgid ""
"Returns the 3D cartesian minimum distance (based on spatial ref) between two "
"geometries in projected units."
msgstr ""
"도형 유형에 대해, 두 도형 사이의 (SRS에 기반한) 3차원 데카르트 최단 거리를 투"
"영 단위로 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:435
#, no-c-format
msgid ""
"<funcdef>float <function>ST_3DDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_3DDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:450
#, fuzzy, no-c-format
msgid ""
"Returns the 3-dimensional minimum cartesian distance between two geometries "
"in projected units (spatial ref units)."
msgstr ""
"도형 유형에 대해, 두 도형 사이의 3차원 데카르트 최단 거리를 두 도형의 투영 단"
"위(SRS 단위)로 반환합니다."

#. Tag: para
#: reference_measure.xml:456
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM ?"
msgstr "&sqlmm_compliant; SQL-MM ?"

#. Tag: para
#: reference_measure.xml:459 reference_measure.xml:1147
#, no-c-format
msgid ""
"Changed: 2.2.0 - In case of 2D and 3D, Z is no longer assumed to be 0 for "
"missing Z."
msgstr ""
"변경 사항: 2.2.0 버전부터, 2D 및 3D의 경우 더 이상 Z가 없을 때 Z를 0으로 가정"
"하지 않습니다."

#. Tag: para
#: reference_measure.xml:460
#, no-c-format
msgid "Changed: 3.0.0 - SFCGAL version removed"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:466
#, fuzzy, no-c-format
msgid ""
"-- Geometry example - units in meters (SRID: 2163 US National Atlas Equal "
"area) (3D point and line compared 2D point and line)\n"
"-- Note: currently no vertical datum support so Z is not transformed and "
"assumed to be same units as final.\n"
"SELECT ST_3DDistance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521 4)'::"
"geometry,2163),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45 "
"15, -72.123 42.1546 20)'::geometry,2163)\n"
"                ) As dist_3d,\n"
"                ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry,2163),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry,2163)\n"
"                ) As dist_2d;\n"
"\n"
"     dist_3d      |     dist_2d\n"
"------------------+-----------------\n"
" 127.295059324629 | 126.66425605671"
msgstr ""
"-- 도형 예시 - 미터 단위 (SRID 2163 미국 등적 전도) (2D 포인트 및 라인과 비교"
"한 3D 포인트 및 라인)\n"
"-- 주의: 현재 수직 데이터를 지원하지 않으므로 Z를 변환하지 않고 최종 결과물"
"과 동일한 단위로 가정합니다.\n"
"SELECT ST_3DDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 4)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_3d,\n"
"                ST_Distance(\n"
"                        ST_Transform(ST_GeomFromText('POINT(-72.1235 "
"42.3521)',4326),2163),\n"
"                        ST_Transform(ST_GeomFromText('LINESTRING(-72.1260 "
"42.45, -72.123 42.1546)', 4326),2163)\n"
"                ) As dist_2d;\n"
"\n"
"     dist_3d      |     dist_2d\n"
"------------------+-----------------\n"
" 127.295059324629 | 126.66425605671"

#. Tag: programlisting
#: reference_measure.xml:467
#, fuzzy, no-c-format
msgid ""
"-- Multilinestring and polygon both 3d and 2d distance\n"
"-- Same example as 3D closest point example\n"
"SELECT ST_3DDistance(poly, mline) As dist3d,\n"
"    ST_Distance(poly, mline) As dist2d\n"
"        FROM (SELECT  'POLYGON((175 150 5, 20 40 5, 35 45 5, 50 60 5, 100 "
"100 5, 175 150 5))'::geometry as poly,\n"
"               'MULTILINESTRING((175 155 2, 20 40 20, 50 60 -2, 125 100 1, "
"175 155 1), (1 10 2, 5 20 1))'::geometry as mline) as foo;\n"
"      dist3d       | dist2d\n"
"-------------------+--------\n"
" 0.716635696066337 |      0"
msgstr ""
"-- 멀티라인스트링과 폴리곤 모두의 3D 및 2D 거리\n"
"-- 3D 최근접점(closest point) 예시와 동일\n"
"SELECT ST_3DDistance(poly, mline) As dist3d,\n"
"    ST_Distance(poly, mline) As dist2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"      dist3d       | dist2d\n"
"-------------------+--------\n"
" 0.716635696066337 |      0"

#. Tag: para
#: reference_measure.xml:473
#, no-c-format
msgid ""
", <xref linkend=\"ST_3DClosestPoint\"/>, <xref linkend=\"ST_3DDWithin\"/>, "
"<xref linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_3DShortestLine\"/>, "
"<xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_3DClosestPoint\"/>, <xref linkend=\"ST_3DDWithin\"/>, "
"<xref linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_3DShortestLine\"/>, "
"<xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_measure.xml:479
#, no-c-format
msgid "ST_DistanceSphere"
msgstr "ST_DistanceSphere"

#. Tag: refpurpose
#: reference_measure.xml:481
#, fuzzy, no-c-format
msgid ""
"Returns minimum distance in meters between two lon/lat geometries using a "
"spherical earth model."
msgstr ""
"특정 회전타원체가 주어진 두 경위도 도형 사이의 최단 거리를 반환합니다. "
"PostGIS 1.5 미만 버전은 포인트만 지원했습니다."

#. Tag: funcprototype
#: reference_measure.xml:488
#, no-c-format
msgid ""
"<funcdef>float <function>ST_DistanceSphere</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomlonlatA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>geomlonlatB</"
"parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_DistanceSphere</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomlonlatA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>geomlonlatB</"
"parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:499
#, no-c-format
msgid ""
"Returns minimum distance in meters between two lon/lat points. Uses a "
"spherical earth and radius derived from the spheroid defined by the SRID. "
"Faster than <xref linkend=\"ST_Distance_Spheroid\"/>, but less accurate. "
"PostGIS Versions prior to 1.5 only implemented for points."
msgstr ""
"경위도 포인트 2개 사이의 최단 거리를 미터 단위로 반환합니다. SRID가 정의하는 "
"회전타원체에서 추출한 반경을 가진 지구 구체를 이용합니다. <xref linkend="
"\"ST_Distance_Spheroid\"/> 보다는 처리 속도가 빠르지만, 정확도는 떨어집니다. "
"PostGIS 1.5 미만 버전에서는 포인트에 대해서만 구현돼 있었습니다."

#. Tag: para
#: reference_measure.xml:505 reference_measure.xml:555
#, no-c-format
msgid ""
"Availability: 1.5 - support for other geometry types besides points was "
"introduced. Prior versions only work with points."
msgstr ""
"1.5 버전부터 포인트가 아닌 다른 도형 유형을 지원하기 시작했습니다. 1.5 미만 "
"버전에서는 포인트에 대해서만 구현돼 있었습니다."

#. Tag: para
#: reference_measure.xml:506
#, no-c-format
msgid ""
"Changed: 2.2.0 In prior versions this used to be called ST_Distance_Sphere"
msgstr ""
"변경 사항: 2.2.0 미만 버전에서는 ST_Distance_Sphere라는 명칭이었습니다."

#. Tag: programlisting
#: reference_measure.xml:513
#, no-c-format
msgid ""
"SELECT round(CAST(ST_DistanceSphere(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As dist_meters,\n"
"round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As dist_utm11_meters,\n"
"round(CAST(ST_Distance(ST_Centroid(the_geom), ST_GeomFromText('POINT(-118 "
"38)', 4326)) As numeric),5) As dist_degrees,\n"
"round(CAST(ST_Distance(ST_Transform(the_geom,32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As min_dist_line_point_meters\n"
"FROM\n"
"        (SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', "
"4326) As the_geom) as foo;\n"
"         dist_meters | dist_utm11_meters | dist_degrees | "
"min_dist_line_point_meters\n"
"        -------------+-------------------+--------------"
"+----------------------------\n"
"                70424.47 |          70438.00 |      0.72900 "
"|                   65871.18"
msgstr ""
"SELECT round(CAST(ST_DistanceSphere(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As dist_meters,\n"
"round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As dist_utm11_meters,\n"
"round(CAST(ST_Distance(ST_Centroid(the_geom), ST_GeomFromText('POINT(-118 "
"38)', 4326)) As numeric),5) As dist_degrees,\n"
"round(CAST(ST_Distance(ST_Transform(the_geom,32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As min_dist_line_point_meters\n"
"FROM\n"
"        (SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', "
"4326) As the_geom) as foo;\n"
"         dist_meters | dist_utm11_meters | dist_degrees | "
"min_dist_line_point_meters\n"
"        -------------+-------------------+--------------"
"+----------------------------\n"
"                70424.47 |          70438.00 |      0.72900 "
"|                   65871.18"

#. Tag: para
#: reference_measure.xml:520
#, no-c-format
msgid ", <xref linkend=\"ST_Distance_Spheroid\"/>"
msgstr ", <xref linkend=\"ST_Distance_Spheroid\"/>"

#. Tag: refname
#: reference_measure.xml:526
#, no-c-format
msgid "ST_DistanceSpheroid"
msgstr "ST_DistanceSpheroid"

#. Tag: refpurpose
#: reference_measure.xml:528
#, fuzzy, no-c-format
msgid ""
"Returns the minimum distance between two lon/lat geometries using a "
"spheroidal earth model."
msgstr ""
"특정 회전타원체가 주어진 두 경위도 도형 사이의 최단 거리를 반환합니다. "
"PostGIS 1.5 미만 버전은 포인트만 지원했습니다."

#. Tag: funcprototype
#: reference_measure.xml:534
#, no-c-format
msgid ""
"<funcdef>float <function>ST_DistanceSpheroid</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomlonlatA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>geomlonlatB</"
"parameter></paramdef> <paramdef><type>spheroid </type> "
"<parameter>measurement_spheroid</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_DistanceSpheroid</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomlonlatA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>geomlonlatB</"
"parameter></paramdef> <paramdef><type>spheroid </type> "
"<parameter>measurement_spheroid</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:546
#, fuzzy, no-c-format
msgid ""
"Returns minimum distance in meters between two lon/lat geometries given a "
"particular spheroid. See the explanation of spheroids given for <xref "
"linkend=\"ST_Length_Spheroid\"/>."
msgstr ""
"특정 회전타원체가 주어진 두 경위도 도형 사이의 최단 거리를 반환합니다. 주어"
"진 회전타원체에 대한 설명은 <xref linkend=\"ST_Length_Spheroid\"/> 를 참조하"
"십시오. PostGIS 1.5 미만 버전은 포인트만 지원했습니다."

#. Tag: para
#: reference_measure.xml:550
#, fuzzy, no-c-format
msgid ""
"This function does not look at the SRID of the geometry. It assumes the "
"geometry coordinates are based on the provided spheroid."
msgstr ""
"현재 이 함수는 도형의 SRID를 찾아보지 않고 주어진 회전타원체의 좌표로 쓰여 있"
"다고 가정할 것입니다. 이 함수의 이전 버전은 포인트만 지원했습니다."

#. Tag: para
#: reference_measure.xml:556
#, fuzzy, no-c-format
msgid "Changed: 2.2.0 In prior versions this was called ST_Distance_Spheroid"
msgstr ""
"변경 사항: 2.2.0 미만 버전에서는 ST_Distance_Spheroid라는 명칭이었습니다."

#. Tag: programlisting
#: reference_measure.xml:563
#, no-c-format
msgid ""
"SELECT round(CAST(\n"
"                ST_DistanceSpheroid(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326), 'SPHEROID[\"WGS "
"84\",6378137,298.257223563]')\n"
"                        As numeric),2) As dist_meters_spheroid,\n"
"                round(CAST(ST_DistanceSphere(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As "
"dist_meters_sphere,\n"
"round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As dist_utm11_meters\n"
"FROM\n"
"        (SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', "
"4326) As the_geom) as foo;\n"
" dist_meters_spheroid | dist_meters_sphere | dist_utm11_meters\n"
"----------------------+--------------------+-------------------\n"
"                         70454.92 |           70424.47 |          70438.00"
msgstr ""
"SELECT round(CAST(\n"
"                ST_DistanceSpheroid(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326), 'SPHEROID[\"WGS "
"84\",6378137,298.257223563]')\n"
"                        As numeric),2) As dist_meters_spheroid,\n"
"                round(CAST(ST_DistanceSphere(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As "
"dist_meters_sphere,\n"
"round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As dist_utm11_meters\n"
"FROM\n"
"        (SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', "
"4326) As the_geom) as foo;\n"
" dist_meters_spheroid | dist_meters_sphere | dist_utm11_meters\n"
"----------------------+--------------------+-------------------\n"
"                         70454.92 |           70424.47 |          70438.00"

#. Tag: para
#: reference_measure.xml:570
#, no-c-format
msgid ", <xref linkend=\"ST_DistanceSphere\"/>"
msgstr ", <xref linkend=\"ST_DistanceSphere\"/>"

#. Tag: refname
#: reference_measure.xml:577
#, no-c-format
msgid "ST_FrechetDistance"
msgstr ""

#. Tag: refpurpose
#: reference_measure.xml:579
#, fuzzy, no-c-format
msgid "Returns the Fréchet distance between two geometries."
msgstr "두 도형 사이의 3차원 최단(shortest) 라인을 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:584
#, no-c-format
msgid ""
"<funcdef>float <function>ST_FrechetDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>densifyFrac = -1</parameter></"
"paramdef>"
msgstr ""

#. Tag: para
#: reference_measure.xml:602
#, no-c-format
msgid ""
"Implements algorithm for computing the Fréchet distance restricted to "
"discrete points for both geometries, based on <ulink url=\"http://www.kr."
"tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf\">Computing Discrete "
"Fréchet Distance</ulink>. The Fréchet distance is a measure of similarity "
"between curves that takes into account the location and ordering of the "
"points along the curves. Therefore it is often better than the Hausdorff "
"distance."
msgstr ""

#. Tag: para
#: reference_measure.xml:604
#, no-c-format
msgid ""
"When the optional densifyFrac is specified, this function performs a segment "
"densification before computing the discrete Fréchet distance. The "
"densifyFrac parameter sets the fraction by which to densify each segment. "
"Each segment will be split into a number of equal-length subsegments, whose "
"fraction of the total length is closest to the given fraction."
msgstr ""

#. Tag: para
#: reference_measure.xml:607 reference_measure.xml:682
#, no-c-format
msgid ""
"Units are in the units of the spatial reference system of the geometries."
msgstr ""

#. Tag: para
#: reference_measure.xml:611 reference_measure.xml:686
#, no-c-format
msgid ""
"The current implementation supports only vertices as the discrete locations. "
"This could be extended to allow an arbitrary density of points to be used."
msgstr ""
"현재 구현된 함수는 불연속 위치로 꼭짓점만 지원합니다. 이를 임의 밀도의 포인트"
"들을 사용할 수 있도록 확장할 수 있습니다."

#. Tag: para
#: reference_measure.xml:616
#, no-c-format
msgid ""
"The smaller densifyFrac we specify, the more acurate Fréchet distance we "
"get. But, the computation time and the memory usage increase with the square "
"of the number of subsegments."
msgstr ""

#. Tag: para
#: reference_measure.xml:620 reference_measure.xml:1259
#, fuzzy, no-c-format
msgid "Performed by the GEOS module."
msgstr "GEOS 모듈로 실행"

#. Tag: para
#: reference_measure.xml:621
#, no-c-format
msgid "Availability: 2.4.0 - requires GEOS &gt;= 3.7.0"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:627
#, no-c-format
msgid ""
"postgres=# SELECT st_frechetdistance('LINESTRING (0 0, 100 0)'::geometry, "
"'LINESTRING (0 0, 50 50, 100 0)'::geometry);\n"
" st_frechetdistance\n"
"--------------------\n"
"   70.7106781186548\n"
"(1 row)"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:628
#, no-c-format
msgid ""
"SELECT st_frechetdistance('LINESTRING (0 0, 100 0)'::geometry, 'LINESTRING "
"(0 0, 50 50, 100 0)'::geometry, 0.5);\n"
" st_frechetdistance\n"
"--------------------\n"
"                 50\n"
"(1 row)"
msgstr ""

#. Tag: refname
#: reference_measure.xml:640
#, no-c-format
msgid "ST_HausdorffDistance"
msgstr "ST_HausdorffDistance"

#. Tag: refpurpose
#: reference_measure.xml:642
#, fuzzy, no-c-format
msgid "Returns the Hausdorff distance between two geometries."
msgstr "두 도형 사이의 3차원 최단(shortest) 라인을 반환합니다."

#. Tag: funcsynopsis
#: reference_measure.xml:646
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_HausdorffDistance</function></"
"funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_HausdorffDistance</function></funcdef> <paramdef><type>geometry "
"</type> <parameter>g1</parameter></paramdef> <paramdef><type>geometry </"
"type> <parameter>g2</parameter></paramdef> <paramdef><type>float</type> "
"<parameter>densifyFrac</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_HausdorffDistance</function></"
"funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_HausdorffDistance</function></funcdef> <paramdef><type>geometry "
"</type> <parameter>g1</parameter></paramdef> <paramdef><type>geometry </"
"type> <parameter>g2</parameter></paramdef> <paramdef><type>float</type> "
"<parameter>densifyFrac</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_measure.xml:674
#, fuzzy, no-c-format
msgid ""
"Returns the Hausdorff distance between two geometries, a measure of how "
"similar or dissimilar 2 geometries are."
msgstr ""
"두 도형 사이의 하우스도르프 거리를 반환합니다. 기본적으로 두 도형이 얼마나 유"
"사한지 또는 유사하지 않은지에 대한 척도입니다. 두 도형의 공간 참조 시스템 단"
"위를 씁니다."

#. Tag: para
#: reference_measure.xml:676
#, no-c-format
msgid ""
"Implements algorithm for computing a distance metric which can be thought of "
"as the \"Discrete Hausdorff Distance\". This is the Hausdorff distance "
"restricted to discrete points for one of the geometries. <ulink url=\"http://"
"en.wikipedia.org/wiki/Hausdorff_distance\">Wikipedia article on Hausdorff "
"distance</ulink> <ulink url=\"http://lin-ear-th-inking.blogspot.com/2009/01/"
"computing-geometric-similarity.html\">Martin Davis note on how Hausdorff "
"Distance calculation was used to prove correctness of the "
"CascadePolygonUnion approach.</ulink>"
msgstr ""
"\"이산 하우스도르프 거리\"라고 할 수 있는 거리 척도를 계산하기 위한 알고리즘"
"을 실행합니다. 이산 하우스도르프 거리란 도형들 가운데 하나에 대해 불연속 포인"
"트들에 제한된 하우스도르프 거리를 말합니다.\n"
"<ulink url=\"http://en.wikipedia.org/wiki/Hausdorff_distance\">하우스도르프 "
"거리에 대한 위키백과 항목</ulink>\n"
"<ulink url=\"http://lin-ear-th-inking.blogspot.com/2009/01/computing-"
"geometric-similarity.html\">캐스케이드 폴리곤 합집합 접근법의 정확도를 증명하"
"기 위해 하우스도르프 거리 계산을 이용한 방법에 대한 마틴 데이비스의 메모</"
"ulink>"

#. Tag: para
#: reference_measure.xml:679
#, no-c-format
msgid ""
"When densifyFrac is specified, this function performs a segment "
"densification before computing the discrete hausdorff distance. The "
"densifyFrac parameter sets the fraction by which to densify each segment. "
"Each segment will be split into a number of equal-length subsegments, whose "
"fraction of the total length is closest to the given fraction."
msgstr ""
"densifyFrac 인수를 설정하면, 이 함수는 구간 고밀화(segment densification) 작"
"업을 수행한 다음 이산 하우스도르프 거리를 계산합니다. densifyFrac 파라미터가 "
"각 구간을 고밀화하는 데 쓰이는 분수를 설정합니다. 각 구간은 동일한 길이의 하"
"위 구간 몇 개로 나뉘며, 이 전체 길이를 나누는 분수가 주어진 분수와 가장 가깝"
"습니다."

#. Tag: para
#: reference_measure.xml:691
#, no-c-format
msgid ""
"This algorithm is NOT equivalent to the standard Hausdorff distance. "
"However, it computes an approximation that is correct for a large subset of "
"useful cases. One important part of this subset is Linestrings that are "
"roughly parallel to each other, and roughly equal in length. This is a "
"useful metric for line matching."
msgstr ""
"이 알고리즘은 표준 하우스도르프 거리 알고리즘과 동등하지 않습니다. 하지만, 유"
"용한 용례의 대용량 하위집합에 대해서 정확할 정도의 근사치를 계산합니다. 이 하"
"위집합의 중요한 부분 가운데 하나가 서로 대강 평행하며 대강 같은 길이를 가진 "
"라인스트링들입니다. 해당 하위집합이 라인을 맞춰보는 데 유용한 척도입니다."

#. Tag: para
#: reference_measure.xml:702
#, no-c-format
msgid ""
"For each building, find the parcel that best represents it. First we require "
"the parcel intersect with the geometry. DISTINCT ON guarantees we get each "
"building listed only once, the ORDER BY .. ST_HausdorffDistance gives us a "
"preference of parcel that is most similar to the building."
msgstr ""
"각 건물에 대해, 해당 건물을 가장 잘 표현하는 구획(parcel)을 찾습니다. 먼저 도"
"형과 교차하는 구획이 필요합니다. DISTINCT ON 이 목록에 한 번씩만 나온 각 건물"
"을 반환해주고, ORDER BY .. ST_HausdorffDistance 가 건물과 가장 유사한 구획의 "
"선호도를 얻게 해줍니다."

#. Tag: programlisting
#: reference_measure.xml:704
#, no-c-format
msgid ""
"SELECT DISTINCT ON(buildings.gid) buildings.gid, parcels.parcel_id\n"
"   FROM buildings INNER JOIN parcels ON ST_Intersects(buildings.geom,parcels."
"geom)\n"
"     ORDER BY buildings.gid, ST_HausdorffDistance(buildings.geom, parcels."
"geom);"
msgstr ""
"SELECT DISTINCT ON(buildings.gid) buildings.gid, parcels.parcel_id\n"
"   FROM buildings INNER JOIN parcels ON ST_Intersects(buildings.geom,parcels."
"geom)\n"
"     ORDER BY buildings.gid, ST_HausdorffDistance(buildings.geom, parcels."
"geom);"

#. Tag: programlisting
#: reference_measure.xml:706
#, no-c-format
msgid ""
"postgis=# SELECT ST_HausdorffDistance(\n"
"                                'LINESTRING (0 0, 2 0)'::geometry,\n"
"                                'MULTIPOINT (0 1, 1 0, 2 1)'::geometry);\n"
" st_hausdorffdistance\n"
" ----------------------\n"
"                                         1\n"
"(1 row)"
msgstr ""
"postgis=# SELECT ST_HausdorffDistance(\n"
"                                'LINESTRING (0 0, 2 0)'::geometry,\n"
"                                'MULTIPOINT (0 1, 1 0, 2 1)'::geometry);\n"
" st_hausdorffdistance\n"
" ----------------------\n"
"                                         1\n"
"(1 row)"

#. Tag: programlisting
#: reference_measure.xml:707
#, no-c-format
msgid ""
"postgis=# SELECT st_hausdorffdistance('LINESTRING (130 0, 0 0, 0 150)'::"
"geometry, 'LINESTRING (10 10, 10 150, 130 10)'::geometry, 0.5);\n"
" st_hausdorffdistance\n"
" ----------------------\n"
"                                        70\n"
"(1 row)"
msgstr ""
"postgis=# SELECT st_hausdorffdistance('LINESTRING (130 0, 0 0, 0 150)'::"
"geometry, 'LINESTRING (10 10, 10 150, 130 10)'::geometry, 0.5);\n"
" st_hausdorffdistance\n"
" ----------------------\n"
"                                        70\n"
"(1 row)"

#. Tag: refname
#: reference_measure.xml:719
#, no-c-format
msgid "ST_Length"
msgstr "ST_Length"

#. Tag: refpurpose
#: reference_measure.xml:721
#, fuzzy, no-c-format
msgid "Returns the 2D length of a linear geometry."
msgstr "도형의 기하학적 중심을 반환합니다."

#. Tag: funcsynopsis
#: reference_measure.xml:724
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Length</function></funcdef> "
"<paramdef><type>geometry </type><parameter>a_2dlinestring</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_Length</function></funcdef> <paramdef><type>geography </"
"type><parameter>geog</parameter></paramdef> <paramdef choice=\"opt"
"\"><type>boolean </type><parameter>use_spheroid=true</parameter></paramdef> "
"</funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_Length</function></funcdef> "
"<paramdef><type>geometry </type><parameter>a_2dlinestring</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_Length</function></funcdef> <paramdef><type>geography </"
"type><parameter>geog</parameter></paramdef> <paramdef choice=\"opt"
"\"><type>boolean </type><parameter>use_spheroid=true</parameter></paramdef> "
"</funcprototype>"

#. Tag: para
#: reference_measure.xml:739
#, fuzzy, no-c-format
msgid ""
"For geometry types: returns the 2D Cartesian length of the geometry if it is "
"a LineString, MultiLineString, ST_Curve, ST_MultiCurve. For areal geometries "
"0 is returned; use <xref linkend=\"ST_Perimeter\"/> instead. The units of "
"length is determined by the spatial reference system of the geometry."
msgstr ""
"도형의 경우: 도형이 라인스트링, 멀티라인스트링, ST_Curve, ST_MultiCurve일 경"
"우 도형의 2차원 데카르트 길이를 반환합니다. 면 도형의 경우 0을 반환합니다. "
"면 도형에 대해서는 <xref linkend=\"ST_Perimeter\"/> 를 이용하십시오. 도형 유"
"형의 경우, 도형의 공간 참조 시스템이 해당 길이의 측정 단위를 설정합니다."

#. Tag: para
#: reference_measure.xml:743
#, fuzzy, no-c-format
msgid ""
"For geography types: computation is performed using the inverse geodesic "
"calculation. Units of length are in meters. If PostGIS is compiled with PROJ "
"version 4.8.0 or later, the spheroid is specified by the SRID, otherwise it "
"is exclusive to WGS84. If <varname>use_spheroid=false</varname>, then the "
"calculation is based on a sphere instead of a spheroid."
msgstr ""
"지리형의 경우: 측지 역 문제(geodesic inverse problem)를 이용해서 계산을 수행"
"합니다. 이때 길이 단위는 미터입니다. PostGIS를 PROJ 4.8.0 이상 버전과 함께 컴"
"파일한 경우, SRID가 회정타원체를 정의합니다. SRID가 없는 경우 오직 WGS84로 설"
"정됩니다. <varname>use_spheroid=false</varname> 일 경우, 회전타원체 대신 구"
"체 상에서 근사치를 계산할 것입니다."

#. Tag: para
#: reference_measure.xml:748
#, no-c-format
msgid ""
"Currently for geometry this is an alias for ST_Length2D, but this may change "
"to support higher dimensions."
msgstr ""
"도형의 경우 이 함수는 현재 ST_Length2D와 동일하지만, 향후 더 높은 차원을 지원"
"하기 위해 변경될 수도 있습니다."

#. Tag: para
#: reference_measure.xml:750
#, no-c-format
msgid ""
"Changed: 2.0.0 Breaking change -- in prior versions applying this to a MULTI/"
"POLYGON of type geography would give you the perimeter of the POLYGON/"
"MULTIPOLYGON. In 2.0.0 this was changed to return 0 to be in line with "
"geometry behavior. Please use ST_Perimeter if you want the perimeter of a "
"polygon"
msgstr ""
"변경 사항: 2.0.0 버전에서 중요한 변경이 이루어졌습니다. 2.0.0 이전 버전에서 "
"이 함수에 폴리곤/멀티폴리곤 유형의 지리형을 입력하면 폴리곤/멀티폴리곤의 둘레"
"를 반환했을 겁니다. 2.0.0 버전부터 도형 습성과 맞추기 위해 0을 반환하도록 변"
"경됐습니다. 폴리곤의 둘레를 원한다면 ST_Perimeter 함수를 이용하십시오."

#. Tag: para
#: reference_measure.xml:753
#, fuzzy, no-c-format
msgid ""
"For geography the calculation defaults to using a spheroidal model. To use "
"the faster but less accurate spherical calculation use ST_Length(gg,false);"
msgstr ""
"지리형 측정시 기본값은 회전타원체 상의 측정입니다. 더 빠르지만 덜 정확한 구체"
"를 이용하려면 ST_Length(gg,false); 를 쓰십시오."

#. Tag: para
#: reference_measure.xml:754 reference_measure.xml:1311
#, no-c-format
msgid "&sfs_compliant; s2.1.5.1"
msgstr "&sfs_compliant; s2.1.5.1"

#. Tag: para
#: reference_measure.xml:755
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 7.1.2, 9.3.4"
msgstr "&sqlmm_compliant; SQL-MM 3: 7.1.2, 9.3.4"

#. Tag: para
#: reference_measure.xml:756
#, no-c-format
msgid "Availability: 1.5.0 geography support was introduced in 1.5."
msgstr "1.5.0 버전부터 지리형을 지원합니다."

#. Tag: para
#: reference_measure.xml:757
#, no-c-format
msgid "&sfcgal_enhanced;"
msgstr "&sfcgal_enhanced;"

#. Tag: title
#: reference_measure.xml:761
#, no-c-format
msgid "Geometry Examples"
msgstr "도형 예시"

#. Tag: para
#: reference_measure.xml:762
#, no-c-format
msgid ""
"Return length in feet for line string. Note this is in feet because "
"EPSG:2249 is Massachusetts State Plane Feet"
msgstr ""
"라인스트링의 길이를 피트 단위로 반환합니다. 투영체 EPSG:2249가 매사추세츠 주 "
"피트 단위 평면이기 때문에 피트 단위라는 사실을 주의하십시오."

#. Tag: programlisting
#: reference_measure.xml:764
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Length(ST_GeomFromText('LINESTRING(743238 2967416,743238 "
"2967450,743265 2967450,\n"
"743265.625 2967416,743238 2967416)',2249));\n"
"\n"
"st_length\n"
"---------\n"
" 122.630744000095\n"
"\n"
"\n"
"--Transforming WGS 84 LineString to Massachusetts state plane meters\n"
"SELECT ST_Length(\n"
"        ST_Transform(\n"
"                ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.1240 42.45666, -72.123 42.1546)'),\n"
"                26986\n"
"        )\n"
");\n"
"\n"
"st_length\n"
"---------\n"
"34309.4563576191"
msgstr ""
"SELECT ST_Length(ST_GeomFromText('LINESTRING(743238 2967416,743238 "
"2967450,743265 2967450,\n"
"743265.625 2967416,743238 2967416)',2249));\n"
"st_length\n"
"---------\n"
" 122.630744000095\n"
"\n"
"\n"
"-- WGS84 라인스트링을 매사추세츠 주 피트 단위 평면으로 변환\n"
"SELECT ST_Length(\n"
"        ST_Transform(\n"
"                ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.1240 42.45666, -72.123 42.1546)'),\n"
"                26986\n"
"        )\n"
");\n"
"st_length\n"
"---------\n"
"34309.4563576191"

#. Tag: para
#: reference_measure.xml:768
#, no-c-format
msgid "Return length of WGS 84 geography line"
msgstr "WGS84 지리형 라인의 길이를 반환합니다."

#. Tag: programlisting
#: reference_measure.xml:769
#, fuzzy, no-c-format
msgid ""
"-- the default calculation uses a spheroid\n"
"SELECT ST_Length(the_geog) As length_spheroid,  ST_Length(the_geog,false) As "
"length_sphere\n"
"FROM (SELECT ST_GeographyFromText(\n"
"'SRID=4326;LINESTRING(-72.1260 42.45, -72.1240 42.45666, -72.123 42.1546)') "
"As the_geog)\n"
" As foo;\n"
"\n"
" length_spheroid  |  length_sphere\n"
"------------------+------------------\n"
" 34310.5703627288 | 34346.2060960742"
msgstr ""
"-- 계산시 회전타원체보다는 구체를 이용합니다.\n"
"SELECT ST_Length(the_geog) As length_spheroid,  ST_Length(the_geog,false) As "
"length_sphere\n"
"FROM (SELECT ST_GeographyFromText(\n"
"'SRID=4326;LINESTRING(-72.1260 42.45, -72.1240 42.45666, -72.123 42.1546)') "
"As the_geog)\n"
" As foo;\n"
" length_spheroid  |  length_sphere\n"
"------------------+------------------\n"
" 34310.5703627288 | 34346.2060960742"

#. Tag: para
#: reference_measure.xml:773
#, no-c-format
msgid ""
", <xref linkend=\"ST_GeomFromEWKT\"/>, <xref linkend=\"ST_Length_Spheroid\"/"
">, <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_GeomFromEWKT\"/>, <xref linkend=\"ST_Length_Spheroid\"/"
">, <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_measure.xml:779
#, no-c-format
msgid "ST_Length2D"
msgstr "ST_Length2D"

#. Tag: refpurpose
#: reference_measure.xml:781
#, fuzzy, no-c-format
msgid ""
"Returns the 2D length of a linear geometry. Alias for <varname>ST_Length</"
"varname>"
msgstr ""
"<para>도형이 라인스트링 또는 멀티라인스트링일 경우 도형의 2차원 길이를 반환합"
"니다. 이 함수는 <varname>ST_Length</varname> 와 동일합니다.</para>"

#. Tag: funcprototype
#: reference_measure.xml:786
#, no-c-format
msgid ""
"<funcdef>float <function>ST_Length2D</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_2dlinestring</parameter></"
"paramdef>"
msgstr ""
"<funcdef>float <function>ST_Length2D</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_2dlinestring</parameter></"
"paramdef>"

#. Tag: para
#: reference_measure.xml:796
#, fuzzy, no-c-format
msgid ""
"Returns the 2D length of the geometry if it is a linestring or multi-"
"linestring. This is an alias for <varname>ST_Length</varname>"
msgstr ""
"<para>도형이 라인스트링 또는 멀티라인스트링일 경우 도형의 2차원 길이를 반환합"
"니다. 이 함수는 <varname>ST_Length</varname> 와 동일합니다.</para>"

#. Tag: para
#: reference_measure.xml:805
#, no-c-format
msgid ", <xref linkend=\"ST_3DLength\"/>"
msgstr ", <xref linkend=\"ST_3DLength\"/>"

#. Tag: refname
#: reference_measure.xml:811
#, no-c-format
msgid "ST_3DLength"
msgstr "ST_3DLength"

#. Tag: refpurpose
#: reference_measure.xml:813
#, fuzzy, no-c-format
msgid "Returns the 3D length of a linear geometry."
msgstr "도형의 기하학적 중심을 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:818
#, no-c-format
msgid ""
"<funcdef>float <function>ST_3DLength</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_3dlinestring</parameter></"
"paramdef>"
msgstr ""
"<funcdef>float <function>ST_3DLength</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_3dlinestring</parameter></"
"paramdef>"

#. Tag: para
#: reference_measure.xml:828
#, no-c-format
msgid ""
"Returns the 3-dimensional or 2-dimensional length of the geometry if it is a "
"linestring or multi-linestring. For 2-d lines it will just return the 2-d "
"length (same as ST_Length and ST_Length2D)"
msgstr ""
"도형이 라인스트링 또는 멀티라인스트링일 경우 도형의 3차원 또는 2차원 길이를 "
"반환합니다. 2차원 라인의 경우 2차원 길이만 반환할 것입니다(ST_Length 및 "
"ST_Length2D와 동일합니다)."

#. Tag: para
#: reference_measure.xml:831
#, no-c-format
msgid "Changed: 2.0.0 In prior versions this used to be called ST_Length3D"
msgstr "변경 사항: 2.0.0 미만 버전에서는 ST_Length3D라는 명칭이었습니다."

#. Tag: para
#: reference_measure.xml:838
#, no-c-format
msgid ""
"Return length in feet for a 3D cable. Note this is in feet because EPSG:2249 "
"is Massachusetts State Plane Feet"
msgstr ""
"3차원 케이블의 길이를 피트 단위로 반환합니다. 투영체 EPSG:2249가 매사추세츠 "
"주 피트 단위 평면이기 때문에 피트 단위라는 사실을 주의하십시오."

#. Tag: programlisting
#: reference_measure.xml:840
#, no-c-format
msgid ""
"SELECT ST_3DLength(ST_GeomFromText('LINESTRING(743238 2967416 1,743238 "
"2967450 1,743265 2967450 3,\n"
"743265.625 2967416 3,743238 2967416 3)',2249));\n"
"ST_3DLength\n"
"-----------\n"
"122.704716741457"
msgstr ""
"SELECT ST_3DLength(ST_GeomFromText('LINESTRING(743238 2967416 1,743238 "
"2967450 1,743265 2967450 3,\n"
"743265.625 2967416 3,743238 2967416 3)',2249));\n"
"ST_3DLength\n"
"-----------\n"
"122.704716741457"

#. Tag: para
#: reference_measure.xml:847
#, no-c-format
msgid ", <xref linkend=\"ST_Length2D\"/>"
msgstr ", <xref linkend=\"ST_Length2D\"/>"

#. Tag: refname
#: reference_measure.xml:853
#, no-c-format
msgid "ST_LengthSpheroid"
msgstr "ST_LengthSpheroid"

#. Tag: refpurpose
#: reference_measure.xml:855
#, fuzzy, no-c-format
msgid ""
"Returns the 2D or 3D length/perimeter of a lon/lat geometry on a spheroid."
msgstr "도형의 기하학적 중심을 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:860
#, no-c-format
msgid ""
"<funcdef>float <function>ST_LengthSpheroid</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_geometry</parameter></"
"paramdef> <paramdef><type>spheroid </type> <parameter>a_spheroid</"
"parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_LengthSpheroid</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_geometry</parameter></"
"paramdef> <paramdef><type>spheroid </type> <parameter>a_spheroid</"
"parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:871
#, fuzzy, no-c-format
msgid ""
"Calculates the length or perimeter of a geometry on an ellipsoid. This is "
"useful if the coordinates of the geometry are in longitude/latitude and a "
"length is desired without reprojection. The spheroid is specified by a text "
"value as follows:"
msgstr ""
"타원체 상에 있는 도형의 길이/둘레를 계산합니다. 이 함수는 도형의 좌표가 경도/"
"위도이며 재투영하지 않고 길이를 얻고 싶을 때 유용합니다. 이 타원체는 개별적"
"인 데이터베이스 유형으로 다음과 같이 작성할 수 있습니다:"

#. Tag: literallayout
#: reference_measure.xml:876
#, no-c-format
msgid ""
"SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR AXIS&gt;,&lt;INVERSE FLATTENING&gt;]"
msgstr ""
"SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR AXIS&gt;,&lt;INVERSE FLATTENING&gt;]"

#. Tag: para
#: reference_measure.xml:877
#, fuzzy, no-c-format
msgid "For example:"
msgstr "도형 예시"

#. Tag: literallayout
#: reference_measure.xml:878
#, no-c-format
msgid "SPHEROID[\"GRS_1980\",6378137,298.257222101]"
msgstr "SPHEROID[\"GRS_1980\",6378137,298.257222101]"

#. Tag: para
#: reference_measure.xml:880
#, no-c-format
msgid "Availability: 1.2.2"
msgstr "1.2.2 버전부터 사용할 수 있습니다."

#. Tag: para
#: reference_measure.xml:881
#, fuzzy, no-c-format
msgid ""
"Changed: 2.2.0 In prior versions this was called ST_Length_Spheroid and had "
"the alias ST_3DLength_Spheroid"
msgstr ""
"변경 사항: 2.2.0 미만 버전에서는 ST_Length_Spheroid라는 명칭이었으며, "
"ST_3DLength_Spheroid라는 동일 함수가 있었습니다."

#. Tag: programlisting
#: reference_measure.xml:888
#, no-c-format
msgid ""
"SELECT ST_LengthSpheroid( geometry_column,\n"
"                          'SPHEROID[\"GRS_1980\",6378137,298.257222101]' )\n"
"                          FROM geometry_table;\n"
"\n"
"SELECT ST_LengthSpheroid( the_geom, sph_m ) As tot_len,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
"                          FROM (SELECT "
"ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),\n"
"        (-71.05957 42.3589 , -71.061 43))') As the_geom,\n"
"CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As sph_m)  "
"as foo;\n"
"        tot_len      |    len_line1     |    len_line2\n"
"------------------+------------------+------------------\n"
" 85204.5207562955 | 13986.8725229309 | 71217.6482333646\n"
"\n"
" --3D\n"
"SELECT ST_LengthSpheroid( the_geom, sph_m ) As tot_len,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
"                          FROM (SELECT "
"ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),\n"
"        (-71.05957 42.3589 75, -71.061 43 90))') As the_geom,\n"
"CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As sph_m)  "
"as foo;\n"
"\n"
"         tot_len      |    len_line1    |    len_line2\n"
"------------------+-----------------+------------------\n"
" 85204.5259107402 | 13986.876097711 | 71217.6498130292"
msgstr ""
"SELECT ST_LengthSpheroid( geometry_column,\n"
"                          'SPHEROID[\"GRS_1980\",6378137,298.257222101]' )\n"
"                          FROM geometry_table;\n"
"\n"
"SELECT ST_LengthSpheroid( the_geom, sph_m ) As tot_len,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
"                          FROM (SELECT "
"ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),\n"
"        (-71.05957 42.3589 , -71.061 43))') As the_geom,\n"
"CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As sph_m)  "
"as foo;\n"
"        tot_len      |    len_line1     |    len_line2\n"
"------------------+------------------+------------------\n"
" 85204.5207562955 | 13986.8725229309 | 71217.6482333646\n"
"\n"
" -- 3D\n"
"SELECT ST_LengthSpheroid( the_geom, sph_m ) As tot_len,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
"                          FROM (SELECT "
"ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),\n"
"        (-71.05957 42.3589 75, -71.061 43 90))') As the_geom,\n"
"CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As sph_m)  "
"as foo;\n"
"\n"
"         tot_len      |    len_line1    |    len_line2\n"
"------------------+-----------------+------------------\n"
" 85204.5259107402 | 13986.876097711 | 71217.6498130292"

#. Tag: para
#: reference_measure.xml:895
#, no-c-format
msgid ", <xref linkend=\"ST_Length\"/>"
msgstr ", <xref linkend=\"ST_Length\"/>"

#. Tag: refname
#: reference_measure.xml:902
#, no-c-format
msgid "ST_LongestLine"
msgstr "ST_LongestLine"

#. Tag: refpurpose
#: reference_measure.xml:904
#, fuzzy, no-c-format
msgid "Returns the 2D longest line between two geometries."
msgstr "두 도형 사이의 3차원 최장(longest) 라인을 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:910
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_LongestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_LongestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:925
#, fuzzy, no-c-format
msgid ""
"Returns the 2-dimensional longest line between the points of two geometries."
msgstr "두 도형 사이의 2차원 최장 라인을 반환합니다."

#. Tag: para
#: reference_measure.xml:927
#, fuzzy, no-c-format
msgid ""
"The function returns the first longest line if more than one is found. The "
"line returned starts on g1 and ends on g2. The length of the line is equal "
"to the distance returned by <xref linkend=\"ST_MaxDistance\"/>."
msgstr ""
"두 도형 사이의 3차원 최장(longest) 라인을 반환합니다. 하나 이상의 최장 라인"
"이 있을 경우, 이 함수는 첫 번째 최장 라인만 반환할 것입니다. 반환되는 라인은 "
"항상 g1에서 시작해서 g2에서 끝납니다. 이 함수가 반환하는 라인의 3차원 길이는 "
"<xref linkend=\"ST_3DMaxDistance\"/> 함수가 g1과 g2에 대해 반환하는 길이와 언"
"제나 동일합니다."

#. Tag: para
#: reference_measure.xml:946
#, fuzzy, no-c-format
msgid "Longest line between a point and a line"
msgstr "포인트와 라인 사이의 최장 라인"

#. Tag: programlisting
#: reference_measure.xml:949
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"        ST_LongestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As lline;\n"
"\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(100 100,98 190)"
msgstr ""
"SELECT ST_AsText(\n"
"        ST_LongestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As lline;\n"
"\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(100 100,98 190)"

#. Tag: para
#: reference_measure.xml:958
#, fuzzy, no-c-format
msgid "Longest line between two polygons"
msgstr "폴리곤과 폴리곤 사이의 최장 라인"

#. Tag: programlisting
#: reference_measure.xml:961
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"        ST_LongestLine(\n"
"                ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"                        50 60, 125 100, 175 150))'),\n"
"                ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                )\n"
"        ) As llinewkt;\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(20 40,121.111404660392 186.629392246051)"
msgstr ""
"SELECT ST_AsText(\n"
"        ST_LongestLine(\n"
"                ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"                        50 60, 125 100, 175 150))'),\n"
"                ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                )\n"
"        ) As llinewkt;\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(20 40,121.111404660392 186.629392246051)"

#. Tag: para
#: reference_measure.xml:977
#, fuzzy, no-c-format
msgid ""
"Longest straight distance to travel from one part of a city to another. Note "
"that the maximum distance is equal to the length of the line."
msgstr ""
"어떤 도시의 한 부분에서 다른 부분으로 여행하는 경우의 최장 직선 거리(최장 거"
"리가 라인의 길이라는 점에 주의하십시오)"

#. Tag: programlisting
#: reference_measure.xml:981
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText( ST_LongestLine(c.geom, c.geom)) AS llinewkt,\n"
"       ST_MaxDistance( c.geom,c.geom) AS max_dist,\n"
"       ST_Length( ST_LongestLine(c.geom, c.geom)) AS lenll\n"
"FROM (SELECT ST_MakeValid( ST_Collect(geom)) AS geom\n"
"      FROM (SELECT ST_Translate( ST_SnapToGrid(\n"
"                ST_Buffer(\n"
"                    ST_Point(50 ,generate_series(50,190, 50)),\n"
"                    40, 'quad_segs=2'),1), x, 0) AS geom\n"
"            FROM generate_series(1,100,50) As x) AS foo\n"
"      ) AS c;\n"
"\n"
"          llinewkt          |     max_dist     |      lenll\n"
"---------------------------+------------------+------------------\n"
" LINESTRING(23 22,129 178) | 188.605408193933 | 188.605408193933"
msgstr ""
"SELECT ST_AsText(ST_LongestLine(c.the_geom, c.the_geom)) As llinewkt,\n"
"        ST_MaxDistance(c.the_geom,c.the_geom) As max_dist,\n"
"        ST_Length(ST_LongestLine(c.the_geom, c.the_geom)) As lenll\n"
"FROM (SELECT ST_BuildArea(ST_Collect(the_geom)) As the_geom\n"
"        FROM (SELECT ST_Translate(ST_SnapToGrid(ST_Buffer(ST_Point(50 ,"
"generate_series(50,190, 50)\n"
"                        ),40, 'quad_segs=2'),1), x, 0)  As the_geom\n"
"                        FROM generate_series(1,100,50) As x)  AS foo\n"
") As c;\n"
"\n"
"          llinewkt          |     max_dist     |      lenll\n"
"---------------------------+------------------+------------------\n"
" LINESTRING(23 22,129 178) | 188.605408193933 | 188.605408193933"

#. Tag: para
#: reference_measure.xml:992
#, fuzzy, no-c-format
msgid ""
", <xref linkend=\"ST_MakeValid\"/>, <xref linkend=\"ST_ShortestLine\"/>, "
"<xref linkend=\"ST_3DLongestLine\"/>"
msgstr ""
", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_MaxDistance\"/>"

#. Tag: refname
#: reference_measure.xml:998
#, no-c-format
msgid "ST_3DLongestLine"
msgstr "ST_3DLongestLine"

#. Tag: refpurpose
#: reference_measure.xml:1000
#, fuzzy, no-c-format
msgid "Returns the 3D longest line between two geometries"
msgstr "두 도형 사이의 3차원 최장(longest) 라인을 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:1005
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_3DLongestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_3DLongestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1020
#, fuzzy, no-c-format
msgid ""
"Returns the 3-dimensional longest line between two geometries. The function "
"returns the first longest line if more than one. The line returned starts in "
"g1 and ends in g2. The 3D length of the line is equal to the distance "
"returned by <xref linkend=\"ST_3DMaxDistance\"/>."
msgstr ""
"두 도형 사이의 3차원 최장(longest) 라인을 반환합니다. 하나 이상의 최장 라인"
"이 있을 경우, 이 함수는 첫 번째 최장 라인만 반환할 것입니다. 반환되는 라인은 "
"항상 g1에서 시작해서 g2에서 끝납니다. 이 함수가 반환하는 라인의 3차원 길이는 "
"<xref linkend=\"ST_3DMaxDistance\"/> 함수가 g1과 g2에 대해 반환하는 길이와 언"
"제나 동일합니다."

#. Tag: para
#: reference_measure.xml:1039
#, no-c-format
msgid "linestring and point -- both 3d and 2d longest line"
msgstr "라인스트링과 포인트 -- 3D, 2D 모두의 최장 라인"

#. Tag: programlisting
#: reference_measure.xml:1040
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DLongestLine(line,pt)) AS lol3d_line_pt,\n"
"                ST_AsEWKT(ST_LongestLine(line,pt)) As lol2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"           lol3d_line_pt           |       lol2d_line_pt\n"
"-----------------------------------+----------------------------\n"
" LINESTRING(50 75 1000,100 100 30) | LINESTRING(98 190,100 100)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DLongestLine(line,pt)) AS lol3d_line_pt,\n"
"                ST_AsEWKT(ST_LongestLine(line,pt)) As lol2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"           lol3d_line_pt           |       lol2d_line_pt\n"
"-----------------------------------+----------------------------\n"
" LINESTRING(50 75 1000,100 100 30) | LINESTRING(98 190,100 100)"

#. Tag: para
#: reference_measure.xml:1044
#, no-c-format
msgid "linestring and multipoint -- both 3d and 2d longest line"
msgstr "라인스트링과 멀티포인트 -- 3D, 2D 모두의 최장 라인"

#. Tag: programlisting
#: reference_measure.xml:1045
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DLongestLine(line,pt)) AS lol3d_line_pt,\n"
"                ST_AsEWKT(ST_LongestLine(line,pt)) As lol2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"          lol3d_line_pt          |      lol2d_line_pt\n"
"---------------------------------+--------------------------\n"
" LINESTRING(98 190 1,50 74 1000) | LINESTRING(98 190,50 74)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DLongestLine(line,pt)) AS lol3d_line_pt,\n"
"                ST_AsEWKT(ST_LongestLine(line,pt)) As lol2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"          lol3d_line_pt          |      lol2d_line_pt\n"
"---------------------------------+--------------------------\n"
" LINESTRING(98 190 1,50 74 1000) | LINESTRING(98 190,50 74)"

#. Tag: para
#: reference_measure.xml:1049
#, no-c-format
msgid "Multilinestring and polygon both 3d and 2d longest line"
msgstr "멀티라인스트링과 폴리곤 -- 3D, 2D 모두의 최장 라인"

#. Tag: programlisting
#: reference_measure.xml:1050
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DLongestLine(poly, mline)) As lol3d,\n"
"    ST_AsEWKT(ST_LongestLine(poly, mline)) As lol2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"            lol3d             |          lol2d\n"
"------------------------------+--------------------------\n"
" LINESTRING(175 150 5,1 10 2) | LINESTRING(175 150,1 10)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DLongestLine(poly, mline)) As lol3d,\n"
"    ST_AsEWKT(ST_LongestLine(poly, mline)) As lol2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"            lol3d             |          lol2d\n"
"------------------------------+--------------------------\n"
" LINESTRING(175 150 5,1 10 2) | LINESTRING(175 150,1 10)"

#. Tag: para
#: reference_measure.xml:1062
#, no-c-format
msgid ""
", <xref linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_LongestLine\"/>, "
"<xref linkend=\"ST_3DShortestLine\"/>, <xref linkend=\"ST_3DMaxDistance\"/>"
msgstr ""
", <xref linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_LongestLine\"/>, "
"<xref linkend=\"ST_3DShortestLine\"/>, <xref linkend=\"ST_3DMaxDistance\"/>"

#. Tag: refname
#: reference_measure.xml:1068
#, no-c-format
msgid "ST_MaxDistance"
msgstr "ST_MaxDistance"

#. Tag: refpurpose
#: reference_measure.xml:1070
#, fuzzy, no-c-format
msgid ""
"Returns the 2D largest distance between two geometries in projected units."
msgstr "두 도형 사이의 2차원 최장 거리를 투영 단위로 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:1076
#, no-c-format
msgid ""
"<funcdef>float <function>ST_MaxDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_MaxDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1088
#, fuzzy, no-c-format
msgid ""
"Returns the 2-dimensional maximum distance between two geometries, in "
"projected units. The maximum distance always occurs between two vertices. "
"This is the length of the line returned by <xref linkend=\"ST_LongestLine\"/"
">."
msgstr ""
"두 도형 사이의 2차원 최장 거리를 투영 단위로 반환합니다. g1과 g2가 동일한 도"
"형일 경우 이 함수는 해당 도형 내에서 서로 가장 멀리 있는 두 꼭짓점 사이의 거"
"리를 반환합니다."

#. Tag: para
#: reference_measure.xml:1092
#, fuzzy, no-c-format
msgid ""
"If g1 and g2 are the same geometry, returns the distance between the two "
"vertices farthest apart in that geometry."
msgstr ""
"두 도형 사이의 2차원 최장 거리를 투영 단위로 반환합니다. g1과 g2가 동일한 도"
"형일 경우 이 함수는 해당 도형 내에서 서로 가장 멀리 있는 두 꼭짓점 사이의 거"
"리를 반환합니다."

#. Tag: para
#: reference_measure.xml:1101
#, fuzzy, no-c-format
msgid "Maximum distance between a point and lines."
msgstr "포인트와 라인 사이의 최장 라인"

#. Tag: programlisting
#: reference_measure.xml:1102
#, fuzzy, no-c-format
msgid ""
"postgis=# SELECT ST_MaxDistance('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 "
"2 )'::geometry);\n"
"   st_maxdistance\n"
"-----------------\n"
" 2\n"
"\n"
"postgis=# SELECT ST_MaxDistance('POINT(0 0)'::geometry, 'LINESTRING ( 2 2, 2 "
"2 )'::geometry);\n"
"  st_maxdistance\n"
"------------------\n"
" 2.82842712474619"
msgstr ""
"postgis=# SELECT ST_MaxDistance('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 "
"2 )'::geometry);\n"
"   st_maxdistance\n"
"-----------------\n"
" 2\n"
"(1 row)\n"
"\n"
"postgis=# SELECT ST_MaxDistance('POINT(0 0)'::geometry, 'LINESTRING ( 2 2, 2 "
"2 )'::geometry);\n"
"  st_maxdistance\n"
"------------------\n"
" 2.82842712474619\n"
"(1 row)"

#. Tag: para
#: reference_measure.xml:1104
#, fuzzy, no-c-format
msgid "Maximum distance between vertices of a geometry."
msgstr "두 도형 사이의 3차원 최단(shortest) 라인을 반환합니다."

#. Tag: programlisting
#: reference_measure.xml:1105
#, no-c-format
msgid ""
"SELECT ST_MaxDistance('POLYGON ((10 10, 10 0, 0 0, 10 10))'::geometry,\n"
"                      'POLYGON ((10 10, 10 0, 0 0, 10 10))'::geometry);\n"
"  st_maxdistance\n"
"------------------\n"
" 14.142135623730951"
msgstr ""

#. Tag: para
#: reference_measure.xml:1111
#, no-c-format
msgid ""
", <xref linkend=\"ST_LongestLine\"/>, <xref linkend=\"ST_DFullyWithin\"/>"
msgstr ""
", <xref linkend=\"ST_LongestLine\"/>, <xref linkend=\"ST_DFullyWithin\"/>"

#. Tag: refname
#: reference_measure.xml:1117
#, no-c-format
msgid "ST_3DMaxDistance"
msgstr "ST_3DMaxDistance"

#. Tag: refpurpose
#: reference_measure.xml:1119
#, fuzzy, no-c-format
msgid ""
"Returns the 3D cartesian maximum distance (based on spatial ref) between two "
"geometries in projected units."
msgstr ""
"도형 유형에 대해, 두 도형 사이의 (SRS에 기반한) 3차원 데카르트 최장 거리를 투"
"영 단위로 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:1124
#, no-c-format
msgid ""
"<funcdef>float <function>ST_3DMaxDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_3DMaxDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1139
#, fuzzy, no-c-format
msgid ""
"Returns the 3-dimensional maximum cartesian distance between two geometries "
"in projected units (spatial ref units)."
msgstr ""
"도형 유형에 대해, 두 도형 사이의 3차원 데카르트 최대 거리를 두 도형의 투영 단"
"위(SRS 단위)로 반환합니다."

#. Tag: programlisting
#: reference_measure.xml:1153
#, no-c-format
msgid ""
"-- Geometry example - units in meters (SRID: 2163 US National Atlas Equal "
"area) (3D point and line compared 2D point and line)\n"
"-- Note: currently no vertical datum support so Z is not transformed and "
"assumed to be same units as final.\n"
"SELECT ST_3DMaxDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 10000)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_3d,\n"
"                ST_MaxDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 10000)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_2d;\n"
"\n"
"     dist_3d      |     dist_2d\n"
"------------------+------------------\n"
" 24383.7467488441 | 22247.8472107251"
msgstr ""
"-- 도형 예시 - 미터 단위 (SRID 2163 미국 등적 전도) (2D 포인트 및 라인과 비교"
"한 3D 포인트 및 라인)\n"
"-- 주의: 현재 수직 데이터를 지원하지 않으므로 Z를 변환하지 않고 최종 결과물"
"과 동일한 단위로 가정합니다.\n"
"SELECT ST_3DMaxDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 10000)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_3d,\n"
"                ST_MaxDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 10000)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_2d;\n"
"\n"
"     dist_3d      |     dist_2d\n"
"------------------+------------------\n"
" 24383.7467488441 | 22247.8472107251"

#. Tag: para
#: reference_measure.xml:1159
#, no-c-format
msgid ""
", <xref linkend=\"ST_3DDWithin\"/>, <xref linkend=\"ST_3DMaxDistance\"/>, "
"<xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_3DDWithin\"/>, <xref linkend=\"ST_3DMaxDistance\"/>, "
"<xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_measure.xml:1165
#, no-c-format
msgid "ST_MinimumClearance"
msgstr "ST_MinimumClearance"

#. Tag: refpurpose
#: reference_measure.xml:1166
#, no-c-format
msgid ""
"Returns the minimum clearance of a geometry, a measure of a geometry's "
"robustness."
msgstr ""
"도형의 튼튼함(robustness)의 척도인 도형의 최소 여유(clearance)를 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:1171
#, no-c-format
msgid ""
"<funcdef>float <function>ST_MinimumClearance</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_MinimumClearance</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1181
#, no-c-format
msgid ""
"It is not uncommon to have a geometry that, while meeting the criteria for "
"validity according to ST_IsValid (polygons) or ST_IsSimple (lines), would "
"become invalid if one of the vertices moved by a slight distance, as can "
"happen during conversion to text-based formats (such as WKT, KML, GML "
"GeoJSON), or binary formats that do not use double-precision floating point "
"coordinates (MapInfo TAB)."
msgstr ""
"(폴리곤일 경우) ST_IsValid 또는 (라인일 경우) ST_IsSimple 함수에 따라 유효성"
"에 대한 기준을 만족시키지만, 텍스트 기반 형식(WKT, KML, GML GeoJSON 등) 또는 "
"이중 정밀도 부동소수점 좌표를 이용하지 않는 바이너리 형식(MapInfo TAB 등)으"
"로 변환하는 과정에서 일어날 수 있는 것처럼, 꼭짓점 가운데 하나가 살짝 이동하"
"면 유효하지 않아지는 도형이 그렇게 희귀한 것은 아닙니다."

#. Tag: para
#: reference_measure.xml:1188
#, no-c-format
msgid ""
"A geometry's \"minimum clearance\" is the smallest distance by which a "
"vertex of the geometry could be moved to produce an invalid geometry. It can "
"be thought of as a quantitative measure of a geometry's robustness, where "
"increasing values of minimum clearance indicate increasing robustness."
msgstr ""
"도형의 \"최소 여유\"란 도형의 꼭짓점이 움직여 유효하지 않은 도형을 만드는 최"
"소 거리를 뜻합니다. 이를 도형의 튼튼함의 정량적 척도로 생각할 수 있습니다. 최"
"소 여유 값이 높을수록 도형은 더 튼튼한 것이죠."

#. Tag: para
#: reference_measure.xml:1194
#, no-c-format
msgid ""
"If a geometry has a minimum clearance of <varname>e</varname>, it can be "
"said that:"
msgstr ""
"도형이 <varname>e</varname> 라는 최소 여유를 가지고 있을 경우, 다음과 같이 말"
"할 수 있습니다:"

#. Tag: para
#: reference_measure.xml:1198
#, no-c-format
msgid ""
"No two distinct vertices in the geometry are separated by less than "
"<varname>e</varname>."
msgstr ""
"도형 내부의 어떤 서로 다른 꼭짓점 2개도 <varname>e</varname> 보다 더 떨어져 "
"있지 않습니다."

#. Tag: para
#: reference_measure.xml:1203
#, no-c-format
msgid ""
"No vertex is closer than <varname>e</varname> to a line segement of which it "
"is not an endpoint."
msgstr ""
"종단점이 아닌 한 어떤 꼭짓점도 라인 선분에 <varname>e</varname> 보다 가까이 "
"있을 수는 없습니다."

#. Tag: para
#: reference_measure.xml:1210
#, no-c-format
msgid ""
"If no minimum clearance exists for a geometry (for example, a single point, "
"or a multipoint whose points are identical), then ST_MinimumClearance will "
"return Infinity."
msgstr ""
"도형에 대해 최소 여유가 존재하지 않을 경우 (예를 들어 단일 포인트 또는 포인트"
"들이 서로 동일한 멀티포인트인 경우) ST_MinimumClearance 함수는 무한을 반환할 "
"것입니다."

#. Tag: para
#: reference_measure.xml:1215
#, no-c-format
msgid "Availability: 2.3.0"
msgstr "2.3.0 버전부터 사용할 수 있습니다."

#. Tag: programlisting
#: reference_measure.xml:1221
#, no-c-format
msgid ""
"SELECT ST_MinimumClearance('POLYGON ((0 0, 1 0, 1 1, 0.5 3.2e-4, 0 0))');\n"
" st_minimumclearance\n"
"---------------------\n"
"             0.00032"
msgstr ""
"SELECT ST_MinimumClearance('POLYGON ((0 0, 1 0, 1 1, 0.5 3.2e-4, 0 0))');\n"
" st_minimumclearance\n"
"---------------------\n"
"             0.00032"

#. Tag: refname
#: reference_measure.xml:1236
#, no-c-format
msgid "ST_MinimumClearanceLine"
msgstr "ST_MinimumClearanceLine"

#. Tag: refpurpose
#: reference_measure.xml:1237
#, no-c-format
msgid ""
"Returns the two-point LineString spanning a geometry's minimum clearance."
msgstr ""
"포인트 2개로 이루어진, 도형의 최소 여유를 나타내는 라인스트링을 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:1242
#, no-c-format
msgid ""
"<funcdef>Geometry <function>ST_MinimumClearanceLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g</parameter></paramdef>"
msgstr ""
"<funcdef>Geometry <function>ST_MinimumClearanceLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1255
#, no-c-format
msgid ""
"Returns the two-point LineString spanning a geometry's minimum clearance. If "
"the geometry does not have a minimum clearance, <varname>LINESTRING EMPTY</"
"varname> will be returned."
msgstr ""
"포인트 2개로 이루어진, 도형의 최소 여유를 나타내는 라인스트링을 반환합니다. "
"도형이 최소 여유를 가지고 있지 않을 경우, <varname>LINESTRING EMPTY</"
"varname> 를 반환할 것입니다."

#. Tag: para
#: reference_measure.xml:1260
#, no-c-format
msgid "Availability: 2.3.0 - requires GEOS &gt;= 3.6.0"
msgstr "2.3.0 버전부터 사용할 수 있습니다. GEOS 3.6.0 이상 버전이 필요합니다."

#. Tag: programlisting
#: reference_measure.xml:1266
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_MinimumClearanceLine('POLYGON ((0 0, 1 0, 1 1, 0.5 "
"3.2e-4, 0 0))'));\n"
"st_astext\n"
"-------------------------------\n"
"LINESTRING(0.5 0.00032,0.5 0)"
msgstr ""
"SELECT ST_AsText(ST_MinimumClearanceLine('POLYGON ((0 0, 1 0, 1 1, 0.5 "
"3.2e-4, 0 0))'));\n"
"st_astext\n"
"-------------------------------\n"
"LINESTRING(0.5 0.00032,0.5 0)"

#. Tag: refname
#: reference_measure.xml:1281
#, no-c-format
msgid "ST_Perimeter"
msgstr "ST_Perimeter"

#. Tag: refpurpose
#: reference_measure.xml:1283
#, no-c-format
msgid ""
"Returns the length of the boundary of a polygonal geometry or geography."
msgstr ""

#. Tag: funcsynopsis
#: reference_measure.xml:1286
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Perimeter</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Perimeter</"
"function></funcdef> <paramdef><type>geography </type><parameter>geog</"
"parameter></paramdef> <paramdef choice=\"opt\"><type>boolean </"
"type><parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_Perimeter</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Perimeter</"
"function></funcdef> <paramdef><type>geography </type><parameter>geog</"
"parameter></paramdef> <paramdef choice=\"opt\"><type>boolean </"
"type><parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_measure.xml:1302
#, no-c-format
msgid ""
"Returns the 2D perimeter of the geometry/geography if it is a ST_Surface, "
"ST_MultiSurface (Polygon, MultiPolygon). 0 is returned for non-areal "
"geometries. For linear geometries use <xref linkend=\"ST_Length\"/>. For "
"geometry types, units for perimeter measures are specified by the spatial "
"reference system of the geometry."
msgstr ""
"도형/지리형이 ST_Surface, ST_MultiSurface(폴리곤, 멀티폴리곤)일 경우 도형/지"
"리형의 2차원 둘레를 반환합니다. 면이 없는 도형의 경우 0을 반환합니다. 선형 도"
"형의 경우 <xref linkend=\"ST_Length\"/> 를 이용하십시오. 도형 유형의 경우, 도"
"형의 공간 참조 시스템이 해당 둘레의 측정 단위를 설정합니다."

#. Tag: para
#: reference_measure.xml:1305
#, no-c-format
msgid ""
"For geography types, the calculations are performed using the inverse "
"geodesic problem, where perimeter units are in meters. If PostGIS is "
"compiled with PROJ version 4.8.0 or later, the spheroid is specified by the "
"SRID, otherwise it is exclusive to WGS84. If <varname>use_spheroid=false</"
"varname>, then calculations will approximate a sphere instead of a spheroid."
msgstr ""
"지리형의 경우: 측지 역 문제(geodesic inverse problem)를 이용해서 계산을 수행"
"합니다. 이때 둘레 단위는 미터입니다. PostGIS를 PROJ 4.8.0 이상 버전과 함께 컴"
"파일한 경우, SRID가 회정타원체를 정의합니다. SRID가 없는 경우 오직 WGS84로 설"
"정됩니다. <varname>use_spheroid=false</varname> 일 경우, 회전타원체 대신 구"
"체 상에서 근사치를 계산할 것입니다."

#. Tag: para
#: reference_measure.xml:1309
#, no-c-format
msgid ""
"Currently this is an alias for ST_Perimeter2D, but this may change to "
"support higher dimensions."
msgstr ""
"이 함수는 현재 ST_Perimeter2D와 동일하지만, 향후 더 높은 차원을 지원하기 위"
"해 변경될 수도 있습니다."

#. Tag: para
#: reference_measure.xml:1312
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 8.1.3, 9.5.4"
msgstr "&sqlmm_compliant; SQL-MM 3: 8.1.3, 9.5.4"

#. Tag: para
#: reference_measure.xml:1313
#, no-c-format
msgid "Availability 2.0.0: Support for geography was introduced"
msgstr "개선 사항: 2.0.0 버전부터 지리형을 지원합니다."

#. Tag: title
#: reference_measure.xml:1317
#, no-c-format
msgid "Examples: Geometry"
msgstr "예시: 도형"

#. Tag: para
#: reference_measure.xml:1318
#, no-c-format
msgid ""
"Return perimeter in feet for Polygon and MultiPolygon. Note this is in feet "
"because EPSG:2249 is Massachusetts State Plane Feet"
msgstr ""
"폴리곤 및 멀티폴리곤의 둘레를 피트 단위로 반환합니다. 투영체 EPSG:2249가 매사"
"추세츠 주 피트 단위 평면이기 때문에 피트 단위라는 사실을 주의하십시오."

#. Tag: programlisting
#: reference_measure.xml:1320
#, no-c-format
msgid ""
"SELECT ST_Perimeter(ST_GeomFromText('POLYGON((743238 2967416,743238 "
"2967450,743265 2967450,\n"
"743265.625 2967416,743238 2967416))', 2249));\n"
"st_perimeter\n"
"---------\n"
" 122.630744000095\n"
"(1 row)\n"
"\n"
"SELECT ST_Perimeter(ST_GeomFromText('MULTIPOLYGON(((763104.471273676 "
"2949418.44119003,\n"
"763104.477769673 2949418.42538203,\n"
"763104.189609677 2949418.22343004,763104.471273676 2949418.44119003)),\n"
"((763104.471273676 2949418.44119003,763095.804579742 2949436.33850239,\n"
"763086.132105649 2949451.46730207,763078.452329651 2949462.11549407,\n"
"763075.354136904 2949466.17407812,763064.362142565 2949477.64291974,\n"
"763059.953961626 2949481.28983009,762994.637609571 2949532.04103014,\n"
"762990.568508415 2949535.06640477,762986.710889563 2949539.61421415,\n"
"763117.237897679 2949709.50493431,763235.236617789 2949617.95619822,\n"
"763287.718121842 2949562.20592617,763111.553321674 2949423.91664605,\n"
"763104.471273676 2949418.44119003)))', 2249));\n"
"st_perimeter\n"
"---------\n"
" 845.227713366825\n"
"(1 row)"
msgstr ""
"SELECT ST_Perimeter(ST_GeomFromText('POLYGON((743238 2967416,743238 "
"2967450,743265 2967450,\n"
"743265.625 2967416,743238 2967416))', 2249));\n"
"st_perimeter\n"
"---------\n"
" 122.630744000095\n"
"(1 row)\n"
"\n"
"SELECT ST_Perimeter(ST_GeomFromText('MULTIPOLYGON(((763104.471273676 "
"2949418.44119003,\n"
"763104.477769673 2949418.42538203,\n"
"763104.189609677 2949418.22343004,763104.471273676 2949418.44119003)),\n"
"((763104.471273676 2949418.44119003,763095.804579742 2949436.33850239,\n"
"763086.132105649 2949451.46730207,763078.452329651 2949462.11549407,\n"
"763075.354136904 2949466.17407812,763064.362142565 2949477.64291974,\n"
"763059.953961626 2949481.28983009,762994.637609571 2949532.04103014,\n"
"762990.568508415 2949535.06640477,762986.710889563 2949539.61421415,\n"
"763117.237897679 2949709.50493431,763235.236617789 2949617.95619822,\n"
"763287.718121842 2949562.20592617,763111.553321674 2949423.91664605,\n"
"763104.471273676 2949418.44119003)))', 2249));\n"
"st_perimeter\n"
"---------\n"
" 845.227713366825\n"
"(1 row)"

#. Tag: title
#: reference_measure.xml:1323
#, no-c-format
msgid "Examples: Geography"
msgstr "예시: 지리형"

#. Tag: para
#: reference_measure.xml:1324
#, no-c-format
msgid ""
"Return perimeter in meters and feet for Polygon and MultiPolygon. Note this "
"is geography (WGS 84 long lat)"
msgstr ""
"폴리곤 및 멀티폴리곤의 둘레를 미터 단위로 반환합니다. 지리형이기 때문에 투영"
"체가 WGS84 경위도라는 점에 주의하십시오."

#. Tag: programlisting
#: reference_measure.xml:1325
#, no-c-format
msgid ""
"SELECT  ST_Perimeter(geog) As per_meters, ST_Perimeter(geog)/0.3048 As "
"per_ft\n"
"FROM ST_GeogFromText('POLYGON((-71.1776848522251 "
"42.3902896512902,-71.1776843766326 42.3903829478009,\n"
"-71.1775844305465 42.3903826677917,-71.1775825927231 "
"42.3902893647987,-71.1776848522251 42.3902896512902))') As geog;\n"
"\n"
"   per_meters    |      per_ft\n"
"-----------------+------------------\n"
"37.3790462565251 | 122.634666195949\n"
"\n"
"\n"
"-- MultiPolygon example --\n"
"SELECT  ST_Perimeter(geog) As per_meters, ST_Perimeter(geog,false) As "
"per_sphere_meters,  ST_Perimeter(geog)/0.3048 As per_ft\n"
"FROM ST_GeogFromText('MULTIPOLYGON(((-71.1044543107478 "
"42.340674480411,-71.1044542869917 42.3406744369506,\n"
"-71.1044553562977 42.340673886454,-71.1044543107478 42.340674480411)),\n"
"((-71.1044543107478 42.340674480411,-71.1044860600303 "
"42.3407237015564,-71.1045215770124 42.3407653385914,\n"
"-71.1045498002983 42.3407946553165,-71.1045611902745 "
"42.3408058316308,-71.1046016507427 42.340837442371,\n"
"-71.104617893173 42.3408475056957,-71.1048586153981 "
"42.3409875993595,-71.1048736143677 42.3409959528211,\n"
"-71.1048878050242 42.3410084812078,-71.1044020965803 42.3414730072048,\n"
"-71.1039672113619 42.3412202916693,-71.1037740497748 42.3410666421308,\n"
"-71.1044280218456 42.3406894151355,-71.1044543107478 42.340674480411)))') As "
"geog;\n"
"\n"
"    per_meters    | per_sphere_meters |      per_ft\n"
"------------------+-------------------+------------------\n"
" 257.634283683311 |  257.412311446337 | 845.256836231335"
msgstr ""
"SELECT  ST_Perimeter(geog) As per_meters, ST_Perimeter(geog)/0.3048 As "
"per_ft\n"
"FROM ST_GeogFromText('POLYGON((-71.1776848522251 "
"42.3902896512902,-71.1776843766326 42.3903829478009,\n"
"-71.1775844305465 42.3903826677917,-71.1775825927231 "
"42.3902893647987,-71.1776848522251 42.3902896512902))') As geog;\n"
"\n"
"   per_meters    |      per_ft\n"
"-----------------+------------------\n"
"37.3790462565251 | 122.634666195949\n"
"\n"
"\n"
"-- 멀티폴리곤 예시 --\n"
"SELECT  ST_Perimeter(geog) As per_meters, ST_Perimeter(geog,false) As "
"per_sphere_meters,  ST_Perimeter(geog)/0.3048 As per_ft\n"
"FROM ST_GeogFromText('MULTIPOLYGON(((-71.1044543107478 "
"42.340674480411,-71.1044542869917 42.3406744369506,\n"
"-71.1044553562977 42.340673886454,-71.1044543107478 42.340674480411)),\n"
"((-71.1044543107478 42.340674480411,-71.1044860600303 "
"42.3407237015564,-71.1045215770124 42.3407653385914,\n"
"-71.1045498002983 42.3407946553165,-71.1045611902745 "
"42.3408058316308,-71.1046016507427 42.340837442371,\n"
"-71.104617893173 42.3408475056957,-71.1048586153981 "
"42.3409875993595,-71.1048736143677 42.3409959528211,\n"
"-71.1048878050242 42.3410084812078,-71.1044020965803 42.3414730072048,\n"
"-71.1039672113619 42.3412202916693,-71.1037740497748 42.3410666421308,\n"
"-71.1044280218456 42.3406894151355,-71.1044543107478 42.340674480411)))') As "
"geog;\n"
"\n"
"    per_meters    | per_sphere_meters |      per_ft\n"
"------------------+-------------------+------------------\n"
" 257.634283683311 |  257.412311446337 | 845.256836231335"

#. Tag: para
#: reference_measure.xml:1329
#, no-c-format
msgid ", <xref linkend=\"ST_GeomFromText\"/>, <xref linkend=\"ST_Length\"/>"
msgstr ", <xref linkend=\"ST_GeomFromText\"/>, <xref linkend=\"ST_Length\"/>"

#. Tag: refname
#: reference_measure.xml:1335
#, no-c-format
msgid "ST_Perimeter2D"
msgstr "ST_Perimeter2D"

#. Tag: refpurpose
#: reference_measure.xml:1337
#, no-c-format
msgid ""
"Returns the 2D perimeter of a polygonal geometry. Alias for "
"<varname>ST_Perimeter</varname>."
msgstr ""

#. Tag: funcprototype
#: reference_measure.xml:1343
#, no-c-format
msgid ""
"<funcdef>float <function>ST_Perimeter2D</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_Perimeter2D</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1353
#, fuzzy, no-c-format
msgid "Returns the 2-dimensional perimeter of a polygonal geometry."
msgstr "도형이 폴리곤 또는 멀티폴리곤일 경우 도형의 2차원 둘레를 반환합니다."

#. Tag: para
#: reference_measure.xml:1357
#, no-c-format
msgid ""
"This is currently an alias for ST_Perimeter. In future versions ST_Perimeter "
"may return the highest dimension perimeter for a geometry. This is still "
"under consideration"
msgstr ""
"이 함수는 현재 <varname>ST_Perimeter</varname> 와 동일합니다. 향후 버전에서 "
"<varname>ST_Perimeter</varname> 는 도형에 대해 최고 차원의 둘레를 반환할 수"
"도 있습니다. 이는 아직 고려 대상입니다."

#. Tag: refname
#: reference_measure.xml:1371
#, no-c-format
msgid "ST_3DPerimeter"
msgstr "ST_3DPerimeter"

#. Tag: refpurpose
#: reference_measure.xml:1373
#, fuzzy, no-c-format
msgid "Returns the 3D perimeter of a polygonal geometry."
msgstr "도형의 기하학적 중심을 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:1378
#, no-c-format
msgid ""
"<funcdef>float <function>ST_3DPerimeter</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_3DPerimeter</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1388
#, no-c-format
msgid ""
"Returns the 3-dimensional perimeter of the geometry, if it is a polygon or "
"multi-polygon. If the geometry is 2-dimensional, then the 2-dimensional "
"perimeter is returned."
msgstr ""
"도형이 폴리곤 또는 멀티폴리곤일 경우 도형의 3차원 둘레를 반환합니다. 2차원 도"
"형의 경우 2차원 둘레를 반환할 것입니다."

#. Tag: para
#: reference_measure.xml:1391
#, no-c-format
msgid "Changed: 2.0.0 In prior versions this used to be called ST_Perimeter3D"
msgstr "변경 사항: 2.0.0 미만 버전에서는 ST_Perimeter3D라는 명칭이었습니다."

#. Tag: para
#: reference_measure.xml:1397
#, no-c-format
msgid ""
"Perimeter of a slightly elevated polygon in the air in Massachusetts state "
"plane feet"
msgstr "매사추세츠 주 피트 단위 평면에서 공중에 살짝 떠 있는 폴리곤의 둘레"

#. Tag: programlisting
#: reference_measure.xml:1398
#, no-c-format
msgid ""
"SELECT ST_3DPerimeter(the_geom), ST_Perimeter2d(the_geom), "
"ST_Perimeter(the_geom) FROM\n"
"                        (SELECT ST_GeomFromEWKT('SRID=2249;POLYGON((743238 "
"2967416 2,743238 2967450 1,\n"
"743265.625 2967416 1,743238 2967416 2))') As the_geom) As foo;\n"
"\n"
"  ST_3DPerimeter  |  st_perimeter2d  |   st_perimeter\n"
"------------------+------------------+------------------\n"
" 105.465793597674 | 105.432997272188 | 105.432997272188"
msgstr ""
"SELECT ST_3DPerimeter(the_geom), ST_Perimeter2d(the_geom), "
"ST_Perimeter(the_geom) FROM\n"
"                        (SELECT ST_GeomFromEWKT('SRID=2249;POLYGON((743238 "
"2967416 2,743238 2967450 1,\n"
"743265.625 2967416 1,743238 2967416 2))') As the_geom) As foo;\n"
"\n"
"  ST_3DPerimeter  |  st_perimeter2d  |   st_perimeter\n"
"------------------+------------------+------------------\n"
" 105.465793597674 | 105.432997272188 | 105.432997272188"

#. Tag: para
#: reference_measure.xml:1405
#, no-c-format
msgid ", <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Perimeter2D\"/>"
msgstr ", <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Perimeter2D\"/>"

#. Tag: refname
#: reference_measure.xml:1411
#, no-c-format
msgid "ST_Project"
msgstr "ST_Project"

#. Tag: refpurpose
#: reference_measure.xml:1413
#, fuzzy, no-c-format
msgid ""
"Returns a point projected from a start point by a distance and bearing "
"(azimuth)."
msgstr ""
"시작점으로부터 미터 단위 거리 및 라디안 단위 방향(방위각)을 이용해 투영된 "
"<varname>POINT</varname> 를 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:1418
#, no-c-format
msgid ""
"<funcdef>geography <function>ST_Project</function></funcdef> "
"<paramdef><type>geography </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>distance</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>azimuth</parameter></paramdef>"
msgstr ""
"<funcdef>geography <function>ST_Project</function></funcdef> "
"<paramdef><type>geography </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>distance</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>azimuth</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1434
#, fuzzy, no-c-format
msgid ""
"Returns a point projected from a start point along a geodesic using a given "
"distance and azimuth (bearing). This is known as the direct geodesic problem."
msgstr ""
"시작점으로부터 미터 단위로 측정된 거리 및 라디안 단위로 측정된 방향(방위각)"
"을 이용해 측지선을 따라 투영된 <varname>POINT</varname> 를 반환합니다. 이를 "
"측지 주 문제(geodesic direct problem)라고도 합니다."

#. Tag: para
#: reference_measure.xml:1437
#, fuzzy, no-c-format
msgid "The distance is given in meters. Negative values are supported."
msgstr "거리의 단위는 미터입니다."

#. Tag: para
#: reference_measure.xml:1438
#, fuzzy, no-c-format
msgid ""
"The azimuth (also known as heading or bearing) is given in radians. It is "
"measured clockwise from true north (azimuth zero). East is azimuth "
"&#x03C0;/2 (90 degrees); south is azimuth &#x03C0; (180 degrees); west is "
"azimuth 3&#x03C0;/2 (270 degrees). Negative azimuth values and values "
"greater than 2&#x03C0; (360 degrees) are supported."
msgstr ""
"운항 분야에서 때로 방위각을 기수방위(heading) 또는 방향(bearing)으로 부르기"
"도 합니다. 방위각은 진북(방위각 0)을 기준으로 측정됩니다. 동쪽은 방위각 "
"90(&#x03C0;/2), 남쪽은 방위각 180(&#x03C0;), 서쪽은 방위각 270(3&#x03C0;/2)입"
"니다."

#. Tag: para
#: reference_measure.xml:1448
#, no-c-format
msgid "Enhanced: 2.4.0 Allow negative distance and non-normalized azimuth."
msgstr ""

#. Tag: title
#: reference_measure.xml:1453
#, fuzzy, no-c-format
msgid "Example: Projected point at 100,000 meters and bearing 45 degrees"
msgstr "예시: 도 단위 이용 - 100,000미터 및 45도 방향으로 포인트 투영"

#. Tag: programlisting
#: reference_measure.xml:1455
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_Project('POINT(0 0)'::geography, 100000, "
"radians(45.0)));\n"
"\n"
"                 st_astext\n"
"--------------------------------------------\n"
" POINT(0.635231029125537 0.639472334729198)\n"
"(1 row)"
msgstr ""
"SELECT ST_AsText(ST_Project('POINT(0 0)'::geography, 100000, "
"radians(45.0)));\n"
"\n"
"                 st_astext\n"
"--------------------------------------------\n"
" POINT(0.635231029125537 0.639472334729198)\n"
"(1 row)"

#. Tag: para
#: reference_measure.xml:1461
#, fuzzy, no-c-format
msgid ""
", <xref linkend=\"ST_Distance\"/>, <ulink url=\"http://www.postgresql.org/"
"docs/current/interactive/functions-math.html\">PostgreSQL function "
"radians()</ulink>"
msgstr ""
", <xref linkend=\"ST_Distance\"/>, <ulink url=\"http://www.postgresql.org/"
"docs/current/interactive/functions-math.html\">PostgreSQL Math Functions</"
"ulink>"

#. Tag: refname
#: reference_measure.xml:1468
#, no-c-format
msgid "ST_ShortestLine"
msgstr "ST_ShortestLine"

#. Tag: refpurpose
#: reference_measure.xml:1470
#, fuzzy, no-c-format
msgid "Returns the 2D shortest line between two geometries"
msgstr "두 도형 사이의 2차원 최단 라인을 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:1475
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_ShortestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_ShortestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1490
#, no-c-format
msgid ""
"Returns the 2-dimensional shortest line between two geometries. The function "
"will only return the first shortest line if more than one, that the function "
"finds. If g1 and g2 intersects in just one point the function will return a "
"line with both start and end in that intersection-point. If g1 and g2 are "
"intersecting with more than one point the function will return a line with "
"start and end in the same point but it can be any of the intersecting "
"points. The line returned will always start in g1 and end in g2. The length "
"of the line this function returns will always be the same as ST_Distance "
"returns for g1 and g2."
msgstr ""
"두 도형 사이의 2차원 최단(shortest) 라인을 반환합니다. 하나 이상의 최단 라인"
"이 있을 경우, 이 함수는 첫 번째 최단 라인만 반환할 것입니다. g1과 g2가 단 한 "
"개의 포인트에서만 교차할 경우, 이 함수는 교차점에서 시작하고 끝나는 라인을 반"
"환할 것입니다. g1과 g2가 한 개 이상의 포인트에서 교차할 경우, 이 함수는 동일"
"한 포인트에서 시작하고 끝나는 라인을 반환하지만 해당 포인트는 교차하는 포인트"
"들 가운데 어떤 포인트라도 될 수 있습니다. 반환되는 라인은 항상 g1에서 시작해"
"서 g2에서 끝납니다. 이 함수가 반환하는 라인의 2차원 길이는 <xref linkend="
"\"ST_Distance\"/> 함수가 g1과 g2에 대해 반환하는 길이와 언제나 동일합니다."

#. Tag: para
#: reference_measure.xml:1514
#, no-c-format
msgid "Shortest line between point and linestring"
msgstr "포인트와 라인 사이의 최단 라인"

#. Tag: programlisting
#: reference_measure.xml:1517
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"        ST_ShortestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As sline;\n"
"\n"
"\n"
"   sline\n"
"-----------------\n"
"LINESTRING(100 100,73.0769230769231 115.384615384615)"
msgstr ""
"SELECT ST_AsText(\n"
"        ST_ShortestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As sline;\n"
"\n"
"\n"
"   sline\n"
"-----------------\n"
"LINESTRING(100 100,73.0769230769231 115.384615384615)"

#. Tag: para
#: reference_measure.xml:1525
#, no-c-format
msgid "shortest line between polygon and polygon"
msgstr "폴리곤과 폴리곤 사이의 최단 라인"

#. Tag: programlisting
#: reference_measure.xml:1528
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"                ST_ShortestLine(\n"
"                        ST_GeomFromText('POLYGON((175 150, 20 40, 50 60, 125 "
"100, 175 150))'),\n"
"                        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                        )\n"
"                ) As slinewkt;\n"
"\n"
" LINESTRING(140.752120669087 125.695053378061,121.111404660392 "
"153.370607753949)"
msgstr ""
"SELECT ST_AsText(\n"
"                ST_ShortestLine(\n"
"                        ST_GeomFromText('POLYGON((175 150, 20 40, 50 60, 125 "
"100, 175 150))'),\n"
"                        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                        )\n"
"                ) As slinewkt;\n"
"\n"
" LINESTRING(140.752120669087 125.695053378061,121.111404660392 "
"153.370607753949)"

#. Tag: para
#: reference_measure.xml:1540
#, no-c-format
msgid ""
", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_MaxDistance\"/>"
msgstr ""
", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_MaxDistance\"/>"

#. Tag: refname
#: reference_measure.xml:1545
#, no-c-format
msgid "ST_3DShortestLine"
msgstr "ST_3DShortestLine"

#. Tag: refpurpose
#: reference_measure.xml:1547
#, fuzzy, no-c-format
msgid "Returns the 3D shortest line between two geometries"
msgstr "두 도형 사이의 3차원 최단(shortest) 라인을 반환합니다."

#. Tag: funcprototype
#: reference_measure.xml:1552
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_3DShortestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_3DShortestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1567
#, no-c-format
msgid ""
"Returns the 3-dimensional shortest line between two geometries. The function "
"will only return the first shortest line if more than one, that the function "
"finds. If g1 and g2 intersects in just one point the function will return a "
"line with both start and end in that intersection-point. If g1 and g2 are "
"intersecting with more than one point the function will return a line with "
"start and end in the same point but it can be any of the intersecting "
"points. The line returned will always start in g1 and end in g2. The 3D "
"length of the line this function returns will always be the same as <xref "
"linkend=\"ST_3DDistance\"/> returns for g1 and g2."
msgstr ""
"두 도형 사이의 3차원 최단(shortest) 라인을 반환합니다. 하나 이상의 최단 라인"
"이 있을 경우, 이 함수는 첫 번째 최단 라인만 반환할 것입니다. g1과 g2가 단 한 "
"개의 포인트에서만 교차할 경우, 이 함수는 교차점에서 시작하고 끝나는 라인을 반"
"환할 것입니다. g1과 g2가 한 개 이상의 포인트에서 교차할 경우, 이 함수는 동일"
"한 포인트에서 시작하고 끝나는 라인을 반환하지만 해당 포인트는 교차하는 포인트"
"들 가운데 어떤 포인트라도 될 수 있습니다. 반환되는 라인은 항상 g1에서 시작해"
"서 g2에서 끝납니다. 이 함수가 반환하는 라인의 3차원 길이는 <xref linkend="
"\"ST_3DDistance\"/> 함수가 g1과 g2에 대해 반환하는 길이와 언제나 동일합니다."

#. Tag: para
#: reference_measure.xml:1590
#, no-c-format
msgid "linestring and point -- both 3d and 2d shortest line"
msgstr "라인스트링과 포인트 -- 3D, 2D 모두의 최단 라인"

#. Tag: programlisting
#: reference_measure.xml:1591
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DShortestLine(line,pt)) AS shl3d_line_pt,\n"
"                ST_AsEWKT(ST_ShortestLine(line,pt)) As shl2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
" shl3d_line_pt                                                                 "
"|               shl2d_line_pt\n"
"----------------------------------------------------------------------------"
"+------------------------------------------------------\n"
" LINESTRING(54.6993798867619 128.935022917228 11.5475869506606,100 100 30)  "
"| LINESTRING(73.0769230769231 115.384615384615,100 100)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DShortestLine(line,pt)) AS shl3d_line_pt,\n"
"                ST_AsEWKT(ST_ShortestLine(line,pt)) As shl2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
" shl3d_line_pt                                                                 "
"|               shl2d_line_pt\n"
"----------------------------------------------------------------------------"
"+------------------------------------------------------\n"
" LINESTRING(54.6993798867619 128.935022917228 11.5475869506606,100 100 30)  "
"| LINESTRING(73.0769230769231 115.384615384615,100 100)"

#. Tag: para
#: reference_measure.xml:1595
#, no-c-format
msgid "linestring and multipoint -- both 3d and 2d shortest line"
msgstr "라인스트링과 멀티포인트 -- 3D, 2D 모두의 최단 라인"

#. Tag: programlisting
#: reference_measure.xml:1596
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DShortestLine(line,pt)) AS shl3d_line_pt,\n"
"                ST_AsEWKT(ST_ShortestLine(line,pt)) As shl2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"                       shl3d_line_pt                                       | "
"shl2d_line_pt\n"
"---------------------------------------------------------------------------"
"+------------------------\n"
" LINESTRING(54.6993798867619 128.935022917228 11.5475869506606,100 100 30) | "
"LINESTRING(50 75,50 74)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DShortestLine(line,pt)) AS shl3d_line_pt,\n"
"                ST_AsEWKT(ST_ShortestLine(line,pt)) As shl2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"                       shl3d_line_pt                                       | "
"shl2d_line_pt\n"
"---------------------------------------------------------------------------"
"+------------------------\n"
" LINESTRING(54.6993798867619 128.935022917228 11.5475869506606,100 100 30) | "
"LINESTRING(50 75,50 74)"

#. Tag: para
#: reference_measure.xml:1600
#, no-c-format
msgid "Multilinestring and polygon both 3d and 2d shortest line"
msgstr "멀티라인스트링과 폴리곤 -- 3D, 2D 모두의 최단 라인"

#. Tag: programlisting
#: reference_measure.xml:1601
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DShortestLine(poly, mline)) As shl3d,\n"
"    ST_AsEWKT(ST_ShortestLine(poly, mline)) As shl2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"                   shl3d                                                                           "
"|     shl2d\n"
"---------------------------------------------------------------------------------------------------"
"+------------------------\n"
" LINESTRING(39.993580415989 54.1889925532825 5,40.4078575708294 "
"53.6052383805529 5.03423778139177) | LINESTRING(20 40,20 40)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DShortestLine(poly, mline)) As shl3d,\n"
"    ST_AsEWKT(ST_ShortestLine(poly, mline)) As shl2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"                   shl3d                                                                           "
"|     shl2d\n"
"---------------------------------------------------------------------------------------------------"
"+------------------------\n"
" LINESTRING(39.993580415989 54.1889925532825 5,40.4078575708294 "
"53.6052383805529 5.03423778139177) | LINESTRING(20 40,20 40)"

#. Tag: para
#: reference_measure.xml:1613
#, no-c-format
msgid ""
", <xref linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_LongestLine\"/>, "
"<xref linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_3DMaxDistance\"/>"
msgstr ""
", <xref linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_LongestLine\"/>, "
"<xref linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_3DMaxDistance\"/>"

#, fuzzy
#~ msgid ""
#~ ", <xref linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_3DLongestLine\"/"
#~ ">"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_LongestLine\"/>"

#~ msgid "Basic furthest distance the point is to any part of the line"
#~ msgstr ""
#~ "기본적으로 가장 먼 거리에 있는 포인트는 라인의 어느 부분에라도 존재할 수 "
#~ "있습니다."

#~ msgid "Spatial Relationships and Measurements"
#~ msgstr "공간 관계성 및 측정"

#~ msgid "ST_3DDWithin"
#~ msgstr "ST_3DDWithin"

#~ msgid ""
#~ "For 3d (z) geometry type Returns true if two geometries 3d distance is "
#~ "within number of units."
#~ msgstr ""
#~ "3D(Z) 도형 유형에 대해, 두 도형의 3차원 거리가 단위의 개수 내일 경우 참을 "
#~ "반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_3DDWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance_of_srid</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_3DDWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance_of_srid</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "For geometry type returns true if the 3d distance between two objects is "
#~ "within distance_of_srid specified projected units (spatial ref units)."
#~ msgstr ""
#~ "도형 유형에 대해, 두 객체 사이의 3차원 거리가 투영 단위(SRS 단위)를 설정하"
#~ "는 distance_of_srid 범위 내에 있을 경우 참을 반환합니다."

#~ msgid ""
#~ "-- Geometry example - units in meters (SRID: 2163 US National Atlas Equal "
#~ "area) (3D point and line compared 2D point and line)\n"
#~ "-- Note: currently no vertical datum support so Z is not transformed and "
#~ "assumed to be same units as final.\n"
#~ "SELECT ST_3DDWithin(\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-72.1235 42.3521 4)'),2163),\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163),\n"
#~ "                        126.8\n"
#~ "                ) As within_dist_3d,\n"
#~ "ST_DWithin(\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-72.1235 42.3521 4)'),2163),\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163),\n"
#~ "                        126.8\n"
#~ "                ) As within_dist_2d;\n"
#~ "\n"
#~ " within_dist_3d | within_dist_2d\n"
#~ "----------------+----------------\n"
#~ " f              | t"
#~ msgstr ""
#~ "-- 도형 예시 - 미터 단위 (SRID 2163 미국 등적 전도) (2D 포인트 및 라인과 "
#~ "비교한 3D 포인트 및 라인)\n"
#~ "-- 주의: 현재 수직 데이터를 지원하지 않으므로 Z를 변환하지 않고 최종 결과"
#~ "물과 동일한 단위로 가정합니다.\n"
#~ "SELECT ST_3DDWithin(\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-72.1235 42.3521 4)'),2163),\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163),\n"
#~ "                        126.8\n"
#~ "                ) As within_dist_3d,\n"
#~ "ST_DWithin(\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-72.1235 42.3521 4)'),2163),\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163),\n"
#~ "                        126.8\n"
#~ "                ) As within_dist_2d;\n"
#~ "\n"
#~ " within_dist_3d | within_dist_2d\n"
#~ "----------------+----------------\n"
#~ " f              | t"

#~ msgid ""
#~ ", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_DWithin\"/>, <xref "
#~ "linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_Transform\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_DWithin\"/>, <xref "
#~ "linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_Transform\"/>"

#~ msgid "ST_3DDFullyWithin"
#~ msgstr "ST_3DDFullyWithin"

#~ msgid ""
#~ "Returns true if all of the 3D geometries are within the specified "
#~ "distance of one another."
#~ msgstr "모든 3D 도형이 서로의 설정된 거리 내에 있을 경우 참을 반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_3DDFullyWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance</parameter></"
#~ "paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_3DDFullyWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance</parameter></"
#~ "paramdef>"

#~ msgid ""
#~ "Returns true if the 3D geometries are fully within the specified distance "
#~ "of one another. The distance is specified in units defined by the spatial "
#~ "reference system of the geometries. For this function to make sense, the "
#~ "source geometries must both be of the same coordinate projection, having "
#~ "the same SRID."
#~ msgstr ""
#~ "3D 도형들이 완전히 서로의 설정된 거리 내에 있을 경우 참을 반환합니다. 이 "
#~ "거리는 도형들의 공간 참조 시스템이 정의한 단위로 설정됩니다. 이 함수가 제"
#~ "대로 동작하려면, 소스 도형들이 둘 다 동일한 SRID를 가진, 동일한 좌표 투영"
#~ "체여야 합니다."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries."
#~ msgstr ""
#~ "이 함수를 호출하면 도형에서 이용할 수 있는 모든 인덱스를 활용하는 경계 상"
#~ "자 비교 작업을 자동적으로 포함하게 됩니다."

#~ msgid ""
#~ "-- This compares the difference between fully within and distance within "
#~ "as well\n"
#~ "                -- as the distance fully within for the 2D footprint of "
#~ "the line/point vs. the 3d fully within\n"
#~ "                SELECT ST_3DDFullyWithin(geom_a, geom_b, 10) as "
#~ "D3DFullyWithin10, ST_3DDWithin(geom_a, geom_b, 10) as D3DWithin10,\n"
#~ "        ST_DFullyWithin(geom_a, geom_b, 20) as D2DFullyWithin20,\n"
#~ "        ST_3DDFullyWithin(geom_a, geom_b, 20) as D3DFullyWithin20 from\n"
#~ "                (select ST_GeomFromEWKT('POINT(1 1 2)') as geom_a,\n"
#~ "                ST_GeomFromEWKT('LINESTRING(1 5 2, 2 7 20, 1 9 100, 14 12 "
#~ "3)') as geom_b) t1;\n"
#~ " d3dfullywithin10 | d3dwithin10 | d2dfullywithin20 | d3dfullywithin20\n"
#~ "------------------+-------------+------------------+------------------\n"
#~ " f                | t           | t                | f"
#~ msgstr ""
#~ "-- 이 예시는 2D 라인/포인트의 궤적과 범위 내에 완전히 들어가는 3D 라인/포"
#~ "인트의 궤적을 비교하여 그 안에 완전히 들어가는 거리는 물론\n"
#~ "                -- 완전히 들어가는 범위 및 범위 내의 거리 사이의 차이를 비"
#~ "교합니다.\n"
#~ "                SELECT ST_3DDFullyWithin(geom_a, geom_b, 10) as "
#~ "D3DFullyWithin10, ST_3DDWithin(geom_a, geom_b, 10) as D3DWithin10,\n"
#~ "        ST_DFullyWithin(geom_a, geom_b, 20) as D2DFullyWithin20,\n"
#~ "        ST_3DDFullyWithin(geom_a, geom_b, 20) as D3DFullyWithin20 from\n"
#~ "                (select ST_GeomFromEWKT('POINT(1 1 2)') as geom_a,\n"
#~ "                ST_GeomFromEWKT('LINESTRING(1 5 2, 2 7 20, 1 9 100, 14 12 "
#~ "3)') as geom_b) t1;\n"
#~ " d3dfullywithin10 | d3dwithin10 | d2dfullywithin20 | d3dfullywithin20\n"
#~ "------------------+-------------+------------------+------------------\n"
#~ " f                | t           | t                | f"

#~ msgid ""
#~ ", <xref linkend=\"ST_3DDWithin\"/>, <xref linkend=\"ST_DWithin\"/>, <xref "
#~ "linkend=\"ST_DFullyWithin\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_3DDWithin\"/>, <xref linkend=\"ST_DWithin\"/>, <xref "
#~ "linkend=\"ST_DFullyWithin\"/>"

#~ msgid "ST_3DIntersects"
#~ msgstr "ST_3DIntersects"

#~ msgid ""
#~ "Returns TRUE if the Geometries \"spatially intersect\" in 3d - only for "
#~ "points, linestrings, polygons, polyhedral surface (area). With SFCGAL "
#~ "backend enabled also supports TINS"
#~ msgstr ""
#~ "도형들이 3차원에서 \"공간적으로 교차\"하는 경우 참을 반환합니다. 포인트, "
#~ "라인스트링, 폴리곤, 다면체 표면(면적)만 입력받습니다. SFCGAL 백엔드가 활성"
#~ "화됐다면 TIN도 지원합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_3DIntersects</function></funcdef> "
#~ "<paramdef> <type>geometry</type> <parameter>geomA</parameter> </paramdef> "
#~ "<paramdef> <type>geometry</type> <parameter>geomB</parameter> </paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_3DIntersects</function></funcdef> "
#~ "<paramdef> <type>geometry</type> <parameter>geomA</parameter> </paramdef> "
#~ "<paramdef> <type>geometry</type> <parameter>geomB</parameter> </paramdef>"

#~ msgid ""
#~ "Overlaps, Touches, Within all imply spatial intersection. If any of the "
#~ "aforementioned returns true, then the geometries also spatially "
#~ "intersect. Disjoint implies false for spatial intersection."
#~ msgstr ""
#~ "겹치기(overlap), 접촉(touch), 범위 내(within) 모두 공간 교차를 의미하는 말"
#~ "입니다. 앞에서 언급한 함수들 가운데 어느 하나라도 참을 반환하는 경우, 해"
#~ "당 도형들도 공간적으로 교차하는 겁니다. 도형들이 교차하는 경우, 분리"
#~ "(disjoint) 함수는 거짓을 반환합니다."

#~ msgid ""
#~ "In order to take advantage of support for TINS, you need to enable the "
#~ "SFCGAL backend. This can be done at session time with: <code>set postgis."
#~ "backend = sfcgal;</code> or at the database or system level. Database "
#~ "level can be done with <code>ALTER DATABASE gisdb SET postgis.backend = "
#~ "sfcgal;</code>."
#~ msgstr ""
#~ "TIN 지원의 장점을 취하려면, SFCGAL 백엔드를 활성화해야 합니다. 세션 단계에"
#~ "서 <code>set postgis.backend = sfcgal;</code> 로 설정하면 됩니다. 또는 또"
#~ "는 데이터베이스나 시스템 단계에서도 설정할 수 있습니다. 데이터베이스 단계"
#~ "에서는 <code>ALTER DATABASE gisdb SET postgis.backend = sfcgal;</code> 이"
#~ "라고 설정하면 됩니다."

#~ msgid "&T_support;"
#~ msgstr "&T_support;"

#~ msgid "&sqlmm_compliant; SQL-MM 3: ?"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: ?"

#~ msgid ""
#~ "SELECT ST_3DIntersects(pt, line), ST_Intersects(pt,line)\n"
#~ "        FROM (SELECT 'POINT(0 0 2)'::geometry As pt,\n"
#~ "                'LINESTRING (0 0 1, 0 2 3 )'::geometry As line) As foo;\n"
#~ " st_3dintersects | st_intersects\n"
#~ "-----------------+---------------\n"
#~ " f               | t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_3DIntersects(pt, line), ST_Intersects(pt,line)\n"
#~ "        FROM (SELECT 'POINT(0 0 2)'::geometry As pt,\n"
#~ "                'LINESTRING (0 0 1, 0 2 3 )'::geometry As line) As foo;\n"
#~ " st_3dintersects | st_intersects\n"
#~ "-----------------+---------------\n"
#~ " f               | t\n"
#~ "(1 row)"

#~ msgid "TIN Examples"
#~ msgstr "TIN 예시"

#~ msgid ""
#~ "set postgis.backend = sfcgal;\n"
#~ "SELECT ST_3DIntersects('TIN(((0 0,1 0,0 1,0 0)))'::geometry, "
#~ "'POINT(.1 .1)'::geometry);\n"
#~ " st_3dintersects\n"
#~ "-----------------\n"
#~ " t"
#~ msgstr ""
#~ "set postgis.backend = sfcgal;\n"
#~ "SELECT ST_3DIntersects('TIN(((0 0,1 0,0 1,0 0)))'::geometry, "
#~ "'POINT(.1 .1)'::geometry);\n"
#~ " st_3dintersects\n"
#~ "-----------------\n"
#~ " t"

#~ msgid ""
#~ "Returns the area of the surface if it is a Polygon or MultiPolygon. For "
#~ "geometry, a 2D Cartesian area is determined with units specified by the "
#~ "SRID. For geography, area is determined on a curved surface with units in "
#~ "square meters."
#~ msgstr ""
#~ "도형이 폴리곤이나 멀티폴리곤일 경우 표면의 면적을 반환합니다. 도형 유형의 "
#~ "경우, SRID가 지정한 단위로 2차원 데카르트 면적을 구합니다. 지리형 유형의 "
#~ "경우, 평방미터 단위로 곡면(curved surface)의 면적을 구합니다."

#~ msgid ""
#~ "SELECT ST_Area(the_geom) As sqft, ST_Area(the_geom)*POWER(0.3048,2) As "
#~ "sqm\n"
#~ "                FROM (SELECT\n"
#~ "                ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,\n"
#~ "                        743265 2967450,743265.625 2967416,743238 "
#~ "2967416))',2249) ) As foo(the_geom);\n"
#~ "  sqft   |     sqm\n"
#~ "---------+-------------\n"
#~ " 928.625 | 86.27208552"
#~ msgstr ""
#~ "SELECT ST_Area(the_geom) As sqft, ST_Area(the_geom)*POWER(0.3048,2) As "
#~ "sqm\n"
#~ "                FROM (SELECT\n"
#~ "                ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,\n"
#~ "                        743265 2967450,743265.625 2967416,743238 "
#~ "2967416))',2249) ) As foo(the_geom);\n"
#~ "  sqft   |     sqm\n"
#~ "---------+-------------\n"
#~ " 928.625 | 86.27208552"

#~ msgid ""
#~ "SELECT ST_Area(the_geom) As sqft, ST_Area(ST_Transform(the_geom,26986)) "
#~ "As sqm\n"
#~ "                FROM (SELECT\n"
#~ "                ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,\n"
#~ "                        743265 2967450,743265.625 2967416,743238 "
#~ "2967416))',2249) ) As foo(the_geom);\n"
#~ "  sqft   |       sqm\n"
#~ "---------+------------------\n"
#~ " 928.625 | 86.2724304199219"
#~ msgstr ""
#~ "SELECT ST_Area(the_geom) As sqft, ST_Area(ST_Transform(the_geom,26986)) "
#~ "As sqm\n"
#~ "                FROM (SELECT\n"
#~ "                ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,\n"
#~ "                        743265 2967450,743265.625 2967416,743238 "
#~ "2967416))',2249) ) As foo(the_geom);\n"
#~ "  sqft   |       sqm\n"
#~ "---------+------------------\n"
#~ " 928.625 | 86.2724304199219"

#~ msgid ""
#~ "SELECT ST_Area(the_geog)/POWER(0.3048,2) As sqft_spheroid,  "
#~ "ST_Area(the_geog,false)/POWER(0.3048,2) As sqft_sphere, ST_Area(the_geog) "
#~ "As sqm_spheroid\n"
#~ "                FROM (SELECT\n"
#~ "                geography(\n"
#~ "                ST_Transform(\n"
#~ "                        ST_GeomFromText('POLYGON((743238 2967416,743238 "
#~ "2967450,743265 2967450,743265.625 2967416,743238 2967416))',\n"
#~ "                                2249\n"
#~ "                                ) ,4326\n"
#~ "                        )\n"
#~ "                )\n"
#~ "        ) As foo(the_geog);\n"
#~ "  sqft_spheroid   |   sqft_sphere    |   sqm_spheroid\n"
#~ "------------------+------------------+------------------\n"
#~ " 928.684403538925 | 927.049336105925 | 86.2776042893529\n"
#~ "\n"
#~ " --if your data is in geography already\n"
#~ " SELECT ST_Area(the_geog)/POWER(0.3048,2) As  sqft, ST_Area(the_geog) As "
#~ "sqm\n"
#~ "        FROM somegeogtable;"
#~ msgstr ""
#~ "SELECT ST_Area(the_geog)/POWER(0.3048,2) As sqft_spheroid,  "
#~ "ST_Area(the_geog,false)/POWER(0.3048,2) As sqft_sphere, ST_Area(the_geog) "
#~ "As sqm_spheroid\n"
#~ "                FROM (SELECT\n"
#~ "                geography(\n"
#~ "                ST_Transform(\n"
#~ "                        ST_GeomFromText('POLYGON((743238 2967416,743238 "
#~ "2967450,743265 2967450,743265.625 2967416,743238 2967416))',\n"
#~ "                                2249\n"
#~ "                                ) ,4326\n"
#~ "                        )\n"
#~ "                )\n"
#~ "        ) As foo(the_geog);\n"
#~ "  sqft_spheroid   |   sqft_sphere    |   sqm_spheroid\n"
#~ "------------------+------------------+------------------\n"
#~ " 928.684403538925 | 927.049336105925 | 86.2776042893529\n"
#~ "\n"
#~ " -- 사용자 데이터가 이미 지리형인 경우\n"
#~ " SELECT ST_Area(the_geog)/POWER(0.3048,2) As  sqft, ST_Area(the_geog) As "
#~ "sqm\n"
#~ "        FROM somegeogtable;"

#~ msgid ""
#~ ", <xref linkend=\"ST_GeographyFromText\"/>, <xref linkend=\"ST_SetSRID\"/"
#~ ">, <xref linkend=\"ST_Transform\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_GeographyFromText\"/>, <xref linkend=\"ST_SetSRID\"/"
#~ ">, <xref linkend=\"ST_Transform\"/>"

#~ msgid "ST_Centroid"
#~ msgstr "ST_Centroid"

#~ msgid ""
#~ "Computes the geometric center of a geometry, or equivalently, the center "
#~ "of mass of the geometry as a <varname>POINT</varname>. For "
#~ "[<varname>MULTI</varname>]<varname>POINT</varname>s, this is computed as "
#~ "the arithmetic mean of the input coordinates. For [<varname>MULTI</"
#~ "varname>]<varname>LINESTRING</varname>s, this is computed as the weighted "
#~ "length of each line segment. For [<varname>MULTI</"
#~ "varname>]<varname>POLYGON</varname>s, \"weight\" is thought in terms of "
#~ "area. If an empty geometry is supplied, an empty "
#~ "<varname>GEOMETRYCOLLECTION</varname> is returned. If <varname>NULL</"
#~ "varname> is supplied, <varname>NULL</varname> is returned. If "
#~ "<varname>CIRCULARSTRING</varname> or <varname>COMPOUNDCURVE</varname> are "
#~ "supplied, they are converted to linestring wtih CurveToLine first, then "
#~ "same than for <varname>LINESTRING</varname>"
#~ msgstr ""
#~ "도형의 기하학적 중심, 또는 다른 말로, 도형의 질량 중심을 <varname>POINT</"
#~ "varname> 로 계산합니다. [<varname>MULTI</varname>]<varname>POINT</"
#~ "varname> 의 경우, 입력 좌표들의 산술 평균으로 계산합니다. "
#~ "[<varname>MULTI</varname>]<varname>LINESTRING</varname> 의 경우, 각 라인 "
#~ "선분의 가중 길이로 계산합니다. [<varname>MULTI</"
#~ "varname>]<varname>POLYGON</varname> 의 경우, 면적이라는 관점에서 \"가중치"
#~ "(weight)\"를 다룹니다. 텅 빈 도형을 입력할 경우, 텅 빈 "
#~ "<varname>GEOMETRYCOLLECTION</varname> 을 반환합니다. <varname>NULL</"
#~ "varname> 을 입력하면 <varname>NULL</varname> 을 반환합니다. "
#~ "<varname>CIRCULARSTRING</varname> 또는 <varname>COMPOUNDCURVE</varname> "
#~ "를 입력할 경우, 먼저 CurveToLine을 통해 라인스트링으로 변환한 다음, "
#~ "<varname>LINESTRING</varname> 에 대해서도 동일한 작업을 합니다."

#~ msgid ""
#~ "New in 2.3.0 : support <varname>CIRCULARSTRING</varname> and "
#~ "<varname>COMPOUNDCURVE</varname> (using CurveToLine)"
#~ msgstr ""
#~ "개선 사항: 2.3.0 버전부터 (CurveToLine을 이용해서) "
#~ "<varname>CIRCULARSTRING</varname> 및 <varname>COMPOUNDCURVE</varname> 를 "
#~ "지원합니다."

#~ msgid ""
#~ "The centroid is equal to the centroid of the set of component Geometries "
#~ "of highest dimension (since the lower-dimension geometries contribute "
#~ "zero \"weight\" to the centroid)."
#~ msgstr ""
#~ "중심점은 가장 높은 차원의 구성 도형들의 집합의 중심점과 동일합니다(낮은 차"
#~ "원의 도형은 중심점에 가중치를 전혀 주지 않기 때문입니다)."

#~ msgid "&sqlmm_compliant; SQL-MM 3: 8.1.4, 9.5.5"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 8.1.4, 9.5.5"

#~ msgid ""
#~ "In each of the following illustrations, the green dot represents the "
#~ "centroid of the source geometry."
#~ msgstr "다음 그림들 각각에서, 파란색 점이 입력 도형의 중심점을 나타냅니다."

#~ msgid "Centroid of a <varname>MULTIPOINT</varname>"
#~ msgstr "<varname>MULTIPOINT</varname> 의 중심점"

#~ msgid "Centroid of a <varname>LINESTRING</varname>"
#~ msgstr "<varname>LINESTRING</varname> 의 중심점"

#~ msgid "Centroid of a <varname>POLYGON</varname>"
#~ msgstr "<varname>POLYGON</varname> 의 중심점"

#~ msgid "Centroid of a <varname>GEOMETRYCOLLECTION</varname>"
#~ msgstr "<varname>GEOMETRYCOLLECTION</varname> 의 중심점"

#~ msgid ""
#~ "SELECT ST_AsText(ST_Centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, "
#~ "0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'));\n"
#~ "                                st_astext\n"
#~ "------------------------------------------\n"
#~ " POINT(2.30769230769231 3.30769230769231)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_centroid(g))\n"
#~ "FROM  ST_GeomFromText('CIRCULARSTRING(0 2, -1 1,0 0, 0.5 0, 1 0, 2 1, 1 "
#~ "2, 0.5 2, 0 2)')  AS g ;\n"
#~ "------------------------------------------\n"
#~ "POINT(0.5 1)\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_centroid(g))\n"
#~ "FROM  ST_GeomFromText('COMPOUNDCURVE(CIRCULARSTRING(0 2, -1 1,0 0),(0 0, "
#~ "0.5 0, 1 0),CIRCULARSTRING( 1 0, 2 1, 1 2),(1 2, 0.5 2, 0 2))' ) AS g;\n"
#~ "------------------------------------------\n"
#~ "POINT(0.5 1)"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_Centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, "
#~ "0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'));\n"
#~ "                                st_astext\n"
#~ "------------------------------------------\n"
#~ " POINT(2.30769230769231 3.30769230769231)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_centroid(g))\n"
#~ "FROM  ST_GeomFromText('CIRCULARSTRING(0 2, -1 1,0 0, 0.5 0, 1 0, 2 1, 1 "
#~ "2, 0.5 2, 0 2)')  AS g ;\n"
#~ "------------------------------------------\n"
#~ "POINT(0.5 1)\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_centroid(g))\n"
#~ "FROM  ST_GeomFromText('COMPOUNDCURVE(CIRCULARSTRING(0 2, -1 1,0 0),(0 0, "
#~ "0.5 0, 1 0),CIRCULARSTRING( 1 0, 2 1, 1 2),(1 2, 0.5 2, 0 2))' ) AS g;\n"
#~ "------------------------------------------\n"
#~ "POINT(0.5 1)"

#~ msgid ""
#~ "<refpurpose>Returns the 2-dimensional point on g1 that is closest to g2. "
#~ "This is the first point of the shortest line.</refpurpose>"
#~ msgstr ""
#~ "<refpurpose>g2에 가장 가까운 g1 상에 있는 2차원 포인트를 반환합니다. 해당 "
#~ "포인트는 최단 라인의 첫 번째 포인트입니다.</refpurpose>"

#~ msgid ""
#~ "<para>Returns the 2-dimensional point on g1 that is closest to g2. This "
#~ "is the first point of the shortest line.</para>"
#~ msgstr ""
#~ "<para>g2에 가장 가까운 g1 상에 있는 2차원 포인트를 반환합니다. 해당 포인트"
#~ "는 최단 라인의 첫 번째 포인트입니다.</para>"

#~ msgid "ST_ClusterDBSCAN"
#~ msgstr "ST_ClusterDBSCAN"

#~ msgid ""
#~ "Windowing function that returns integer id for the cluster each input "
#~ "geometry is in based on 2D implementation of Density-based spatial "
#~ "clustering of applications with noise (DBSCAN) algorithm."
#~ msgstr ""
#~ "각 입력 도형이 있는 클러스터에 대한 정수 ID를 DBSCAN(Density-Based "
#~ "Spatial Clustering of Applications with Noise) 알고리듬의 2차원 구현에 기"
#~ "반해서 반환하는, 서로 다른 데이터를 윈도를 통해 동시에 한 화면에 표시하는 "
#~ "함수입니다."

#~ msgid ""
#~ "<funcdef>integer <function>ST_ClusterDBSCAN</function></funcdef> "
#~ "<paramdef><type>geometry winset </type> <parameter>geom</parameter></"
#~ "paramdef> <paramdef><type>float8 </type> <parameter>eps</parameter></"
#~ "paramdef> <paramdef><type>integer </type> <parameter>minpoints</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>integer <function>ST_ClusterDBSCAN</function></funcdef> "
#~ "<paramdef><type>geometry winset </type> <parameter>geom</parameter></"
#~ "paramdef> <paramdef><type>float8 </type> <parameter>eps</parameter></"
#~ "paramdef> <paramdef><type>integer </type> <parameter>minpoints</"
#~ "parameter></paramdef>"

#~ msgid "An input geometry will be added to a cluster if it is either:"
#~ msgstr ""
#~ "입력 도형이 다음과 같은 경우 클러스터에 해당 도형을 추가할 것입니다:"

#~ msgid ""
#~ "Note that border geometries may be within <varname>eps</varname> distance "
#~ "of core geometries in more than one cluster; in this case, either "
#~ "assignment would be correct, and the border geometry will be arbitrarily "
#~ "asssigned to one of the available clusters. In these cases, it is "
#~ "possible for a correct cluster to be generated with fewer than "
#~ "<varname>minpoints</varname> geometries. When assignment of a border "
#~ "geometry is ambiguous, repeated calls to ST_ClusterDBSCAN will produce "
#~ "identical results if an ORDER BY clause is included in the window "
#~ "definition, but cluster assignments may differ from other implementations "
#~ "of the same algorithm."
#~ msgstr ""
#~ "경계 도형이 하나 이상의 클러스터에서 핵심 도형으로부터 <varname>eps</"
#~ "varname> 거리 안에 있을 수도 있다는 점에 주의하십시오. 이번 경우, 어느 쪽"
#~ "으로 할당해도 정확하며, 경계 도형은 가능한 클러스터 가운데 하나에 임의적으"
#~ "로 할당될 것입니다. 이런 경우에, 정확한 클러스터가 <varname>minpoints</"
#~ "varname> 밀도보다 적은 도형들과 함께 생성될 수도 있습니다. 경계 도형을 어"
#~ "느 쪽에 할당할지 모호한 경우, 윈도 정의에 ORDER BY 절이 포함돼 있다면 "
#~ "ST_ClusterDBSCAN 함수를 반복 호출했을 때 동일한 결과를 생성할 것이지만, 클"
#~ "러스터 할당이 동일 알고리즘의 다른 구현과 달라질 수도 있습니다."

#~ msgid ""
#~ "Input geometries that do not meet the criteria to join any other cluster "
#~ "will be assigned a cluster number of NULL."
#~ msgstr ""
#~ "다른 어떤 클러스터에도 들어갈 기준을 만족하지 못 하는 입력 도형은 번호가 "
#~ "NULL인 클러스터에 할당될 것입니다."

#~ msgid "Availability: 2.3.0 - requires GEOS"
#~ msgstr "2.3.0 버전부터 사용할 수 있습니다. GEOS가 필요합니다."

#~ msgid ""
#~ "Combining parcels with the same cluster number into a single geometry. "
#~ "This uses named argument calling"
#~ msgstr ""
#~ "동일한 클러스터 번호를 가진 구획들을 단일 도형으로 통합합니다. 이번에는 호"
#~ "출할 때 명칭을 가진 인수를 이용합니다."

#~ msgid ""
#~ "SELECT cid, ST_Collect(geom) AS cluster_geom, array_agg(parcel_id) AS "
#~ "ids_in_cluster FROM (\n"
#~ "    SELECT parcel_id, ST_ClusterDBSCAN(geom, eps := 0.5, minpoints := 5) "
#~ "over () AS cid, geom\n"
#~ "    FROM parcels) sq\n"
#~ "GROUP BY cid;"
#~ msgstr ""
#~ "SELECT cid, ST_Collect(geom) AS cluster_geom, array_agg(parcel_id) AS "
#~ "ids_in_cluster FROM (\n"
#~ "    SELECT parcel_id, ST_ClusterDBSCAN(geom, eps := 0.5, minpoints := 5) "
#~ "over () AS cid, geom\n"
#~ "    FROM parcels) sq\n"
#~ "GROUP BY cid;"

#~ msgid "ST_ClusterIntersecting"
#~ msgstr "ST_ClusterIntersecting"

#~ msgid ""
#~ "Aggregate. Returns an array with the connected components of a set of "
#~ "geometries"
#~ msgstr ""
#~ "종합 함수입니다. 도형들의 집합의 연결된 구성 요소들을 가진 배열을 반환합니"
#~ "다."

#~ msgid ""
#~ "<funcdef>geometry[] <function>ST_ClusterIntersecting</function></funcdef> "
#~ "<paramdef><type>geometry set</type> <parameter>g</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry[] <function>ST_ClusterIntersecting</function></funcdef> "
#~ "<paramdef><type>geometry set</type> <parameter>g</parameter></paramdef>"

#~ msgid ""
#~ "ST_ClusterIntersecting is an aggregate function that returns an array of "
#~ "GeometryCollections, where each GeometryCollection represents an "
#~ "interconnected set of geometries."
#~ msgstr ""
#~ "ST_ClusterIntersecting은 도형 집합의 배열을 반환하는 종합 함수입니다. 이"
#~ "때 도형 집합은 도형들의 상호 연결된 집합을 나타냅니다."

#~ msgid "Availability: 2.2.0 - requires GEOS"
#~ msgstr "2.2.0 버전부터 사용할 수 있습니다. GEOS가 필요합니다."

#~ msgid ""
#~ "WITH testdata AS\n"
#~ "  (SELECT unnest(ARRAY['LINESTRING (0 0, 1 1)'::geometry,\n"
#~ "                       'LINESTRING (5 5, 4 4)'::geometry,\n"
#~ "                       'LINESTRING (6 6, 7 7)'::geometry,\n"
#~ "                       'LINESTRING (0 0, -1 -1)'::geometry,\n"
#~ "                       'POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))'::geometry]) "
#~ "AS geom)\n"
#~ "\n"
#~ "SELECT ST_AsText(unnest(ST_ClusterIntersecting(geom))) FROM testdata;\n"
#~ "\n"
#~ "--result\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(0 0,1 1),LINESTRING(5 5,4 4),LINESTRING(0 "
#~ "0,-1 -1),POLYGON((0 0,4 0,4 4,0 4,0 0)))\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(6 6,7 7))"
#~ msgstr ""
#~ "WITH testdata AS\n"
#~ "  (SELECT unnest(ARRAY['LINESTRING (0 0, 1 1)'::geometry,\n"
#~ "                       'LINESTRING (5 5, 4 4)'::geometry,\n"
#~ "                       'LINESTRING (6 6, 7 7)'::geometry,\n"
#~ "                       'LINESTRING (0 0, -1 -1)'::geometry,\n"
#~ "                       'POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))'::geometry]) "
#~ "AS geom)\n"
#~ "\n"
#~ "SELECT ST_AsText(unnest(ST_ClusterIntersecting(geom))) FROM testdata;\n"
#~ "\n"
#~ "-- 결과\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(0 0,1 1),LINESTRING(5 5,4 4),LINESTRING(0 "
#~ "0,-1 -1),POLYGON((0 0,4 0,4 4,0 4,0 0)))\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(6 6,7 7))"

#~ msgid ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend=\"ST_ClusterWithin"
#~ "\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend=\"ST_ClusterWithin"
#~ "\"/>"

#~ msgid "ST_ClusterKMeans"
#~ msgstr "ST_ClusterKMeans"

#~ msgid ""
#~ "Windowing function that returns integer id for the cluster each input "
#~ "geometry is in."
#~ msgstr ""
#~ "각 입력 도형이 있는 클러스터에 대한 정수 ID를 반환하는, 서로 다른 데이터"
#~ "를 윈도를 통해 동시에 한 화면에 표시하는 함수입니다."

#~ msgid ""
#~ "<funcdef>integer <function>ST_ClusterKMeans</function></funcdef> "
#~ "<paramdef><type>geometry winset </type> <parameter>geom</parameter></"
#~ "paramdef> <paramdef><type>integer </type> <parameter>number_of_clusters</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>integer <function>ST_ClusterKMeans</function></funcdef> "
#~ "<paramdef><type>geometry winset </type> <parameter>geom</parameter></"
#~ "paramdef> <paramdef><type>integer </type> <parameter>number_of_clusters</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "Returns 2D distance based <ulink url=\"https://en.wikipedia.org/wiki/K-"
#~ "means_clustering\">k-means</ulink> cluster number for each input "
#~ "geometry. The distance used for clustering is the distance between the "
#~ "centroids of the geometries."
#~ msgstr ""
#~ "각 입력 도형에 대해 <ulink url=\"https://en.wikipedia.org/wiki/K-"
#~ "means_clustering\">k-means</ulink> 클러스터 번호에 기반한 2차원 거리를 반"
#~ "환합니다. 클러스터 작업에 쓰이는 거리는 도형들의 중심점 사이의 거리입니다."

#~ msgid "Generate dummy set of parcels for examples"
#~ msgstr "예시 용 가짜 구획 집합을 생성"

#~ msgid ""
#~ "CREATE TABLE parcels AS\n"
#~ "SELECT lpad((row_number() over())::text,3,'0') As parcel_id, geom,\n"
#~ "('{residential, commercial}'::text[])[1 + mod(row_number()OVER(),2)] As "
#~ "type\n"
#~ "FROM\n"
#~ "    ST_Subdivide(ST_Buffer('LINESTRING(40 100, 98 100, 100 150, 60 90)'::"
#~ "geometry,\n"
#~ "    40, 'endcap=square'),12) As geom;"
#~ msgstr ""
#~ "CREATE TABLE parcels AS\n"
#~ "SELECT lpad((row_number() over())::text,3,'0') As parcel_id, geom,\n"
#~ "('{residential, commercial}'::text[])[1 + mod(row_number()OVER(),2)] As "
#~ "type\n"
#~ "FROM\n"
#~ "    ST_Subdivide(ST_Buffer('LINESTRING(40 100, 98 100, 100 150, 60 90)'::"
#~ "geometry,\n"
#~ "    40, 'endcap=square'),12) As geom;"

#~ msgid "Original Parcels"
#~ msgstr "원본 구획"

#~ msgid "Parcels color-coded by cluster number (cid)"
#~ msgstr "클러스터 번호(cid)를 기준으로 색상 구분된 구획"

#~ msgid ""
#~ "SELECT ST_ClusterKMeans(geom, 5) OVER() AS cid, parcel_id, geom\n"
#~ "FROM parcels;\n"
#~ "-- result\n"
#~ " cid | parcel_id |   geom\n"
#~ "-----+-----------+---------------\n"
#~ "   0 | 001       | 0103000000...\n"
#~ "   0 | 002       | 0103000000...\n"
#~ "   1 | 003       | 0103000000...\n"
#~ "   0 | 004       | 0103000000...\n"
#~ "   1 | 005       | 0103000000...\n"
#~ "   2 | 006       | 0103000000...\n"
#~ "   2 | 007       | 0103000000...\n"
#~ "(7 rows)"
#~ msgstr ""
#~ "SELECT ST_ClusterKMeans(geom, 5) OVER() AS cid, parcel_id, geom\n"
#~ "FROM parcels;\n"
#~ "-- 결과\n"
#~ " cid | parcel_id |   geom\n"
#~ "-----+-----------+---------------\n"
#~ "   0 | 001       | 0103000000...\n"
#~ "   0 | 002       | 0103000000...\n"
#~ "   1 | 003       | 0103000000...\n"
#~ "   0 | 004       | 0103000000...\n"
#~ "   1 | 005       | 0103000000...\n"
#~ "   2 | 006       | 0103000000...\n"
#~ "   2 | 007       | 0103000000...\n"
#~ "(7 rows)"

#~ msgid ""
#~ "-- Partitioning parcel clusters by type\n"
#~ "SELECT ST_ClusterKMeans(geom,3) over (PARTITION BY type) AS cid, "
#~ "parcel_id, type\n"
#~ "FROM parcels;\n"
#~ "-- result\n"
#~ " cid | parcel_id |    type\n"
#~ "-----+-----------+-------------\n"
#~ "   1 | 005       | commercial\n"
#~ "   1 | 003       | commercial\n"
#~ "   2 | 007       | commercial\n"
#~ "   0 | 001       | commercial\n"
#~ "   1 | 004       | residential\n"
#~ "   0 | 002       | residential\n"
#~ "   2 | 006       | residential\n"
#~ "(7 rows)"
#~ msgstr ""
#~ "-- 유형을 기준으로 구획 클러스터 분할하기\n"
#~ "SELECT ST_ClusterKMeans(geom,3) over (PARTITION BY type) AS cid, "
#~ "parcel_id, type\n"
#~ "FROM parcels;\n"
#~ "-- 결과\n"
#~ " cid | parcel_id |    type\n"
#~ "-----+-----------+-------------\n"
#~ "   1 | 005       | commercial\n"
#~ "   1 | 003       | commercial\n"
#~ "   2 | 007       | commercial\n"
#~ "   0 | 001       | commercial\n"
#~ "   1 | 004       | residential\n"
#~ "   0 | 002       | residential\n"
#~ "   2 | 006       | residential\n"
#~ "(7 rows)"

#~ msgid ""
#~ ", <xref linkend=\"ST_ClusterIntersecting\"/>, <xref linkend="
#~ "\"ST_ClusterWithin\"/>, <xref linkend=\"ST_Subdivide\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ClusterIntersecting\"/>, <xref linkend="
#~ "\"ST_ClusterWithin\"/>, <xref linkend=\"ST_Subdivide\"/>"

#~ msgid "ST_ClusterWithin"
#~ msgstr "ST_ClusterWithin"

#~ msgid ""
#~ "Aggregate. Returns an array of GeometryCollections, where each "
#~ "GeometryCollection represents a set of geometries separated by no more "
#~ "than the specified distance."
#~ msgstr ""
#~ "종합 합수입니다. 도형 집합의 배열을 반환합니다. 이때 도형 집합은 설정된 거"
#~ "리 미만으로 떨어진 도형들의 집합을 나타냅니다."

#~ msgid ""
#~ "<funcdef>geometry[] <function>ST_ClusterWithin</function></funcdef> "
#~ "<paramdef><type>geometry set </type> <parameter>g</parameter></paramdef> "
#~ "<paramdef><type>float8 </type> <parameter>distance</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry[] <function>ST_ClusterWithin</function></funcdef> "
#~ "<paramdef><type>geometry set </type> <parameter>g</parameter></paramdef> "
#~ "<paramdef><type>float8 </type> <parameter>distance</parameter></paramdef>"

#~ msgid ""
#~ "WITH testdata AS\n"
#~ "  (SELECT unnest(ARRAY['LINESTRING (0 0, 1 1)'::geometry,\n"
#~ "                       'LINESTRING (5 5, 4 4)'::geometry,\n"
#~ "                       'LINESTRING (6 6, 7 7)'::geometry,\n"
#~ "                       'LINESTRING (0 0, -1 -1)'::geometry,\n"
#~ "                       'POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))'::geometry]) "
#~ "AS geom)\n"
#~ "\n"
#~ "SELECT ST_AsText(unnest(ST_ClusterWithin(geom, 1.4))) FROM testdata;\n"
#~ "\n"
#~ "--result\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(0 0,1 1),LINESTRING(5 5,4 4),LINESTRING(0 "
#~ "0,-1 -1),POLYGON((0 0,4 0,4 4,0 4,0 0)))\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(6 6,7 7))"
#~ msgstr ""
#~ "WITH testdata AS\n"
#~ "  (SELECT unnest(ARRAY['LINESTRING (0 0, 1 1)'::geometry,\n"
#~ "                       'LINESTRING (5 5, 4 4)'::geometry,\n"
#~ "                       'LINESTRING (6 6, 7 7)'::geometry,\n"
#~ "                       'LINESTRING (0 0, -1 -1)'::geometry,\n"
#~ "                       'POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))'::geometry]) "
#~ "AS geom)\n"
#~ "\n"
#~ "SELECT ST_AsText(unnest(ST_ClusterWithin(geom, 1.4))) FROM testdata;\n"
#~ "\n"
#~ "-- 결과\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(0 0,1 1),LINESTRING(5 5,4 4),LINESTRING(0 "
#~ "0,-1 -1),POLYGON((0 0,4 0,4 4,0 4,0 0)))\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(6 6,7 7))"

#~ msgid ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend="
#~ "\"ST_ClusterIntersecting\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend="
#~ "\"ST_ClusterIntersecting\"/>"

#~ msgid "ST_Contains"
#~ msgstr "ST_Contains"

#~ msgid ""
#~ "Returns true if and only if no points of B lie in the exterior of A, and "
#~ "at least one point of the interior of B lies in the interior of A."
#~ msgstr ""
#~ "A  외부에 놓인 B의 포인트가 하나도 없고, 적어도 B 내부의 포인트 하나가 A"
#~ "의 내부에 있는 경우 참을 반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Contains</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Contains</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#~ msgid ""
#~ "Geometry A contains Geometry B if and only if no points of B lie in the "
#~ "exterior of A, and at least one point of the interior of B lies in the "
#~ "interior of A. An important subtlety of this definition is that A does "
#~ "not contain its boundary, but A does contain itself. Contrast that to "
#~ "<xref linkend=\"ST_ContainsProperly\"/> where geometry A does not Contain "
#~ "Properly itself."
#~ msgstr ""
#~ "도형A  외부에 놓인 도형 B의 포인트가 하나도 없고, 적어도 B 내부의 포인트 "
#~ "하나가 A의 내부에 있을 때 도형 A가 도형 B를 담고 있다고 합니다. 이 정의의 "
#~ "중요한 섬세성은 A가 자기 자신을 담고는 있지만, A가 자신의 경계선을 담고 있"
#~ "지는 않다는 점입니다. 도형 A가 자기 자신을 제대로 담고 있지 않은 <xref "
#~ "linkend=\"ST_ContainsProperly\"/> 의 경우와 대조해보십시오."

#~ msgid ""
#~ "Returns TRUE if geometry B is completely inside geometry A. For this "
#~ "function to make sense, the source geometries must both be of the same "
#~ "coordinate projection, having the same SRID. ST_Contains is the inverse "
#~ "of ST_Within. So ST_Contains(A,B) implies ST_Within(B,A) except in the "
#~ "case of invalid geometries where the result is always false regardless or "
#~ "not defined."
#~ msgstr ""
#~ "도형 B가 도형 A 안에 완전히 들어 있을 경우 참을 반환합니다. 이 함수가 제대"
#~ "로 동작하려면, 입력 도형들 둘 다 동일한 좌표 투영체, 즉 동일한 SRID를 가져"
#~ "야 합니다. ST_Contains는 ST_Within의 역함수입니다. 따라서 ST_Contains(A,B)"
#~ "와 ST_Within(B,A)는 동일합니다. 다만 정의에 상관없이 또는 정의되지 않아 언"
#~ "제나 거짓을 반환하는 유효하지 않은 도형의 경우를 제외하면 말이죠."

#~ msgid ""
#~ "Enhanced: 2.3.0 Enhancement to PIP short-circuit extended to support "
#~ "MultiPoints with few points. Prior versions only supported point in "
#~ "polygon."
#~ msgstr ""
#~ "개선 사항: 2.3.0버전에서 PIP 단락(short-circuit)이 포인트가 몇 개 없는 멀"
#~ "티포인트를 지원하도록 확장/개선됐습니다. 예전 버전은 폴리곤 내부에 있는 포"
#~ "인트만 지원했습니다."

#~ msgid ""
#~ "Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument"
#~ msgstr "<varname>GEOMETRYCOLLECTION</varname> 을 인수로 호출하지 마십시오."

#~ msgid ""
#~ "Do not use this function with invalid geometries. You will get unexpected "
#~ "results."
#~ msgstr ""
#~ "이 함수에 유효하지 않은 도형을 입력하지 마십시오. 결과를 예측할 수 없습니"
#~ "다."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_Contains."
#~ msgstr ""
#~ "이 함수를 호출하면 도형에서 이용할 수 있는 모든 인덱스를 활용하는 경계 상"
#~ "자 비교 작업을 자동적으로 포함하게 됩니다. 인덱스 활용을 피하려면, "
#~ "_ST_Contains 함수를 이용하십시오."

#~ msgid ""
#~ "NOTE: this is the \"allowable\" version that returns a boolean, not an "
#~ "integer."
#~ msgstr ""
#~ "주의: 이 함수는 정수가 아니라 불값을 반환하는, \"사용할 만한\" 버전입니다."

#~ msgid ""
#~ "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - same as within(geometry B, "
#~ "geometry A)"
#~ msgstr ""
#~ "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - within(geometry B, geometry A)와 "
#~ "동일"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.31"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.31"

#~ msgid ""
#~ "There are certain subtleties to ST_Contains and ST_Within that are not "
#~ "intuitively obvious. For details check out <ulink url=\"http://lin-ear-th-"
#~ "inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html"
#~ "\">Subtleties of OGC Covers, Contains, Within</ulink>"
#~ msgstr ""
#~ "ST_Contains 및 ST_Within 함수에는 직관적으로 명백하지 않은, 어떤 섬세함들"
#~ "이 있습니다. 자세한 내용은 <ulink url=\"http://lin-ear-th-inking.blogspot."
#~ "com/2007/06/subtleties-of-ogc-covers-spatial.html\">Subtleties of OGC "
#~ "Covers, Contains, Within</ulink> 을 확인해보십시오."

#~ msgid ""
#~ "The <function>ST_Contains</function> predicate returns <varname>TRUE</"
#~ "varname> in all the following illustrations."
#~ msgstr ""
#~ "<function>ST_Contains</function> 의 술부는 다음 모든 그림들에서 "
#~ "<varname>TRUE</varname> 를 반환합니다."

#~ msgid "<varname>LINESTRING</varname> / <varname>MULTIPOINT</varname>"
#~ msgstr "<varname>LINESTRING</varname> / <varname>MULTIPOINT</varname>"

#~ msgid "<varname>POLYGON</varname> / <varname>POINT</varname>"
#~ msgstr "<varname>POLYGON</varname> / <varname>POINT</varname>"

#~ msgid "<varname>POLYGON</varname> / <varname>LINESTRING</varname>"
#~ msgstr "<varname>POLYGON</varname> / <varname>LINESTRING</varname>"

#~ msgid "<varname>POLYGON</varname> / <varname>POLYGON</varname>"
#~ msgstr "<varname>POLYGON</varname> / <varname>POLYGON</varname>"

#~ msgid ""
#~ "The <function>ST_Contains</function> predicate returns <varname>FALSE</"
#~ "varname> in all the following illustrations."
#~ msgstr ""
#~ "<function>ST_Contains</function> 의 술부는 다음 모든 그림들에서 "
#~ "<varname>FALSE</varname> 를 반환합니다."

#~ msgid "<varname>POLYGON</varname> / <varname>MULTIPOINT</varname>"
#~ msgstr "<varname>POLYGON</varname> / <varname>MULTIPOINT</varname>"

#~ msgid ""
#~ "-- A circle within a circle\n"
#~ "SELECT ST_Contains(smallc, bigc) As smallcontainsbig,\n"
#~ "           ST_Contains(bigc,smallc) As bigcontainssmall,\n"
#~ "           ST_Contains(bigc, ST_Union(smallc, bigc)) as "
#~ "bigcontainsunion,\n"
#~ "           ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
#~ "           ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "           ST_Contains(bigc, ST_ExteriorRing(bigc)) As "
#~ "bigcontainsexterior\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "                         ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As "
#~ "bigc) As foo;\n"
#~ "\n"
#~ "-- Result\n"
#~ "  smallcontainsbig | bigcontainssmall | bigcontainsunion | bigisunion | "
#~ "bigcoversexterior | bigcontainsexterior\n"
#~ "------------------+------------------+------------------+------------"
#~ "+-------------------+---------------------\n"
#~ " f                | t                | t                | t          | "
#~ "t        | f\n"
#~ "\n"
#~ "-- Example demonstrating difference between contains and contains "
#~ "properly\n"
#~ "SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
#~ "acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
#~ "   ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
#~ "ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
#~ "FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
#~ "                         ( ST_MakeLine(ST_Point(1,1), "
#~ "ST_Point(-1,-1) ) ),\n"
#~ "                         ( ST_Point(1,1) )\n"
#~ "          ) As foo(geomA);\n"
#~ "\n"
#~ "  geomtype    | acontainsa | acontainspropa | acontainsba | "
#~ "acontainspropba\n"
#~ "--------------+------------+----------------+-------------"
#~ "+-----------------\n"
#~ "ST_Polygon    | t          | f              | f           | f\n"
#~ "ST_LineString | t          | f              | f           | f\n"
#~ "ST_Point      | t          | t              | f           | f"
#~ msgstr ""
#~ "-- 원 안의 원\n"
#~ "SELECT ST_Contains(smallc, bigc) As smallcontainsbig,\n"
#~ "           ST_Contains(bigc,smallc) As bigcontainssmall,\n"
#~ "           ST_Contains(bigc, ST_Union(smallc, bigc)) as "
#~ "bigcontainsunion,\n"
#~ "           ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
#~ "           ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "           ST_Contains(bigc, ST_ExteriorRing(bigc)) As "
#~ "bigcontainsexterior\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "                         ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As "
#~ "bigc) As foo;\n"
#~ "\n"
#~ "-- 결과\n"
#~ "  smallcontainsbig | bigcontainssmall | bigcontainsunion | bigisunion | "
#~ "bigcoversexterior | bigcontainsexterior\n"
#~ "------------------+------------------+------------------+------------"
#~ "+-------------------+---------------------\n"
#~ " f                | t                | t                | t          | "
#~ "t        | f\n"
#~ "\n"
#~ "-- 담고 있는 것과 제대로 담고 있는 것의 차이점을 보여주는 예시\n"
#~ "SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
#~ "acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
#~ "   ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
#~ "ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
#~ "FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
#~ "                         ( ST_MakeLine(ST_Point(1,1), "
#~ "ST_Point(-1,-1) ) ),\n"
#~ "                         ( ST_Point(1,1) )\n"
#~ "          ) As foo(geomA);\n"
#~ "\n"
#~ "  geomtype    | acontainsa | acontainspropa | acontainsba | "
#~ "acontainspropba\n"
#~ "--------------+------------+----------------+-------------"
#~ "+-----------------\n"
#~ "ST_Polygon    | t          | f              | f           | f\n"
#~ "ST_LineString | t          | f              | f           | f\n"
#~ "ST_Point      | t          | t              | f           | f"

#~ msgid ""
#~ ", <xref linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, "
#~ "<xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
#~ "linkend=\"ST_Within\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, "
#~ "<xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
#~ "linkend=\"ST_Within\"/>"

#~ msgid "ST_ContainsProperly"
#~ msgstr "ST_ContainsProperly"

#~ msgid ""
#~ "Returns true if B intersects the interior of A but not the boundary (or "
#~ "exterior). A does not contain properly itself, but does contain itself."
#~ msgstr ""
#~ "B가 A의 내부와 교차하지만 A의 경계선(또는 외부)과 교차하지는 않을 경우 참"
#~ "을 반환합니다. A는 자기 자신을 제대로 담고 있지는 않지만, 자기 자신을 담"
#~ "고 있긴 합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_ContainsProperly</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_ContainsProperly</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#~ msgid ""
#~ "Returns true if B intersects the interior of A but not the boundary (or "
#~ "exterior)."
#~ msgstr ""
#~ "B가 A의 내부와 교차하지만 A의 경계선(또는 외부)과 교차하지는 않을 경우 참"
#~ "을 반환합니다."

#~ msgid "A does not contain properly itself, but does contain itself."
#~ msgstr ""
#~ "A는 자기 자신을 제대로 담고 있지는 않지만, 자기 자신을 담고 있긴 합니다."

#~ msgid ""
#~ "Every point of the other geometry is a point of this geometry's interior. "
#~ "The DE-9IM Intersection Matrix for the two geometries matches [T**FF*FF*] "
#~ "used in <xref linkend=\"ST_Relate\"/>"
#~ msgstr ""
#~ "다른 도형의 모든 포인트가 이 도형 내부의 포인트입니다. 이 두 도형에 대한 "
#~ "DE-9IM 교차점 매트릭스가 <xref linkend=\"ST_Relate\"/> 에서 쓰인 "
#~ "[T**FF*FF*]와 일치합니다."

#~ msgid ""
#~ "From JTS docs slightly reworded: The advantage to using this predicate "
#~ "over <xref linkend=\"ST_Contains\"/> and <xref linkend=\"ST_Intersects\"/"
#~ "> is that it can be computed efficiently, with no need to compute "
#~ "topology at individual points."
#~ msgstr ""
#~ "JTS 문서에서 살짝 말을 바꿔 인용했습니다: <xref linkend=\"ST_Contains\"/> "
#~ "및 <xref linkend=\"ST_Intersects\"/> 대신 이 함수를 사용하는 경우의 장점"
#~ "은 각 개별 포인트에서 위상기하를 계산할 필요가 없어 더 효율적으로 계산할 "
#~ "수 있다는 점입니다."

#~ msgid ""
#~ "An example use case for this predicate is computing the intersections of "
#~ "a set of geometries with a large polygonal geometry. Since intersection "
#~ "is a fairly slow operation, it can be more efficient to use "
#~ "containsProperly to filter out test geometries which lie wholly inside "
#~ "the area. In these cases the intersection is known a priori to be exactly "
#~ "the original test geometry."
#~ msgstr ""
#~ "이 함수의 용례는 대용량 폴리곤 도형을 가진 도형 집합의 교차점을 계산하는 "
#~ "예시입니다. 교차점을 파악하는 것이 꽤 느린 작업이기 때문에, 면 안에 도형 "
#~ "전체가 들어가는 테스트 도형을 필터링하는 containsProperly를 이용하는 편이 "
#~ "더 효율적입니다. 이런 경우, 교차점이 정확히 원래 테스트 도형이라는 사실이 "
#~ "선험적으로 알려져 있습니다."

#~ msgid "Availability: 1.4.0 - requires GEOS &gt;= 3.1.0."
#~ msgstr ""
#~ "1.4.0 버전부터 사용할 수 있습니다. GEOS 3.1.0 이상 버전이 필요합니다."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_ContainsProperly."
#~ msgstr ""
#~ "이 함수를 호출하면 도형에서 이용할 수 있는 모든 인덱스를 활용하는 경계 상"
#~ "자 비교 작업을 자동적으로 포함하게 됩니다. 인덱스 활용을 피하려면, "
#~ "_ST_ContainsProperly 함수를 이용하십시오."

#~ msgid ""
#~ "--a circle within a circle\n"
#~ "        SELECT ST_ContainsProperly(smallc, bigc) As "
#~ "smallcontainspropbig,\n"
#~ "        ST_ContainsProperly(bigc,smallc) As bigcontainspropsmall,\n"
#~ "        ST_ContainsProperly(bigc, ST_Union(smallc, bigc)) as "
#~ "bigcontainspropunion,\n"
#~ "        ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
#~ "        ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "        ST_ContainsProperly(bigc, ST_ExteriorRing(bigc)) As "
#~ "bigcontainsexterior\n"
#~ "        FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As "
#~ "smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        --Result\n"
#~ "  smallcontainspropbig | bigcontainspropsmall | bigcontainspropunion | "
#~ "bigisunion | bigcoversexterior | bigcontainsexterior\n"
#~ "------------------+------------------+------------------+------------"
#~ "+-------------------+---------------------\n"
#~ " f                     | t                    | f                    | "
#~ "t          | t                 | f\n"
#~ "\n"
#~ " --example demonstrating difference between contains and contains "
#~ "properly\n"
#~ " SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
#~ "acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
#~ " ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
#~ "ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
#~ " FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
#~ "                  ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
#~ "                  ( ST_Point(1,1) )\n"
#~ "        ) As foo(geomA);\n"
#~ "\n"
#~ "  geomtype    | acontainsa | acontainspropa | acontainsba | "
#~ "acontainspropba\n"
#~ "--------------+------------+----------------+-------------"
#~ "+-----------------\n"
#~ "ST_Polygon    | t          | f              | f           | f\n"
#~ "ST_LineString | t          | f              | f           | f\n"
#~ "ST_Point      | t          | t              | f           | f"
#~ msgstr ""
#~ "-- 원 안의 원\n"
#~ "        SELECT ST_ContainsProperly(smallc, bigc) As "
#~ "smallcontainspropbig,\n"
#~ "        ST_ContainsProperly(bigc,smallc) As bigcontainspropsmall,\n"
#~ "        ST_ContainsProperly(bigc, ST_Union(smallc, bigc)) as "
#~ "bigcontainspropunion,\n"
#~ "        ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
#~ "        ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "        ST_ContainsProperly(bigc, ST_ExteriorRing(bigc)) As "
#~ "bigcontainsexterior\n"
#~ "        FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As "
#~ "smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        -- 결과\n"
#~ "  smallcontainspropbig | bigcontainspropsmall | bigcontainspropunion | "
#~ "bigisunion | bigcoversexterior | bigcontainsexterior\n"
#~ "------------------+------------------+------------------+------------"
#~ "+-------------------+---------------------\n"
#~ " f                     | t                    | f                    | "
#~ "t          | t                 | f\n"
#~ "\n"
#~ " -- 담고 있는 것과 제대로 담고 있는 것의 차이점을 보여주는 예시\n"
#~ " SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
#~ "acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
#~ " ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
#~ "ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
#~ " FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
#~ "                  ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
#~ "                  ( ST_Point(1,1) )\n"
#~ "        ) As foo(geomA);\n"
#~ "\n"
#~ "  geomtype    | acontainsa | acontainspropa | acontainsba | "
#~ "acontainspropba\n"
#~ "--------------+------------+----------------+-------------"
#~ "+-----------------\n"
#~ "ST_Polygon    | t          | f              | f           | f\n"
#~ "ST_LineString | t          | f              | f           | f\n"
#~ "ST_Point      | t          | t              | f           | f"

#~ msgid ""
#~ ", <xref linkend=\"ST_Boundary\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
#~ "linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref linkend="
#~ "\"ST_Equals\"/>, <xref linkend=\"ST_Relate\"/>, <xref linkend=\"ST_Within"
#~ "\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_Boundary\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
#~ "linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref linkend="
#~ "\"ST_Equals\"/>, <xref linkend=\"ST_Relate\"/>, <xref linkend=\"ST_Within"
#~ "\"/>"

#~ msgid "ST_Covers"
#~ msgstr "ST_Covers"

#~ msgid "Returns 1 (TRUE) if no point in Geometry B is outside Geometry A"
#~ msgstr ""
#~ "도형 B 안에 있는 어떤 포인트도 도형 A 외부에 없을 경우 1(참)을 반환합니다."

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Covers</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "</funcprototype> <funcprototype> <funcdef>boolean <function>ST_Covers</"
#~ "function></funcdef> <paramdef><type>geography </type> "
#~ "<parameter>geogpolyA</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>geogpointB</parameter></paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Covers</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "</funcprototype> <funcprototype> <funcdef>boolean <function>ST_Covers</"
#~ "function></funcdef> <paramdef><type>geography </type> "
#~ "<parameter>geogpolyA</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>geogpointB</parameter></paramdef> </funcprototype>"

#~ msgid ""
#~ "Returns 1 (TRUE) if no point in Geometry/Geography B is outside Geometry/"
#~ "Geography A"
#~ msgstr ""
#~ "도형/지리형 B 안에 있는 어떤 포인트도 도형/지리형 A 외부에 없을 경우 1(참)"
#~ "을 반환합니다."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_Covers."
#~ msgstr ""
#~ "이 함수를 호출하면 도형에서 이용할 수 있는 모든 인덱스를 활용하는 경계 상"
#~ "자 비교 작업을 자동적으로 포함하게 됩니다. 인덱스 활용을 피하려면, "
#~ "_ST_Covers 함수를 이용하십시오."

#~ msgid ""
#~ "Enhanced: 2.3.0 Enhancement to PIP short-circuit for geometry extended to "
#~ "support MultiPoints with few points. Prior versions only supported point "
#~ "in polygon."
#~ msgstr ""
#~ "개선 사항: 2.3.0버전에서 도형에 대한 PIP 단락(short-circuit)이 포인트가 "
#~ "몇 개 없는 멀티포인트를 지원하도록 확장/개선됐습니다. 예전 버전은 폴리곤 "
#~ "내부에 있는 포인트만 지원했습니다."

#~ msgid "Availability: 1.5 - support for geography was introduced."
#~ msgstr "1.5.0 버전부터 지리형을 지원합니다."

#~ msgid "Availability: 1.2.2 - requires GEOS &gt;= 3.0"
#~ msgstr "1.2.2 버전부터 사용할 수 있습니다. GEOS 3.0 이상 버전이 필요합니다."

#~ msgid "Not an OGC standard, but Oracle has it too."
#~ msgstr "OGC 표준은 아니지만, Oracle도 이 함수를 내장하고 있습니다."

#~ msgid ""
#~ "--a circle covering a circle\n"
#~ "SELECT ST_Covers(smallc,smallc) As smallinsmall,\n"
#~ "        ST_Covers(smallc, bigc) As smallcoversbig,\n"
#~ "        ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "        ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        --Result\n"
#~ " smallinsmall | smallcoversbig | bigcoversexterior | bigcontainsexterior\n"
#~ "--------------+----------------+-------------------"
#~ "+---------------------\n"
#~ " t            | f              | t                 | f\n"
#~ "(1 row)"
#~ msgstr ""
#~ "-- 원을 커버하는 원\n"
#~ "SELECT ST_Covers(smallc,smallc) As smallinsmall,\n"
#~ "        ST_Covers(smallc, bigc) As smallcoversbig,\n"
#~ "        ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "        ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        -- 결과\n"
#~ " smallinsmall | smallcoversbig | bigcoversexterior | bigcontainsexterior\n"
#~ "--------------+----------------+-------------------"
#~ "+---------------------\n"
#~ " t            | f              | t                 | f\n"
#~ "(1 row)"

#~ msgid "Geeography Example"
#~ msgstr "지리형 예시"

#~ msgid ""
#~ "-- a point with a 300 meter buffer compared to a point, a point and its "
#~ "10 meter buffer\n"
#~ "SELECT ST_Covers(geog_poly, geog_pt) As poly_covers_pt,\n"
#~ "        ST_Covers(ST_Buffer(geog_pt,10), geog_pt) As "
#~ "buff_10m_covers_cent\n"
#~ "        FROM (SELECT ST_Buffer(ST_GeogFromText('SRID=4326;POINT(-99.327 "
#~ "31.4821)'), 300) As geog_poly,\n"
#~ "                                ST_GeogFromText('SRID=4326;POINT(-99.33 "
#~ "31.483)') As geog_pt ) As foo;\n"
#~ "\n"
#~ " poly_covers_pt | buff_10m_covers_cent\n"
#~ "----------------+------------------\n"
#~ " f              | t"
#~ msgstr ""
#~ "-- 300미터 버퍼를 준 포인트와 10미터 버퍼를 준 포인트를 비교 \n"
#~ "SELECT ST_Covers(geog_poly, geog_pt) As poly_covers_pt,\n"
#~ "        ST_Covers(ST_Buffer(geog_pt,10), geog_pt) As "
#~ "buff_10m_covers_cent\n"
#~ "        FROM (SELECT ST_Buffer(ST_GeogFromText('SRID=4326;POINT(-99.327 "
#~ "31.4821)'), 300) As geog_poly,\n"
#~ "                                ST_GeogFromText('SRID=4326;POINT(-99.33 "
#~ "31.483)') As geog_pt ) As foo;\n"
#~ "\n"
#~ " poly_covers_pt | buff_10m_covers_cent\n"
#~ "----------------+------------------\n"
#~ " f              | t"

#~ msgid ", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Within\"/>"
#~ msgstr ", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Within\"/>"

#~ msgid "ST_CoveredBy"
#~ msgstr "ST_CoveredBy"

#~ msgid ""
#~ "<refpurpose>Returns 1 (TRUE) if no point in Geometry/Geography A is "
#~ "outside Geometry/Geography B</refpurpose>"
#~ msgstr ""
#~ "<refpurpose>도형/지리형 A 안에 있는 어떤 포인트도 도형/지리형 B 외부에 없"
#~ "을 경우 1(참)을 반환합니다.</refpurpose>"

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_CoveredBy</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>geomA</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>geomB</parameter></"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
#~ "<function>ST_CoveredBy</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>geogA</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>geogB</parameter></paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_CoveredBy</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>geomA</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>geomB</parameter></"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
#~ "<function>ST_CoveredBy</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>geogA</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>geogB</parameter></paramdef> </funcprototype>"

#~ msgid ""
#~ "<para>Returns 1 (TRUE) if no point in Geometry/Geography A is outside "
#~ "Geometry/Geography B</para>"
#~ msgstr ""
#~ "<para>도형/지리형 A 안에 있는 어떤 포인트도 도형/지리형 B 외부에 없을 경"
#~ "우 1(참)을 반환합니다.</para>"

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_CoveredBy."
#~ msgstr ""
#~ "이 함수를 호출하면 도형에서 이용할 수 있는 모든 인덱스를 활용하는 경계 상"
#~ "자 비교 작업을 자동적으로 포함하게 됩니다. 인덱스 활용을 피하려면, "
#~ "_ST_CoveredBy 함수를 이용하십시오."

#~ msgid ""
#~ "--a circle coveredby a circle\n"
#~ "SELECT ST_CoveredBy(smallc,smallc) As smallinsmall,\n"
#~ "        ST_CoveredBy(smallc, bigc) As smallcoveredbybig,\n"
#~ "        ST_CoveredBy(ST_ExteriorRing(bigc), bigc) As "
#~ "exteriorcoveredbybig,\n"
#~ "        ST_Within(ST_ExteriorRing(bigc),bigc) As exeriorwithinbig\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        --Result\n"
#~ " smallinsmall | smallcoveredbybig | exteriorcoveredbybig | "
#~ "exeriorwithinbig\n"
#~ "--------------+-------------------+----------------------"
#~ "+------------------\n"
#~ " t            | t                 | t                    | f\n"
#~ "(1 row)"
#~ msgstr ""
#~ "-- 원이 커버하는 원\n"
#~ "SELECT ST_CoveredBy(smallc,smallc) As smallinsmall,\n"
#~ "        ST_CoveredBy(smallc, bigc) As smallcoveredbybig,\n"
#~ "        ST_CoveredBy(ST_ExteriorRing(bigc), bigc) As "
#~ "exteriorcoveredbybig,\n"
#~ "        ST_Within(ST_ExteriorRing(bigc),bigc) As exeriorwithinbig\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "-- 결과\n"
#~ " smallinsmall | smallcoveredbybig | exteriorcoveredbybig | "
#~ "exeriorwithinbig\n"
#~ "--------------+-------------------+----------------------"
#~ "+------------------\n"
#~ " t            | t                 | t                    | f\n"
#~ "(1 row)"

#~ msgid ""
#~ ", <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_ExteriorRing\"/>, "
#~ "<xref linkend=\"ST_Within\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_ExteriorRing\"/>, "
#~ "<xref linkend=\"ST_Within\"/>"

#~ msgid "ST_Crosses"
#~ msgstr "ST_Crosses"

#~ msgid ""
#~ "Returns <varname>TRUE</varname> if the supplied geometries have some, but "
#~ "not all, interior points in common."
#~ msgstr ""
#~ "입력 도형들이 전부가 아닌 일부 내부 포인트를 공유하는 경우 <varname>TRUE</"
#~ "varname> 를 반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Crosses</function></funcdef> "
#~ "<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type><parameter>g2</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Crosses</function></funcdef> "
#~ "<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type><parameter>g2</parameter></paramdef>"

#~ msgid ""
#~ "<function>ST_Crosses</function> takes two geometry objects and returns "
#~ "<varname>TRUE</varname> if their intersection \"spatially cross\", that "
#~ "is, the geometries have some, but not all interior points in common. The "
#~ "intersection of the interiors of the geometries must not be the empty set "
#~ "and must have a dimensionality less than the maximum dimension of the two "
#~ "input geometries. Additionally, the intersection of the two geometries "
#~ "must not equal either of the source geometries. Otherwise, it returns "
#~ "<varname>FALSE</varname>."
#~ msgstr ""
#~ "<function>ST_Crosses</function> 는 두 도형 객체를 입력받아 두 도형이 \"공"
#~ "간적으로 교차\"하는 경우, 즉 두 도형이 전부가 아닌 일부 내부 포인트를 공유"
#~ "하는 경우 <varname>TRUE</varname> 를 반환합니다. 두 도형의 내부의 교차점"
#~ "은 절대 텅 빈 집합이어서는 안 되며 두 입력 도형의 최대 차원보다 차원수가 "
#~ "적어야만 합니다. 또, 두 도형의 교차점은 두 도형 어느쪽과도 동일해서는 안 "
#~ "됩니다. 반대의 경우, <varname>FALSE</varname> 를 반환합니다."

#~ msgid "In mathematical terms, this is expressed as:"
#~ msgstr "수학적인 관점에서, 다음과 같이 표현됩니다:"

#~ msgid ""
#~ "TODO: Insert appropriate MathML markup here or use a gif. Simple HTML "
#~ "markup does not work well in both IE and Firefox."
#~ msgstr ""
#~ "할 일: 여기에 적절한 MathML 마크업 언어를 삽입하든지 또는 GIF를 사용할 "
#~ "것. 단순한 HTML 마크업 언어는 IE와 FF 양쪽 모두에서 잘 동작하지 않음."

#~ msgid "The DE-9IM Intersection Matrix for the two geometries is:"
#~ msgstr "두 도형에 대한 DE-9IM 교차점 매트릭스는 다음과 같습니다:"

#~ msgid ""
#~ "<markup>T*T******</markup> (for Point/Line, Point/Area, and Line/Area "
#~ "situations)"
#~ msgstr "<markup>T*T******</markup> (포인트/라인, 포인트/면, 라인/면 상황)"

#~ msgid ""
#~ "<markup>T*****T**</markup> (for Line/Point, Area/Point, and Area/Line "
#~ "situations)"
#~ msgstr "<markup>T*****T**</markup> (라인/포인트, 면/포인트, 면/라인 상황)"

#~ msgid "<markup>0********</markup> (for Line/Line situations)"
#~ msgstr "<markup>0********</markup> (라인/라인 상황)"

#~ msgid ""
#~ "For any other combination of dimensions this predicate returns false."
#~ msgstr ""
#~ "이 조합이 아닌 다른 차원들의 조합일 경우, 이 함수는 거짓을 반환합니다."

#~ msgid ""
#~ "The OpenGIS Simple Features Specification defines this predicate only for "
#~ "Point/Line, Point/Area, Line/Line, and Line/Area situations. JTS / GEOS "
#~ "extends the definition to apply to Line/Point, Area/Point and Area/Line "
#~ "situations as well. This makes the relation symmetric."
#~ msgstr ""
#~ "OpenGIS 단순 피처 사양서는 포인트/라인, 포인트/면, 라인/라인, 라인/면 조합"
#~ "의 경우에만 이 함수를 정의하고 있습니다. JTS/GEOS는 라인/포인트, 면/포인"
#~ "트, 면/라인 조합 또한 적용되도록 정의를 확장시킵니다. 이렇게 상관 관계가 "
#~ "대칭을 이루었습니다."

#~ msgid "&sfs_compliant; s2.1.13.3"
#~ msgstr "&sfs_compliant; s2.1.13.3"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.29"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.29"

#~ msgid "The following illustrations all return <varname>TRUE</varname>."
#~ msgstr "다음 그림들은 모두 <varname>TRUE</varname> 를 반환합니다."

#~ msgid "<varname>MULTIPOINT</varname> / <varname>LINESTRING</varname>"
#~ msgstr "<varname>MULTIPOINT</varname> / <varname>LINESTRING</varname>"

#~ msgid "<varname>MULTIPOINT</varname> / <varname>POLYGON</varname>"
#~ msgstr "<varname>MULTIPOINT</varname> / <varname>POLYGON</varname>"

#~ msgid "<varname>LINESTRING</varname> / <varname>POLYGON</varname>"
#~ msgstr "<varname>LINESTRING</varname> / <varname>POLYGON</varname>"

#~ msgid "<varname>LINESTRING</varname> / <varname>LINESTRING</varname>"
#~ msgstr "<varname>LINESTRING</varname> / <varname>LINESTRING</varname>"

#~ msgid ""
#~ "Consider a situation where a user has two tables: a table of roads and a "
#~ "table of highways."
#~ msgstr ""
#~ "사용자가 도로 테이블과 고속도로 테이블, 테이블 두 개를 가지고 있는 경우를 "
#~ "상정해봅시다."

#~ msgid ""
#~ "CREATE TABLE roads (\n"
#~ "  id serial NOT NULL,\n"
#~ "  the_geom geometry,\n"
#~ "  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
#~ ");"
#~ msgstr ""
#~ "CREATE TABLE roads (\n"
#~ "  id serial NOT NULL,\n"
#~ "  the_geom geometry,\n"
#~ "  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
#~ ");"

#~ msgid ""
#~ "CREATE TABLE highways (\n"
#~ "  id serial NOT NULL,\n"
#~ "  the_gem geometry,\n"
#~ "  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
#~ ");"
#~ msgstr ""
#~ "CREATE TABLE highways (\n"
#~ "  id serial NOT NULL,\n"
#~ "  the_gem geometry,\n"
#~ "  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
#~ ");"

#~ msgid ""
#~ "To determine a list of roads that cross a highway, use a query similiar "
#~ "to:"
#~ msgstr ""
#~ "고속도로와 교차하는 도로의 목록을 구하려면, 다음과 비슷한 쿼리를 해야 합니"
#~ "다:"

#~ msgid ""
#~ "SELECT roads.id\n"
#~ "FROM roads, highways\n"
#~ "WHERE ST_Crosses(roads.the_geom, highways.the_geom);"
#~ msgstr ""
#~ "SELECT roads.id\n"
#~ "FROM roads, highways\n"
#~ "WHERE ST_Crosses(roads.the_geom, highways.the_geom);"

#~ msgid "ST_LineCrossingDirection"
#~ msgstr "ST_LineCrossingDirection"

#~ msgid ""
#~ "Given 2 linestrings, returns a number between -3 and 3 denoting what kind "
#~ "of crossing behavior. 0 is no crossing."
#~ msgstr ""
#~ "라인스트링 2개를 입력하면, 어떤 형태로 교차하고 있는지를 나타내는 -3에서 "
#~ "3 사이의 숫자를 반환합니다. 0은 교차하지 않음을 뜻합니다."

#~ msgid ""
#~ "<funcdef>integer <function>ST_LineCrossingDirection</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>linestringA</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>linestringB</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>integer <function>ST_LineCrossingDirection</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>linestringA</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>linestringB</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "Given 2 linestrings, returns a number between -3 and 3 denoting what kind "
#~ "of crossing behavior. 0 is no crossing. This is only supported for "
#~ "<varname>LINESTRING</varname>"
#~ msgstr ""
#~ "라인스트링 2개를 입력하면, 어떤 형태로 교차하고 있는지를 나타내는 -3에서 "
#~ "3 사이의 숫자를 반환합니다. 0은 교차하지 않음을 뜻합니다. 이 함수는 "
#~ "<varname>LINESTRING</varname> 만 지원합니다."

#~ msgid "Definition of integer constants is as follows:"
#~ msgstr "정수형 상수의 정의는 다음과 같습니다:"

#~ msgid "0: LINE NO CROSS"
#~ msgstr "0: 라인이 교차하지 않음"

#~ msgid "-1: LINE CROSS LEFT"
#~ msgstr "-1: 라인이 왼쪽 방향으로 교차"

#~ msgid "1: LINE CROSS RIGHT"
#~ msgstr "1: 라인이 오른쪽 방향으로 교차"

#~ msgid "-2: LINE MULTICROSS END LEFT"
#~ msgstr "-2: 라인이 종단점 왼쪽 방향으로 복수교차(multicross)"

#~ msgid "2: LINE MULTICROSS END RIGHT"
#~ msgstr "2: 라인이 종단점 오른쪽 방향으로 복수교차"

#~ msgid "-3: LINE MULTICROSS END SAME FIRST LEFT"
#~ msgstr "-3: 라인이 종단점과 시작점의 동일한 왼쪽 방향으로 복수교차"

#~ msgid "3: LINE MULTICROSS END SAME FIRST RIGHT"
#~ msgstr "3: 라인이 종단점과 시작점의 동일한 오른쪽 방향으로 복수교차"

#~ msgid "Availability: 1.4"
#~ msgstr "1.4.0 버전부터 사용할 수 있습니다."

#~ msgid ""
#~ "Line 1 (green), Line 2 ball is start point, triangle are end points. "
#~ "Query below."
#~ msgstr ""
#~ "라인 1(초록색), 라인 2(파란색)의 둥근점이 시작점이고, 화살표가 종단점입니"
#~ "다. 아래는 쿼리입니다."

#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ "SELECT\n"
#~ " ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ " ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As line2\n"
#~ "        ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           3 |          -3"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ "SELECT\n"
#~ " ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ " ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As line2\n"
#~ "        ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           3 |          -3"

#~ msgid ""
#~ "Line 1 (green), Line 2 (blue) ball is start point, triangle are end "
#~ "points. Query below."
#~ msgstr ""
#~ "라인 1(초록색), 라인 2(파란색)의 둥근점이 시작점이고, 화살표가 종단점입니"
#~ "다. 아래는 쿼리입니다."

#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (171 154, 20 140, 71 74, 2.99 90.16)') As "
#~ "line2\n"
#~ ") As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           2 |          -2"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (171 154, 20 140, 71 74, 2.99 90.16)') As "
#~ "line2\n"
#~ ") As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           2 |          -2"

#~ msgid ""
#~ "SELECT\n"
#~ "        ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "        ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -1 |          1"
#~ msgstr ""
#~ "SELECT\n"
#~ "        ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "        ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -1 |          1"

#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (SELECT\n"
#~ "        ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As "
#~ "line1,\n"
#~ "        ST_GeomFromText('LINESTRING(2.99 90.16,71 74,20 140,171 154)') As "
#~ "line2\n"
#~ "        ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -2 |          2"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (SELECT\n"
#~ "        ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As "
#~ "line1,\n"
#~ "        ST_GeomFromText('LINESTRING(2.99 90.16,71 74,20 140,171 154)') As "
#~ "line2\n"
#~ "        ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -2 |          2"

#~ msgid ""
#~ "SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.the_geom, s2."
#~ "the_geom)\n"
#~ "        FROM streets s1 CROSS JOIN streets s2 ON (s1.gid != s2.gid AND s1."
#~ "the_geom &amp;&amp; s2.the_geom )\n"
#~ "WHERE ST_CrossingDirection(s1.the_geom, s2.the_geom) > 0;"
#~ msgstr ""
#~ "SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.the_geom, s2."
#~ "the_geom)\n"
#~ "        FROM streets s1 CROSS JOIN streets s2 ON (s1.gid != s2.gid AND s1."
#~ "the_geom &amp;&amp; s2.the_geom )\n"
#~ "WHERE ST_CrossingDirection(s1.the_geom, s2.the_geom) > 0;"

#~ msgid "ST_Disjoint"
#~ msgstr "ST_Disjoint"

#~ msgid ""
#~ "Returns TRUE if the Geometries do not \"spatially intersect\" - if they "
#~ "do not share any space together."
#~ msgstr ""
#~ "도형들이 \"공간적으로 교차\"하지 않을 경우 - 어떤 공간도 함께 공유하지 않"
#~ "을 경우 - 참을 반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Disjoint</function></funcdef> <paramdef> "
#~ "<type>geometry</type> <parameter>A</parameter> </paramdef> <paramdef> "
#~ "<type>geometry</type> <parameter>B</parameter> </paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Disjoint</function></funcdef> <paramdef> "
#~ "<type>geometry</type> <parameter>A</parameter> </paramdef> <paramdef> "
#~ "<type>geometry</type> <parameter>B</parameter> </paramdef>"

#~ msgid ""
#~ "Overlaps, Touches, Within all imply geometries are not spatially "
#~ "disjoint. If any of the aforementioned returns true, then the geometries "
#~ "are not spatially disjoint. Disjoint implies false for spatial "
#~ "intersection."
#~ msgstr ""
#~ "겹치기(overlap), 접촉(touch), 범위 내(within) 모두 공간 분리(disjoint)되"
#~ "지 않음을 의미하는 말입니다. 앞에서 언급한 함수들 가운데 어느 하나라도 참"
#~ "을 반환하는 경우, 해당 도형들도 공간적으로 분리되지 않은 겁니다. 도형들이 "
#~ "교차하는 경우, 분리(disjoint) 함수는 거짓을 반환합니다."

#~ msgid "This function call does not use indexes"
#~ msgstr "이 함수 호출은 인덱스를 활용하지 않습니다."

#~ msgid "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - a.Relate(b, 'FF*FF****')"
#~ msgstr "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - a.Relate(b, 'FF*FF****')"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.26"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.26"

#~ msgid ""
#~ "SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_disjoint\n"
#~ "---------------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_disjoint\n"
#~ "---------------\n"
#~ " f\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_disjoint\n"
#~ "---------------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_disjoint\n"
#~ "---------------\n"
#~ " f\n"
#~ "(1 row)"

#~ msgid ""
#~ "<funcprototype> <funcdef>float <function>ST_Distance</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> </"
#~ "funcprototype> <funcprototype> <funcdef>float <function>ST_Distance</"
#~ "function></funcdef> <paramdef><type>geography </type> <parameter>gg1</"
#~ "parameter></paramdef> <paramdef><type>geography </type> <parameter>gg2</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>float "
#~ "<function>ST_Distance</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>gg1</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>gg2</parameter></paramdef> <paramdef><type>boolean </"
#~ "type> <parameter>use_spheroid</parameter></paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>float <function>ST_Distance</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> </"
#~ "funcprototype> <funcprototype> <funcdef>float <function>ST_Distance</"
#~ "function></funcdef> <paramdef><type>geography </type> <parameter>gg1</"
#~ "parameter></paramdef> <paramdef><type>geography </type> <parameter>gg2</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>float "
#~ "<function>ST_Distance</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>gg1</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>gg2</parameter></paramdef> <paramdef><type>boolean </"
#~ "type> <parameter>use_spheroid</parameter></paramdef> </funcprototype>"

#~ msgid "Availability: 1.5.0 - requires GEOS &gt;= 3.2.0"
#~ msgstr ""
#~ "1.5.0 버전부터 사용할 수 있습니다. GEOS 3.2.0 이상 버전이 필요합니다."

#~ msgid ""
#~ "Returns minimum distance in meters between two lon/lat geometries. Uses a "
#~ "spherical earth and radius derived from the spheroid defined by the SRID. "
#~ "Faster than ST_DistanceSpheroid <xref linkend=\"ST_Distance_Spheroid\"/>, "
#~ "but less accurate. PostGIS versions prior to 1.5 only implemented for "
#~ "points."
#~ msgstr ""
#~ "경위도 도형 2개 사이의 최단 거리를 미터 단위로 반환합니다. SRID가 정의하"
#~ "는 회전타원체에서 추출한 반경을 가진 지구 구체를 이용합니다. <xref "
#~ "linkend=\"ST_Distance_Spheroid\"/> 보다는 처리 속도가 빠르지만, 정확도는 "
#~ "떨어집니다. PostGIS 1.5 미만 버전에서는 포인트에 대해서만 구현돼 있었습니"
#~ "다."

#~ msgid "ST_DFullyWithin"
#~ msgstr "ST_DFullyWithin"

#~ msgid ""
#~ "Returns true if all of the geometries are within the specified distance "
#~ "of one another"
#~ msgstr "모든 도형이 서로 설정된 거리 안에 있을 경우 참을 반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_DFullyWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance</parameter></"
#~ "paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_DFullyWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance</parameter></"
#~ "paramdef>"

#~ msgid ""
#~ "Returns true if the geometries is fully within the specified distance of "
#~ "one another. The distance is specified in units defined by the spatial "
#~ "reference system of the geometries. For this function to make sense, the "
#~ "source geometries must both be of the same coordinate projection, having "
#~ "the same SRID."
#~ msgstr ""
#~ "도형들이 완전히 서로의 설정된 거리 내에 있을 경우 참을 반환합니다. 이 거리"
#~ "는 도형들의 공간 참조 시스템이 정의한 단위로 설정됩니다. 이 함수가 제대로 "
#~ "동작하려면, 소스 도형들이 둘 다 동일한 SRID를 가진, 동일한 좌표 투영체여"
#~ "야 합니다."

#~ msgid ""
#~ "postgis=# SELECT ST_DFullyWithin(geom_a, geom_b, 10) as DFullyWithin10, "
#~ "ST_DWithin(geom_a, geom_b, 10) as DWithin10, ST_DFullyWithin(geom_a, "
#~ "geom_b, 20) as DFullyWithin20 from\n"
#~ "                (select ST_GeomFromText('POINT(1 1)') as geom_a,"
#~ "ST_GeomFromText('LINESTRING(1 5, 2 7, 1 9, 14 12)') as geom_b) t1;\n"
#~ "\n"
#~ "-----------------\n"
#~ " DFullyWithin10 | DWithin10 | DFullyWithin20 |\n"
#~ "---------------+----------+---------------+\n"
#~ " f             | t        | t             |"
#~ msgstr ""
#~ "postgis=# SELECT ST_DFullyWithin(geom_a, geom_b, 10) as DFullyWithin10, "
#~ "ST_DWithin(geom_a, geom_b, 10) as DWithin10, ST_DFullyWithin(geom_a, "
#~ "geom_b, 20) as DFullyWithin20 from\n"
#~ "                (select ST_GeomFromText('POINT(1 1)') as geom_a,"
#~ "ST_GeomFromText('LINESTRING(1 5, 2 7, 1 9, 14 12)') as geom_b) t1;\n"
#~ "\n"
#~ "-----------------\n"
#~ " DFullyWithin10 | DWithin10 | DFullyWithin20 |\n"
#~ "---------------+----------+---------------+\n"
#~ " f             | t        | t             |"

#~ msgid ", <xref linkend=\"ST_DWithin\"/>"
#~ msgstr ", <xref linkend=\"ST_DWithin\"/>"

#~ msgid "ST_DWithin"
#~ msgstr "ST_DWithin"

#, fuzzy
#~ msgid ""
#~ "Returns true if the geometries are within the specified distance of one "
#~ "another. For geometry units are in those of spatial reference and for "
#~ "geography units are in meters and measurement is defaulted to "
#~ "use_spheroid=true (measure around spheroid), for faster check, "
#~ "use_spheroid=false to measure along sphere."
#~ msgstr ""
#~ "도형들이 서로 설정된 거리 안에 있을 경우 참을 반환합니다. 도형의 경우 공"
#~ "간 참조의 단위를 쓰고, 지리형의 경우 미터 단위를 씁니다. 또 지리형의 경우 "
#~ "측정시 use_spheroid=true(회전타원체 상에서 측정)가 기본값이며, 더 빨리 검"
#~ "사하려면 구체 상에서 측정하도록 use_spheroid=false로 설정하십시오."

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_of_srid</parameter></paramdef> </funcprototype> "
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geography </type> <parameter>gg1</parameter></"
#~ "paramdef> <paramdef><type>geography </type> <parameter>gg2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_meters</parameter></paramdef> </funcprototype> "
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geography </type> <parameter>gg1</parameter></"
#~ "paramdef> <paramdef><type>geography </type> <parameter>gg2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_meters</parameter></paramdef> <paramdef><type>boolean "
#~ "</type> <parameter>use_spheroid</parameter></paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_of_srid</parameter></paramdef> </funcprototype> "
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geography </type> <parameter>gg1</parameter></"
#~ "paramdef> <paramdef><type>geography </type> <parameter>gg2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_meters</parameter></paramdef> </funcprototype> "
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geography </type> <parameter>gg1</parameter></"
#~ "paramdef> <paramdef><type>geography </type> <parameter>gg2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_meters</parameter></paramdef> <paramdef><type>boolean "
#~ "</type> <parameter>use_spheroid</parameter></paramdef> </funcprototype>"

#~ msgid ""
#~ "Returns true if the geometries are within the specified distance of one "
#~ "another."
#~ msgstr "도형들이 서로 설정된 거리 안에 있을 경우 참을 반환합니다."

#, fuzzy
#~ msgid ""
#~ "For <type>geometry</type>: The distance is specified in units defined by "
#~ "the spatial reference system of the geometries. For this function to make "
#~ "sense, the source geometries must both be of the same coordinate "
#~ "projection, having the same SRID."
#~ msgstr ""
#~ "도형의 경우: 거리는 도형들의 공간 참조 시스템이 정의한 단위로 설정됩니다. "
#~ "이 함수가 제대로 동작하려면, 소스 도형들이 둘 다 동일한 SRID를 가진, 동일"
#~ "한 좌표 투영체여야 합니다."

#, fuzzy
#~ msgid ""
#~ "For <type>geography</type> units are in meters and measurement is "
#~ "defaulted to <varname>use_spheroid</varname>=true, for faster check, "
#~ "<varname>use_spheroid</varname>=false to measure along sphere."
#~ msgstr ""
#~ "지리형의 경우: 미터 단위를 씁니다. 또 측정시 use_spheroid=true(회전타원체 "
#~ "상에서 측정)가 기본값이며, 더 빨리 검사하려면 구체 상에서 측정하도록 "
#~ "use_spheroid=false로 설정합니다."

#~ msgid ""
#~ "Prior to 1.3, ST_Expand was commonly used in conjunction with &amp;&amp; "
#~ "and ST_Distance to achieve the same effect and in pre-1.3.4 this function "
#~ "was basically short-hand for that construct. From 1.3.4, ST_DWithin uses "
#~ "a more short-circuit distance function which should make it more "
#~ "efficient than prior versions for larger buffer regions."
#~ msgstr ""
#~ "1.3 미만 버전에서는, 동일한 효과를 얻기 위해 흔히 ST_Expand함수를 &amp;"
#~ "&amp; 및 ST_Distance와 연결해서 썼습니다. 1.3.4 이전 버전에서 이 함수는 기"
#~ "본적으로 해당 함수 연결의 약칭이었습니다. 1.3.4 버전부터, ST_DWithin 함수"
#~ "는 대용량 버퍼 지역에 대해 이전 버전보다 더 효율적으로 만들어주는 단락"
#~ "(short-circuit) 거리 함수를 더욱 사용하고 있습니다."

#~ msgid "Use ST_3DDWithin if you have 3D geometries."
#~ msgstr "3차원 도형의 경우 ST_3DDWithin 함수를 이용하십시오."

#~ msgid "Availability: 1.5.0 support for geography was introduced"
#~ msgstr "1.5.0 버전부터 지리형을 지원합니다."

#~ msgid ""
#~ "Enhanced: 2.1.0 improved speed for geography. See <ulink url=\"http://"
#~ "blog.opengeo.org/2012/07/12/making-geography-faster/\">Making Geography "
#~ "faster</ulink> for details."
#~ msgstr ""
#~ "개선 사항: 2.1.0 버전부터 지리형에 대한 속도가 향상됐습니다. 자세한 내용"
#~ "은 <ulink url=\"http://blog.opengeo.org/2012/07/12/making-geography-"
#~ "faster/\">Making Geography faster</ulink> 를 참조하십시오."

#~ msgid "Enhanced: 2.1.0 support for curved geometries was introduced."
#~ msgstr "개선 사항: 2.1.0 버전부터 만곡 도형을 지원하기 시작했습니다."

#, fuzzy
#~ msgid ""
#~ "-- Find the nearest hospital to each school\n"
#~ "-- that is within 3000 units of the school.\n"
#~ "--  We do an ST_DWithin search to utilize indexes to limit our search "
#~ "list\n"
#~ "--  that the non-indexable ST_Distance needs to process\n"
#~ "-- If the units of the spatial reference is meters then units would be "
#~ "meters\n"
#~ "SELECT DISTINCT ON (s.gid) s.gid, s.school_name, s.geom, h.hospital_name\n"
#~ "        FROM schools s\n"
#~ "                LEFT JOIN hospitals h ON ST_DWithin(s.the_geom, h.geom, "
#~ "3000)\n"
#~ "        ORDER BY s.gid, ST_Distance(s.geom, h.geom);\n"
#~ "\n"
#~ "-- The schools with no close hospitals\n"
#~ "-- Find all schools with no hospital within 3000 units\n"
#~ "-- away from the school.  Units is in units of spatial ref (e.g. meters, "
#~ "feet, degrees)\n"
#~ "SELECT s.gid, s.school_name\n"
#~ "        FROM schools s\n"
#~ "                LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, "
#~ "3000)\n"
#~ "        WHERE h.gid IS NULL;\n"
#~ "\n"
#~ "-- Find broadcasting towers that receiver with limited range can "
#~ "receive.\n"
#~ "-- Data is geometry in Spherical Mercator (SRID=3857), ranges are "
#~ "approximate.\n"
#~ "\n"
#~ "-- Create geometry index that will check proximity limit of user to "
#~ "tower\n"
#~ "CREATE INDEX ON broadcasting_towers using gist (geom);\n"
#~ "\n"
#~ "-- Create geometry index that will check proximity limit of tower to "
#~ "user\n"
#~ "CREATE INDEX ON broadcasting_towers using gist (ST_Expand(geom, "
#~ "sending_range));\n"
#~ "\n"
#~ "-- Query towers that 4-kilometer receiver in Minsk Hackerspace can get\n"
#~ "-- Note: two conditions, because shorter LEAST(b.sending_range, 4000) "
#~ "will not use index.\n"
#~ "SELECT b.tower_id, b.geom\n"
#~ "  FROM broadcasting_towers b\n"
#~ "  WHERE ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', 4000)\n"
#~ "          AND ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', "
#~ "b.sending_range);"
#~ msgstr ""
#~ "-- 각 학교에서 3,000단위 내에 있는 병원 가운데\n"
#~ "-- 각 학교에서 가장 가까운 병원을 찾습니다.\n"
#~ "-- 인덱스를 활용해서, 인덱스를 사용할 수 없는 ST_Distance가 공간처리해야 "
#~ "하는\n"
#~ "-- 검색 목록을 제한하기 위해 ST_DWithin 검색을 실행합니다.\n"
#~ "-- 공간 참조 시스템의 단위가 미터라면 단위도 미터가 됩니다.\n"
#~ "SELECT DISTINCT ON (s.gid) s.gid, s.school_name, s.the_geom, h."
#~ "hospital_name\n"
#~ "        FROM schools s\n"
#~ "                LEFT JOIN hospitals h ON ST_DWithin(s.the_geom, h."
#~ "the_geom, 3000)\n"
#~ "        ORDER BY s.gid, ST_Distance(s.the_geom, h.the_geom);\n"
#~ "\n"
#~ "-- 가까운 병원이 없는 학교들\n"
#~ "-- 학교에서 3,000단위 내에 병원이 없는 모든 학교를 찾습니다.\n"
#~ "-- 이때 단위는 공간 참조 시스템의 단위입니다(예: 미터, 피트, 도)\n"
#~ "SELECT s.gid, s.school_name\n"
#~ "        FROM schools s\n"
#~ "                LEFT JOIN hospitals h ON ST_DWithin(s.the_geom, h."
#~ "the_geom, 3000)\n"
#~ "        WHERE h.gid IS NULL;"

#, fuzzy
#~ msgid ", <xref linkend=\"ST_Expand\"/>, <xref linkend=\"ST_3DDWithin\"/>"
#~ msgstr ", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Within\"/>"

#~ msgid "ST_Equals"
#~ msgstr "ST_Equals"

#~ msgid ""
#~ "Returns true if the given geometries represent the same geometry. "
#~ "Directionality is ignored."
#~ msgstr ""
#~ "주어진 도형들이 동일한 도형일 경우 참을 반환합니다. 방향성은 무시합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Equals</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Equals</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#~ msgid ""
#~ "Returns TRUE if the given Geometries are \"spatially equal\". Use this "
#~ "for a 'better' answer than '='. Note by spatially equal we mean "
#~ "ST_Within(A,B) = true and ST_Within(B,A) = true and also mean ordering of "
#~ "points can be different but represent the same geometry structure. To "
#~ "verify the order of points is consistent, use ST_OrderingEquals (it must "
#~ "be noted ST_OrderingEquals is a little more stringent than simply "
#~ "verifying order of points are the same)."
#~ msgstr ""
#~ "주어진 도형들이 \"공간적으로 동등\"한 경우 참을 반환합니다. '='보다 '나"
#~ "은' 답을 원한다면 이 함수를 이용하십시오. 공간적으로 동등하다는 것은 "
#~ "ST_Within(A,B) = true 이고 ST_Within(B,A) = true 이며 또 포인트의 정렬 순"
#~ "서는 다를 수 있지만 동일한 도형 구조를 표현한다는 의미입니다. 포인트의 순"
#~ "서가 일관된다는 사실을 검증하려면, ST_OrderingEquals 함수를 이용하십시오"
#~ "(ST_OrderingEquals가 단순히 포인트 순서가 동일한지 검증하는 것보다 조금 "
#~ "더 엄중한 함수라는 점은 언급해야겠군요)."

#~ msgid "Do not call with a GEOMETRYCOLLECTION as an argument."
#~ msgstr "<varname>GEOMETRYCOLLECTION</varname> 을 인수로 호출하지 마십시오."

#~ msgid "&sfs_compliant; s2.1.1.2"
#~ msgstr "&sfs_compliant; s2.1.1.2"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.24"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.24"

#~ msgid ""
#~ "SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_equals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_Equals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_equals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_equals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_Equals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_equals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)"

#~ msgid ""
#~ ", <xref linkend=\"ST_OrderingEquals\"/>, <xref linkend=\"ST_Reverse\"/>, "
#~ "<xref linkend=\"ST_Within\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_OrderingEquals\"/>, <xref linkend=\"ST_Reverse\"/>, "
#~ "<xref linkend=\"ST_Within\"/>"

#~ msgid "ST_GeometricMedian"
#~ msgstr "ST_GeometricMedian"

#~ msgid "Returns the geometric median of a MultiPoint."
#~ msgstr "멀티 포인트의 기하학적 중심값(median)을 반환합니다."

#~ msgid ""
#~ "<funcdef>geometry <function> ST_GeometricMedian </function> </funcdef> "
#~ "<paramdef> <type> geometry </type> <parameter> g </parameter> </paramdef> "
#~ "<paramdef> <type> float8 </type> <parameter> tolerance </parameter> </"
#~ "paramdef> <paramdef> <type> int </type> <parameter> max_iter </parameter> "
#~ "</paramdef> <paramdef> <type> boolean </type> <parameter> "
#~ "fail_if_not_converged </parameter> </paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function> ST_GeometricMedian </function> </funcdef> "
#~ "<paramdef> <type> geometry </type> <parameter> g </parameter> </paramdef> "
#~ "<paramdef> <type> float8 </type> <parameter> tolerance </parameter> </"
#~ "paramdef> <paramdef> <type> int </type> <parameter> max_iter </parameter> "
#~ "</paramdef> <paramdef> <type> boolean </type> <parameter> "
#~ "fail_if_not_converged </parameter> </paramdef>"

#~ msgid "&M_support;"
#~ msgstr "&M_support;"

#~ msgid ""
#~ "Comparison of the centroid (turquoise point) and geometric median (red "
#~ "point) of a four-point MultiPoint (yellow points)."
#~ msgstr ""
#~ "포인트 4개로 이루어진 멀티포인트(노란색 포인트들)의 중심점(청록색 포인트)"
#~ "과 기하학적 중심값(빨간색 포인트)의 비교"

#~ msgid ""
#~ "WITH test AS (\n"
#~ "SELECT 'MULTIPOINT((0 0), (1 1), (2 2), (200 200))'::geometry geom)\n"
#~ "SELECT\n"
#~ "  ST_AsText(ST_Centroid(geom)) centroid,\n"
#~ "  ST_AsText(ST_GeometricMedian(geom)) median\n"
#~ "FROM test;\n"
#~ "      centroid      |                 median\n"
#~ "--------------------+----------------------------------------\n"
#~ " POINT(50.75 50.75) | POINT(1.9761550281255 1.9761550281255)\n"
#~ "(1 row)"
#~ msgstr ""
#~ "WITH test AS (\n"
#~ "SELECT 'MULTIPOINT((0 0), (1 1), (2 2), (200 200))'::geometry geom)\n"
#~ "SELECT\n"
#~ "  ST_AsText(ST_Centroid(geom)) centroid,\n"
#~ "  ST_AsText(ST_GeometricMedian(geom)) median\n"
#~ "FROM test;\n"
#~ "      centroid      |                 median\n"
#~ "--------------------+----------------------------------------\n"
#~ " POINT(50.75 50.75) | POINT(1.9761550281255 1.9761550281255)\n"
#~ "(1 row)"

#~ msgid "ST_HasArc"
#~ msgstr "ST_HasArc"

#~ msgid ""
#~ "<refpurpose>Returns true if a geometry or geometry collection contains a "
#~ "circular string</refpurpose>"
#~ msgstr ""
#~ "<refpurpose>도형 또는 도형 집합이 원호 스트링을 담고 있을 경우 참을 반환합"
#~ "니다.</refpurpose>"

#~ msgid ""
#~ "<funcdef>boolean <function>ST_HasArc</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_HasArc</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"

#~ msgid ""
#~ "<para>Returns true if a geometry or geometry collection contains a "
#~ "circular string</para>"
#~ msgstr ""
#~ "<para>도형 또는 도형 집합이 원호 스트링을 담고 있을 경우 참을 반환합니다."
#~ "</para>"

#~ msgid "Availability: 1.2.3?"
#~ msgstr "1.2.3 버전(?)부터 사용할 수 있습니다."

#~ msgid ""
#~ "SELECT ST_HasArc(ST_Collect('LINESTRING(1 2, 3 4, 5 6)', "
#~ "'CIRCULARSTRING(1 1, 2 3, 4 5, 6 7, 5 6)'));\n"
#~ "                st_hasarc\n"
#~ "                --------\n"
#~ "                t"
#~ msgstr ""
#~ "SELECT ST_HasArc(ST_Collect('LINESTRING(1 2, 3 4, 5 6)', "
#~ "'CIRCULARSTRING(1 1, 2 3, 4 5, 6 7, 5 6)'));\n"
#~ "                st_hasarc\n"
#~ "                --------\n"
#~ "                t"

#~ msgid ", <xref linkend=\"ST_LineToCurve\"/>"
#~ msgstr ", <xref linkend=\"ST_LineToCurve\"/>"

#~ msgid "ST_Intersects"
#~ msgstr "ST_Intersects"

#~ msgid ""
#~ "Returns TRUE if the Geometries/Geography \"spatially intersect in 2D\" - "
#~ "(share any portion of space) and FALSE if they don't (they are Disjoint). "
#~ "For geography -- tolerance is 0.00001 meters (so any points that close "
#~ "are considered to intersect)"
#~ msgstr ""
#~ "도형/지리형이 \"2차원에서 공간적으로 교차\"(공간의 일부라도 공유)할 경우 "
#~ "참을 반환합니다. 그렇지 않을 경우 (도형/지리형이 서로 분리돼 있을 경우) 거"
#~ "짓을 반환합니다. 지리형의 경우 허용 오차가 0.00001미터입니다(따라서 10마이"
#~ "크로미터보다 가까운 포인트들은 교차한다고 여깁니다)."

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Intersects</function></"
#~ "funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
#~ "paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
#~ "<function>ST_Intersects</function></funcdef> <paramdef> <type>geography</"
#~ "type> <parameter>geogA</parameter> </paramdef> <paramdef> "
#~ "<type>geography</type> <parameter>geogB</parameter> </paramdef> </"
#~ "funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Intersects</function></"
#~ "funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
#~ "paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
#~ "<function>ST_Intersects</function></funcdef> <paramdef> <type>geography</"
#~ "type> <parameter>geogA</parameter> </paramdef> <paramdef> "
#~ "<type>geography</type> <parameter>geogB</parameter> </paramdef> </"
#~ "funcprototype>"

#~ msgid ""
#~ "If a geometry or geography shares any portion of space then they "
#~ "intersect. For geography -- tolerance is 0.00001 meters (so any points "
#~ "that are close are considered to intersect)"
#~ msgstr ""
#~ "도형 또는 지리형이 공간의 일부라도 공유할 경우, 교차하는 것입니다. 지리형"
#~ "의 경우 허용 오차가 0.00001미터입니다(따라서 10마이크로미터보다 가까운 포"
#~ "인트들은 교차한다고 여깁니다)."

#~ msgid "Performed by the GEOS module (for geometry), geography is native"
#~ msgstr "GEOS 모듈로 실행(도형에 대해), 지리형은 자체 지원"

#~ msgid "Availability: 1.5 support for geography was introduced."
#~ msgstr "1.5.0 버전부터 지리형을 지원합니다."

#~ msgid ""
#~ "For geography, this function has a distance tolerance of about 0.00001 "
#~ "meters and uses the sphere rather than spheroid calculation."
#~ msgstr ""
#~ "지리형의 경우, 이 함수는 약 0.00001미터의 거리 오차를 허용하며 회전타원체 "
#~ "계산보다는 구체 계산을 이용합니다."

#~ msgid ""
#~ "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - ST_Intersects(g1, g2 ) --&gt; Not "
#~ "(ST_Disjoint(g1, g2 ))"
#~ msgstr ""
#~ "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - ST_Intersects(g1, g2 ) --&gt; Not "
#~ "(ST_Disjoint(g1, g2 ))"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.27"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.27"

#~ msgid ""
#~ "SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_intersects\n"
#~ "---------------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_intersects\n"
#~ "---------------\n"
#~ " t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_intersects\n"
#~ "---------------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_intersects\n"
#~ "---------------\n"
#~ " t\n"
#~ "(1 row)"

#~ msgid ", <xref linkend=\"ST_Disjoint\"/>"
#~ msgstr ", <xref linkend=\"ST_Disjoint\"/>"

#~ msgid ""
#~ "Returns the 2D length of the geometry if it is a LineString or "
#~ "MultiLineString. geometry are in units of spatial reference and geography "
#~ "are in meters (default spheroid)"
#~ msgstr ""
#~ "도형이 라인스트링 또는 멀티라인스트링일 경우 도형의 2차원 길이를 반환합니"
#~ "다. 도형의 단위는 공간 참조 시스템 단위이며 지리형의 단위는 (기본값 회전타"
#~ "원체의) 미터 단위입니다."

#~ msgid ""
#~ "<refpurpose>Returns the 2-dimensional length of the geometry if it is a "
#~ "linestring or multi-linestring. This is an alias for <varname>ST_Length</"
#~ "varname></refpurpose>"
#~ msgstr ""
#~ "<refpurpose>도형이 라인스트링 또는 멀티라인스트링일 경우 도형의 2차원 길이"
#~ "를 반환합니다. 이 함수는 <varname>ST_Length</varname> 와 동일합니다.</"
#~ "refpurpose>"

#~ msgid ""
#~ "Returns the 3-dimensional or 2-dimensional length of the geometry if it "
#~ "is a linestring or multi-linestring."
#~ msgstr ""
#~ "도형이 라인스트링 또는 멀티라인스트링일 경우 도형의 3차원 또는 2차원 길이"
#~ "를 반환합니다."

#~ msgid ""
#~ "Calculates the 2D or 3D length/perimeter of a geometry on an ellipsoid. "
#~ "This is useful if the coordinates of the geometry are in longitude/"
#~ "latitude and a length is desired without reprojection."
#~ msgstr ""
#~ "타원체 상에 있는 도형의 2차원 또는 3차원 길이/둘레를 계산합니다. 이 함수"
#~ "는 도형의 좌표가 경도/위도이며 재투영하지 않고 길이를 얻고 싶을 때 유용합"
#~ "니다."

#~ msgid "ST_Length2D_Spheroid"
#~ msgstr "ST_Length2D_Spheroid"

#~ msgid ""
#~ "Calculates the 2D length/perimeter of a geometry on an ellipsoid. This is "
#~ "useful if the coordinates of the geometry are in longitude/latitude and a "
#~ "length is desired without reprojection."
#~ msgstr ""
#~ "타원체 상에 있는 도형의 2차원 길이/둘레를 계산합니다. 이 함수는 도형의 좌"
#~ "표가 경도/위도이며 재투영하지 않고 길이를 얻고 싶을 때 유용합니다."

#~ msgid ""
#~ "<funcdef>float <function>ST_Length2D_Spheroid</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>a_geometry</parameter></"
#~ "paramdef> <paramdef><type>spheroid </type> <parameter>a_spheroid</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>float <function>ST_Length2D_Spheroid</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>a_geometry</parameter></"
#~ "paramdef> <paramdef><type>spheroid </type> <parameter>a_spheroid</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "Calculates the 2D length/perimeter of a geometry on an ellipsoid. This is "
#~ "useful if the coordinates of the geometry are in longitude/latitude and a "
#~ "length is desired without reprojection. The ellipsoid is a separate "
#~ "database type and can be constructed as follows:"
#~ msgstr ""
#~ "타원체 상에 있는 도형의 2차원 길이/둘레를 계산합니다. 이 함수는 도형의 좌"
#~ "표가 경도/위도이며 재투영하지 않고 길이를 얻고 싶을 때 유용합니다. 이 타원"
#~ "체는 개별적인 데이터베이스 유형으로 다음과 같이 작성할 수 있습니다:"

#~ msgid ""
#~ "This is much like <xref linkend=\"ST_Length_Spheroid\"/> except it will "
#~ "ignore the Z ordinate in calculations."
#~ msgstr ""
#~ "이 함수는 계산 과정에서 Z 좌표를 무시한다는 점을 제외하면 <xref linkend="
#~ "\"ST_Length_Spheroid\"/> 와 거의 비슷합니다."

#~ msgid ""
#~ "SELECT ST_Length2D_Spheroid( geometry_column,\n"
#~ "                          'SPHEROID[\"GRS_1980\",6378137,298.257222101]' )\n"
#~ "                          FROM geometry_table;\n"
#~ "\n"
#~ "SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
#~ "                          FROM (SELECT "
#~ "ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),\n"
#~ "        (-71.05957 42.3589 , -71.061 43))') As the_geom,\n"
#~ "CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As "
#~ "sph_m)  as foo;\n"
#~ "        tot_len      |    len_line1     |    len_line2\n"
#~ "------------------+------------------+------------------\n"
#~ " 85204.5207562955 | 13986.8725229309 | 71217.6482333646\n"
#~ "\n"
#~ " --3D Observe same answer\n"
#~ "SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
#~ "                          FROM (SELECT "
#~ "ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),\n"
#~ "        (-71.05957 42.3589 75, -71.061 43 90))') As the_geom,\n"
#~ "CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As "
#~ "sph_m)  as foo;\n"
#~ "\n"
#~ "        tot_len      |    len_line1     |    len_line2\n"
#~ "------------------+------------------+------------------\n"
#~ " 85204.5207562955 | 13986.8725229309 | 71217.6482333646"
#~ msgstr ""
#~ "SELECT ST_Length2D_Spheroid( geometry_column,\n"
#~ "                          'SPHEROID[\"GRS_1980\",6378137,298.257222101]' )\n"
#~ "                          FROM geometry_table;\n"
#~ "\n"
#~ "SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
#~ "                          FROM (SELECT "
#~ "ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),\n"
#~ "        (-71.05957 42.3589 , -71.061 43))') As the_geom,\n"
#~ "CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As "
#~ "sph_m)  as foo;\n"
#~ "        tot_len      |    len_line1     |    len_line2\n"
#~ "------------------+------------------+------------------\n"
#~ " 85204.5207562955 | 13986.8725229309 | 71217.6482333646\n"
#~ "\n"
#~ "-- 3D도 동일한 답을 관찰할 수 있습니다.\n"
#~ "SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
#~ "                          FROM (SELECT "
#~ "ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),\n"
#~ "        (-71.05957 42.3589 75, -71.061 43 90))') As the_geom,\n"
#~ "CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As "
#~ "sph_m)  as foo;\n"
#~ "\n"
#~ "        tot_len      |    len_line1     |    len_line2\n"
#~ "------------------+------------------+------------------\n"
#~ " 85204.5207562955 | 13986.8725229309 | 71217.6482333646"

#~ msgid ", <xref linkend=\"ST_Length_Spheroid\"/>"
#~ msgstr ", <xref linkend=\"ST_Length_Spheroid\"/>"

#~ msgid ""
#~ "Returns the 2-dimensional longest line points of two geometries. The "
#~ "function will only return the first longest line if more than one, that "
#~ "the function finds. The line returned will always start in g1 and end in "
#~ "g2. The length of the line this function returns will always be the same "
#~ "as st_maxdistance returns for g1 and g2."
#~ msgstr ""
#~ "두 도형 사이의 2차원 최장 라인을 반환합니다. 하나 이상의 최장 라인이 있을 "
#~ "경우, 이 함수는 자신이 찾은 첫 번째 최장 라인만 반환할 것입니다. 반환되는 "
#~ "라인은 항상 g1에서 시작해서 g2에서 끝납니다. 이 함수가 반환하는 라인의 길"
#~ "이는 <xref linkend=\"ST_MaxDistance\"/> 함수가 g1과 g2에 대해 반환하는 길"
#~ "이와 언제나 동일합니다."

#~ msgid "ST_OrderingEquals"
#~ msgstr "ST_OrderingEquals"

#~ msgid ""
#~ "Returns true if the given geometries represent the same geometry and "
#~ "points are in the same directional order."
#~ msgstr ""
#~ "주어진 도형들이 동일한 도형이며 포인트들의 순서가 동일한 방향일 경우 참을 "
#~ "반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_OrderingEquals</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_OrderingEquals</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#~ msgid ""
#~ "ST_OrderingEquals compares two geometries and returns t (TRUE) if the "
#~ "geometries are equal and the coordinates are in the same order; otherwise "
#~ "it returns f (FALSE)."
#~ msgstr ""
#~ "ST_OrderingEquals 함수는 두 도형을 비교해서 도형들이 동일하며 좌표들이 동"
#~ "일한 순서일 경우 t(참)를 반환하고, 그렇지 않을 경우 f(거짓)를 반환합니다."

#~ msgid ""
#~ "This function is implemented as per the ArcSDE SQL specification rather "
#~ "than SQL-MM. http://edndoc.esri.com/arcsde/9.1/sql_api/sqlapi3."
#~ "htm#ST_OrderingEquals"
#~ msgstr ""
#~ "이 함수는 SQL-MM보다는 ArcSDE SQL 사양에 맞춰 구현됐습니다. http://edndoc."
#~ "esri.com/arcsde/9.1/sql_api/sqlapi3.htm#ST_OrderingEquals"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.43"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.43"

#~ msgid ""
#~ "SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_OrderingEquals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 "
#~ "10)')),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " f\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_OrderingEquals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 "
#~ "10)')),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " f\n"
#~ "(1 row)"

#~ msgid ", <xref linkend=\"ST_Reverse\"/>"
#~ msgstr ", <xref linkend=\"ST_Reverse\"/>"

#~ msgid "ST_Overlaps"
#~ msgstr "ST_Overlaps"

#~ msgid ""
#~ "Returns TRUE if the Geometries share space, are of the same dimension, "
#~ "but are not completely contained by each other."
#~ msgstr ""
#~ "도형들이 공간을 공유하고, 동일한 차원이지만, 어느 한 쪽이 다른 쪽을 완전"
#~ "히 담고 있지 않을 경우 참을 반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Overlaps</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Overlaps</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#~ msgid ""
#~ "Returns TRUE if the Geometries \"spatially overlap\". By that we mean "
#~ "they intersect, but one does not completely contain another."
#~ msgstr ""
#~ "도형들이 \"공간적으로 중첩(overlap)\"할 경우 참을 반환합니다. 즉 도형들이 "
#~ "교차하지만, 어느 한 쪽이 다른 쪽을 완전히 담고 있지 않다는 뜻입니다."

#~ msgid "Do not call with a GeometryCollection as an argument"
#~ msgstr "도형 집합을 인수로 호출하지 마십시오."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_Overlaps."
#~ msgstr ""
#~ "이 함수를 호출하면 도형에서 이용할 수 있는 모든 인덱스를 활용하는 경계 상"
#~ "자 비교 작업을 자동적으로 포함하게 됩니다. 인덱스 활용을 피하려면, "
#~ "_ST_Overlaps 함수를 이용하십시오."

#~ msgid "&sfs_compliant; s2.1.1.2 // s2.1.13.3"
#~ msgstr "&sfs_compliant; s2.1.1.2 // s2.1.13.3"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.32"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.32"

#~ msgid "<varname>MULTIPOINT</varname> / <varname>MULTIPOINT</varname>"
#~ msgstr "<varname>MULTIPOINT</varname> / <varname>MULTIPOINT</varname>"

#~ msgid ""
#~ "--a point on a line is contained by the line and is of a lower dimension, "
#~ "and therefore does not overlap the line\n"
#~ "                        nor crosses\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b,\n"
#~ "        ST_Crosses(a,b) As a_crosses_b,\n"
#~ "                ST_Intersects(a, b) As a_intersects_b, ST_Contains(b,a) "
#~ "As b_contains_a\n"
#~ "FROM (SELECT ST_GeomFromText('POINT(1 0.5)') As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "        As foo\n"
#~ "\n"
#~ "a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a\n"
#~ "------------+-------------+----------------+--------------\n"
#~ "f           | f           | t              | t\n"
#~ "\n"
#~ "--a line that is partly contained by circle, but not fully is defined as "
#~ "intersecting and crossing,\n"
#~ "-- but since of different dimension it does not overlap\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b,\n"
#~ "        ST_Intersects(a, b) As a_intersects_b,\n"
#~ "        ST_Contains(a,b) As a_contains_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "        As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | a_contains_b\n"
#~ "-------------+-------------+----------------+--------------\n"
#~ " f           | t           | t              | f\n"
#~ "\n"
#~ " -- a 2-dimensional bent hot dog (aka buffered line string) that "
#~ "intersects a circle,\n"
#~ " --        but is not fully contained by the circle is defined as "
#~ "overlapping since they are of the same dimension,\n"
#~ "--        but it does not cross, because the intersection of the 2 is of "
#~ "the same dimension\n"
#~ "--        as the maximum dimension of the 2\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b, "
#~ "ST_Intersects(a, b) As a_intersects_b,\n"
#~ "ST_Contains(b,a) As b_contains_a,\n"
#~ "ST_Dimension(a) As dim_a, ST_Dimension(b) as dim_b, "
#~ "ST_Dimension(ST_Intersection(a,b)) As dima_intersection_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a,\n"
#~ "        ST_Buffer(ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)'),0.5)  As "
#~ "b)\n"
#~ "        As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a | dim_a | "
#~ "dim_b | dima_intersection_b\n"
#~ "-------------+-------------+----------------+--------------+-------"
#~ "+-------+---------------------\n"
#~ " t           | f           | t              | f            |     2 |     "
#~ "2 |              2"
#~ msgstr ""
#~ "-- 라인 상에 있는 포인트는 라인에 담겨 있으며 라인보다 낮은 차원이기 때문"
#~ "에, 라인과 중첩하거나 교차하지 않습니다.\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b,\n"
#~ "        ST_Crosses(a,b) As a_crosses_b,\n"
#~ "                ST_Intersects(a, b) As a_intersects_b, ST_Contains(b,a) "
#~ "As b_contains_a\n"
#~ "FROM (SELECT ST_GeomFromText('POINT(1 0.5)') As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "        As foo\n"
#~ "\n"
#~ "a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a\n"
#~ "------------+-------------+----------------+--------------\n"
#~ "f           | f           | t              | t\n"
#~ "\n"
#~ "-- 원이 부분적으로 담고 있지만 완전히 담고 있지 않은 라인은 교차한다"
#~ "(intersect) 또는\n"
#~ "-- 가로지른다(cross)고 정의되지만, 차원수가 다르기 때문에 중첩하지는 않습"
#~ "니다.\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b,\n"
#~ "        ST_Intersects(a, b) As a_intersects_b,\n"
#~ "        ST_Contains(a,b) As a_contains_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "        As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | a_contains_b\n"
#~ "-------------+-------------+----------------+--------------\n"
#~ " f           | t           | t              | f\n"
#~ "\n"
#~ "-- 원과 교차하지만 원에 완전히 담겨 있지는 않은, 버퍼가 적용된 2차원 라인"
#~ "스트링은\n"
#~ "-- 두 도형이 동일한 차원이기 때문에 중첩한다고 정의되지만,\n"
#~ "-- 두 도형의 교차점이 두 도형의 최대 차원과 동일한 차원이기 때문에\n"
#~ "-- 가로지른다(cross)고 할 수는 없습니다.\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b, "
#~ "ST_Intersects(a, b) As a_intersects_b,\n"
#~ "ST_Contains(b,a) As b_contains_a,\n"
#~ "ST_Dimension(a) As dim_a, ST_Dimension(b) as dim_b, "
#~ "ST_Dimension(ST_Intersection(a,b)) As dima_intersection_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a,\n"
#~ "        ST_Buffer(ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)'),0.5)  As "
#~ "b)\n"
#~ "        As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a | dim_a | "
#~ "dim_b | dima_intersection_b\n"
#~ "-------------+-------------+----------------+--------------+-------"
#~ "+-------+---------------------\n"
#~ " t           | f           | t              | f            |     2 |     "
#~ "2 |              2"

#~ msgid ""
#~ ", <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Dimension\"/>, <xref "
#~ "linkend=\"ST_Intersects\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Dimension\"/>, <xref "
#~ "linkend=\"ST_Intersects\"/>"

#~ msgid ""
#~ "Return the length measurement of the boundary of an ST_Surface or "
#~ "ST_MultiSurface geometry or geography. (Polygon, MultiPolygon). geometry "
#~ "measurement is in units of spatial reference and geography is in meters."
#~ msgstr ""
#~ "ST_Surface 또는 ST_MultiSurface 도형 또는 지리형(폴리곤, 멀티폴리곤)의 경"
#~ "계선의 길이 측정치를 반환합니다. 도형의 단위는 공간 참조 시스템 단위이며 "
#~ "지리형의 단위는 미터 단위입니다."

#~ msgid ""
#~ "Returns the 2-dimensional perimeter of the geometry, if it is a polygon "
#~ "or multi-polygon. This is currently an alias for ST_Perimeter."
#~ msgstr ""
#~ "도형이 폴리곤 또는 멀티폴리곤일 경우 도형의 2차원 둘레를 반환합니다. 이 함"
#~ "수는 현재 <varname>ST_Perimeter</varname> 와 동일합니다."

#~ msgid ""
#~ "Returns the 3-dimensional perimeter of the geometry, if it is a polygon "
#~ "or multi-polygon."
#~ msgstr ""
#~ "도형이 폴리곤 또는 멀티폴리곤일 경우 도형의 3차원 둘레를 반환합니다."

#~ msgid "ST_PointOnSurface"
#~ msgstr "ST_PointOnSurface"

#~ msgid "Returns a <varname>POINT</varname> guaranteed to lie on the surface."
#~ msgstr "표면에 붙어 있게 될 <varname>POINT</varname> 를 반환합니다."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_PointOnSurface</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_PointOnSurface</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>"

#~ msgid ""
#~ "Returns a <varname>POINT</varname> guaranteed to intersect a surface."
#~ msgstr "표면과 교차하게 될 <varname>POINT</varname> 를 반환합니다."

#~ msgid "&sfs_compliant; s3.2.14.2 // s3.2.18.2"
#~ msgstr "&sfs_compliant; s3.2.14.2 // s3.2.18.2"

#~ msgid ""
#~ "&sqlmm_compliant; SQL-MM 3: 8.1.5, 9.5.6. According to the specs, "
#~ "ST_PointOnSurface works for surface geometries (POLYGONs, MULTIPOLYGONS, "
#~ "CURVED POLYGONS). So PostGIS seems to be extending what the spec allows "
#~ "here. Most databases Oracle,DB II, ESRI SDE seem to only support this "
#~ "function for surfaces. SQL Server 2008 like PostGIS supports for all "
#~ "common geometries."
#~ msgstr ""
#~ "&sqlmm_compliant; SQL-MM 3: 8.1.5, 9.5.6. 사양에 따라, ST_PointOnSurface"
#~ "는 표면을 가진 도형(POLYGONs, MULTIPOLYGONS, CURVED POLYGONS)을 입력받습니"
#~ "다. 따라서 PostGIS가 사양서가 허용한 범위를 확장시키는 것 같습니다. "
#~ "Oracle, DB II, ESRI SDE 등 대부분의 데이터베이스는 표면에 대해서만 이 함수"
#~ "를 지원합니다. SQL Server 2008은, PostGIS처럼, 모든 일반 도형을 지원합니"
#~ "다."

#~ msgid ""
#~ "SELECT ST_AsText(ST_PointOnSurface('POINT(0 5)'::geometry));\n"
#~ " st_astext\n"
#~ "------------\n"
#~ " POINT(0 5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_PointOnSurface('LINESTRING(0 5, 0 10)'::geometry));\n"
#~ " st_astext\n"
#~ "------------\n"
#~ " POINT(0 5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_PointOnSurface('POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))'::"
#~ "geometry));\n"
#~ "   st_astext\n"
#~ "----------------\n"
#~ " POINT(2.5 2.5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsEWKT(ST_PointOnSurface(ST_GeomFromEWKT('LINESTRING(0 5 1, 0 0 "
#~ "1, 0 10 2)')));\n"
#~ "   st_asewkt\n"
#~ "----------------\n"
#~ " POINT(0 0 1)\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_PointOnSurface('POINT(0 5)'::geometry));\n"
#~ " st_astext\n"
#~ "------------\n"
#~ " POINT(0 5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_PointOnSurface('LINESTRING(0 5, 0 10)'::geometry));\n"
#~ " st_astext\n"
#~ "------------\n"
#~ " POINT(0 5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_PointOnSurface('POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))'::"
#~ "geometry));\n"
#~ "   st_astext\n"
#~ "----------------\n"
#~ " POINT(2.5 2.5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsEWKT(ST_PointOnSurface(ST_GeomFromEWKT('LINESTRING(0 5 1, 0 0 "
#~ "1, 0 10 2)')));\n"
#~ "   st_asewkt\n"
#~ "----------------\n"
#~ " POINT(0 0 1)\n"
#~ "(1 row)"

#~ msgid ", <xref linkend=\"ST_Point_Inside_Circle\"/>"
#~ msgstr ", <xref linkend=\"ST_Point_Inside_Circle\"/>"

#~ msgid "ST_Relate"
#~ msgstr "ST_Relate"

#~ msgid ""
#~ "Returns true if this Geometry is spatially related to anotherGeometry, by "
#~ "testing for intersections between the Interior, Boundary and Exterior of "
#~ "the two geometries as specified by the values in the "
#~ "intersectionMatrixPattern. If no intersectionMatrixPattern is passed in, "
#~ "then returns the maximum intersectionMatrixPattern that relates the 2 "
#~ "geometries."
#~ msgstr ""
#~ "도형의 내부 사이의 교차점을 확인해서 한 도형이 다른 도형과 공간 관계가 있"
#~ "을 경우 참을 반환합니다. 두 도형의 경계선 및 외부는 "
#~ "intersectionMatrixPattern 안의 값들로 설정됩니다. "
#~ "intersectionMatrixPattern이 입력되지 않을 경우, 두 도형을 관계시키는 최대 "
#~ "intersectionMatrixPattern을 반환합니다."

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Relate</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "<paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>text "
#~ "<function>ST_Relate</function></funcdef> <paramdef><type>geometry </type> "
#~ "<parameter>geomA</parameter></paramdef> <paramdef><type>geometry </type> "
#~ "<parameter>geomB</parameter></paramdef> </funcprototype> <funcprototype> "
#~ "<funcdef>text <function>ST_Relate</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "<paramdef><type>integer </type> <parameter>BoundaryNodeRule</parameter></"
#~ "paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Relate</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "<paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>text "
#~ "<function>ST_Relate</function></funcdef> <paramdef><type>geometry </type> "
#~ "<parameter>geomA</parameter></paramdef> <paramdef><type>geometry </type> "
#~ "<parameter>geomB</parameter></paramdef> </funcprototype> <funcprototype> "
#~ "<funcdef>text <function>ST_Relate</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "<paramdef><type>integer </type> <parameter>BoundaryNodeRule</parameter></"
#~ "paramdef> </funcprototype>"

#~ msgid ""
#~ "Version 1: Takes geomA, geomB, intersectionMatrix and Returns 1 (TRUE) if "
#~ "this Geometry is spatially related to anotherGeometry, by testing for "
#~ "intersections between the Interior, Boundary and Exterior of the two "
#~ "geometries as specified by the values in the <ulink url=\"http://en."
#~ "wikipedia.org/wiki/DE-9IM\">DE-9IM matrix pattern</ulink>."
#~ msgstr ""
#~ "버전 1: geomA, geomB, intersectionMatrix를 입력받아 도형의 내부 사이의 교"
#~ "차점을 확인해서 한 도형이 다른 도형과 공간 관계가 있을 경우 1(참)을 반환합"
#~ "니다. 두 도형의 경계선 및 외부는 <ulink url=\"http://en.wikipedia.org/"
#~ "wiki/DE-9IM\">DE-9IM 매트릭스 패턴</ulink> 안의 값들로 설정됩니다."

#~ msgid ""
#~ "This is especially useful for testing compound checks of intersection, "
#~ "crosses, etc in one step."
#~ msgstr ""
#~ "이 함수는 교차점, 가로지르기 등 복합(compound) 확인을 한번에 검사하는 데 "
#~ "특히 유용합니다."

#~ msgid ""
#~ "This is the \"allowable\" version that returns a boolean, not an integer. "
#~ "This is defined in OGC spec"
#~ msgstr ""
#~ "이 함수는 정수가 아니라 불값을 반환하는, \"사용할 만한\" 버전입니다. OGC "
#~ "사양서가 함수를 정의하고 있습니다."

#~ msgid ""
#~ "This DOES NOT automagically include an index call. The reason for that is "
#~ "some relationships are anti e.g. Disjoint. If you are using a "
#~ "relationship pattern that requires intersection, then include the &amp;"
#~ "&amp; index call."
#~ msgstr ""
#~ "이 함수는 인덱스 호출을 마술처럼 쉽게 포함하지 않습니다. 그 이유는 몇몇 관"
#~ "계성들이, 예를 들어, 반(反) 분리(disjoint)이기 때문입니다. 사용자가 교차점"
#~ "이 필요한 관계성 패턴을 사용하고 있다면, &amp;&amp; 인덱스 호출을 포함시키"
#~ "십시오."

#~ msgid ""
#~ "Version 2: Takes geomA and geomB and returns the <xref linkend=\"DE-9IM\"/"
#~ ">"
#~ msgstr ""
#~ "버전 2: geomA와 geomB를 입력받아 <xref linkend=\"DE-9IM\"/> 을 반환합니다."

#~ msgid ""
#~ "Version 3: same as version 2, but allows to specify a boundary node rule "
#~ "(1:OGC/MOD2, 2:Endpoint, 3:MultivalentEndpoint, 4:MonovalentEndpoint)"
#~ msgstr ""
#~ "버전 3: 버전 2와 동일하지만, 경계선 노드 규칙(1:OGC/MOD2, 2:Endpoint, 3:"
#~ "MultivalentEndpoint, 4:MonovalentEndpoint)을 설정할 수 있습니다."

#~ msgid "not in OGC spec, but implied. see s2.1.13.2"
#~ msgstr ""
#~ "OGC 사양서에는 없지만, 언급은 돼 있습니다. s2.1.13.2 단원을 참조하십시오."

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.25"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.25"

#~ msgid ""
#~ "Enhanced: 2.0.0 - added support for specifying boundary node rule "
#~ "(requires GEOS &gt;= 3.0)."
#~ msgstr ""
#~ "개선 사항: 2.0.0 버전부터 경계선 노드 규칙(GEOS 3.0 이상 버전 필요)을 설정"
#~ "할 수 있도록 지원합니다."

#~ msgid ""
#~ "--Find all compounds that intersect and not touch a poly (interior "
#~ "intersects)\n"
#~ "SELECT l.* , b.name As poly_name\n"
#~ "        FROM polys As b\n"
#~ "INNER JOIN compounds As l\n"
#~ "ON (p.the_geom &amp;&amp; b.the_geom\n"
#~ "AND ST_Relate(l.the_geom, b.the_geom,'T********'));\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "0FFFFF212\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('LINESTRING(1 2, 3 4)'), "
#~ "ST_GeometryFromText('LINESTRING(5 6, 7 8)'));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "FF1FF0102\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '0FFFFF212');\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "t\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '*FF*FF212');\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "t"
#~ msgstr ""
#~ "-- 서로 교차하지만 내부 교차점들(poly)과 접촉하지는 않는 모든 복합 도형을 "
#~ "찾습니다.\n"
#~ "SELECT l.* , b.name As poly_name\n"
#~ "        FROM polys As b\n"
#~ "INNER JOIN compounds As l\n"
#~ "ON (p.the_geom &amp;&amp; b.the_geom\n"
#~ "AND ST_Relate(l.the_geom, b.the_geom,'T********'));\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "0FFFFF212\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('LINESTRING(1 2, 3 4)'), "
#~ "ST_GeometryFromText('LINESTRING(5 6, 7 8)'));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "FF1FF0102\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '0FFFFF212');\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "t\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '*FF*FF212');\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "t"

#~ msgid ""
#~ ", <xref linkend=\"DE-9IM\"/>, <xref linkend=\"ST_Disjoint\"/>, <xref "
#~ "linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"DE-9IM\"/>, <xref linkend=\"ST_Disjoint\"/>, <xref "
#~ "linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>"

#~ msgid "ST_RelateMatch"
#~ msgstr "ST_RelateMatch"

#~ msgid ""
#~ "Returns true if intersectionMattrixPattern1 implies "
#~ "intersectionMatrixPattern2"
#~ msgstr ""
#~ "intersectionMattrixPattern1이 intersectionMattrixPattern2를 의미할 경우 참"
#~ "을 반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_RelateMatch</function></funcdef> "
#~ "<paramdef><type>text </type> <parameter>intersectionMatrix</parameter></"
#~ "paramdef> <paramdef><type>text </type> "
#~ "<parameter>intersectionMatrixPattern</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_RelateMatch</function></funcdef> "
#~ "<paramdef><type>text </type> <parameter>intersectionMatrix</parameter></"
#~ "paramdef> <paramdef><type>text </type> "
#~ "<parameter>intersectionMatrixPattern</parameter></paramdef>"

#~ msgid ""
#~ "Takes intersectionMatrix and intersectionMatrixPattern and Returns true "
#~ "if the intersectionMatrix satisfies the intersectionMatrixPattern. For "
#~ "more information refer to <xref linkend=\"DE-9IM\"/>."
#~ msgstr ""
#~ "intersectionMatrix와 intersectionMatrixPattern을 입력받아 "
#~ "intersectionMatrix가 intersectionMatrixPattern을 만족할 경우 참을 반환합니"
#~ "다. 자세한 정보는 <xref linkend=\"DE-9IM\"/> 을 참조하십시오."

#~ msgid "Availability: 2.0.0 - requires GEOS &gt;= 3.3.0."
#~ msgstr ""
#~ "2.0.0 버전부터 사용할 수 있습니다. GEOS 3.3.0 이상 버전이 필요합니다."

#~ msgid ""
#~ "SELECT ST_RelateMatch('101202FFF', 'TTTTTTFFF') ;\n"
#~ "-- result --\n"
#~ "t\n"
#~ "--example of common intersection matrix patterns and example matrices\n"
#~ "-- comparing relationships of involving one invalid geometry and ( a line "
#~ "and polygon that intersect at interior and boundary)\n"
#~ "SELECT mat.name, pat.name, ST_RelateMatch(mat.val, pat.val) As satisfied\n"
#~ "    FROM\n"
#~ "        ( VALUES ('Equality', 'T1FF1FFF1'),\n"
#~ "                ('Overlaps', 'T*T***T**'),\n"
#~ "                ('Within', 'T*F**F***'),\n"
#~ "                ('Disjoint', 'FF*FF****') As pat(name,val)\n"
#~ "        CROSS JOIN\n"
#~ "            (        VALUES ('Self intersections (invalid)', "
#~ "'111111111'),\n"
#~ "                    ('IE2_BI1_BB0_BE1_EI1_EE2', 'FF2101102'),\n"
#~ "                    ('IB1_IE1_BB0_BE0_EI2_EI1_EE2', 'F11F00212')\n"
#~ "            ) As mat(name,val);"
#~ msgstr ""
#~ "SELECT ST_RelateMatch('101202FFF', 'TTTTTTFFF') ;\n"
#~ "-- 결과 --\n"
#~ "t\n"
#~ "-- 유효하지 않은 도형 한 개가 관련된 관계성을 비교하는 (내부 및 경계선에"
#~ "서 교차하는 라인과 폴리곤)\n"
#~ "-- 일반 교차점 매트릭스 패턴의 예시와 예시 매트릭스들\n"
#~ "SELECT mat.name, pat.name, ST_RelateMatch(mat.val, pat.val) As satisfied\n"
#~ "    FROM\n"
#~ "        ( VALUES ('Equality', 'T1FF1FFF1'),\n"
#~ "                ('Overlaps', 'T*T***T**'),\n"
#~ "                ('Within', 'T*F**F***'),\n"
#~ "                ('Disjoint', 'FF*FF****') As pat(name,val)\n"
#~ "        CROSS JOIN\n"
#~ "            (        VALUES ('Self intersections (invalid)', "
#~ "'111111111'),\n"
#~ "                    ('IE2_BI1_BB0_BE1_EI1_EE2', 'FF2101102'),\n"
#~ "                    ('IB1_IE1_BB0_BE0_EI2_EI1_EE2', 'F11F00212')\n"
#~ "            ) As mat(name,val);"

#~ msgid ", <xref linkend=\"ST_Relate\"/>"
#~ msgstr ", <xref linkend=\"ST_Relate\"/>"

#~ msgid "ST_Touches"
#~ msgstr "ST_Touches"

#~ msgid ""
#~ "Returns <varname>TRUE</varname> if the geometries have at least one point "
#~ "in common, but their interiors do not intersect."
#~ msgstr ""
#~ "입력 도형들이 최소한 포인트 한 개를 공유하지만, 내부가 교차하지는 않을 경"
#~ "우 <varname>TRUE</varname> 를 반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Touches</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Touches</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#~ msgid ""
#~ "Returns <varname>TRUE</varname> if the only points in common between "
#~ "<parameter>g1</parameter> and <parameter>g2</parameter> lie in the union "
#~ "of the boundaries of <parameter>g1</parameter> and <parameter>g2</"
#~ "parameter>. The <function>ST_Touches</function> relation applies to all "
#~ "Area/Area, Line/Line, Line/Area, Point/Area and Point/Line pairs of "
#~ "relationships, but <emphasis>not</emphasis> to the Point/Point pair."
#~ msgstr ""
#~ "<parameter>g1</parameter> 과 <parameter>g2</parameter> 사이의 포인트만이 "
#~ "<parameter>g1</parameter> 과 <parameter>g2</parameter> 의 경계선들의 합집"
#~ "합 안에 있을 경우 <varname>TRUE</varname> 를 반환합니다. "
#~ "<function>ST_Touches</function> 관계성은 모든 면/면, 선분/선분, 선분/면, "
#~ "점/면 그리고 점/선 쌍에 적용되지만 점/점 쌍에는 적용되지 <emphasis>않습니"
#~ "다</emphasis>."

#~ msgid "In mathematical terms, this predicate is expressed as:"
#~ msgstr "수학적인 관점에서, 이 함수는 다음과 같이 표현됩니다:"

#~ msgid ""
#~ "The allowable DE-9IM Intersection Matrices for the two geometries are:"
#~ msgstr "두 도형에 대해 쓸 수 있는 DE-9IM 교차점 매트릭스는 다음과 같습니다:"

#~ msgid "FT*******"
#~ msgstr "FT*******"

#~ msgid "F**T*****"
#~ msgstr "F**T*****"

#~ msgid "F***T****"
#~ msgstr "F***T****"

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid using an index, use <function>_ST_Touches</function> instead."
#~ msgstr ""
#~ "이 함수를 호출하면 도형에서 이용할 수 있는 모든 인덱스를 활용하는 경계 상"
#~ "자 비교 작업을 자동적으로 포함하게 됩니다. 인덱스 활용을 피하려면, "
#~ "<function>_ST_Touches</function> 함수를 대신 이용하십시오."

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.28"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.28"

#~ msgid ""
#~ "The <function>ST_Touches</function> predicate returns <varname>TRUE</"
#~ "varname> in all the following illustrations."
#~ msgstr ""
#~ "<function>ST_Touches</function> 의 술부는 다음 모든 그림들에서 "
#~ "<varname>TRUE</varname> 를 반환합니다."

#~ msgid ""
#~ "SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(1 1)'::"
#~ "geometry);\n"
#~ " st_touches\n"
#~ "------------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(0 2)'::"
#~ "geometry);\n"
#~ " st_touches\n"
#~ "------------\n"
#~ " t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(1 1)'::"
#~ "geometry);\n"
#~ " st_touches\n"
#~ "------------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(0 2)'::"
#~ "geometry);\n"
#~ " st_touches\n"
#~ "------------\n"
#~ " t\n"
#~ "(1 row)"

#~ msgid "ST_Within"
#~ msgstr "ST_Within"

#~ msgid "Returns true if the geometry A is completely inside geometry B"
#~ msgstr "도형 A 전체가 도형 B 안에 들어갈 경우 참을 반환합니다."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Within</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Within</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#~ msgid ""
#~ "Returns TRUE if geometry A is completely inside geometry B. For this "
#~ "function to make sense, the source geometries must both be of the same "
#~ "coordinate projection, having the same SRID. It is a given that if "
#~ "ST_Within(A,B) is true and ST_Within(B,A) is true, then the two "
#~ "geometries are considered spatially equal."
#~ msgstr ""
#~ "도형 A가 도형 B 안에 완전히 들어 있을 경우 참을 반환합니다. 이 함수가 제대"
#~ "로 동작하려면, 입력 도형들 둘 다 동일한 좌표 투영체, 즉 동일한 SRID를 가져"
#~ "야 합니다. ST_Within(A,B)가 참이고 ST_Contains(B,A)도 참일 경우, 두 도형"
#~ "은 공간적으로 동등하다고 여겨집니다."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_Within."
#~ msgstr ""
#~ "이 함수를 호출하면 도형에서 이용할 수 있는 모든 인덱스를 활용하는 경계 상"
#~ "자 비교 작업을 자동적으로 포함하게 됩니다. 인덱스 활용을 피하려면, "
#~ "<function>_ST_Within</function> 함수를 이용하십시오."

#~ msgid "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*F**F***')"
#~ msgstr "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*F**F***')"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.30"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.30"

#~ msgid ""
#~ "--a circle within a circle\n"
#~ "SELECT ST_Within(smallc,smallc) As smallinsmall,\n"
#~ "        ST_Within(smallc, bigc) As smallinbig,\n"
#~ "        ST_Within(bigc,smallc) As biginsmall,\n"
#~ "        ST_Within(ST_Union(smallc, bigc), bigc) as unioninbig,\n"
#~ "        ST_Within(bigc, ST_Union(smallc, bigc)) as biginunion,\n"
#~ "        ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion\n"
#~ "FROM\n"
#~ "(\n"
#~ "SELECT ST_Buffer(ST_GeomFromText('POINT(50 50)'), 20) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(50 50)'), 40) As bigc) As foo;\n"
#~ "--Result\n"
#~ " smallinsmall | smallinbig | biginsmall | unioninbig | biginunion | "
#~ "bigisunion\n"
#~ "--------------+------------+------------+------------+------------"
#~ "+------------\n"
#~ " t            | t          | f          | t          | t          | t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "-- 원 안에 들어가는 원\n"
#~ "SELECT ST_Within(smallc,smallc) As smallinsmall,\n"
#~ "        ST_Within(smallc, bigc) As smallinbig,\n"
#~ "        ST_Within(bigc,smallc) As biginsmall,\n"
#~ "        ST_Within(ST_Union(smallc, bigc), bigc) as unioninbig,\n"
#~ "        ST_Within(bigc, ST_Union(smallc, bigc)) as biginunion,\n"
#~ "        ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion\n"
#~ "FROM\n"
#~ "(\n"
#~ "SELECT ST_Buffer(ST_GeomFromText('POINT(50 50)'), 20) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(50 50)'), 40) As bigc) As foo;\n"
#~ "-- 결과\n"
#~ " smallinsmall | smallinbig | biginsmall | unioninbig | biginunion | "
#~ "bigisunion\n"
#~ "--------------+------------+------------+------------+------------"
#~ "+------------\n"
#~ " t            | t          | f          | t          | t          | t\n"
#~ "(1 row)"

#~ msgid ", <xref linkend=\"ST_Equals\"/>, <xref linkend=\"ST_IsValid\"/>"
#~ msgstr ", <xref linkend=\"ST_Equals\"/>, <xref linkend=\"ST_IsValid\"/>"

#~ msgid ", <xref linkend=\"ST_Expand\"/>"
#~ msgstr ", <xref linkend=\"ST_Expand\"/>"

#~ msgid ""
#~ "Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument "
#~ "for geometry version. The geography version supports GEOMETRYCOLLECTION "
#~ "since its a thin wrapper around distance implementation."
#~ msgstr ""
#~ "이 함수의 도형 버전에 <varname>GEOMETRYCOLLECTION</varname> 을 인수로 호출"
#~ "하지 마십시오. 지리형 버전은 <varname>GEOMETRYCOLLECTION</varname> 이 거"
#~ "리 구현을 둘러싼 얇은 래퍼(wrapper)이기 때문에 도형 집합을 지원합니다."
