# SOME DESCRIPTIVE TITLE.
#
# Translators:
# BJ Jang <qgis.tr.kr@gmail.com>, 2013
# HANJIN LEE <jinifor@gmail.com>, 2015
# Kwon.Yongchan <ruvyn@naver.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2017-09-19 15:47+0000\n"
"PO-Revision-Date: 2016-07-22 07:09+0000\n"
"Last-Translator: Kwon.Yongchan <ruvyn@naver.com>\n"
"Language-Team: Korean (Korea) (http://www.transifex.com/postgis/postgis/"
"language/ko_KR/)\n"
"Language: ko_KR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. Tag: title
#: using_postgis_dataman.xml:3
#, no-c-format
msgid "Using PostGIS: Data Management and Queries"
msgstr "PostGIS 사용하기: 데이터 관리 및 쿼리"

#. Tag: title
#: using_postgis_dataman.xml:6
#, no-c-format
msgid "GIS Objects"
msgstr "GIS 오브젝트"

#. Tag: para
#: using_postgis_dataman.xml:8
#, no-c-format
msgid ""
"The GIS objects supported by PostGIS are a superset of the \"Simple Features"
"\" defined by the OpenGIS Consortium (OGC). As of version 0.9, PostGIS "
"supports all the objects and functions specified in the OGC \"Simple "
"Features for SQL\" specification."
msgstr ""
"PostGIS가 지원하는 GIS 오브젝트들은 OpenGIS 컨소시엄(OGC)에 의해 정의되는 "
"“simple feature”들의 확장판입니다. 0.9 버전 기준으로, PostGIS는 OGC Simple "
"Features for SQL”에 명시된 모든 오브젝트와 함수들을 지원합니다. "

#. Tag: para
#: using_postgis_dataman.xml:13
#, no-c-format
msgid ""
"PostGIS extends the standard with support for 3DZ,3DM and 4D coordinates."
msgstr "PostGIS e3DZ,3DM와 4D 좌표계 지원과 함께 표준을 확장하였습니다."

#. Tag: title
#: using_postgis_dataman.xml:17
#, no-c-format
msgid "OpenGIS WKB and WKT"
msgstr "OpenGIS WKB 및 WKT"

#. Tag: para
#: using_postgis_dataman.xml:19
#, no-c-format
msgid ""
"The OpenGIS specification defines two standard ways of expressing spatial "
"objects: the Well-Known Text (WKT) form and the Well-Known Binary (WKB) "
"form. Both WKT and WKB include information about the type of the object and "
"the coordinates which form the object."
msgstr ""
"OpenGIS사양서에는 공간 오브젝트들을 나타내는 두 가지 표준 방법이 정의되어 있"
"습니다: Well-Known Text (WKT) 형태와 Well-Known Binary (WKB) 형태. WKT와 WKB "
"모두 오브젝트 타입과 오브젝트를 구성하는 좌표들에 대한 정보를 포함하고 있습니"
"다."

#. Tag: para
#: using_postgis_dataman.xml:24
#, no-c-format
msgid ""
"Examples of the text representations (WKT) of the spatial objects of the "
"features are as follows:"
msgstr ""
"피쳐들의 공간 오브젝트들의 텍스트 문자열표현들(WKT) 의 예들로는 다음과 같은 "
"것들이 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:29
#, no-c-format
msgid "POINT(0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:33
#, no-c-format
msgid "LINESTRING(0 0,1 1,1 2)"
msgstr "LINESTRING(0 0,1 1,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:37
#, no-c-format
msgid "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"
msgstr "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"

#. Tag: para
#: using_postgis_dataman.xml:41
#, no-c-format
msgid "MULTIPOINT((0 0),(1 2))"
msgstr "MULTIPOINT((0 0),(1 2))"

#. Tag: para
#: using_postgis_dataman.xml:45
#, no-c-format
msgid "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"
msgstr "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"

#. Tag: para
#: using_postgis_dataman.xml:49
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"
msgstr ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"

#. Tag: para
#: using_postgis_dataman.xml:54
#, no-c-format
msgid "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"
msgstr "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"

#. Tag: para
#: using_postgis_dataman.xml:58
#, no-c-format
msgid ""
"The OpenGIS specification also requires that the internal storage format of "
"spatial objects include a spatial referencing system identifier (SRID). The "
"SRID is required when creating spatial objects for insertion into the "
"database."
msgstr ""
"OpenGIS 사양서는 공간 객체의 내부 저장 형식이 공간 참조 시스템 식별자(SRID)"
"를 포함하도록 요구합니다. 데이터베이스에 삽입될 공간 객체 생성시 SRID가 필요"
"합니다."

#. Tag: para
#: using_postgis_dataman.xml:63 using_postgis_dataman.xml:151
#, no-c-format
msgid ""
"Input/Output of these formats are available using the following interfaces:"
msgstr "다음과 같은 인터페이스를 이용해서 이 형식을 입력/출력할 수 있습니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:66
#, no-c-format
msgid ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"
msgstr ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"

#. Tag: para
#: using_postgis_dataman.xml:68
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert an OGC spatial "
"object would be:"
msgstr ""
"예를 들어 OGC 공간 객체를 생성하고 삽입하기 위한 유효한 삽입 구문은 다음과 같"
"을 것입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:71
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"

#. Tag: title
#: using_postgis_dataman.xml:75
#, no-c-format
msgid "PostGIS EWKB, EWKT and Canonical Forms"
msgstr "PostGIS EWKB, EWKT 및 기본형"

#. Tag: para
#: using_postgis_dataman.xml:77
#, no-c-format
msgid ""
"OGC formats only support 2d geometries, and the associated SRID is *never* "
"embedded in the input/output representations."
msgstr ""
"OGC 형식은 2D 도형만을 지원하며, 관련 SRID는 입력/출력 표현식에 절대로 내장되"
"지 않습니다."

#. Tag: para
#: using_postgis_dataman.xml:80
#, no-c-format
msgid ""
"PostGIS extended formats are currently superset of OGC one (every valid WKB/"
"WKT is a valid EWKB/EWKT) but this might vary in the future, specifically if "
"OGC comes out with a new format conflicting with our extensions. Thus you "
"SHOULD NOT rely on this feature!"
msgstr ""
"PostGIS는 현재 OGC 형식의 상위 집합인 형식을 확장합니다(유효한 모든 WKB/WKT"
"는 유효한 EWKB/EWKT가 됩니다). 하지만 향후 달라질 수도 있습니다. 특히 OGC가 "
"PostGIS 확장 프로그램과 상충하는 새 형식을 들고 나온다면 말입니다. 그러므로 "
"이 피처에 의존해서는 안 됩니다!"

#. Tag: para
#: using_postgis_dataman.xml:85
#, no-c-format
msgid ""
"PostGIS EWKB/EWKT add 3dm,3dz,4d coordinates support and embedded SRID "
"information."
msgstr ""
"PostGIS EWKB/EWKT에는 3DM, 3DZ 및 4D 좌표 지원과 내장 SRID 정보가 추가됩니다."

#. Tag: para
#: using_postgis_dataman.xml:88
#, fuzzy, no-c-format
msgid ""
"Examples of the text representations (EWKT) of the extended spatial objects "
"of the features are as follows."
msgstr ""
"피쳐들의 공간 오브젝트들의 텍스트 문자열표현들(WKT) 의 예들로는 다음과 같은 "
"것들이 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:93
#, no-c-format
msgid "POINT(0 0 0) -- XYZ"
msgstr "POINT(0 0 0) -- XYZ"

#. Tag: para
#: using_postgis_dataman.xml:97
#, no-c-format
msgid "SRID=32632;POINT(0 0) -- XY with SRID"
msgstr "SRID=32632;POINT(0 0) -- SRID 추가 XY"

#. Tag: para
#: using_postgis_dataman.xml:101
#, no-c-format
msgid "POINTM(0 0 0) -- XYM"
msgstr "POINTM(0 0 0) -- XYM"

#. Tag: para
#: using_postgis_dataman.xml:105
#, no-c-format
msgid "POINT(0 0 0 0) -- XYZM"
msgstr "POINT(0 0 0 0) -- XYZM"

#. Tag: para
#: using_postgis_dataman.xml:109
#, no-c-format
msgid "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"
msgstr "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- SRID 추가 XYM"

#. Tag: para
#: using_postgis_dataman.xml:113
#, no-c-format
msgid "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"
msgstr "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"

#. Tag: para
#: using_postgis_dataman.xml:118
#, no-c-format
msgid ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"
msgstr ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"

#. Tag: para
#: using_postgis_dataman.xml:123
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"
msgstr ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"

#. Tag: para
#: using_postgis_dataman.xml:128
#, no-c-format
msgid "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"
msgstr "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"

#. Tag: para
#: using_postgis_dataman.xml:132
#, no-c-format
msgid "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"
msgstr "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"

#. Tag: para
#: using_postgis_dataman.xml:136
#, no-c-format
msgid ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"
msgstr ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"

#. Tag: para
#: using_postgis_dataman.xml:142
#, no-c-format
msgid "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"
msgstr "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"

#. Tag: para
#: using_postgis_dataman.xml:146
#, no-c-format
msgid "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"
msgstr "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"

#. Tag: programlisting
#: using_postgis_dataman.xml:154
#, no-c-format
msgid ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"
msgstr ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"

#. Tag: para
#: using_postgis_dataman.xml:156
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert a PostGIS spatial "
"object would be:"
msgstr ""
"예를 들어 PostGIS 공간 객체를 생성하고 삽입하기 위한 유효한 삽입 구문은 다음"
"과 같을 것입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:159
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"

#. Tag: para
#: using_postgis_dataman.xml:161
#, no-c-format
msgid ""
"The \"canonical forms\" of a PostgreSQL type are the representations you get "
"with a simple query (without any function call) and the one which is "
"guaranteed to be accepted with a simple insert, update or copy. For the "
"postgis 'geometry' type these are:"
msgstr ""
"PostgreSQL의 \"기본형(canonical form)\"은 (어떤 함수도 호출하지 않는) 단순 쿼"
"리로 얻게 되는 표현식을 뜻하며, 간단한 삽입, 업데이트, 또는 복사 쿼리와 함께 "
"사용할 수 있습니다. PostGIS '도형' 유형의 경우 다음과 같은 기본형을 쓸 수 있"
"습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:164
#, no-c-format
msgid ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"
msgstr ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"

#. Tag: para
#: using_postgis_dataman.xml:166
#, no-c-format
msgid ""
"For example this statement reads EWKT and returns HEXEWKB in the process of "
"canonical ascii input/output:"
msgstr ""
"예를 들어 다음 구문은 EWKT를 읽어들여 기본 ASCII 입력/출력 과정에서 HEXEWKB"
"를 반환합니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:169
#, no-c-format
msgid ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"
msgstr ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"

#. Tag: title
#: using_postgis_dataman.xml:172
#, no-c-format
msgid "SQL-MM Part 3"
msgstr "SQL-MM Part 3"

#. Tag: para
#: using_postgis_dataman.xml:174
#, no-c-format
msgid ""
"The SQL Multimedia Applications Spatial specification extends the simple "
"features for SQL spec by defining a number of circularly interpolated curves."
msgstr ""
"SQL 멀티미디어 응용 프로그램(SQL Multimedia Applications)의 공간 사양서는 일"
"련의 원호 보간 곡선(circularly interpolated curve) 을 정의해서 SQL 사양에 대"
"응하는 단순 피처를 확장합니다."

#. Tag: para
#: using_postgis_dataman.xml:178
#, no-c-format
msgid ""
"The SQL-MM definitions include 3dm, 3dz and 4d coordinates, but do not allow "
"the embedding of SRID information."
msgstr ""
"SQL-MM 정의는 3DM, 3DZ 및 4D 좌표를 포함하지만 SRID 정보를 내장할 수는 없습니"
"다."

#. Tag: para
#: using_postgis_dataman.xml:181
#, no-c-format
msgid ""
"The well-known text extensions are not yet fully supported. Examples of some "
"simple curved geometries are shown below:"
msgstr ""
"아직 WKT 확장 프로그램을 완전히 지원하지는 않습니다. 다음은 단순 곡선 도형의 "
"일부 예시입니다."

#. Tag: para
#: using_postgis_dataman.xml:186
#, no-c-format
msgid "CIRCULARSTRING(0 0, 1 1, 1 0)"
msgstr "CIRCULARSTRING(0 0, 1 1, 1 0)"

#. Tag: para
#: using_postgis_dataman.xml:187
#, no-c-format
msgid "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"
msgstr "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"

#. Tag: para
#: using_postgis_dataman.xml:188
#, fuzzy, no-c-format
msgid ""
"The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the "
"linear world. A single segment required three points, the start and end "
"points (first and third) and any other point on the arc. The exception to "
"this is for a closed circle, where the start and end points are the same. In "
"this case the second point MUST be the center of the arc, ie the opposite "
"side of the circle. To chain arcs together, the last point of the previous "
"arc becomes the first point of the next arc, just like in LINESTRING. This "
"means that a valid circular string must have an odd number of points greater "
"than 1."
msgstr ""
"CIRCULARSTRING은 기본 곡선 유형으로, 선형계의 LINESTRING과 비슷합니다. 단일 "
"분절에는 시작점과 종단점(첫 번째 및 세 번째) 그리고 곡선 위의 다른 한 점 이렇"
"게 포인트 세 개가 필요합니다. 예외는 닫힌 원으로, 이 경우 시작점과 종단점이 "
"동일합니다. 이 경우 두 번째 포인트는 원호의 중심, 즉 원의 반대편이 되어야만 "
"합니다. 원호를 함께 묶으려면, LINESTRING과 마찬가지로 한 원호의 마지막 포인트"
"가 다음 원호의 첫 번째 포인트가 되어야 합니다. 즉 유효한 원형 스트링은 1을 초"
"과하는 홀수 개수의 포인트들을 가져야만 한다는 뜻입니다."

#. Tag: para
#: using_postgis_dataman.xml:201
#, no-c-format
msgid "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"
msgstr "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"

#. Tag: para
#: using_postgis_dataman.xml:202
#, no-c-format
msgid ""
"A compound curve is a single, continuous curve that has both curved "
"(circular) segments and linear segments. That means that in addition to "
"having well-formed components, the end point of every component (except the "
"last) must be coincident with the start point of the following component."
msgstr ""
"복심곡선(compound curve)이란 곡선(원호) 분절과 선형 분절이 함께 있는 연속적"
"인 단일 곡선을 말합니다. 즉 구성 요소들이 잘 형성되어야 함은 물론, (마지막을 "
"제외한) 모든 구성 요소의 종단점이 다음 구성 요소의 시작점과 일치해야한 한다"
"는 뜻입니다."

#. Tag: para
#: using_postgis_dataman.xml:210
#, no-c-format
msgid ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"
msgstr ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"

#. Tag: para
#: using_postgis_dataman.xml:212
#, no-c-format
msgid ""
"Example compound curve in a curve polygon: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"
msgstr ""
"만곡 폴리곤 내부의 복심곡선의 예: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"

#. Tag: para
#: using_postgis_dataman.xml:216
#, no-c-format
msgid ""
"A CURVEPOLYGON is just like a polygon, with an outer ring and zero or more "
"inner rings. The difference is that a ring can take the form of a circular "
"string, linear string or compound string."
msgstr ""
"CURVEPOLYGON은 일반 폴리곤입니다. 외곽선과 함께 0개 이상의 내곽선을 가지고 있"
"을 뿐입니다. 차이라면 내외곽선이 원형 스트링, 선형 스트링, 또는 복합 스트링 "
"형태를 할 수 있다는 점입니다."

#. Tag: para
#: using_postgis_dataman.xml:220
#, no-c-format
msgid "As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon."
msgstr "PostGIS는 1.4버전부터 만곡 폴리곤에 대해 복심곡선을 지원합니다."

#. Tag: para
#: using_postgis_dataman.xml:224
#, no-c-format
msgid "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"
msgstr "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"

#. Tag: para
#: using_postgis_dataman.xml:225
#, no-c-format
msgid ""
"The MULTICURVE is a collection of curves, which can include linear strings, "
"circular strings or compound strings."
msgstr ""
"MULTICURVE는 원형 스트링, 선형 스트링, 복합 스트링을 포함할 수 있는 곡선 집합"
"입니다."

#. Tag: para
#: using_postgis_dataman.xml:230
#, no-c-format
msgid ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"
msgstr ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"

#. Tag: para
#: using_postgis_dataman.xml:233
#, no-c-format
msgid ""
"This is a collection of surfaces, which can be (linear) polygons or curve "
"polygons."
msgstr ""
"MULTISURFACE는 면 집합으로, (선형) 폴리곤일 수도 만곡 폴리곤일 수도 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:239
#, no-c-format
msgid ""
"PostGIS prior to 1.4 does not support compound curves in a curve polygon, "
"but PostGIS 1.4 and above do support the use of Compound Curves in a Curve "
"Polygon."
msgstr ""
"PostGIS 1.4 이전 버전은 만곡 폴리곤 안에서 복심곡선을 지원하지 않았지만, 1.4 "
"버전 이후로 만곡 폴리곤 안에서 복심곡선을 지원하고 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:245
#, no-c-format
msgid ""
"All floating point comparisons within the SQL-MM implementation are "
"performed to a specified tolerance, currently 1E-8."
msgstr ""
"SQL-MM 실행 과정에서 지정된 허용 오차를 기준으로 부동소수점을 비교합니다. 현"
"재 허용 오차는 1E-8입니다."

#. Tag: title
#: using_postgis_dataman.xml:251
#, no-c-format
msgid "PostGIS Geography Type"
msgstr "PostGIS 지리형 유형"

#. Tag: para
#: using_postgis_dataman.xml:253
#, no-c-format
msgid ""
"The geography type provides native support for spatial features represented "
"on \"geographic\" coordinates (sometimes called \"geodetic\" coordinates, or "
"\"lat/lon\", or \"lon/lat\"). Geographic coordinates are spherical "
"coordinates expressed in angular units (degrees)."
msgstr ""
"지리형 유형은 (종종 \"측지\" 좌표, 또는 \"위도/경도\"나 \"경도/위도\"라고 불"
"리는) \"지리\" 좌표로 표현되는 공간 피처를 자체적으로 지원합니다. 지리 좌표"
"는 각도 단위(도)를 사용하는 구면(球面) 좌표입니다."

#. Tag: para
#: using_postgis_dataman.xml:255
#, no-c-format
msgid ""
"The basis for the PostGIS geometry type is a plane. The shortest path "
"between two points on the plane is a straight line. That means calculations "
"on geometries (areas, distances, lengths, intersections, etc) can be "
"calculated using cartesian mathematics and straight line vectors."
msgstr ""
"PostGIS 도형 유형은 평면을 기반으로 합니다. 평면상에서 두 포인트 사이의 가장 "
"짧은 경로는 직선입니다. 즉 데카르트 수학과 직선 벡터를 이용해서 도형에 대해 "
"계산(면적, 거리, 길이, 교차점 등)한다는 뜻입니다."

#. Tag: para
#: using_postgis_dataman.xml:257
#, no-c-format
msgid ""
"The basis for the PostGIS geographic type is a sphere. The shortest path "
"between two points on the sphere is a great circle arc. That means that "
"calculations on geographies (areas, distances, lengths, intersections, etc) "
"must be calculated on the sphere, using more complicated mathematics. For "
"more accurate measurements, the calculations must take the actual spheroidal "
"shape of the world into account, and the mathematics becomes very "
"complicated indeed."
msgstr ""
"PostGIS 지리형 유형은 구면을 기반으로 합니다. 구면상에서 두 포인트 사이의 가"
"장 짧은 경로는 대권(大圈; great circle arc)입니다. 즉 지리형에 대한 계산(면"
"적, 거리, 길이, 교차점 등)은 더 복잡한 수학을 이용해서 구면상에서 이루어져야 "
"한다는 뜻입니다. 더 정확하게 측정하려면 지구의 실제 회전타원체(spheroidal "
"shape)를 고려해서 계산해야 하는데, 수학이 아주 복잡해질 수밖에 없습니다."

#. Tag: para
#: using_postgis_dataman.xml:259
#, no-c-format
msgid ""
"Because the underlying mathematics is much more complicated, there are fewer "
"functions defined for the geography type than for the geometry type. Over "
"time, as new algorithms are added, the capabilities of the geography type "
"will expand."
msgstr ""
"기저 수학이 훨씬 더 복잡하기 때문에, 지리형 유형을 위해 정의된 함수는 도형 유"
"형의 함수보다 더 적습니다. 시간이 지날수록 새 알고리즘이 추가되어 지리형 유형"
"의 역량은 확장될 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:262
#, no-c-format
msgid ""
"One restriction is that it only supports WGS 84 long lat (SRID:4326). It "
"uses a new data type called geography. None of the GEOS functions support "
"this new type. As a workaround one can convert back and forth between "
"geometry and geography types."
msgstr ""
"한 가지 제약 사항이 있다면 지리형이 WGS84 경위도 좌표계(SRID:4326)만 지원한다"
"는 점입니다. 이 새 유형을 지원하는 GEOS 함수는 하나도 없습니다. 이 문제를 해"
"결하려면 도형과 지리형 유형을 번갈아 가며 변환할 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:266
#, no-c-format
msgid ""
"The new geography type uses the PostgreSQL 8.3+ typmod definition format so "
"that a table with a geography field can be added in a single step. All the "
"standard OGC formats except for curves are supported."
msgstr ""
"이 새로운 지리형 유형은 PostgreSQL 8.3 이상 버전의 typmod 정의 형식을 이용하"
"므로 지리형 필드를 담은 테이블을 한번에 추가시킬 수 있습니다. 곡선을 제외한 "
"모든 표준 OGC 형식을 지원합니다."

#. Tag: title
#: using_postgis_dataman.xml:270
#, no-c-format
msgid "Geography Basics"
msgstr "지리형의 기초"

#. Tag: para
#: using_postgis_dataman.xml:271
#, no-c-format
msgid ""
"The geography type only supports the simplest of simple features. Standard "
"geometry type data will autocast to geography if it is of SRID 4326. You can "
"also use the EWKT and EWKB conventions to insert data."
msgstr ""
"지리형 유형은 단순 피처 중에서도 가장 단순한 것만 지원합니다. 표준 도형 유형 "
"데이터는, SRID 4326인 경우, 지리형으로 자동 변환됩니다. 또한 데이터를 삽입하"
"는 데 EWKT 및 EWKB 규약을 이용할 수도 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:276
#, no-c-format
msgid "POINT: Creating a table with 2d point geometry:"
msgstr "POINT: 2D 포인트 도형을 담은 테이블 생성:"

#. Tag: programlisting
#: using_postgis_dataman.xml:277
#, no-c-format
msgid ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINT,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:278
#, no-c-format
msgid "Creating a table with z coordinate point"
msgstr "Z좌표 포인트를 담은 테이블 생성:"

#. Tag: programlisting
#: using_postgis_dataman.xml:279
#, no-c-format
msgid ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINTZ,4326) );"
msgstr ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINTZ,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:282
#, no-c-format
msgid "LINESTRING"
msgstr "LINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:285
#, no-c-format
msgid "POLYGON"
msgstr "POLYGON"

#. Tag: para
#: using_postgis_dataman.xml:288
#, no-c-format
msgid "MULTIPOINT"
msgstr "MULTIPOINT"

#. Tag: para
#: using_postgis_dataman.xml:291
#, no-c-format
msgid "MULTILINESTRING"
msgstr "MULTILINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:294
#, no-c-format
msgid "MULTIPOLYGON"
msgstr "MULTIPOLYGON"

#. Tag: para
#: using_postgis_dataman.xml:297
#, no-c-format
msgid "GEOMETRYCOLLECTION"
msgstr "GEOMETRYCOLLECTION"

#. Tag: para
#: using_postgis_dataman.xml:301
#, no-c-format
msgid ""
"The new geography fields don't get registered in the "
"<varname>geometry_columns</varname>. They get registered in a new view "
"called geography_columns which is a view against the system catalogs so is "
"always automatically kept up to date without need for an AddGeom... like "
"function."
msgstr ""
"새 지리형 필드는 <varname>geometry_columns</varname>에 등록되지 않습니다. "
"geography_columns라는 새로운 뷰에 등록되는데, 이 뷰는 시스템 카탈로그를 기반"
"으로 하기 때문에 AddGeom을 사용할 필요없이 자동적으로 항상 최신 상태를 유지합"
"니다. 마치 함수처럼 말이죠."

#. Tag: para
#: using_postgis_dataman.xml:305
#, no-c-format
msgid ""
"Now, check the \"geography_columns\" view and see that your table is listed."
msgstr ""
"그러면 \"geography_columns\" 뷰를 확인해서 사용자 테이블이 목록에 추가됐는지 "
"살펴보십시오."

#. Tag: para
#: using_postgis_dataman.xml:307
#, no-c-format
msgid ""
"You can create a new table with a GEOGRAPHY column using the CREATE TABLE "
"syntax. Unlike GEOMETRY, there is no need to run a separate "
"AddGeometryColumns() process to register the column in metadata."
msgstr ""
"CREATE TABLE 문법을 이용해서 지리형(GEOGRAPHY) 열을 가진 새 테이블을 생성할 "
"수 있습니다. 도형(GEOMETRY)과는 달리, 메타데이터에 해당 열을 등록하기 위해 별"
"도로 AddGeometryColumns() 함수를 실행할 필요가 없습니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:311
#, no-c-format
msgid ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"
msgstr ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"

#. Tag: para
#: using_postgis_dataman.xml:314
#, no-c-format
msgid ""
"Note that the location column has type GEOGRAPHY and that geography type "
"supports two optional modifier: a type modifier that restricts the kind of "
"shapes and dimensions allowed in the column; an SRID modifier that restricts "
"the coordinate reference identifier to a particular number."
msgstr ""
"location 열이 지리형 유형인데, 지리형 유형은 두 가지 선택적인 변경자"
"(modifier)를 지원한다는 사실을 주의하십시오. 열에 들어갈 수 있는 형태 및 차"
"원 종류를 제한하는 유형 변경자, 그리고 좌표 참조 식별자를 특정 숫자로 제한하"
"는 SRID 변경자입니다."

#. Tag: para
#: using_postgis_dataman.xml:315
#, no-c-format
msgid ""
"Allowable values for the type modifier are: POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. The modifier also supports "
"dimensionality restrictions through suffixes: Z, M and ZM. So, for example a "
"modifier of 'LINESTRINGM' would only allow line strings with three "
"dimensions in, and would treat the third dimension as a measure. Similarly, "
"'POINTZM' would expect four dimensional data."
msgstr ""
"유형 변경자가 허용하는 값은 다음과 같습니다. POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. 또 이 변경자는 Z, M 및 ZM이라는 접"
"미사를 통해 차원수 제약도 지원합니다. 따라서, 예를 들자면 'LINESTRINGM'의 변"
"경자는 3차원 이하의 라인 스트링만을 허용할 것이며, 세 번째 차원을 기준으로 취"
"급할 것입니다. 마찬가지로 'POINTZM'은 네 가지 차원의 데이터를 입력해야 할 것"
"입니다."

#. Tag: para
#: using_postgis_dataman.xml:317
#, no-c-format
msgid ""
"The SRID modifier is currently of limited use: only 4326 (WGS84) is allowed "
"as a value. If you do not specify an SRID, the a value 0 (undefined "
"spheroid) will be used, and all calculations will proceed using WGS84 "
"anyways."
msgstr ""
"SRID 변경자는 현재 제한적으로 사용됩니다. 허용되는 값이 4326(WGS84)뿐입니다. "
"SRID를 지정하지 않을 경우 0값(정의되지 않은 회전타원체)을 사용하는데, 이와 상"
"관없이 WGS84를 이용해서 계산이 이루어질 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:318
#, no-c-format
msgid ""
"In the future, alternate SRIDs will allow calculations on spheroids other "
"than WGS84."
msgstr ""
"향후 WGS84만이 아니라 다른 회전타원체 상에서도 계산할 수 있게 될 겁니다."

#. Tag: para
#: using_postgis_dataman.xml:319
#, no-c-format
msgid ""
"Once you have created your table, you can see it in the GEOGRAPHY_COLUMNS "
"table:"
msgstr ""
"사용자 테이블 생성을 완료했다면, GEOGRAPHY_COLUMNS 테이블에서 사용자 테이블"
"을 살펴볼 수 있습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:320
#, no-c-format
msgid ""
"-- See the contents of the metadata view\n"
"SELECT * FROM geography_columns;"
msgstr ""
"-- 메타데이터 뷰의 내용을 살펴봅시다\n"
"SELECT * FROM geography_columns;"

#. Tag: para
#: using_postgis_dataman.xml:322
#, no-c-format
msgid ""
"You can insert data into the table the same as you would if it was using a "
"GEOMETRY column:"
msgstr ""
"도형 열을 사용하는 경우와 동일한 방법으로 테이블에 데이터를 삽입할 수 있습니"
"다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:324
#, no-c-format
msgid ""
"-- Add some data into the test table\n"
"INSERT INTO global_points (name, location) VALUES ('Town', "
"ST_GeographyFromText('SRID=4326;POINT(-110 30)') );\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', "
"ST_GeographyFromText('SRID=4326;POINT(-109 29)') );\n"
"INSERT INTO global_points (name, location) VALUES ('London', "
"ST_GeographyFromText('SRID=4326;POINT(0 49)') );"
msgstr ""
"-- 테스트용 테이블에 데이터를 추가해봅시다\n"
"INSERT INTO global_points (name, location) VALUES ('Town', "
"ST_GeographyFromText('SRID=4326;POINT(-110 30)') );\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', "
"ST_GeographyFromText('SRID=4326;POINT(-109 29)') );\n"
"INSERT INTO global_points (name, location) VALUES ('London', "
"ST_GeographyFromText('SRID=4326;POINT(0 49)') );"

#. Tag: para
#: using_postgis_dataman.xml:326
#, no-c-format
msgid ""
"Creating an index works the same as GEOMETRY. PostGIS will note that the "
"column type is GEOGRAPHY and create an appropriate sphere-based index "
"instead of the usual planar index used for GEOMETRY."
msgstr ""
"도형과 동일한 방법으로 인덱스를 생성합니다. PostGIS가 열 유형이 지리형인 것"
"을 감지하고 일반적인 도형 용 평면 인덱스 대신 적절한 구면 기반 인덱스를 생성"
"할 것입니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:329
#, no-c-format
msgid ""
"-- Index the test table with a spherical index\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"
msgstr ""
"-- 테스트 테이블에 구면 인덱스 생성\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"

#. Tag: para
#: using_postgis_dataman.xml:332
#, no-c-format
msgid ""
"Query and measurement functions use units of meters. So distance parameters "
"should be expressed in meters, and return values should be expected in "
"meters (or square meters for areas)."
msgstr ""
"쿼리 및 측정 함수는 미터 단위를 사용합니다. 따라서 거리 파라미터는 미터로 표"
"현되어야 하고, 반환값도 미터(또는 면적의 경우 평방미터) 단위가 될 것입니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:334
#, no-c-format
msgid ""
"-- Show a distance query and note, London is outside the 1000km tolerance\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, "
"ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);"
msgstr ""
"-- 다음은 거리 쿼리입니다. 주의: 런던이 허용 범위 1000km 밖에 있습니다\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, "
"ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);"

#. Tag: para
#: using_postgis_dataman.xml:337
#, no-c-format
msgid ""
"You can see the power of GEOGRAPHY in action by calculating the how close a "
"plane flying from Seattle to London (LINESTRING(-122.33 47.606, 0.0 51.5)) "
"comes to Reykjavik (POINT(-21.96 64.15))."
msgstr ""
"시애틀에서 런던으로 가는 비행기가(LINESTRING(-122.33 47.606, 0.0 51.5)) 레이"
"캬비크에(POINT(-21.96 64.15)) 얼마나 접근하는지 계산해보면, 실제 계산시 지리"
"형이 얼마나 강력한지 알 수 있습니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:339
#, no-c-format
msgid ""
"-- Distance calculation using GEOGRAPHY (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)':: geography);"
msgstr ""
"-- 지리형을 이용한 거리 계산(122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)':: geography);"

#. Tag: programlisting
#: using_postgis_dataman.xml:342
#, no-c-format
msgid ""
"-- Distance calculation using GEOMETRY (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)':: geometry);"
msgstr ""
"-- 도형을 이용한 거리 계산(13.3\"도\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)':: geometry);"

#. Tag: para
#: using_postgis_dataman.xml:345
#, no-c-format
msgid ""
"The GEOGRAPHY type calculates the true shortest distance over the sphere "
"between Reykjavik and the great circle flight path between Seattle and "
"London."
msgstr ""
"지리형 유형이 시애틀과 런던을 잇는 대권항로와 레이캬비크 사이의 구면 상 가장 "
"짧은 거리를 실제로 계산할 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:347
#, no-c-format
msgid ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> The GEOMETRY type calculates a meaningless cartesian distance "
"between Reykjavik and the straight line path from Seattle to London plotted "
"on a flat map of the world. The nominal units of the result might be called "
"\"degrees\", but the result doesn't correspond to any true angular "
"difference between the points, so even calling them \"degrees\" is "
"inaccurate."
msgstr ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">대권 매퍼(Great "
"Circle mapper)</ulink> 도형 유형은 평면 세계지도 상에서 시애틀과 런던을 직선"
"으로 잇는 경로와 레이캬비크 사이의 아무 의미도 없는 데카르트 거리를 계산합니"
"다. 결과값의 명목상 단위를 \"도(degree)\"라고 할 수도 있겠지만, 결과값은 세 "
"포인트 사이의 어떤 실제 각도 차이도 반영하지 않기 때문에 \"도\"라고 하는 것조"
"차 부정확한 일이 됩니다."

#. Tag: title
#: using_postgis_dataman.xml:351
#, no-c-format
msgid "When to use Geography Data type over Geometry data type"
msgstr "도형 데이터 유형과 지리형 데이터 유형을 중첩해서 이용하는 경우"

#. Tag: para
#: using_postgis_dataman.xml:352
#, no-c-format
msgid ""
"The new GEOGRAPHY type allows you to store data in longitude/latitude "
"coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY "
"than there are on GEOMETRY; those functions that are defined take more CPU "
"time to execute."
msgstr ""
"새로운 지리형 유형은 데이터를 경도/위도 좌표로 저장할 수 있도록 해주지만, 단"
"점도 있습니다. 도형을 대상으로 정의된 함수보다 지리형 대상 함수가 더 적고, "
"그 정의된 함수도 실행하는 데 CPU 시간을 더 많이 잡아먹습니다."

#. Tag: para
#: using_postgis_dataman.xml:353
#, no-c-format
msgid ""
"The type you choose should be conditioned on the expected working area of "
"the application you are building. Will your data span the globe or a large "
"continental area, or is it local to a state, county or municipality?"
msgstr ""
"사용자가 선택한 유형은 사용자가 빌드하는 응용 프로그램 영역에서 기대한대로 동"
"작하도록 적합한 조건을 갖춰야 합니다. 사용자 데이터가 전세계 또는 광대한 대"
"륙 지역을 포괄할 예정입니까 아니면 시, 도, 군 또는 그 이하의 지자체에 국한될 "
"예정입니까?"

#. Tag: para
#: using_postgis_dataman.xml:355
#, no-c-format
msgid ""
"If your data is contained in a small area, you might find that choosing an "
"appropriate projection and using GEOMETRY is the best solution, in terms of "
"performance and functionality available."
msgstr ""
"사용자 데이터가 좁은 지역에 국한된다면, 사용 가능한 실행성 및 기능성 관점에"
"서, 적합한 투영을 선택하고 도형을 이용하는 것이 최선의 해결책이 될 수도 있습"
"니다."

#. Tag: para
#: using_postgis_dataman.xml:356
#, no-c-format
msgid ""
"If your data is global or covers a continental region, you may find that "
"GEOGRAPHY allows you to build a system without having to worry about "
"projection details. You store your data in longitude/latitude, and use the "
"functions that have been defined on GEOGRAPHY."
msgstr ""
"사용자 데이터가 전세계 또는 대륙에 걸쳐 있을 경우, 지리형을 이용하면 일일이 "
"어떤 투영법을 이용할지 고민하지 않고 시스템을 빌드할 수도 있습니다. 사용자 데"
"이터를 경도/위도로 저장하고, 지리형을 대상으로 정의된 함수를 이용하십시오."

#. Tag: para
#: using_postgis_dataman.xml:358
#, no-c-format
msgid ""
"If you don't understand projections, and you don't want to learn about them, "
"and you're prepared to accept the limitations in functionality available in "
"GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. "
"Simply load your data up as longitude/latitude and go from there."
msgstr ""
"투영에 대한 이해가 부족하고, 따로 공부하고 싶지도 않으며, 지리형 사용시 기능"
"성이 제한된다는 사실을 받아들일 준비가 되어 있다면, 도형보다 지리형을 사용하"
"는 편이 더 쉬울 수 있습니다. 그냥 사용자 데이터를 경도/위도로 로드한 다음 작"
"업을 시작하십시오."

#. Tag: para
#: using_postgis_dataman.xml:361
#, no-c-format
msgid ""
"Refer to <xref linkend=\"PostGIS_TypeFunctionMatrix\"/> for compare between "
"what is supported for Geography vs. Geometry. For a brief listing and "
"description of Geography functions, refer to <xref linkend="
"\"PostGIS_GeographyFunctions\"/>"
msgstr ""
"지리형과 도형을 각각 지원하는 함수를 비교해보려면 <xref linkend="
"\"PostGIS_TypeFunctionMatrix\"/> 를 참조하십시오. 지리형 함수의 목록 및 설명"
"을 간단하게 살펴보려면 <xref linkend=\"PostGIS_GeographyFunctions\"/> 를 참조"
"하십시오."

#. Tag: title
#: using_postgis_dataman.xml:367
#, no-c-format
msgid "Geography Advanced FAQ"
msgstr "지리형 고급 FAQ"

#. Tag: para
#: using_postgis_dataman.xml:371
#, no-c-format
msgid "Do you calculate on the sphere or the spheroid?"
msgstr "계산 작업시 구체 상에서 계산하게 됩니까 회전타원체 상에서 하게 됩니까?"

#. Tag: para
#: using_postgis_dataman.xml:375
#, no-c-format
msgid ""
"By default, all distance and area calculations are done on the spheroid. You "
"should find that the results of calculations in local areas match up will "
"with local planar results in good local projections. Over larger areas, the "
"spheroidal calculations will be more accurate than any calculation done on a "
"projected plane."
msgstr ""
"기본적으로, 모든 거리 및 면적 계산은 회전타원체 상에서 이루어집니다. 좁은 지"
"역을 대상으로 한 계산의 결과와 해당 지역에 적절한 투영법을 적용한 평면 상 계"
"산 결과는 일치할 것입니다. 더 넓은 지역이라면 투영법을 적용한 평면 상 계산보"
"다 회전타원체 상 계산이 언제나 더 정확할 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:378
#, no-c-format
msgid ""
"All the geography functions have the option of using a sphere calculation, "
"by setting a final boolean parameter to 'FALSE'. This will somewhat speed up "
"calculations, particularly for cases where the geometries are very simple."
msgstr ""
"최종 불 파라미터 'FALSE'를 설정하면 모든 지리형 함수가 구체 상 계산을 할 수 "
"있습니다. 이렇게 하면 계산 속도가 조금 빨라질 것입니다. 특히 도형들이 매우 단"
"순한 경우에 말입니다."

#. Tag: para
#: using_postgis_dataman.xml:384
#, no-c-format
msgid "What about the date-line and the poles?"
msgstr "날짜변경선과 남극/북극은 어떻습니까?"

#. Tag: para
#: using_postgis_dataman.xml:388
#, no-c-format
msgid ""
"All the calculations have no conception of date-line or poles, the "
"coordinates are spherical (longitude/latitude) so a shape that crosses the "
"dateline is, from a calculation point of view, no different from any other "
"shape."
msgstr ""
"모든 계산은 날짜변경선이나 양극을 고려하지 않고 이루어집니다. 좌표가 회전타원"
"체(경도/위도)이기 때문에 날짜변경선을 지나는 형상이라도, 계산이라는 관점에서 "
"보면, 다른 어떤 형상과도 다를 바가 없습니다."

#. Tag: para
#: using_postgis_dataman.xml:396
#, no-c-format
msgid "What is the longest arc you can process?"
msgstr "공간 처리할 수 있는 가장 긴 원호가 무엇인가요?"

#. Tag: para
#: using_postgis_dataman.xml:400
#, no-c-format
msgid ""
"We use great circle arcs as the \"interpolation line\" between two points. "
"That means any two points are actually joined up two ways, depending on "
"which direction you travel along the great circle. All our code assumes that "
"the points are joined by the *shorter* of the two paths along the great "
"circle. As a consequence, shapes that have arcs of more than 180 degrees "
"will not be correctly modelled."
msgstr ""
"두 포인트 사이의 \"보간 라인\"으로 대권호(great circle arc)를 이용합니다. 즉 "
"대권을 따라 어느 방향으로 이동하느냐에 따라 두 포인트가 실제로는 두 가지 방식"
"으로 만난다는 뜻입니다. 모든 코드는 포인트들이 대권을 따라 가는 두 경로 가운"
"데 '짧은' 경로로 만난다고 가정합니다. 결과적으로, 180도 이상의 원호를 가진다"
"면 정확히 모델링된 형상이 아니게 됩니다."

#. Tag: para
#: using_postgis_dataman.xml:407
#, no-c-format
msgid ""
"Why is it so slow to calculate the area of Europe / Russia / insert big "
"geographic region here ?"
msgstr ""
"유럽이나 러시아의 면적을 계산하거나 또는 광대한 지역을 삽입하는 작업이 이렇"
"게 느린 이유가 뭐지요?"

#. Tag: para
#: using_postgis_dataman.xml:411
#, no-c-format
msgid ""
"Because the polygon is so darned huge! Big areas are bad for two reasons: "
"their bounds are huge, so the index tends to pull the feature no matter what "
"query you run; the number of vertices is huge, and tests (distance, "
"containment) have to traverse the vertex list at least once and sometimes N "
"times (with N being the number of vertices in the other candidate feature)."
msgstr ""
"폴리곤이 너무나 크기 때문이지요! 광대한 지역은 두 가지 이유로 좋지 않습니다. "
"먼저 경계가 워낙 길기 때문에 어떤 쿼리를 실행하든 인덱스가 피처 전체를 읽어오"
"는 경향이 있습니다. 그리고 꼭짓점 개수도 너무 많아서 거리, 밀폐 여부 등의 테"
"스트를 할 때 적어도 한 번, 때로는 n번 이상(이때 n은 다른 후보 피처의 꼭짓점 "
"개수) 꼭짓점 목록 전체를 훑어야 하기 때문입니다."

#. Tag: para
#: using_postgis_dataman.xml:416
#, no-c-format
msgid ""
"As with GEOMETRY, we recommend that when you have very large polygons, but "
"are doing queries in small areas, you \"denormalize\" your geometric data "
"into smaller chunks so that the index can effectively subquery parts of the "
"object and so queries don't have to pull out the whole object every time. "
"Just because you *can* store all of Europe in one polygon doesn't mean you "
"*should*."
msgstr ""
"도형의 경우, 대용량 폴리곤을 대상으로 좁은 지역에 대한 쿼리를 할 때 사용자 도"
"형 데이터를 더 작은 덩어리들로 \"비정규화\"해서 인덱스가 효율적으로 객체의 일"
"부분을 하위 쿼리(subquery)할 수 있도록 만들어 쿼리 시 매번 전체 객체를 읽어"
"올 필요가 없도록 하는 편이 좋습니다. 유럽 전체를 폴리곤 한 개로 저장할 수 있"
"다고 해서 꼭 그렇게 해야 한다는 뜻은 아닙니다."

#. Tag: title
#: using_postgis_dataman.xml:425
#, no-c-format
msgid "Using OpenGIS Standards"
msgstr "OpenGIS 표준 이용"

#. Tag: para
#: using_postgis_dataman.xml:427
#, no-c-format
msgid ""
"The OpenGIS \"Simple Features Specification for SQL\" defines standard GIS "
"object types, the functions required to manipulate them, and a set of meta-"
"data tables. In order to ensure that meta-data remain consistent, operations "
"such as creating and removing a spatial column are carried out through "
"special procedures defined by OpenGIS."
msgstr ""
"OpenGIS의 \"SQL 용 단순 피처 사양서(Simple Features Specification for "
"SQL)\"는 표준 GIS 객체 유형, 그 유형들을 다루기 위해 필요한 함수, 그리고 메타"
"데이터 테이블의 집합을 정의합니다. 메타데이터의 일관성을 유지하기 위해 공간 "
"열 생성 및 삭제와 같은 작업은 OpenGIS가 정의한 특별한 과정을 거쳐 이루어집니"
"다."

#. Tag: para
#: using_postgis_dataman.xml:433
#, no-c-format
msgid ""
"There are two OpenGIS meta-data tables: <varname>SPATIAL_REF_SYS</varname> "
"and <varname>GEOMETRY_COLUMNS</varname>. The <varname>SPATIAL_REF_SYS</"
"varname> table holds the numeric IDs and textual descriptions of coordinate "
"systems used in the spatial database."
msgstr ""
"OpenGIS 메타데이터 테이블이 두 개 있습니다. <varname>SPATIAL_REF_SYS</"
"varname> 와 <varname>GEOMETRY_COLUMNS</varname> 입니다. "
"<varname>SPATIAL_REF_SYS</varname> 테이블은 공간 데이터베이스가 사용하는 좌표"
"계의 숫자 ID 및 텍스트 설명을 담습니다."

#. Tag: title
#: using_postgis_dataman.xml:440
#, no-c-format
msgid "The SPATIAL_REF_SYS Table and Spatial Reference Systems"
msgstr "SPATIAL_REF_SYS 테이블과 공간 참조 시스템"

#. Tag: para
#: using_postgis_dataman.xml:442
#, no-c-format
msgid ""
"The spatial_ref_sys table is a PostGIS included and OGC compliant database "
"table that lists over 3000 known <ulink url=\"http://www.sharpgis.net/"
"post/2007/05/Spatial-references2c-coordinate-systems2c-projections2c-"
"datums2c-ellipsoids-e28093-confusing.aspx\">spatial reference systems</"
"ulink> and details needed to transform/reproject between them."
msgstr ""
"<varname>SPATIAL_REF_SYS</varname> 테이블은 OGC를 따르는 PostGIS에 내장된 테"
"이블로, 공간 참조 시스템을 서로 변환/재투영하는 데 필요한 <ulink url="
"\"http://www.sharpgis.net/post/2007/05/Spatial-references2c-coordinate-"
"systems2c-projections2c-datums2c-ellipsoids-e28093-confusing.aspx\">공간 참"
"조 시스템(spatial reference systems)</ulink> 3000여 개의 목록 및 상세 정보를 "
"가지고 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:446
#, no-c-format
msgid ""
"Although the PostGIS spatial_ref_sys table contains over 3000 of the more "
"commonly used spatial reference system definitions that can be handled by "
"the proj library, it does not contain all known to man and you can even "
"define your own custom projection if you are familiar with proj4 constructs. "
"Keep in mind that most spatial reference systems are regional and have no "
"meaning when used outside of the bounds they were intended for."
msgstr ""
"PostGIS의 <varname>SPATIAL_REF_SYS</varname> 테이블이 proj 라이브러리가 처리"
"할 수 있는, 좀 더 널리 사용되는 공간 참조 시스템 3000여 개를 담고 있긴 하지"
"만 현재까지 알려진 모든 공간 참조 시스템을 다 담고 있지는 않으며, 사용자가 "
"proj4의 구조를 잘 알고 있다면 자기만의 사용자 지정 투영을 정의할 수도 있습니"
"다. 공간 참조 시스템 대부분은 특정 지역에 특화되어 있으며, 특화된 지역 범위 "
"바깥에서 사용할 경우 어떤 의미도 없다는 점을 명심하십시오."

#. Tag: para
#: using_postgis_dataman.xml:449
#, no-c-format
msgid ""
"An excellent resource for finding spatial reference systems not defined in "
"the core set is <ulink url=\"http://spatialreference.org/\">http://"
"spatialreference.org/</ulink>"
msgstr ""
"핵심 <varname>SPATIAL_REF_SYS</varname> 테이블에 정의되지 않은 공간 참조 시스"
"템은 <ulink url=\"http://spatialreference.org/\">http://spatialreference.org/"
"</ulink> 에 훌륭하게 정리되어 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:451
#, no-c-format
msgid ""
"Some of the more commonly used spatial reference systems are: <ulink url="
"\"http://spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD "
"83 Long Lat</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/"
"\">3395 - WGS 84 World Mercator</ulink>, <ulink url=\"http://"
"spatialreference.org/ref/epsg/2163/\">2163 - US National Atlas Equal Area</"
"ulink>, Spatial reference systems for each NAD 83, WGS 84 UTM zone - UTM "
"zones are one of the most ideal for measurement, but only cover 6-degree "
"regions."
msgstr ""
"좀 더 널리 사용되는 공간 참조 시스템에는 <ulink url=\"http://"
"spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</ulink>, <ulink "
"url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD 83 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/\">3395 - WGS "
"84 World Mercator</ulink>, <ulink url=\"http://spatialreference.org/ref/"
"epsg/2163/\">2163 - US National Atlas Equal Area</ulink>, 그리고 NAD 83 및 "
"WGS 84 UTM 대(帶; zone)의 공간 참조 시스템이 있습니다. 각 UTM 대는 측정에 가"
"장 이상적인 공간 참조 시스템이지만, 6도 범위의 지역에만 특화되어 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:457
#, no-c-format
msgid ""
"Various US state plane spatial reference systems (meter or feet based) - "
"usually one or 2 exists per US state. Most of the meter ones are in the core "
"set, but many of the feet based ones or ESRI created ones you will need to "
"pull from <ulink url=\"http://spatialreference.org\">spatialreference.org</"
"ulink>."
msgstr ""
"미국 여러 주의 평면 공간 참조 시스템(미터 또는 피트 기반)은 각 주마다 보통 "
"한 개 또는 두 개가 존재합니다. 미터 기반 공간 참조 시스템 대부분은 "
"<varname>SPATIAL_REF_SYS</varname> 테이블에 들어 있지만, 피트 기반 또는 ESRI"
"가 생성한 공간 참조 시스템 중 상당수는 사용자가 <ulink url=\"http://"
"spatialreference.org\">spatialreference.org</ulink> 에서 찾아와야 합니다."

#. Tag: para
#: using_postgis_dataman.xml:461
#, no-c-format
msgid ""
"For details on determining which UTM zone to use for your area of interest, "
"check out the <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
"UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper function</"
"ulink>."
msgstr ""
"사용자 관심 지역에 어떤 UTM 대를 사용할지 결정하는 데에 대한 자세한 정보는 "
"<ulink url=\"http://trac.osgeo.org/postgis/wiki/"
"UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper function</"
"ulink> 를 확인해보십시오."

#. Tag: para
#: using_postgis_dataman.xml:465
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> table definition is as follows:"
msgstr "<varname>SPATIAL_REF_SYS</varname> 테이블 정의는 다음과 같습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:468
#, no-c-format
msgid ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"
msgstr ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"

#. Tag: para
#: using_postgis_dataman.xml:470
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> columns are as follows:"
msgstr "<varname>SPATIAL_REF_SYS</varname> 테이블의 열들은 다음과 같습니다:"

#. Tag: ulink
#: using_postgis_dataman.xml:475
#, no-c-format
msgid "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"
msgstr "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:478
#, no-c-format
msgid ""
"An integer value that uniquely identifies the Spatial Referencing System "
"(SRS) within the database."
msgstr ""
"데이터베이스 내부에서 공간 참조 시스템(SRS)을 고유하게 식별하는 정수값입니다."

#. Tag: term
#: using_postgis_dataman.xml:484
#, no-c-format
msgid "AUTH_NAME"
msgstr "AUTH_NAME"

#. Tag: para
#: using_postgis_dataman.xml:487
#, no-c-format
msgid ""
"The name of the standard or standards body that is being cited for this "
"reference system. For example, \"EPSG\" would be a valid <varname>AUTH_NAME</"
"varname>."
msgstr ""
"해당 참조 시스템을 위해 인용되는 표준 또는 표준들 본체의 명칭입니다. 예를 들"
"어 \"EPSG\"는 유효한 <varname>AUTH_NAME</varname> 이라고 할 수 있습니다."

#. Tag: term
#: using_postgis_dataman.xml:494
#, no-c-format
msgid "AUTH_SRID"
msgstr "AUTH_SRID"

#. Tag: para
#: using_postgis_dataman.xml:497
#, no-c-format
msgid ""
"The ID of the Spatial Reference System as defined by the Authority cited in "
"the <varname>AUTH_NAME</varname>. In the case of EPSG, this is where the "
"EPSG projection code would go."
msgstr ""
"<varname>AUTH_NAME</varname> 에 인용된 권위체(Authority)가 정의하는 공간 참"
"조 시스템의 ID입니다. EPSG의 경우, 이 열에 EPSG 투영 코드가 들어갑니다."

#. Tag: term
#: using_postgis_dataman.xml:504
#, no-c-format
msgid "SRTEXT"
msgstr "SRTEXT"

#. Tag: para
#: using_postgis_dataman.xml:507
#, no-c-format
msgid ""
"The Well-Known Text representation of the Spatial Reference System. An "
"example of a WKT SRS representation is:"
msgstr ""
"공간 참조 시스템의 WKT(Well-Known Text) 표현식입니다. 다음은 WKT SRS 표현식"
"의 예입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:510
#, no-c-format
msgid ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"
msgstr ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"

#. Tag: para
#: using_postgis_dataman.xml:512
#, no-c-format
msgid ""
"For a listing of EPSG projection codes and their corresponding WKT "
"representations, see <ulink url=\"http://www.opengeospatial.org/\">http://"
"www.opengeospatial.org/</ulink>. For a discussion of WKT in general, see the "
"OpenGIS \"Coordinate Transformation Services Implementation Specification\" "
"at <ulink url=\"http://www.opengeospatial.org/standards\">http://www."
"opengeospatial.org/standards</ulink>. For information on the European "
"Petroleum Survey Group (EPSG) and their database of spatial reference "
"systems, see <ulink url=\"http://www.epsg.org/\">http://www.epsg.org</ulink>."
msgstr ""
"EPSG 투영 코드 및 이에 대응하는 WKT 표현식 목록은 <ulink url=\"http://www."
"opengeospatial.org/\">http://www.opengeospatial.org/</ulink> 를  살펴보십시"
"오. WKT에 대한 개괄적인 논의는 <ulink url=\"http://www.opengeospatial.org/"
"standards\">http://www.opengeospatial.org/standards</ulink> 에 있는 OpenGIS"
"의 \"좌표 변환 서비스 시행 사양서(Coordinate Transformation Services "
"Implementation Specification)\"를 살펴보십시오. EPSG(European Petroleum "
"Survey Group) 및 EPSG의 공간 참조 시스템 데이터베이스에 대한 정보는 <ulink "
"url=\"http://www.epsg.org/\">http://www.epsg.org</ulink> 를 살펴보십시오."

#. Tag: term
#: using_postgis_dataman.xml:525
#, no-c-format
msgid "PROJ4TEXT"
msgstr "PROJ4TEXT"

#. Tag: para
#: using_postgis_dataman.xml:528
#, no-c-format
msgid ""
"PostGIS uses the Proj4 library to provide coordinate transformation "
"capabilities. The <varname>PROJ4TEXT</varname> column contains the Proj4 "
"coordinate definition string for a particular SRID. For example:"
msgstr ""
"PostGIS는 좌표 변환 기능을 제공하기 위해 proj4 라이브러리를 이용합니다. "
"<varname>PROJ4TEXT</varname> 열이 특정 SRID에 대응하는 proj4 좌펴 정의 스트링"
"을 담고 있습니다. 다음은 그 예입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:533
#, no-c-format
msgid "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"
msgstr "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"

#. Tag: para
#: using_postgis_dataman.xml:535
#, no-c-format
msgid ""
"For more information about, see the Proj4 web site at <ulink url=\"http://"
"trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. The "
"<filename>spatial_ref_sys.sql</filename> file contains both <varname>SRTEXT</"
"varname> and <varname>PROJ4TEXT</varname> definitions for all EPSG "
"projections."
msgstr ""
"이에 대한 자세한 정보는 <ulink url=\"http://trac.osgeo.org/proj/\">http://"
"trac.osgeo.org/proj/</ulink> 주소의 proj4 웹사이트를 참조하십시오. "
"<filename>spatial_ref_sys.sql</filename> 파일이 모든 EPSG 투영에 대한 "
"<varname>SRTEXT</varname> 및 <varname>PROJ4TEXT</varname> 정의를 담고 있습니"
"다."

#. Tag: title
#: using_postgis_dataman.xml:546
#, no-c-format
msgid "The GEOMETRY_COLUMNS VIEW"
msgstr "The GEOMETRY_COLUMNS VIEW"

#. Tag: para
#: using_postgis_dataman.xml:548
#, no-c-format
msgid ""
"In versions of PostGIS prior to 2.0.0, geometry_columns was a table that "
"could be directly edited, and sometimes got out of synch with the actual "
"definition of the geometry columns. In PostGIS 2.0.0, "
"<varname>GEOMETRY_COLUMNS</varname> became a view with the same front-facing "
"structure as prior versions, but reading from database system catalogs Its "
"structure is as follows:"
msgstr ""
"PostGIS 2.0.0 미만 버전에서는 geometry_columns를 직접 편집할 수 있어서 종종 "
"도형 열의 실제 정의와 달라질 때도 있었습니다. PostGIS 2.0.0 버전부터 "
"<varname>GEOMETRY_COLUMNS</varname> 가 이전 버전과 동일한 전향(前向; front-"
"facing) 구조이지만 데이터베이스 시스템 카탈로그를 읽어오는 뷰가 되었습니다. "
"그 구조는 다음과 같습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:552
#, no-c-format
msgid "\\d geometry_columns"
msgstr "\\d geometry_columns"

#. Tag: screen
#: using_postgis_dataman.xml:553
#, no-c-format
msgid ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"
msgstr ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"

#. Tag: para
#: using_postgis_dataman.xml:555
#, no-c-format
msgid "The column meanings have not changed from prior versions and are:"
msgstr "열의 의미는 이전 버전과 달라지지 않았습니다:"

#. Tag: term
#: using_postgis_dataman.xml:559
#, no-c-format
msgid "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"
msgstr "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"

#. Tag: para
#: using_postgis_dataman.xml:562
#, no-c-format
msgid ""
"The fully qualified name of the feature table containing the geometry "
"column. Note that the terms \"catalog\" and \"schema\" are Oracle-ish. There "
"is not PostgreSQL analogue of \"catalog\" so that column is left blank -- "
"for \"schema\" the PostgreSQL schema name is used (<varname>public</varname> "
"is the default)."
msgstr ""
"도형 열을 담고 있는 피처 테이블의 조건을 완전히 만족하는 명칭입니다. \"카탈로"
"그\"와 \"스키마\"가 오라클 용어라는 점을 주목하십시오. \"카탈로그\"를 대체하"
"는 PostgreSQL 용어가 없기 때문에 해당 열은 공백으로 남게 됩니다. \"스키마"
"\"의 경우 PostgreSQL 스키마 명칭이 사용됩니다(기본값은 <varname>public</"
"varname> 입니다)."

#. Tag: term
#: using_postgis_dataman.xml:571
#, no-c-format
msgid "F_GEOMETRY_COLUMN"
msgstr "F_GEOMETRY_COLUMN"

#. Tag: para
#: using_postgis_dataman.xml:574
#, no-c-format
msgid "The name of the geometry column in the feature table."
msgstr "피처 테이블이 담고 있는 도형 열의 명칭입니다."

#. Tag: term
#: using_postgis_dataman.xml:579
#, no-c-format
msgid "COORD_DIMENSION"
msgstr "COORD_DIMENSION"

#. Tag: para
#: using_postgis_dataman.xml:582
#, no-c-format
msgid "The spatial dimension (2, 3 or 4 dimensional) of the column."
msgstr "열의 공간 차원(2, 3, 또는 4차원)입니다."

#. Tag: term
#: using_postgis_dataman.xml:588
#, no-c-format
msgid "<term>SRID</term>"
msgstr "<term>SRID</term>"

#. Tag: para
#: using_postgis_dataman.xml:591
#, no-c-format
msgid ""
"The ID of the spatial reference system used for the coordinate geometry in "
"this table. It is a foreign key reference to the <varname>SPATIAL_REF_SYS</"
"varname>."
msgstr ""
"해당 테이블이 담고 있는 도형의 좌표가 사용하는 공간 좌표 시스템의 ID로, "
"<varname>SPATIAL_REF_SYS</varname> 를 참조하는 외래 키(foreign key)입니다."

#. Tag: term
#: using_postgis_dataman.xml:598
#, no-c-format
msgid "TYPE"
msgstr "TYPE"

#. Tag: para
#: using_postgis_dataman.xml:601
#, no-c-format
msgid ""
"The type of the spatial object. To restrict the spatial column to a single "
"type, use one of: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, "
"MULTIPOLYGON, GEOMETRYCOLLECTION or corresponding XYM versions POINTM, "
"LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, "
"GEOMETRYCOLLECTIONM. For heterogeneous (mixed-type) collections, you can use "
"\"GEOMETRY\" as the type."
msgstr ""
"공간 객체의 유형입니다. 공간 열을 단일 유형으로 제약하려면 다음 유형 가운데 "
"하나를 이용하십시오. POINT, LINESTRING, POLYGON, MULTIPOINT, "
"MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION 또는 이에 상응하는 XYM 버전"
"의 POINTM, LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, "
"MULTIPOLYGONM, GEOMETRYCOLLECTIONM. 혼합 유형 집합을 이용하려면 유형으로 "
"\"GEOMETRY\"를 이용할 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:610
#, no-c-format
msgid ""
"This attribute is (probably) not part of the OpenGIS specification, but is "
"required for ensuring type homogeneity."
msgstr ""
"이런 속성은 (아마도) OpenGIS 사양에는 포함되지 않겠지만, 유형의 동질성"
"(homogeneity)을 보장하는 데 필요합니다."

#. Tag: title
#: using_postgis_dataman.xml:620
#, no-c-format
msgid "Creating a Spatial Table"
msgstr "공간 테이블 생성"

#. Tag: para
#: using_postgis_dataman.xml:622
#, no-c-format
msgid ""
"Creating a table with spatial data, can be done in one step. As shown in the "
"following example which creates a roads table with a 2D linestring geometry "
"column in WGS84 long lat"
msgstr ""
"공간 데이터를 담은 테이블을 한 번에 생성할 수 있습니다. WGS84 경위도 좌표의 "
"2D 라인스트링 도형 열을 가진 도로 테이블을 생성하는 다음 예시를 살펴보십시오."

#. Tag: programlisting
#: using_postgis_dataman.xml:624
#, no-c-format
msgid ""
"CREATE TABLE ROADS ( ID int4\n"
"                , ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) );"
msgstr ""
"CREATE TABLE ROADS ( ID int4\n"
"                , ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:626
#, no-c-format
msgid ""
"We can add additional columns using standard ALTER TABLE command as we do in "
"this next example where we add a 3-D linestring."
msgstr ""
"3D 라인스트링을 추가하는 다음 예시처럼, 표준 ALTER TABLE 명령어를 사용해서 추"
"가적인 열을 추가할 수 있습니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:627
#, no-c-format
msgid "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"
msgstr "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"

#. Tag: para
#: using_postgis_dataman.xml:629
#, no-c-format
msgid ""
"For backwards compability, you can still create a spatial table in two "
"stages using the management functions."
msgstr ""
"이전 버전과의 호환성을 위해, 여전히 공간 테이블을 관리 도구를 사용해서 두 단"
"계에 걸쳐 생성할 수도 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:633
#, no-c-format
msgid "Create a normal non-spatial table."
msgstr "일반적인 비공간 테이블을 생성하십시오."

#. Tag: para
#: using_postgis_dataman.xml:635
#, no-c-format
msgid ""
"For example: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME varchar(25) )</"
"command>"
msgstr ""
"예시: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME varchar(25) )</"
"command>"

#. Tag: para
#: using_postgis_dataman.xml:640
#, no-c-format
msgid ""
"Add a spatial column to the table using the OpenGIS \"AddGeometryColumn\" "
"function. Refer to <xref linkend=\"AddGeometryColumn\"/> for more details."
msgstr ""
"OpenGIS \"AddGeometryColumn\" 함수를 이용해서 테이블에 공간 열을 추가하십시"
"오. 자세한 내용은 <xref linkend=\"AddGeometryColumn\"/> 을 참조하십시오."

#. Tag: para
#: using_postgis_dataman.xml:643
#, no-c-format
msgid ""
"The syntax is: <programlisting>AddGeometryColumn(\n"
"  &lt;schema_name&gt;,\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")</programlisting> Or, using current schema:"
msgstr ""
"문법은 다음과 같습니다: <programlisting>AddGeometryColumn(\n"
"  &lt;schema_name&gt;,\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")</programlisting> 또는, 현재 스키마를 이용해서:"

#. Tag: programlisting
#: using_postgis_dataman.xml:643
#, no-c-format
msgid ""
"AddGeometryColumn(\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")"
msgstr ""
"AddGeometryColumn(\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")"

#. Tag: para
#: using_postgis_dataman.xml:645
#, no-c-format
msgid ""
"Example1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"
msgstr ""
"예시 1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"

#. Tag: para
#: using_postgis_dataman.xml:648
#, no-c-format
msgid ""
"Example2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"
msgstr ""
"예시 2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"

#. Tag: para
#: using_postgis_dataman.xml:653
#, no-c-format
msgid ""
"Here is an example of SQL used to create a table and add a spatial column "
"(assuming that an SRID of 128 exists already):"
msgstr ""
"다음은 SQL을 이용해서 테이블을 생성하고 공간 열을 추가하는 예시입니다"
"(\"128\"의 SRID가 이미 존재한다고 가정합니다)."

#. Tag: programlisting
#: using_postgis_dataman.xml:656
#, no-c-format
msgid ""
"CREATE TABLE parks (\n"
"  park_id    INTEGER,\n"
"  park_name  VARCHAR,\n"
"  park_date  DATE,\n"
"  park_type  VARCHAR\n"
");\n"
"SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"
msgstr ""
"CREATE TABLE parks (\n"
"  park_id    INTEGER,\n"
"  park_name  VARCHAR,\n"
"  park_date  DATE,\n"
"  park_type  VARCHAR\n"
");\n"
"SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"

#. Tag: para
#: using_postgis_dataman.xml:658
#, no-c-format
msgid ""
"Here is another example, using the generic \"geometry\" type and the "
"undefined SRID value of 0:"
msgstr ""
"다음은 포괄적인 \"GEOMETRY\" 유형 및 0값을 가진, 정의되지 않은 SRID를 이용하"
"는 또다른 예시입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:661
#, no-c-format
msgid ""
"CREATE TABLE roads (\n"
"  road_id INTEGER,\n"
"  road_name VARCHAR\n"
");\n"
"SELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"
msgstr ""
"CREATE TABLE roads (\n"
"  road_id INTEGER,\n"
"  road_name VARCHAR\n"
");\n"
"SELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"

#. Tag: title
#: using_postgis_dataman.xml:665
#, no-c-format
msgid "Manually Registering Geometry Columns in geometry_columns"
msgstr "geometry_columns에 도형 열을 직접 등록하기"

#. Tag: para
#: using_postgis_dataman.xml:666
#, fuzzy, no-c-format
msgid ""
"The AddGeometryColumn() approach creates a geometry column of specified "
"type. This type and dimension are queryable from the "
"<varname>geometry_columns</varname> view. Starting with PostGIS 2.0, "
"geometry_columns is no longer editable and all geometry columns are "
"autoregistered."
msgstr ""
"AddGeometryColumn() 함수를 이용하면 도형 열을 생성하고, 이 새 열을 "
"geometry_columns 테이블에 등록도 합니다. 사용자의 소프트웨어가 "
"geometry_columns 테이블을 활용하고 있다면, 사용자가 쿼리해야 하는 모든 도형 "
"열을 반드시 이 뷰에 등록해야 합니다. PostGIS 2.0 버전부터 geometry_columns 테"
"이블을 직접 편집할 수 없고 모든 도형 열은 자동 등록됩니다."

#. Tag: para
#: using_postgis_dataman.xml:669
#, no-c-format
msgid ""
"If your geometry columns were created as generic in a table or view and no "
"constraints applied, they will not have a dimension, type or srid in "
"geometry_columns views, but will still be listed."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:671
#, fuzzy, no-c-format
msgid ""
"Two of the cases where this may happen, but you can't use AddGeometryColumn, "
"is in the case of SQL Views and bulk inserts. For bulk insert case, you can "
"correct the registration in the geometry_columns table by constraining the "
"column or doing an alter table. For views, you could expose using a CAST "
"operation. Note in PostGIS 2.0+ if your column is typmod based, the creation "
"process would register it correctly, so no need to do anything. Also views "
"that have no spatial function applied to the geometry will register the same "
"as the underlying table geometry column."
msgstr ""
"AddGeometryColumn() 함수를 쓸 수 없을 때 이런 일이 발생할 수 있는 두 가지 경"
"우가 있는데, SQL 뷰 그리고 대규모 삽입(bulk insert)의 경우입니다. 이런 경우, "
"해당 열에 제약 조건을 걸어서 geometry_columns 테이블 등록을 바로잡을 수 있습"
"니다. PostGIS 2.0 이상 버전에서는, 사용자 열이 typmod 기반이라면 생성 과정 중"
"에 정확하게 등록할 것이기 때문에 아무것도 할 필요가 없다는 점을 기억하십시오."

#. Tag: programlisting
#: using_postgis_dataman.xml:678
#, no-c-format
msgid ""
"--Lets say you have a view created like this\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- For it to register correctly in PostGIS 2.0+\n"
"-- You need to cast the geometry\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- If you know the geometry type for sure is a 2D POLYGON then you could do\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"
msgstr ""
"-- 이렇게 생성된 뷰가 있다고 합시다.\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- PostGIS 2.0 이상 버전에 정확하게 등록하려면\n"
"-- 도형을 형변환해야 합니다.\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- 도형 유형이 2D 폴리곤이란 사실을 확실히 알고 있을 경우 다음과 같이 할 수 "
"있습니다.\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"

#. Tag: programlisting
#: using_postgis_dataman.xml:679
#, no-c-format
msgid ""
"--Lets say you created a derivative table by doing a bulk insert\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"--Create 2d index on new table\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"\n"
"-- If your points are 3D points or 3M points,\n"
"-- then you might want to create an nd index instead of a 2d index\n"
"-- like so\n"
"CREATE INDEX my_special_pois_geom_gist_nd\n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"--To manually register this new table's geometry column in geometry_columns\n"
"-- Note that this approach will work for both PostGIS 2.0+ and PostGIS 1.4+\n"
"-- For PostGIS 2.0 it will also change the underlying structure of the table "
"to\n"
"-- to make the column typmod based.\n"
"-- For PostGIS prior to 2.0, this technique can also be used to register "
"views\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n"
"\n"
"--If you are using PostGIS 2.0 and for whatever reason, you\n"
"-- you need the old constraint based definition behavior\n"
"-- (such as case of inherited tables where all children do not have the same "
"type and srid)\n"
"-- set new optional  use_typmod argument to false\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"
msgstr ""
"-- 대규모 삽입 작업을 통해 파생 테이블을 생성했다고 합시다.\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"-- 새 테이블에 2D 인덱스를 생성합니다.\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"\n"
"-- 사용자 포인트가 3D 또는 3M 포인트일 경우,\n"
"-- 2D 인덱스가 아니라 nD 인덱스를 생성하는 편이 좋을 수도 있습니다.\n"
"-- 다음처럼 말이죠.\n"
"CREATE INDEX my_special_pois_geom_gist_nd\n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"-- 이 새 테이블의 도형 열을 geometry_columns 테이블에 직접 등록하는\n"
"-- 다음 방법은 PostGIS 2.0 이후 버전 및 1.4 이후 버전 모두에서 동작합니다.\n"
"-- PostGIS 2.0 버전의 경우 열을 typmod 기반으로 만들기 위해\n"
"-- 테이블의 기저 구조를 변경할 것입니다.\n"
"-- PostGIS 2.0 이전 버전의 경우, 동일한 방법으로 뷰를 등록할 수도 있습니다.\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n"
"\n"
"-- PostGIS 2.0 버전을 사용중이고 어떤 이유에서든\n"
"-- 구식 제약조건 기반 정의 동작이 필요한 경우\n"
"-- (모든 자식 객체가 동일한 유형과 SRID가 아닌 상속 테이블의 경우 등)\n"
"-- 선택적인 새 use_typmod argument 파라미터를 거짓으로 설정하십시오.\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"

#. Tag: para
#: using_postgis_dataman.xml:681
#, fuzzy, no-c-format
msgid ""
"Although the old-constraint based method is still supported, a constraint-"
"based geometry column used directly in a view, will not register correctly "
"in geometry_columns, as will a typmod one. In this example we define a "
"column using typmod and another using constraints."
msgstr ""
"구식 제약조건 기반 방법을 여전히 지원하긴 하지만, 뷰에서 직접적으로 사용되는 "
"제약조건 기반 도형 열은 typmod 기반 열과는 달리 geometry_columns 테이블에 정"
"확하게 등록되지 않을 겁니다. 다음은 typmod를 이용하는 열과 제약조건을 이용하"
"는 또다른 열을 정의하는 예시입니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:684
#, no-c-format
msgid ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY\n"
"   , poi_name text, cat varchar(20)\n"
"   , geom geometry(POINT,4326) );\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"
msgstr ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY\n"
"   , poi_name text, cat varchar(20)\n"
"   , geom geometry(POINT,4326) );\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"

#. Tag: para
#: using_postgis_dataman.xml:685
#, no-c-format
msgid "If we run in psql"
msgstr "PSQL에서 실행할 경우"

#. Tag: programlisting
#: using_postgis_dataman.xml:686
#, no-c-format
msgid "\\d pois_ny;"
msgstr "\\d pois_ny;"

#. Tag: para
#: using_postgis_dataman.xml:687
#, no-c-format
msgid ""
"We observe they are defined differently -- one is typmod, one is constraint"
msgstr ""
"두 열이 서로 다르게 정의되었다는 사실을 알 수 있습니다. 하나는 typmod, 다른 "
"하나는 제약조건으로 정의되었습니다."

#. Tag: screen
#: using_postgis_dataman.xml:688
#, no-c-format
msgid ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"
msgstr ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"

#. Tag: para
#: using_postgis_dataman.xml:689
#, no-c-format
msgid "In geometry_columns, they both register correctly"
msgstr "둘 다 geometry_columns 테이블에 정확하게 등록됩니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:690
#, no-c-format
msgid ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"
msgstr ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"

#. Tag: screen
#: using_postgis_dataman.xml:691
#, no-c-format
msgid ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"

#. Tag: para
#: using_postgis_dataman.xml:692
#, no-c-format
msgid "However -- if we were to create a view like this"
msgstr "하지만 -- 다음과 같은 뷰를 생성하려 한다면"

#. Tag: programlisting
#: using_postgis_dataman.xml:693
#, no-c-format
msgid ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: para
#: using_postgis_dataman.xml:694
#, no-c-format
msgid ""
"The typmod based geom view column registers correctly, but the constraint "
"based one does not."
msgstr ""
"typmod 기반 도형 열은 정확하게 등록되지만, 제약조건 기반 도형 열은 정확하게 "
"등록되지 않습니다."

#. Tag: screen
#: using_postgis_dataman.xml:696
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"
msgstr ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"

#. Tag: para
#: using_postgis_dataman.xml:698
#, no-c-format
msgid ""
"This may change in future versions of PostGIS, but for now To force the "
"constraint based view column to register correctly, we need to do this:"
msgstr ""
"PostGIS 향후 버전에서는 변경될 수도 있지만, 현재 버전에서 제약조건 기반 뷰 열"
"을 정확하게 등록하려면 다음과 같이 해야 합니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:700
#, no-c-format
msgid ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT gid, poi_name, cat\n"
"  , geom\n"
"  , geom_2160::geometry(POINT,2160) As geom_2160\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT gid, poi_name, cat\n"
"  , geom\n"
"  , geom_2160::geometry(POINT,2160) As geom_2160\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: screen
#: using_postgis_dataman.xml:701
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"

#. Tag: title
#: using_postgis_dataman.xml:705
#, no-c-format
msgid "Ensuring OpenGIS compliancy of geometries"
msgstr "도형의 OpenGIS 준수 보장"

#. Tag: para
#: using_postgis_dataman.xml:707
#, no-c-format
msgid ""
"PostGIS is compliant with the Open Geospatial Consortium’s (OGC) OpenGIS "
"Specifications. As such, many PostGIS methods require, or more accurately, "
"assume that geometries that are operated on are both simple and valid. For "
"example, it does not make sense to calculate the area of a polygon that has "
"a hole defined outside of the polygon, or to construct a polygon from a non-"
"simple boundary line."
msgstr ""
"PostGIS는 OGC(Open Geospatial Consortium)의 OpenGIS 사양서를 준수합니다. 따라"
"서 많은 PostGIS 방식이 작업 대상인 도형이 단순하고 또 유효할 것을 요구, 아"
"니, 좀 더 정확히 말하자면 가정합니다. 예를 들어 그 외부에 구멍이 있다고 정의"
"된 폴리곤의 면적을 계산하거나 단순하지 않은 경계선으로부터 폴리곤을 그리는 "
"일 등은 말이 되지 않습니다."

#. Tag: para
#: using_postgis_dataman.xml:714
#, no-c-format
msgid ""
"According to the OGC Specifications, a <emphasis>simple</emphasis> geometry "
"is one that has no anomalous geometric points, such as self intersection or "
"self tangency and primarily refers to 0 or 1-dimensional geometries (i.e. "
"<varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). Geometry validity, on "
"the other hand, primarily refers to 2-dimensional geometries (i.e. "
"<varname>[MULTI]POLYGON)</varname> and defines the set of assertions that "
"characterizes a valid polygon. The description of each geometric class "
"includes specific conditions that further detail geometric simplicity and "
"validity."
msgstr ""
"OGC 사양서에 따르면, <emphasis>단순(simple)</emphasis> 도형은 변칙적인 포인"
"트, 즉 자체적으로 교차하거나 접촉하는 기하학적 포인트가 하나도 없으며, 기본적"
"으로 0 또는 1차원 도형(<varname>[MULTI]POINT, [MULTI]LINESTRING</varname>)을 "
"참조하는 도형을 말합니다. 반면, 도형의 유효성은 기본적으로 2차원 도형"
"(<varname>[MULTI]POLYGON)</varname>)을 참조하며 유효한 폴리곤을 특징짓는 일련"
"의 진술(assertion)을 정의합니다. 각 도형 클래스의 설명에는 도형의 단순성과 유"
"효성을 더 상세히 알려주는 특정한 조건들이 포함됩니다."

#. Tag: para
#: using_postgis_dataman.xml:724
#, no-c-format
msgid ""
"A <varname>POINT</varname> is inheritably <emphasis>simple</emphasis> as a 0-"
"dimensional geometry object."
msgstr ""
"<varname>POINT</varname> 란 0차원 도형 객체로서 상속적으로 <emphasis>단순형</"
"emphasis> 입니다."

#. Tag: para
#: using_postgis_dataman.xml:727
#, no-c-format
msgid ""
"<varname>MULTIPOINT</varname>s are <emphasis>simple</emphasis> if no two "
"coordinates (<varname>POINT</varname>s) are equal (have identical coordinate "
"values)."
msgstr ""
"<varname>MULTIPOINT</varname> 는 어떤 두 좌표(<varname>POINT</varname>)도 동"
"일하지 않은 (동일한 좌표를 공유하지 않는) <emphasis>단순형</emphasis> 입니다."

#. Tag: para
#: using_postgis_dataman.xml:731
#, no-c-format
msgid ""
"A <varname>LINESTRING</varname> is <emphasis>simple</emphasis> if it does "
"not pass through the same <varname>POINT</varname> twice (except for the "
"endpoints, in which case it is referred to as a linear ring and additionally "
"considered closed)."
msgstr ""
"<varname>LINESTRING</varname> 은 동일한 <varname>POINT</varname> 를 두 번 통"
"과하지 않는 경우 (종단점은 예외입니다. 이럴 경우 선형 고리라 불리며, 폐쇄 도"
"형으로 간주됩니다) <emphasis>단순형</emphasis> 입니다."

#. Tag: emphasis
#: using_postgis_dataman.xml:746
#, no-c-format
msgid "<emphasis>(a)</emphasis>"
msgstr "<emphasis>(a)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:756
#, no-c-format
msgid "<emphasis>(b)</emphasis>"
msgstr "<emphasis>(b)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:768
#, no-c-format
msgid "<emphasis>(c)</emphasis>"
msgstr "<emphasis>(c)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:778
#, no-c-format
msgid "<emphasis>(d)</emphasis>"
msgstr "<emphasis>(d)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:788
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(a)</emphasis> and <emphasis role=\"bold\">(c)</"
"emphasis> are simple <varname>LINESTRING</varname>s, <emphasis role=\"bold"
"\">(b)</emphasis> and <emphasis role=\"bold\">(d)</emphasis> are not."
msgstr ""
"<emphasis role=\"bold\">(a)</emphasis> 와 <emphasis role=\"bold\">(c)</"
"emphasis> 는 단순 <varname>LINESTRING</varname> 이지만, <emphasis role=\"bold"
"\">(b)</emphasis> 와 <emphasis role=\"bold\">(d)</emphasis> 는 아닙니다."

#. Tag: para
#: using_postgis_dataman.xml:797
#, no-c-format
msgid ""
"A <varname>MULTILINESTRING</varname> is <emphasis>simple</emphasis> only if "
"all of its elements are simple and the only intersection between any two "
"elements occurs at <varname>POINT</varname>s that are on the boundaries of "
"both elements."
msgstr ""
"<varname>MULTILINESTRING</varname> 은 모든 구성 요소가 단순형이며 어떤 두 요"
"소가 해당 두 요소의 경계상에 있는 <varname>POINT</varname>에서 교차하는 경우"
"에만 <emphasis>단순형</emphasis> 입니다."

#. Tag: emphasis
#: using_postgis_dataman.xml:812
#, no-c-format
msgid "<emphasis>(e)</emphasis>"
msgstr "<emphasis>(e)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:822
#, no-c-format
msgid "<emphasis>(f)</emphasis>"
msgstr "<emphasis>(f)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:832
#, no-c-format
msgid "<emphasis>(g)</emphasis>"
msgstr "<emphasis>(g)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:842
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(e)</emphasis> and <emphasis role=\"bold\">(f)</"
"emphasis> are simple <varname>MULTILINESTRING</varname>s, <emphasis role="
"\"bold\">(g)</emphasis> is not."
msgstr ""
"<emphasis role=\"bold\">(e)</emphasis> 와 <emphasis role=\"bold\">(f)</"
"emphasis> 는 단순 <varname>MULTILINESTRING</varname>이지만, <emphasis role="
"\"bold\">(g)</emphasis> 는 아닙니다."

#. Tag: para
#: using_postgis_dataman.xml:851
#, no-c-format
msgid ""
"By definition, a <varname>POLYGON</varname> is always <emphasis>simple</"
"emphasis>. It is <emphasis>valid</emphasis> if no two rings in the boundary "
"(made up of an exterior ring and interior rings) cross. The boundary of a "
"<varname>POLYGON</varname> may intersect at a <varname>POINT</varname> but "
"only as a tangent (i.e. not on a line). A <varname>POLYGON</varname> may not "
"have cut lines or spikes and the interior rings must be contained entirely "
"within the exterior ring."
msgstr ""
"정의에 따르면, <varname>POLYGON</varname> 은 어떤 경우라도 <emphasis>단순형</"
"emphasis> 입니다. 경계선(boundary) 내부의 (외곽 고리와 내곽 고리로 이루어진) "
"어떤 두 고리도 교차하지 않을 경우 <emphasis>유효</emphasis> 합니다. "
"<varname>POLYGON</varname> 의 경계선은 어떤 <varname>POINT</varname> 에서 교"
"차할 수도 있지만, 접선(즉 라인으로는 겹치지 않는)일 경우에만 가능합니다. "
"<varname>POLYGON</varname> 대부분은 커트라인(cut line) 또는 스파이크(spike)"
"를 가지고 있지 않으며, 외곽선이 내곽선을 완전히 감싸 담고 있어야 합니다."

#. Tag: emphasis
#: using_postgis_dataman.xml:869
#, no-c-format
msgid "<emphasis>(h)</emphasis>"
msgstr "<emphasis>(h)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:879
#, no-c-format
msgid "<emphasis>(i)</emphasis>"
msgstr "<emphasis>(i)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:889
#, no-c-format
msgid "<emphasis>(j)</emphasis>"
msgstr "<emphasis>(j)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:901
#, no-c-format
msgid "<emphasis>(k)</emphasis>"
msgstr "<emphasis>(k)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:911
#, no-c-format
msgid "<emphasis>(l)</emphasis>"
msgstr "<emphasis>(l)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:921
#, no-c-format
msgid "<emphasis>(m)</emphasis>"
msgstr "<emphasis>(m)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:930
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(h)</emphasis> and <emphasis role=\"bold\">(i)</"
"emphasis> are valid <varname>POLYGON</varname>s, <emphasis role=\"bold\">(j-"
"m)</emphasis> cannot be represented as single <varname>POLYGON</varname>s, "
"but <emphasis role=\"bold\">(j)</emphasis> and <emphasis role=\"bold\">(m)</"
"emphasis> could be represented as a valid <varname>MULTIPOLYGON</varname>."
msgstr ""
"<emphasis role=\"bold\">(h)</emphasis> 와 <emphasis role=\"bold\">(i)</"
"emphasis> 는 유효한 <varname>POLYGON</varname> 이며, <emphasis role=\"bold"
"\">(j-m)</emphasis> 은 단일 <varname>POLYGON</varname> 이라고 할 수 없지만 "
"<emphasis role=\"bold\">(j)</emphasis> 와 <emphasis role=\"bold\">(m)</"
"emphasis> 은 유효한 <varname>MULTIPOLYGON</varname> 이라고 할 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:942
#, no-c-format
msgid ""
"A <varname>MULTIPOLYGON</varname> is <emphasis>valid</emphasis> if and only "
"if all of its elements are valid and the interiors of no two elements "
"intersect. The boundaries of any two elements may touch, but only at a "
"finite number of <varname>POINT</varname>s."
msgstr ""
"<varname>MULTIPOLYGON</varname> 은 모든 구성 요소가 유효하며 어떤 두 요소의 "
"내부도 교차하지 않을 경우에만 <emphasis>유효</emphasis> 합니다. 어느 두 요소"
"의 경계선은 접촉할 수도 있지만, 유한한 개수의 <varname>POINT</varname> 들에서"
"만 접할 수 있습니다."

#. Tag: emphasis
#: using_postgis_dataman.xml:957
#, no-c-format
msgid "<emphasis>(n)</emphasis>"
msgstr "<emphasis>(n)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:967
#, no-c-format
msgid "<emphasis>(o)</emphasis>"
msgstr "<emphasis>(o)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:977
#, no-c-format
msgid "<emphasis>(p)</emphasis>"
msgstr "<emphasis>(p)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:986
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(n)</emphasis> and <emphasis role=\"bold\">(o)</"
"emphasis> are not valid <varname>MULTIPOLYGON</varname>s. <emphasis role="
"\"bold\">(p)</emphasis>, however, is valid."
msgstr ""
"<emphasis role=\"bold\">(n)</emphasis> 과 <emphasis role=\"bold\">(o)</"
"emphasis> 는 유효한 <varname>MULTIPOLYGON</varname> 이 아닙니다. 하지만, "
"<emphasis role=\"bold\">(p)</emphasis> 는 유효합니다."

#. Tag: para
#: using_postgis_dataman.xml:995
#, no-c-format
msgid ""
"Most of the functions implemented by the GEOS library rely on the assumption "
"that your geometries are valid as specified by the OpenGIS Simple Feature "
"Specification. To check simplicity or validity of geometries you can use the "
"<link linkend=\"ST_IsSimple\">ST_IsSimple()</link> and <link linkend="
"\"ST_IsValid\">ST_IsValid()</link>"
msgstr ""
"GEOS 라이브러리가 실행하는 함수 대부분은 사용자 도형이 OpenGIS 단순 도형 사양"
"서의 정의대로 유효하다는 가정에 의존합니다. 도형의 단순성 및 유효성을 확인하"
"려면 <link linkend=\"ST_IsSimple\">ST_IsSimple()</link> 및 <link linkend="
"\"ST_IsValid\">ST_IsValid()</link> 함수를 이용할 수 있습니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:1001
#, no-c-format
msgid ""
"-- Typically, it doesn't make sense to check\n"
"-- for validity on linear features since it will always return TRUE.\n"
"-- But in this example, PostGIS extends the definition of the OGC IsValid\n"
"-- by returning false if a LineString has less than 2 *distinct* vertices.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"
msgstr ""
"-- 일반적으로, 선형 피처의 유효성을 확인하는 작업은\n"
"-- 언제나 참을 반환하기 때문에 할 필요가 없습니다.\n"
"-- 그러니 이 예시에서는, 라인스트링의 뚜렷이 구분되는 꼭짓점이 2개 미만일 경"
"우\n"
"-- 거짓을 반환하여 PostGIS가 OGC IsValid의 정의를 확장합니다.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"

#. Tag: para
#: using_postgis_dataman.xml:1003
#, no-c-format
msgid ""
"By default, PostGIS does not apply this validity check on geometry input, "
"because testing for validity needs lots of CPU time for complex geometries, "
"especially polygons. If you do not trust your data sources, you can manually "
"enforce such a check to your tables by adding a check constraint:"
msgstr ""
"PostGIS는 기본적으로 도형 입력시 유효성 검사를 하지 않습니다. 복잡 도형, 특"
"히 폴리곤의 경우 유효성 테스트에 많은 CPU 시간이 들기 때문입니다. 사용자가 자"
"신의 데이터소스를 신용하지 못 할 경우, 사용자 테이블에 다음과 같은 검사 제약"
"조건을 걸어 직접 검사해볼 수 있습니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:1009
#, no-c-format
msgid ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"
msgstr ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"

#. Tag: para
#: using_postgis_dataman.xml:1011
#, no-c-format
msgid ""
"If you encounter any strange error messages such as \"GEOS Intersection() "
"threw an error!\" or \"JTS Intersection() threw an error!\" when calling "
"PostGIS functions with valid input geometries, you likely found an error in "
"either PostGIS or one of the libraries it uses, and you should contact the "
"PostGIS developers. The same is true if a PostGIS function returns an "
"invalid geometry for valid input."
msgstr ""
"유효한 입력 도형과 함께 PostGIS 함수를 호출했는데 \"GEOS Intersection() "
"threw an error!\" 또는 \"JTS Intersection() threw an error!\" 같은 이상한 오"
"류 메시지를 받았다면, 사용자가 PostGIS 또는 PostGIS가 사용하는 라이브러리 중 "
"하나의 오류를 찾았을 가능성이 높습니다. PostGIS 개발자에게 연락해주십시오. "
"PostGIS 함수가 유효한 입력에 대해 유효하지 않은 도형을 반환하는 경우도 마찬가"
"지입니다."

#. Tag: para
#: using_postgis_dataman.xml:1019
#, no-c-format
msgid ""
"Strictly compliant OGC geometries cannot have Z or M values. The <link "
"linkend=\"ST_IsValid\">ST_IsValid()</link> function won't consider higher "
"dimensioned geometries invalid! Invocations of <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> will add a constraint "
"checking geometry dimensions, so it is enough to specify 2 there."
msgstr ""
"OGC를 엄격히 준수하는 도형은 Z 또는 M 값을 가질 수 없습니다. <link linkend="
"\"ST_IsValid\">ST_IsValid()</link> 함수는 고차원 도형을 유효하지 않다고 판단"
"하지 않을 것입니다! <link linkend=\"AddGeometryColumn\">AddGeometryColumn()</"
"link> 함수를 호출하면 도형 차원을 검사하는 제약조건을 추가할 것이므로, "
"\"2\"라고 설정해주면 충분합니다."

#. Tag: title
#: using_postgis_dataman.xml:1029
#, no-c-format
msgid "Dimensionally Extended 9 Intersection Model (DE-9IM)"
msgstr "차원 확장 9 교차 모델(DE-9IM)"

#. Tag: para
#: using_postgis_dataman.xml:1031
#, no-c-format
msgid ""
"It is sometimes the case that the typical spatial predicates (<xref linkend="
"\"ST_Contains\"/>, <xref linkend=\"ST_Crosses\"/>, <xref linkend="
"\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>, ...) are insufficient "
"in and of themselves to adequately provide that desired spatial filter."
msgstr ""
"때때로 전형적인 공간 술어(<xref linkend=\"ST_Contains\"/>, <xref linkend="
"\"ST_Crosses\"/>, <xref linkend=\"ST_Intersects\"/>, <xref linkend="
"\"ST_Touches\"/>, ...) 그 자체로는 원하는 공간 필터를 제대로 구현하는 데 부족"
"한 경우가 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:1043
#, no-c-format
msgid ""
"For example, consider a linear dataset representing a road network. It may "
"be the task of a GIS analyst to identify all road segments that cross each "
"other, not at a point, but on a line, perhaps invalidating some business "
"rule. In this case, <xref linkend=\"ST_Crosses\"/> does not adequately "
"provide the necessary spatial filter since, for linear features, it returns "
"<varname>true</varname> only where they cross at a point."
msgstr ""
"예를 들어, 도로망을 표현하는 선형 데이터셋을 생각해보십시오. GIS 분석가가 포"
"인트가 아니라 라인 상에서 겹쳐지는, 아마도 사업 규칙을 무시하는, 모든 도로 구"
"간을 식별해야 할 수도 있습니다. 이런 경우 <xref linkend=\"ST_Crosses\"/> 함수"
"는 선형 피처에 대해 오직 포인트 상에서 교차할 경우에만 <varname>참</varname> "
"을 반환하기 때문에, 필요한 공간 필터를 제대로 제공하지 못 합니다."

#. Tag: para
#: using_postgis_dataman.xml:1050
#, no-c-format
msgid ""
"One two-step solution might be to first perform the actual intersection "
"(<xref linkend=\"ST_Intersection\"/>) of pairs of road segments that "
"spatially intersect (<xref linkend=\"ST_Intersects\"/>), and then compare "
"the intersection's <xref linkend=\"ST_GeometryType\"/> with "
"'<varname>LINESTRING</varname>' (properly dealing with cases that return "
"<varname>GEOMETRYCOLLECTION</varname>s of <varname>[MULTI]POINT</varname>s, "
"<varname>[MULTI]LINESTRING</varname>s, etc.)."
msgstr ""
"먼저 도로 구간 한 쌍이 공간적으로 교차하는(<xref linkend=\"ST_Intersects\"/"
">) 실제 교차점(<xref linkend=\"ST_Intersection\"/>)을 구하는 작업을 수행한 다"
"음, (<varname>[MULTI]POINT</varname>, <varname>[MULTI]LINESTRING</varname> 등"
"의 <varname>GEOMETRYCOLLECTION</varname> 을 반환하는 경우를 적절히 대처하며) "
"해당 교차점의 <xref linkend=\"ST_GeometryType\"/> 을 '<varname>LINESTRING</"
"varname>'과 비교하는 두 단계의 해법을 이용할 수도 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:1058
#, no-c-format
msgid "A more elegant / faster solution may indeed be desirable."
msgstr "물론 더 우아하고 빠른 해법을 원할 수도 있지요."

#. Tag: para
#: using_postgis_dataman.xml:1072
#, no-c-format
msgid ""
"A second [theoretical] example may be that of a GIS analyst trying to locate "
"all wharfs or docks that intersect a lake's boundary on a line and where "
"only one end of the wharf is up on shore. In other words, where a wharf is "
"within, but not completely within a lake, intersecting the boundary of a "
"lake on a line, and where the wharf's endpoints are both completely within "
"and on the boundary of the lake. The analyst may need to use a combination "
"of spatial predicates to isolate the sought after features:"
msgstr ""
"두 번째 (이론적인) 예시로, GIS 분석가가 호수의 경계선상을 침범하며 한쪽 끝만 "
"호수 기슭에 올라가 있는 선창 또는 부두의 위치를 찾으려 할 수도 있습니다. 다"
"시 말해, 선창이 호수의 경계선상을 침범하며 호수 내부에 들어가 있지만 완전히 "
"호수 안에 들어가 있지는 않고, 선창의 종단점 두 개 모두 완전히 호수 경계선 내"
"부 및 경계선상에 있는 경우입니다. 이 분석가는 찾고 있는 피처를 분리해내기 위"
"해 공간 술어들의 조합을 이용해야 할 수도 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:1083
#, no-c-format
msgid "(lake, wharf) = TRUE"
msgstr "(lake, wharf) = TRUE"

#. Tag: para
#: using_postgis_dataman.xml:1087
#, no-c-format
msgid "(lake, wharf) = FALSE"
msgstr "(lake, wharf) = FALSE"

#. Tag: para
#: using_postgis_dataman.xml:1091
#, no-c-format
msgid "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"
msgstr "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"

#. Tag: para
#: using_postgis_dataman.xml:1096
#, no-c-format
msgid ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"
msgstr ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"

#. Tag: para
#: using_postgis_dataman.xml:1099
#, no-c-format
msgid "... (needless to say, this could get quite complicated)"
msgstr "... (말할 필요도 없지만, 굉장히 복잡해질 수도 있습니다)"

#. Tag: para
#: using_postgis_dataman.xml:1108
#, no-c-format
msgid ""
"So enters the Dimensionally Extended 9 Intersection Model, or DE-9IM for "
"short."
msgstr ""
"따라서 차원 확장 9 교차 모델(Dimensionally Extended 9 Intersection Model), 줄"
"여서 DE-9IM이 등장합니다."

#. Tag: title
#: using_postgis_dataman.xml:1112
#, no-c-format
msgid "Theory"
msgstr "이론"

#. Tag: para
#: using_postgis_dataman.xml:1114
#, no-c-format
msgid ""
"According to the <ulink url=\"http://www.opengeospatial.org/standards/sfs"
"\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, "
"\"the basic approach to comparing two geometries is to make pair-wise tests "
"of the intersections between the Interiors, Boundaries and Exteriors of the "
"two geometries and to classify the relationship between the two geometries "
"based on the entries in the resulting 'intersection' matrix.\""
msgstr ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">SQL 용 OpenGIS 단"
"순 피처 실행 사양서</ulink> 에 따르면, \"두 도형을 비교하는 기본 접근법은 두 "
"도형의 내부, 경계, 외부 사이의 교차점을 쌍으로 테스트한 다음, 해당 결과의 '교"
"차점' 매트릭스를 바탕으로 두 도형 사이의 관계를 분류하는 방법\"입니다."

#. Tag: glossterm
#: using_postgis_dataman.xml:1125
#, no-c-format
msgid "<glossterm>Boundary</glossterm>"
msgstr "<glossterm>경계(boundary)</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1128
#, no-c-format
msgid ""
"The boundary of a geometry is the set of geometries of the next lower "
"dimension. For <varname>POINT</varname>s, which have a dimension of 0, the "
"boundary is the empty set. The boundary of a <varname>LINESTRING</varname> "
"are the two endpoints. For <varname>POLYGON</varname>s, the boundary is the "
"linework that make up the exterior and interior rings."
msgstr ""
"도형의 경계는 한 단계 아래 차원의 도형 집합입니다. <varname>POINT</varname> "
"의 경우, 0차원이므로 경계는 공집합입니다. <varname>LINESTRING</varname> 의 경"
"계는 두 종단점입니다. <varname>POLYGON</varname> 의 경우, 경계는 외곽 및 내"
"곽 고리를 이루는 선형 피처입니다."

#. Tag: glossterm
#: using_postgis_dataman.xml:1139
#, no-c-format
msgid "<glossterm>Interior</glossterm>"
msgstr "<glossterm>내부(interior)</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1142
#, no-c-format
msgid ""
"The interior of a geometry are those points of a geometry that are left when "
"the boundary is removed. For <varname>POINT</varname>s, the interior is the "
"<varname>POINT</varname> itself. The interior of a <varname>LINESTRING</"
"varname> are the set of real points between the endpoints. For "
"<varname>POLYGON</varname>s, the interior is the areal surface inside the "
"polygon."
msgstr ""
"도형의 내부란 경계를 제거했을 때 남는 해당 도형의 포인트들입니다. "
"<varname>POINT</varname> 의 경우, 내부는 <varname>POINT</varname> 자체입니"
"다. <varname>LINESTRING</varname> 의 내부는 두 종단점 사이에 있는 실제 포인트"
"들의 집합입니다. <varname>POLYGON</varname> 의 경우, 내부는 폴리곤 안의 면적"
"을 가진 면입니다."

#. Tag: glossterm
#: using_postgis_dataman.xml:1153
#, no-c-format
msgid "<glossterm>Exterior</glossterm>"
msgstr "<glossterm>외부(exterior)</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1156
#, no-c-format
msgid ""
"The exterior of a geometry is the universe, an areal surface, not on the "
"interior or boundary of the geometry."
msgstr ""
"도형의 외부란 해당 도형의 내부 또는 경계가 아닌 세계, 면적을 가진 면입니다."

#. Tag: para
#: using_postgis_dataman.xml:1163
#, no-c-format
msgid ""
"Given geometry <emphasis>a</emphasis>, where the <emphasis>I(a)</emphasis>, "
"<emphasis>B(a)</emphasis>, and <emphasis>E(a)</emphasis> are the "
"<emphasis>Interior</emphasis>, <emphasis>Boundary</emphasis>, and "
"<emphasis>Exterior</emphasis> of a, the mathematical representation of the "
"matrix is:"
msgstr ""
"<emphasis>a</emphasis> 라는 도형이 있을 때 <emphasis>I(a)</emphasis>, "
"<emphasis>B(a)</emphasis>, <emphasis>E(a)</emphasis> 이 각각 도형 "
"<emphasis>a</emphasis> 의 <emphasis>내부</emphasis>, <emphasis>경계</"
"emphasis>, <emphasis>외부</emphasis> 를 뜻하며, 해당 매트릭스의 수학적 표현식"
"은 다음과 같습니다:"

#. Tag: emphasis
#: using_postgis_dataman.xml:1175 using_postgis_dataman.xml:1185
#: using_postgis_dataman.xml:1269 using_postgis_dataman.xml:1282
#, no-c-format
msgid "<emphasis role=\"bold\">Interior</emphasis>"
msgstr "<emphasis role=\"bold\">내부</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1177 using_postgis_dataman.xml:1191
#: using_postgis_dataman.xml:1272 using_postgis_dataman.xml:1305
#, no-c-format
msgid "<emphasis role=\"bold\">Boundary</emphasis>"
msgstr "<emphasis role=\"bold\">경계</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1179 using_postgis_dataman.xml:1197
#: using_postgis_dataman.xml:1275 using_postgis_dataman.xml:1328
#, no-c-format
msgid "<emphasis role=\"bold\">Exterior</emphasis>"
msgstr "<emphasis role=\"bold\">외부</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1186
#, no-c-format
msgid "dim( I(a) ∩ I(b) )"
msgstr "dim( I(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1187
#, no-c-format
msgid "dim( I(a) ∩ B(b) )"
msgstr "dim( I(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1188
#, no-c-format
msgid "dim( I(a) ∩ E(b) )"
msgstr "dim( I(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1192
#, no-c-format
msgid "dim( B(a) ∩ I(b) )"
msgstr "dim( B(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1193
#, no-c-format
msgid "dim( B(a) ∩ B(b) )"
msgstr "dim( B(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1194
#, no-c-format
msgid "dim( B(a) ∩ E(b) )"
msgstr "dim( B(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1198
#, no-c-format
msgid "dim( E(a) ∩ I(b) )"
msgstr "dim( E(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1199
#, no-c-format
msgid "dim( E(a) ∩ B(b) )"
msgstr "dim( E(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1200
#, no-c-format
msgid "dim( E(a) ∩ E(b) )"
msgstr "dim( E(a) ∩ E(b) )"

#. Tag: para
#: using_postgis_dataman.xml:1207
#, no-c-format
msgid ""
"Where <emphasis>dim(a)</emphasis> is the dimension of <emphasis>a</emphasis> "
"as specified by <xref linkend=\"ST_Dimension\"/> but has the domain of "
"<literal>{0,1,2,T,F,*}</literal>"
msgstr ""
"이때 <emphasis>dim(a)</emphasis> 는 <xref linkend=\"ST_Dimension\"/> 이 지정"
"한 도형 <emphasis>a</emphasis> 의 차원이지만 그 정의역(domain)은 "
"<literal>{0,1,2,T,F,*}</literal> 입니다."

#. Tag: para
#: using_postgis_dataman.xml:1214
#, no-c-format
msgid "<literal>0</literal> =&gt; point"
msgstr "<literal>0</literal> =&gt; 포인트"

#. Tag: para
#: using_postgis_dataman.xml:1218
#, no-c-format
msgid "<literal>1</literal> =&gt; line"
msgstr "<literal>1</literal> =&gt; 라인"

#. Tag: para
#: using_postgis_dataman.xml:1222
#, no-c-format
msgid "<literal>2</literal> =&gt; area"
msgstr "<literal>2</literal> =&gt; 면"

#. Tag: para
#: using_postgis_dataman.xml:1226
#, no-c-format
msgid "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"
msgstr "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"

#. Tag: para
#: using_postgis_dataman.xml:1231
#, no-c-format
msgid "<literal>F</literal> =&gt; empty set"
msgstr "<literal>F</literal> =&gt; 공집합"

#. Tag: para
#: using_postgis_dataman.xml:1235
#, no-c-format
msgid "<literal>*</literal> =&gt; don't care"
msgstr "<literal>*</literal> =&gt; 상관없음"

#. Tag: para
#: using_postgis_dataman.xml:1239
#, no-c-format
msgid "Visually, for two overlapping polygonal geometries, this looks like:"
msgstr ""
"서로 겹치는 두 폴리곤 도형의 경우를 시각적으로 나타내면 다음과 같습니다:"

#. Tag: para
#: using_postgis_dataman.xml:1286 using_postgis_dataman.xml:1298
#: using_postgis_dataman.xml:1332 using_postgis_dataman.xml:1344
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1292 using_postgis_dataman.xml:1309
#: using_postgis_dataman.xml:1321 using_postgis_dataman.xml:1338
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1315
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1356
#, no-c-format
msgid ""
"Read from left to right and from top to bottom, the dimensional matrix is "
"represented, '<emphasis role=\"bold\">212101212</emphasis>'."
msgstr ""
"왼쪽에서 오른쪽으로 그리고 위에서 아래로 읽을 경우, 차원 매트릭스는 "
"'<emphasis role=\"bold\">212101212</emphasis>' 와 같이 표현됩니다."

#. Tag: para
#: using_postgis_dataman.xml:1359
#, no-c-format
msgid ""
"A relate matrix that would therefore represent our first example of two "
"lines that intersect on a line would be: '<emphasis role=\"bold\">1*1***1**</"
"emphasis>'"
msgstr ""
"따라서 첫 번째 예시에서 나온, 라인 상에서 겹치는 두 라인을 표현하는 관계 매트"
"릭스는 '<emphasis role=\"bold\">1*1***1**</emphasis>' 가 될 것입니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:1363
#, no-c-format
msgid ""
"-- Identify road segments that cross on a line\n"
"SELECT a.id\n"
"FROM roads a, roads b\n"
"WHERE a.id != b.id\n"
"AND a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '1*1***1**');"
msgstr ""
"-- 라인 상에 겹치는 도로 구간을 식별하기\n"
"SELECT a.id\n"
"FROM roads a, roads b\n"
"WHERE a.id != b.id\n"
"AND a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '1*1***1**');"

#. Tag: para
#: using_postgis_dataman.xml:1365
#, no-c-format
msgid ""
"A relate matrix that represents the second example of wharfs partly on the "
"lake's shoreline would be '<emphasis role=\"bold\">102101FF2</emphasis>'"
msgstr ""
"두 번째 예시에서 나온, 호수의 경계선에 일부분을 걸치는 선창을 표현하는 관계 "
"매트릭스는 '<emphasis role=\"bold\">102101FF2</emphasis>' 가 될 것입니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:1369
#, no-c-format
msgid ""
"-- Identify wharfs partly on a lake's shoreline\n"
"SELECT a.lake_id, b.wharf_id\n"
"FROM lakes a, wharfs b\n"
"WHERE a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '102101FF2');"
msgstr ""
"-- 호수의 경계선에 일부분을 걸치는 선창을 식별하기\n"
"SELECT a.lake_id, b.wharf_id\n"
"FROM lakes a, wharfs b\n"
"WHERE a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '102101FF2');"

#. Tag: para
#: using_postgis_dataman.xml:1371
#, no-c-format
msgid "For more information or reading, see:"
msgstr "더 상세한 정보 또는 읽을 거리가 필요하다면 다음을 참조하십시오:"

#. Tag: para
#: using_postgis_dataman.xml:1375
#, no-c-format
msgid ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink> (version 1.1, section "
"2.1.13.2)"
msgstr ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">SQL 용 OpenGIS 단"
"순 피처 실행 사양서</ulink> (1.1 버전, 2.1.13.2 단원)"

#. Tag: ulink
#: using_postgis_dataman.xml:1380
#, no-c-format
msgid "Dimensionally Extended Nine-Intersection Model (DE-9IM)"
msgstr "차원 확장 9 교차 모델(DE-9IM)"

#. Tag: ulink
#: using_postgis_dataman.xml:1384
#, no-c-format
msgid "GeoTools: Point Set Theory and the DE-9IM Matrix"
msgstr "GeoTools: 포인트 집합 이론 및 DE-9IM 매트릭스"

#. Tag: para
#: using_postgis_dataman.xml:1387
#, no-c-format
msgid "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"
msgstr ""
"<emphasis>GIS 백과사전(Encyclopedia of GIS)</emphasis> - 후이 슝(Hui Xiong) "
"저(著)"

#. Tag: title
#: using_postgis_dataman.xml:1397
#, no-c-format
msgid "Loading GIS (Vector) Data"
msgstr "GIS (벡터) 데이터 로드"

#. Tag: para
#: using_postgis_dataman.xml:1399
#, no-c-format
msgid ""
"Once you have created a spatial table, you are ready to upload GIS data to "
"the database. Currently, there are two ways to get data into a PostGIS/"
"PostgreSQL database: using formatted SQL statements or using the Shape file "
"loader/dumper."
msgstr ""
"공간 테이블 생성을 끝냈다면, 사용자가 데이터베이스에 GIS 데이터를 업로드할 준"
"비가 된 것입니다. 현재, 형식화된 SQL 구문을 사용하거나 shapefile 로더/덤퍼를 "
"사용하는 두 가지 방법으로 PostGIS/PostgreSQL 데이터베이스에 데이터를 입력할 "
"수 있습니다."

#. Tag: title
#: using_postgis_dataman.xml:1405
#, no-c-format
msgid "Loading Data Using SQL"
msgstr "SQL을 이용해서 데이터를 로드하기"

#. Tag: para
#: using_postgis_dataman.xml:1407
#, no-c-format
msgid ""
"If you can convert your data to a text representation, then using formatted "
"SQL might be the easiest way to get your data into PostGIS. As with Oracle "
"and other SQL databases, data can be bulk loaded by piping a large text file "
"full of SQL \"INSERT\" statements into the SQL terminal monitor."
msgstr ""
"사용자 데이터를 텍스트 표현식으로 변환할 수 있다면, PostGIS에 사용자 데이터"
"를 입력하는 가장 쉬운 방법은 형식화된(formatted) SQL을 이용하는 것입니다. "
"Oracle이나 다른 SQL 데이터베이스와 마찬가지로, SQL 터미널 모니터에 SQL "
"\"INSERT\" 선언문으로 가득 찬 대용량 텍스트 파일을 송신하는(piping) 방법으로 "
"데이터를 일괄 로드시킬 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:1413
#, no-c-format
msgid ""
"A data upload file (<filename>roads.sql</filename> for example) might look "
"like this:"
msgstr ""
"데이터 업로드 파일(예를 들어 <filename>roads.sql</filename>)은 다음처럼 보일 "
"것입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1416
#, no-c-format
msgid ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 "
"243242)',-1),'Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 "
"244817)',-1),'Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 "
"229814)',-1),'Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 "
"259122)',-1),'Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 "
"228134)',-1),'Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 "
"268322)',-1),'Dave Cres');\n"
"COMMIT;"
msgstr ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 "
"243242)',-1),'Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 "
"244817)',-1),'Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 "
"229814)',-1),'Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 "
"259122)',-1),'Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 "
"228134)',-1),'Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 "
"268322)',-1),'Dave Cres');\n"
"COMMIT;"

#. Tag: para
#: using_postgis_dataman.xml:1418
#, no-c-format
msgid ""
"The data file can be piped into PostgreSQL very easily using the \"psql\" "
"SQL terminal monitor:"
msgstr ""
"\"psql\" SQL 터미널 모니터를 이용해서 PostgreSQL로 데이터 파일을 매우 쉽게 송"
"신할 수 있습니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:1421
#, no-c-format
msgid "psql -d [database] -f roads.sql"
msgstr "psql -d [database] -f roads.sql"

#. Tag: title
#: using_postgis_dataman.xml:1425
#, no-c-format
msgid "shp2pgsql: Using the ESRI Shapefile Loader"
msgstr "shp2pgsql: ESRI shapefile 로더 이용하기"

#. Tag: para
#: using_postgis_dataman.xml:1427
#, no-c-format
msgid ""
"The <filename>shp2pgsql</filename> data loader converts ESRI Shape files "
"into SQL suitable for insertion into a PostGIS/PostgreSQL database either in "
"geometry or geography format. The loader has several operating modes "
"distinguished by command line flags:"
msgstr ""
"<filename>shp2pgsql</filename> 데이터 로더는 ESRI shapefile을, 도형 형식이든 "
"지리형 형식이든, PostGIS/PostgreSQL 데이터베이스로 삽입하기에 적합한 SQL로 변"
"환합니다. 이 로더에는 명령행(command line) 플래그로 구별되는 몇 가지 실행 모"
"드가 존재합니다."

#. Tag: para
#: using_postgis_dataman.xml:1432
#, no-c-format
msgid ""
"In addition to the shp2pgsql command-line loader, there is an "
"<filename>shp2pgsql-gui</filename> graphical interface with most of the "
"options as the command-line loader, but may be easier to use for one-off non-"
"scripted loading or if you are new to PostGIS. It can also be configured as "
"a plugin to PgAdminIII."
msgstr ""
"shp2pgsql 명령행 로더 외에, 사용자가 PostGIS를 처음 접하는 경우 스크립트를 사"
"용하지 않고 단 한 번 로드하는 데 더 쉽게 사용할 수 있을 뿐만 아니라 명령행 로"
"더가 가진 대부분의 옵션도 가지고 있는 <filename>shp2pgsql-gui</filename> 그래"
"픽 인터페이스도 있습니다. <filename>shp2pgsql-gui</filename>를 pgAdmin III의 "
"플러그인으로 설정할 수도 있습니다."

#. Tag: term
#: using_postgis_dataman.xml:1439
#, no-c-format
msgid "(c|a|d|p) These are mutually exclusive options:"
msgstr "c|a|d|p -- 이들은 상호배타적인 옵션들입니다:"

#. Tag: term
#: using_postgis_dataman.xml:1444
#, no-c-format
msgid "<term>-c</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1446
#, no-c-format
msgid ""
"Creates a new table and populates it from the shapefile. <emphasis>This is "
"the default mode.</emphasis>"
msgstr ""
"새 테이블을 생성한 다음 shapefile의 데이터로 해당 테이블을 채웁니다. "
"<emphasis>이것이 기본 모드입니다.</emphasis>"

#. Tag: term
#: using_postgis_dataman.xml:1454
#, no-c-format
msgid "<term>-a</term>"
msgstr "<term>-a</term>"

#. Tag: para
#: using_postgis_dataman.xml:1456
#, no-c-format
msgid ""
"Appends data from the Shape file into the database table. Note that to use "
"this option to load multiple files, the files must have the same attributes "
"and same data types."
msgstr ""
"기존 데이터베이스 테이블에 shapefile의 데이터를 추가합니다. 이 옵션을 이용해"
"서 복수의 파일을 로드하려면, 파일들이 동일한 속성 및 동일한 데이터 유형을 담"
"고 있어야 한다는 점을 주의하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1465 using_postgis_dataman.xml:1854
#, no-c-format
msgid "<term>-d</term>"
msgstr "<term>-d</term>"

#. Tag: para
#: using_postgis_dataman.xml:1467
#, no-c-format
msgid ""
"Drops the database table before creating a new table with the data in the "
"Shape file."
msgstr ""
"기존 데이터베이스 테이블을 삭제(drop)한 다음 shapefile의 데이터를 가진 새 테"
"이블을 생성합니다."

#. Tag: term
#: using_postgis_dataman.xml:1475
#, no-c-format
msgid "<term>-p</term>"
msgstr "<term>-p</term>"

#. Tag: para
#: using_postgis_dataman.xml:1477
#, no-c-format
msgid ""
"Only produces the table creation SQL code, without adding any actual data. "
"This can be used if you need to completely separate the table creation and "
"data loading steps."
msgstr ""
"테이블을 생성하는 SQL 코드만 생성하고, 어떤 실제 데이터도 추가하지 않습니다. "
"테이블 생성과 데이터 로드 단계를 완전히 분리해야 할 경우 사용할 수 있습니다."

#. Tag: term
#: using_postgis_dataman.xml:1490
#, no-c-format
msgid "<term>-?</term>"
msgstr "<term>-?</term>"

#. Tag: para
#: using_postgis_dataman.xml:1492
#, no-c-format
msgid "Display help screen."
msgstr "도움말 화면을 표출합니다."

#. Tag: term
#: using_postgis_dataman.xml:1499
#, no-c-format
msgid "<term>-D</term>"
msgstr "<term>-D</term>"

#. Tag: para
#: using_postgis_dataman.xml:1501
#, no-c-format
msgid ""
"Use the PostgreSQL \"dump\" format for the output data. This can be combined "
"with -a, -c and -d. It is much faster to load than the default \"insert\" "
"SQL format. Use this for very large data sets."
msgstr ""
"산출물 데이터의 형식으로 PostgreSQL \"덤프(dump)\" 형식을 사용합니다. 이 옵션"
"은 -a, -c 및 -d와 함께 사용할 수 있습니다. 이 덤프 형식은 기본 \"삽입\" SQL "
"형식보다 훨씬 빨리 로드할 수 있습니다. 대용량 데이터셋의 경우 이 옵션을 사용"
"하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1510
#, no-c-format
msgid "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"
msgstr "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1512
#, no-c-format
msgid ""
"Creates and populates the geometry tables with the specified SRID. "
"Optionally specifies that the input shapefile uses the given FROM_SRID, in "
"which case the geometries will be reprojected to the target SRID. FROM_SRID "
"cannot be specified with -D."
msgstr ""
"도형 테이블을 생성하고 지정된 SRID로 채웁니다. 입력 shapefile이 주어진 "
"FROM_SRID를 쓰도록 설정하는 옵션도 있습니다. 이런 경우 도형이 목표 SRID로 재"
"투영될 것입니다. FROM_SRID는 -D 옵션과 함께 사용될 수 없습니다."

#. Tag: term
#: using_postgis_dataman.xml:1523
#, no-c-format
msgid "<term>-k</term>"
msgstr "<term>-k</term>"

#. Tag: para
#: using_postgis_dataman.xml:1525
#, no-c-format
msgid ""
"Keep identifiers' case (column, schema and attributes). Note that attributes "
"in Shapefile are all UPPERCASE."
msgstr ""
"식별자의 대소문자(열, 스키마 및 속성)를 유지합니다. shapefile 안의 속성은 모"
"두 대문자라는 점을 주의하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1533
#, no-c-format
msgid "<term>-i</term>"
msgstr "<term>-i</term>"

#. Tag: para
#: using_postgis_dataman.xml:1535
#, no-c-format
msgid ""
"Coerce all integers to standard 32-bit integers, do not create 64-bit "
"bigints, even if the DBF header signature appears to warrant it."
msgstr ""
"DBF 헤더 서명이 64비트 bigint 형식을 보장하더라도, 모든 정수를 표준 32비트 정"
"수로 강제 변환하고 64비트 bigint 형식을 생성하지 않습니다."

#. Tag: term
#: using_postgis_dataman.xml:1543
#, no-c-format
msgid "<term>-I</term>"
msgstr "<term>-I</term>"

#. Tag: para
#: using_postgis_dataman.xml:1545
#, no-c-format
msgid "Create a GiST index on the geometry column."
msgstr "도형 열에 GiST 인덱스를 생성합니다."

#. Tag: term
#: using_postgis_dataman.xml:1552
#, no-c-format
msgid "<term>-m</term>"
msgstr "<term>-m</term>"

#. Tag: para
#: using_postgis_dataman.xml:1554
#, no-c-format
msgid ""
"-m <filename>a_file_name</filename> Specify a file containing a set of "
"mappings of (long) column names to 10 character DBF column names. The "
"content of the file is one or more lines of two names separated by white "
"space and no trailing or leading space. For example:"
msgstr ""
"\"-m <filename>파일명</filename>\" 형식으로 (긴) 열 명칭과 10문자 DBF 열 명칭"
"을 매핑하는 목록을 담은 파일을 지정합니다. 이 파일의 내용은 공백으로 구분된 "
"두 명칭으로 이루어진 하나 이상의 행으로, 행 맨 앞과 맨 뒤에는 공백이 없어야 "
"합니다. 다음은 그 예시입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1559
#, no-c-format
msgid ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"
msgstr ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"

#. Tag: term
#: using_postgis_dataman.xml:1565
#, no-c-format
msgid "<term>-S</term>"
msgstr "<term>-S</term>"

#. Tag: para
#: using_postgis_dataman.xml:1567
#, no-c-format
msgid ""
"Generate simple geometries instead of MULTI geometries. Will only succeed if "
"all the geometries are actually single (I.E. a MULTIPOLYGON with a single "
"shell, or or a MULTIPOINT with a single vertex)."
msgstr ""
"다중(multi) 도형 대신 단순 도형을 생성합니다. 이 옵션은 모든 도형이 실제로 단"
"일형(예: 단일 외곽선을 가진 다중 폴리곤 또는 단일 꼭짓점을 가진 다중 포인트)"
"일 경우에만 작동합니다."

#. Tag: term
#: using_postgis_dataman.xml:1576
#, no-c-format
msgid "-t &lt;dimensionality&gt;"
msgstr "-t &lt;dimensionality&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1578
#, no-c-format
msgid ""
"Force the output geometry to have the specified dimensionality. Use the "
"following strings to indicate the dimensionality: 2D, 3DZ, 3DM, 4D."
msgstr ""
"산출 도형이 지정된 차원수를 가지도록 강제합니다. 차원수를 지시하는 데 다음 스"
"트링을 사용하십시오: 2D, 3DZ, 3DM, 4D"

#. Tag: para
#: using_postgis_dataman.xml:1582
#, no-c-format
msgid ""
"If the input has fewer dimensions that specified, the output will have those "
"dimensions filled in with zeroes. If the input has more dimensions that "
"specified, the unwanted dimensions will be stripped."
msgstr ""
"입력물이 지정된 차원수보다 낮은 차원일 경우, 출력물의 해당 차원은 0으로 채워"
"질 것입니다. 입력물이 지정된 차원수보다 높은 차원일 경우, 필요 없는 차원은 제"
"거될 것입니다."

#. Tag: term
#: using_postgis_dataman.xml:1591
#, no-c-format
msgid "<term>-w</term>"
msgstr "<term>-w</term>"

#. Tag: para
#: using_postgis_dataman.xml:1593
#, no-c-format
msgid ""
"Output WKT format, instead of WKB. Note that this can introduce coordinate "
"drifts due to loss of precision."
msgstr ""
"WKB 대신 WKT 형식으로 출력합니다. 정확도가 부족하기 때문에 좌표가 이동될 가능"
"성이 있다는 점을 주의하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1601
#, no-c-format
msgid "<term>-e</term>"
msgstr "<term>-e</term>"

#. Tag: para
#: using_postgis_dataman.xml:1603
#, no-c-format
msgid ""
"Execute each statement on its own, without using a transaction. This allows "
"loading of the majority of good data when there are some bad geometries that "
"generate errors. Note that this cannot be used with the -D flag as the \"dump"
"\" format always uses a transaction."
msgstr ""
"각 선언문을 상호처리를 이용하지 않고 자체적으로 실행합니다. 오류를 생성하는 "
"몇몇 망가진 도형이 있을 경우 이 옵션을 사용하면 괜찮은 데이터 대다수를 로드"
"할 수 있습니다. \"덤프\" 형식은 항상 상호처리를 이용하기 때문에 -D 플래그와 "
"함께 사용할 수 없다는 점을 주의하십시오."

#. Tag: term
#: using_postgis_dataman.xml:1613
#, no-c-format
msgid "-W &lt;encoding&gt;"
msgstr "-W &lt;encoding&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1615
#, no-c-format
msgid ""
"Specify encoding of the input data (dbf file). When used, all attributes of "
"the dbf are converted from the specified encoding to UTF8. The resulting SQL "
"output will contain a <code>SET CLIENT_ENCODING to UTF8</code> command, so "
"that the backend will be able to reconvert from UTF8 to whatever encoding "
"the database is configured to use internally."
msgstr ""
"입력 데이터(DBF 파일)의 인코딩을 지정합니다. 이 옵션을 사용하면, DBF의 모든 "
"속성을 지정된 인코딩에서 UTF8로 변환합니다. 그 결과로 생성되는 SQL 출력물은 "
"<code>SET CLIENT_ENCODING to UTF8</code> 명령어를 담게 되어, 백엔드에서 UTF8"
"을 데이터베이스 내부에서 이용하도록 설정된 어떤 인코딩으로든 재변환할 수 있습"
"니다."

#. Tag: term
#: using_postgis_dataman.xml:1625
#, no-c-format
msgid "-N &lt;policy&gt;"
msgstr "-N &lt;policy&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1627
#, no-c-format
msgid "NULL geometries handling policy (insert*,skip,abort)"
msgstr ""
"NULL 도형 처리 방침 -- insert*(상관없이 삽입), skip(건너뛰기), abort(중단)"

#. Tag: term
#: using_postgis_dataman.xml:1633
#, no-c-format
msgid "<term>-n</term>"
msgstr "<term>-n</term>"

#. Tag: para
#: using_postgis_dataman.xml:1635
#, no-c-format
msgid ""
"-n Only import DBF file. If your data has no corresponding shapefile, it "
"will automatically switch to this mode and load just the dbf. So setting "
"this flag is only needed if you have a full shapefile set, and you only want "
"the attribute data and no geometry."
msgstr ""
"DBF 파일만 임포트합니다. 사용자 데이터에 대응하는 shapefile이 없다면, 자동적"
"으로 이 모드로 전환하여  DBF만 로드할 것입니다. 따라서 전체 shapefile 집합을 "
"가지고 있지만 도형을 빼고 속성 데이터만 필요한 경우에만 이 플래그를 설정해야 "
"합니다."

#. Tag: term
#: using_postgis_dataman.xml:1643
#, no-c-format
msgid "<term>-G</term>"
msgstr "<term>-G</term>"

#. Tag: para
#: using_postgis_dataman.xml:1645
#, no-c-format
msgid ""
"Use geography type instead of geometry (requires lon/lat data) in WGS84 long "
"lat (SRID=4326)"
msgstr ""
"(경도/위도가 필요한) 도형 대신 WGS84 경위도(SRID=4326)를 쓰는 지리형을 이용합"
"니다."

#. Tag: term
#: using_postgis_dataman.xml:1651
#, no-c-format
msgid "-T &lt;tablespace&gt;"
msgstr "-T &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1653
#, no-c-format
msgid ""
"Specify the tablespace for the new table. Indexes will still use the default "
"tablespace unless the -X parameter is also used. The PostgreSQL "
"documentation has a good description on when to use custom tablespaces."
msgstr ""
"새 테이블을 위한 테이블스페이스를 지정합니다. -X 파라미터가 함께 쓰인 경우가 "
"아니라면 여전히 인덱스가 기본 테이블스페이스를 이용할 것입니다. PostgreSQL 문"
"서는 사용자 지정 테이블스페이스가 필요한 경우를 잘 설명하고 있습니다."

#. Tag: term
#: using_postgis_dataman.xml:1661
#, no-c-format
msgid "-X &lt;tablespace&gt;"
msgstr "-X &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1663
#, no-c-format
msgid ""
"Specify the tablespace for the new table's indexes. This applies to the "
"primary key index, and the GIST spatial index if -I is also used."
msgstr ""
"새 테이블의 인덱스를 위한 테이블스페이스를 지정합니다. 이 옵션은 기본 키"
"(primary key) 인덱스에 적용되며, -I 플래그를 함께 사용하는 경우 GiST 공간 인"
"덱스에도 적용됩니다."

#. Tag: para
#: using_postgis_dataman.xml:1671
#, no-c-format
msgid ""
"An example session using the loader to create an input file and uploading it "
"might look like this:"
msgstr ""
"다음은 로더를 이용해서 입력 파일을 생성하고 업로드하는 세션의 예시입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1676
#, no-c-format
msgid ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"
msgstr ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"

#. Tag: para
#: using_postgis_dataman.xml:1678
#, no-c-format
msgid "A conversion and upload can be done all in one step using UNIX pipes:"
msgstr ""
"UNIX 파이프(pipe)를 이용하면 모든 변환 및 업로드 작업을 한 번에 끝낼 수 있습"
"니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1682
#, no-c-format
msgid "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"
msgstr "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"

#. Tag: title
#: using_postgis_dataman.xml:1687
#, no-c-format
msgid "Retrieving GIS Data"
msgstr "GIS 데이터 가져오기"

#. Tag: para
#: using_postgis_dataman.xml:1689
#, no-c-format
msgid ""
"Data can be extracted from the database using either SQL or the Shape file "
"loader/dumper. In the section on SQL we will discuss some of the operators "
"available to do comparisons and queries on spatial tables."
msgstr ""
"SQL이나 shapefile 로더/덤퍼를 이용해서 데이터베이스로부터 데이터를 추출할 수 "
"있습니다. SQL 단원에서 공간 테이블에 대한 비교 및 쿼리를 할 수 있는 몇몇 연산"
"자에 대해 논의할 것입니다."

#. Tag: title
#: using_postgis_dataman.xml:1695
#, no-c-format
msgid "Using SQL to Retrieve Data"
msgstr "SQL을 이용해 데이터 가져오기"

#. Tag: para
#: using_postgis_dataman.xml:1697
#, no-c-format
msgid ""
"The most straightforward means of pulling data out of the database is to use "
"a SQL select query to reduce the number of RECORDS and COLUMNS returned and "
"dump the resulting columns into a parsable text file:"
msgstr ""
"데이터베이스로부터 데이터를 추출하는 가장 간단한 방법은 SQL 선별(select) 쿼리"
"로 반환될 레코드 및 열의 개수를 줄인 다음 해당 결과 열을 파싱 가능한 텍스트 "
"파일로 덤프받는 것입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1702
#, no-c-format
msgid ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"
msgstr ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"

#. Tag: para
#: using_postgis_dataman.xml:1704
#, no-c-format
msgid ""
"However, there will be times when some kind of restriction is necessary to "
"cut down the number of fields returned. In the case of attribute-based "
"restrictions, just use the same SQL syntax as normal with a non-spatial "
"table. In the case of spatial restrictions, the following operators are "
"available/useful:"
msgstr ""
"하지만, 반환되는 필드의 개수를 줄이기 위해 어떤 종류의 제약이 필요할 때가 있"
"을 것입니다. 속성 기반 제약의 경우, 일반적인 비공간 테이블의 경우와 동일한 "
"SQL 문법을 쓰면 됩니다. 공간 제약의 경우, 다음 유용한 연산자들을 쓸 수 있습니"
"다."

#. Tag: term
#: using_postgis_dataman.xml:1712
#, no-c-format
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#. Tag: para
#: using_postgis_dataman.xml:1715
#, no-c-format
msgid ""
"This operator tells whether the bounding box of one geometry intersects the "
"bounding box of another."
msgstr ""
"이 연산자는 한 도형의 경계 상자와 다른 도형의 경계 상자가 교차하는지를 알려줍"
"니다."

#. Tag: term
#: using_postgis_dataman.xml:1721
#, no-c-format
msgid "ST_OrderingEquals"
msgstr "ST_OrderingEquals"

#. Tag: para
#: using_postgis_dataman.xml:1724
#, no-c-format
msgid ""
"This tests whether two geometries are geometrically identical. For example, "
"if 'POLYGON((0 0,1 1,1 0,0 0))' is the same as 'POLYGON((0 0,1 1,1 0,0 "
"0))' (it is)."
msgstr ""
"이 연산자는 두 도형이 기하학적으로 동일한지를 테스트합니다.예를 들어, "
"'POLYGON((0 0,1 1,1 0,0 0))'과 'POLYGON((0 0,1 1,1 0,0 0))'이 동일한지를 말입"
"니다(동일합니다)."

#. Tag: term
#: using_postgis_dataman.xml:1731
#, no-c-format
msgid "<term>=</term>"
msgstr "<term>=</term>"

#. Tag: para
#: using_postgis_dataman.xml:1734
#, no-c-format
msgid ""
"This operator is a little more naive, it only tests whether the bounding "
"boxes of two geometries are the same."
msgstr ""
"이 연산자는 좀 더 단순합니다. 두 도형의 경계 상자가 동일한지를 테스트할 뿐입"
"니다."

#. Tag: para
#: using_postgis_dataman.xml:1740
#, no-c-format
msgid ""
"Next, you can use these operators in queries. Note that when specifying "
"geometries and boxes on the SQL command line, you must explicitly turn the "
"string representations into geometries by using the \"ST_GeomFromText()\" "
"function. The 312 is a fictitious spatial reference system that matches our "
"data. So, for example:"
msgstr ""
"다음으로, 이 연산자들을 쿼리에 쓸 수 있습니다. SQL 명령행에 도형과 경계 상자"
"를 지정할 때, \"ST_GeomFromText()\" 함수를 이용해서 스트링 표현식을 도형으로 "
"정확하게 변환시켜야 합니다. 해당 데이터와 일치하는 가공의 공간 참조 시스템은 "
"312입니다. 다음은 그 예시입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1746
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE ST_OrderingEquals(roads_geom , ST_GeomFromText('LINESTRING(191232 "
"243118,191108 243242)',312) ) ;"
msgstr ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE ST_OrderingEquals(roads_geom , ST_GeomFromText('LINESTRING(191232 "
"243118,191108 243242)',312) ) ;"

#. Tag: para
#: using_postgis_dataman.xml:1748
#, no-c-format
msgid ""
"The above query would return the single record from the \"ROADS_GEOM\" table "
"in which the geometry was equal to that value."
msgstr ""
"이 쿼리는 해당 값과 동일한 도형을 담고 있는 \"ROADS_GEOM\" 테이블로부터 단일 "
"레코드를 반환할 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:1751
#, no-c-format
msgid ""
"When using the \"&amp;&amp;\" operator, you can specify either a BOX3D as "
"the comparison feature or a GEOMETRY. When you specify a GEOMETRY, however, "
"its bounding box will be used for the comparison."
msgstr ""
"\"&amp;&amp;\" 연산자 사용시, 비교 피처로 BOX3D 또는 도형을 지정할 수 있습니"
"다. 하지만 도형을 지정했을 경우, 비교 작업에 해당 경계 상자가 사용될 것입니"
"다."

#. Tag: programlisting
#: using_postgis_dataman.xml:1756
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))',312);"
msgstr ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))',312);"

#. Tag: para
#: using_postgis_dataman.xml:1758
#, no-c-format
msgid ""
"The above query will use the bounding box of the polygon for comparison "
"purposes."
msgstr "이 쿼리는 비교 목적으로 폴리곤의 경계 상자를 이용할 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:1761
#, no-c-format
msgid ""
"The most common spatial query will probably be a \"frame-based\" query, used "
"by client software, like data browsers and web mappers, to grab a \"map frame"
"\" worth of data for display. Using a \"BOX3D\" object for the frame, such a "
"query looks like this:"
msgstr ""
"가장 흔한 공간 쿼리는 아마도 데이터 브라우저 또는 웹 매퍼 같은 클라이언트 소"
"프트웨어가 화면 표출을 위해 \"맵 프레임(map frame)\" 용량에 해당하는 데이터"
"를 가져오기 위해 사용하는 \"프레임 기반(frame-based)\" 쿼리일 것입니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:1766
#, no-c-format
msgid ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"
msgstr ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"

#. Tag: para
#: using_postgis_dataman.xml:1768
#, no-c-format
msgid ""
"Note the use of the SRID 312, to specify the projection of the envelope."
msgstr ""
"화면에 해당하는 데이터의 투영체를 지정하는 데 SRID 312를 썼다는 사실에 주의하"
"십시오."

#. Tag: title
#: using_postgis_dataman.xml:1772
#, no-c-format
msgid "Using the Dumper"
msgstr "덤퍼 이용하기"

#. Tag: para
#: using_postgis_dataman.xml:1774
#, no-c-format
msgid ""
"The <filename>pgsql2shp</filename> table dumper connects directly to the "
"database and converts a table (possibly defined by a query) into a shape "
"file. The basic syntax is:"
msgstr ""
"<filename>pgsql2shp</filename> 테이블 덤퍼는 데이터베이스에 직접 연결되어 (아"
"마도 쿼리가 정의했을) 테이블을 shapefile로 변환합니다. 기본 문법은 다음과 같"
"습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1778
#, no-c-format
msgid ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"
msgstr ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"

#. Tag: programlisting
#: using_postgis_dataman.xml:1780
#, no-c-format
msgid "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"
msgstr "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1782
#, no-c-format
msgid "The commandline options are:"
msgstr "다음과 같은 명령행 옵션이 있습니다:"

#. Tag: term
#: using_postgis_dataman.xml:1786
#, no-c-format
msgid "-f &lt;filename&gt;"
msgstr "-f &lt;filename&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1789
#, no-c-format
msgid "Write the output to a particular filename."
msgstr "특정 파일명으로 출력물을 작성합니다."

#. Tag: term
#: using_postgis_dataman.xml:1794
#, no-c-format
msgid "-h &lt;host&gt;"
msgstr "-h &lt;host&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1797
#, no-c-format
msgid "The database host to connect to."
msgstr "연결할 데이터베이스 호스트를 설정합니다."

#. Tag: term
#: using_postgis_dataman.xml:1802
#, no-c-format
msgid "-p &lt;port&gt;"
msgstr "-p &lt;port&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1805
#, no-c-format
msgid "The port to connect to on the database host."
msgstr "데이터베이스 호스트 연결시 사용할 포트를 설정합니다."

#. Tag: term
#: using_postgis_dataman.xml:1810
#, no-c-format
msgid "-P &lt;password&gt;"
msgstr "-P &lt;password&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1813
#, no-c-format
msgid "The password to use when connecting to the database."
msgstr "데이터베이스 연결에 사용할 비밀번호를 설정합니다."

#. Tag: term
#: using_postgis_dataman.xml:1818
#, no-c-format
msgid "-u &lt;user&gt;"
msgstr "-u &lt;user&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1821
#, no-c-format
msgid "The username to use when connecting to the database."
msgstr "데이터베이스 연결에 사용할 사용자명을 설정합니다."

#. Tag: term
#: using_postgis_dataman.xml:1826
#, no-c-format
msgid "-g &lt;geometry column&gt;"
msgstr "-g &lt;geometry column&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1829
#, no-c-format
msgid ""
"In the case of tables with multiple geometry columns, the geometry column to "
"use when writing the shape file."
msgstr ""
"복수의 도형 열을 가진 테이블일 경우, shapefile 작성에 이용될 도형 열을 설정합"
"니다."

#. Tag: term
#: using_postgis_dataman.xml:1835
#, no-c-format
msgid "<term>-b</term>"
msgstr "<term>-b</term>"

#. Tag: para
#: using_postgis_dataman.xml:1838
#, no-c-format
msgid ""
"Use a binary cursor. This will make the operation faster, but will not work "
"if any NON-geometry attribute in the table lacks a cast to text."
msgstr ""
"바이너리 커서를 사용하도록 설정합니다. 이 옵션을 쓰면 실행 속도가 빨라지지"
"만, 테이블 안에 있는 비(非) 도형 속성 가운데 하나라도 텍스트로 작성할 캐스트"
"(cast)가 부족할 경우 실행되지 않을 것입니다."

#. Tag: term
#: using_postgis_dataman.xml:1845
#, no-c-format
msgid "<term>-r</term>"
msgstr "<term>-r</term>"

#. Tag: para
#: using_postgis_dataman.xml:1848
#, no-c-format
msgid ""
"Raw mode. Do not drop the <varname>gid</varname> field, or escape column "
"names."
msgstr ""
"로(raw) 모드입니다. <varname>gid</varname> 필드를 삭제하거나, 열 명칭을 제외"
"하지 않습니다."

#. Tag: para
#: using_postgis_dataman.xml:1857
#, no-c-format
msgid ""
"For backward compatibility: write a 3-dimensional shape file when dumping "
"from old (pre-1.0.0) postgis databases (the default is to write a 2-"
"dimensional shape file in that case). Starting from postgis-1.0.0+, "
"dimensions are fully encoded."
msgstr ""
"하위 호환성에 대해: 구 버전(1.0.0 이전) PostGIS 데이터베이스로부터 덤핑받을 "
"때 3차원 shapefile을 작성하십시오(이런 경우 2차원 shapefile 작성이 기본값입니"
"다). PostGIS 1.0.0 버전부터 차원수를 완전히 인코딩합니다."

#. Tag: term
#: using_postgis_dataman.xml:1865
#, no-c-format
msgid "-m <varname>filename</varname>"
msgstr "-m <varname>filename</varname>"

#. Tag: para
#: using_postgis_dataman.xml:1867
#, no-c-format
msgid ""
"Remap identifiers to ten character names. The content of the file is lines "
"of two symbols separated by a single white space and no trailing or leading "
"space: VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."
msgstr ""
"식별자를 10문자 명칭으로 다시 매핑(remap)합니다. 해당 파일의 내용은 공백으로 "
"구분된 두 심볼로 이루어진 복수의 행으로, 행 맨 앞과 맨 뒤에는 공백이 없어야 "
"합니다. VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER 등과 같은 예가 "
"있습니다."

#. Tag: title
#: using_postgis_dataman.xml:1880
#, no-c-format
msgid "Building Indexes"
msgstr "인덱스 빌드 작업"

#. Tag: para
#: using_postgis_dataman.xml:1882
#, no-c-format
msgid ""
"Indexes are what make using a spatial database for large data sets possible. "
"Without indexing, any search for a feature would require a \"sequential scan"
"\" of every record in the database. Indexing speeds up searching by "
"organizing the data into a search tree which can be quickly traversed to "
"find a particular record. PostgreSQL supports three kinds of indexes by "
"default: B-Tree indexes, R-Tree indexes, and GiST indexes."
msgstr ""
"인덱스 덕분에 공간 데이터베이스가 대용량 데이터셋을 사용할 수 있습니다. 인덱"
"스 작업을 하지 않으면, 어떤 피처를 검색하든 데이터베이스 안의 모든 레코드를 "
"\"순차 스캔\"해야 할 것입니다. 인덱스 작업은 데이터를 특정 레코드를 찾기 위"
"해 빠르게 훑어갈 수 있는 검색 트리로 조직해서 검색 속도를 향상시킵니다. "
"PostgreSQL는 기본적으로 B-Tree, R-Tree, GiST 세 종류의 인덱스를 지원합니다."

#. Tag: para
#: using_postgis_dataman.xml:1892
#, no-c-format
msgid ""
"B-Trees are used for data which can be sorted along one axis; for example, "
"numbers, letters, dates. GIS data cannot be rationally sorted along one axis "
"(which is greater, (0,0) or (0,1) or (1,0)?) so B-Tree indexing is of no use "
"for us."
msgstr ""
"B-Tree 인덱스는 하나의 축을 따라 정렬할 수 있는 데이터에 이용됩니다. 숫자, 글"
"자, 날짜 등이 그 예입니다. GIS 데이터는 하나의 축을 따라 논리적으로 정렬될 "
"수 없기 때문에 ((0,0), (0,1), (1,0) 가운데 어느 것이 더 큰 값인가요?) 이 문서"
"에서 B-Tree 인덱스는 쓸모가 없습니다."

#. Tag: para
#: using_postgis_dataman.xml:1899
#, no-c-format
msgid ""
"R-Trees break up data into rectangles, and sub-rectangles, and sub-sub "
"rectangles, etc. R-Trees are used by some spatial databases to index GIS "
"data, but the PostgreSQL R-Tree implementation is not as robust as the GiST "
"implementation."
msgstr ""
"R-Tree 인덱스는 데이터를 장방형(rectangle), 하위장방형(sub-rectangle), 하하위"
"장방형(sub-sub rectangle) 등으로 분해합니다. 몇몇 공간 데이터베이스는 GIS 데"
"이터 인덱스 작업을 위해 R-Tree 인덱스를 이용하지만, PostgreSQL에서의 R-Tree "
"작업은 GiST 작업만큼 강력하지는 않습니다."

#. Tag: para
#: using_postgis_dataman.xml:1906
#, no-c-format
msgid ""
"GiST (Generalized Search Trees) indexes break up data into \"things to one "
"side\", \"things which overlap\", \"things which are inside\" and can be "
"used on a wide range of data-types, including GIS data. PostGIS uses an R-"
"Tree index implemented on top of GiST to index GIS data."
msgstr ""
"GiST(Generalized Search Tree) 인덱스는 데이터를 \"한 쪽에 있는 것\", \"겹치"
"는 것\", \"내부에 있는 것\"으로 분해하며 GIS 데이터를 포함한 광범위한 데이터 "
"유형에 쓰일 수 있습니다. PostGIS는 GiST를 써서 GIS 데이터에 인덱스 작업을 한 "
"다음, 해당 데이터에 다시 작업된 R-Tree 인덱스를 이용합니다."

#. Tag: title
#: using_postgis_dataman.xml:1915
#, no-c-format
msgid "GiST Indexes"
msgstr "GiST 인덱스"

#. Tag: para
#: using_postgis_dataman.xml:1917
#, no-c-format
msgid ""
"GiST stands for \"Generalized Search Tree\" and is a generic form of "
"indexing. In addition to GIS indexing, GiST is used to speed up searches on "
"all kinds of irregular data structures (integer arrays, spectral data, etc) "
"which are not amenable to normal B-Tree indexing."
msgstr ""
"GiST는 \"일반화된 검색 트리\"의 줄임말로, 인덱스 작업의 포괄적인 형태입니다. "
"GIS 인덱스 작업 외에도, 일반 B-Tree 인덱스 작업으로는 쓸 수 없는 온갖 종류의 "
"비정규 데이터 구조(정수 배열, 분광 데이터 등등)에 대한 검색 속도를 향상시키"
"는 데 GiST를 이용합니다."

#. Tag: para
#: using_postgis_dataman.xml:1922
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields)."
msgstr ""
"GIS 데이터 테이블이 수천 행을 넘게 되면, 데이터 공간 검색의 속도를 향상시키"
"기 위해 인덱스를 빌드하고 싶게 될 것입니다(사용자의 모든 검색이 속성에 기반하"
"는 경우가 아니라면 말입니다. 그런 경우, 속성 필드에 대해 일반 인덱스를 빌드하"
"면 됩니다)."

#. Tag: para
#: using_postgis_dataman.xml:1927
#, no-c-format
msgid ""
"The syntax for building a GiST index on a \"geometry\" column is as follows:"
msgstr ""
"\"도형\" 열에 대해 GiST 인덱스를 빌드하는 데 필요한 문법은 다음과 같습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1930
#, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1931
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get the an n-dimensional "
"index supported in PostGIS 2.0+ for the geometry type, you can create one "
"using this syntax"
msgstr ""
"이 문법은 항상 2D 인덱스를 빌드할 것입니다. 해당 도형 유형에 PostGIS 2.0 이"
"상 버전이 지원하는 n차원 인덱스를 얻으려면, 다음 문법으로 생성할 수 있습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1932
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1934
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive exercise: on tables "
"of around 1 million rows, on a 300MHz Solaris machine, we have found "
"building a GiST index takes about 1 hour. After building an index, it is "
"important to force PostgreSQL to collect table statistics, which are used to "
"optimize query plans:"
msgstr ""
"공간 인덱스 빌드 작업은 계산적으로 집중적인 작업입니다. 300MHz 솔라리스 워크"
"스테이션 상에서, 약 1백만 행을 가진 테이블에 대한 GiST 인덱스 빌드 작업에 약 "
"1시간이 걸렸습니다. 인덱스 빌드 후 PostgreSQL가 테이블 통계를 수집하도록 하"
"는 명령을 해야 합니다. 쿼리 설계를 최적화하는 데 이 통계를 이용하기 때문에, "
"다음 명령이 중요합니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1940 using_postgis_dataman.xml:2023
#, no-c-format
msgid ""
"VACUUM ANALYZE [table_name] [(column_name)];\n"
"-- This is only needed for PostgreSQL 7.4 installations and below\n"
"SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);"
msgstr ""
"VACUUM ANALYZE [table_name] [(column_name)];\n"
"-- This is only needed for PostgreSQL 7.4 installations and below\n"
"SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);"

#. Tag: para
#: using_postgis_dataman.xml:1942
#, no-c-format
msgid ""
"GiST indexes have two advantages over R-Tree indexes in PostgreSQL. Firstly, "
"GiST indexes are \"null safe\", meaning they can index columns which include "
"null values. Secondly, GiST indexes support the concept of \"lossiness\" "
"which is important when dealing with GIS objects larger than the PostgreSQL "
"8K page size. Lossiness allows PostgreSQL to store only the \"important\" "
"part of an object in an index -- in the case of GIS objects, just the "
"bounding box. GIS objects larger than 8K will cause R-Tree indexes to fail "
"in the process of being built."
msgstr ""
"PostgreSQL에서, GiST 인덱스에는 R-Tree 인덱스에 비해 두 가지 장점이 있습니"
"다. 첫째, GiST 인덱스는 \"null값을 처리할 수(null safe)\" 있습니다. 즉 null값"
"을 포함하는 열에 대해 인덱스 작업을 할 수 있다는 뜻입니다. 둘째, GiST 인덱스"
"는 PostgreSQL 8K 페이지 크기보다 더 큰 GIS 객체를 다룰 때 중요한 \"손실"
"(lossiness)\"이라는 개념을 지원합니다. 손실 개념을 통해 PostgreSQL은 인덱스"
"에 객체의 \"중요한\" 부분만을 저장할 수 있습니다. GIS 객체의 경우, 경계 상자"
"만 저장합니다. 8K보다 더 큰 GIS 객체가 있을 경우, R-Tree 인덱스는 인덱스 빌"
"드 과정 중 오류를 일으킬 것입니다."

#. Tag: title
#: using_postgis_dataman.xml:1954
#, fuzzy, no-c-format
msgid "BRIN Indexes"
msgstr "GiST 인덱스"

#. Tag: para
#: using_postgis_dataman.xml:1956
#, no-c-format
msgid ""
"BRIN stands for \"Block Range Index\" and is a generic form of indexing that "
"has been introduced in PostgreSQL 9.5. BRIN is a lossy kind of index, and "
"its main usage is to provide a compromise for both read and write "
"performance. Its primary goal is to handle very large tables for which some "
"of the columns have some natural correlation with their physical location "
"within the table. In addition to GIS indexing, BRIN is used to speed up "
"searches on various kinds of regular or irregular data structures (integer, "
"arrays etc)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1965
#, fuzzy, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields). GiST indexes are really performant as long as their "
"size doesn't exceed the amount of RAM available for the database, and as "
"long as you can afford the storage size, and the penalty in write workload. "
"Otherwise, BRIN index can be considered as an alternative."
msgstr ""
"GIS 데이터 테이블이 수천 행을 넘게 되면, 데이터 공간 검색의 속도를 향상시키"
"기 위해 인덱스를 빌드하고 싶게 될 것입니다(사용자의 모든 검색이 속성에 기반하"
"는 경우가 아니라면 말입니다. 그런 경우, 속성 필드에 대해 일반 인덱스를 빌드하"
"면 됩니다)."

#. Tag: para
#: using_postgis_dataman.xml:1974
#, no-c-format
msgid ""
"The idea of a BRIN index is to store only the bouding box englobing all the "
"geometries contained in all the rows in a set of table blocks, called a "
"range. Obviously, this indexing method will only be efficient if the data is "
"physically ordered in a way where the resulting bouding boxes for block "
"ranges will be mutually exclusive. The resulting index will be really small, "
"but will be less efficient than a GiST index in many cases."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1982
#, no-c-format
msgid ""
"Building a BRIN index is way less intensive than building a GiST index. It's "
"quite common to build a BRIN index in more than ten time less than a GiST "
"index would have required. As a BRIN index only store one bouding box for "
"one to many table blocks, it's pretty common to consume up to a thousand "
"time less disk space for this kind of indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1988
#, no-c-format
msgid ""
"You can choose the number of blocks to summarize in a range. If you decrease "
"this number, the index will be bigger but will probably help to get better "
"performance."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1992
#, fuzzy, no-c-format
msgid ""
"The syntax for building a BRIN index on a \"geometry\" column is as follows:"
msgstr ""
"\"도형\" 열에 대해 GiST 인덱스를 빌드하는 데 필요한 문법은 다음과 같습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1995
#, fuzzy, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1996
#, fuzzy, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get a 3d-dimensional "
"index, you can create one using this syntax"
msgstr ""
"이 문법은 항상 2D 인덱스를 빌드할 것입니다. 해당 도형 유형에 PostGIS 2.0 이"
"상 버전이 지원하는 n차원 인덱스를 얻으려면, 다음 문법으로 생성할 수 있습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1997
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_3d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1998
#, no-c-format
msgid "You can also get a 4d-dimensional index using the 4d operator class"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1999
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_4d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:2000
#, no-c-format
msgid ""
"These above syntaxes will use the default number or block in a range, which "
"is 128. To specify the number of blocks you want to summarise in a range, "
"you can create one using this syntax"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:2001
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] ) WITH "
"(pages_per_range = [number]);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:2002
#, no-c-format
msgid ""
"Also, keep in mind that a BRIN index will only store one index value for a "
"large number of rows. If your table stores geometries with a mixed number of "
"dimensions, it's likely that the resulting index will have poor performance. "
"You can avoid this drop of performance by choosing the operator class whith "
"the least number of dimensions of the stored geometries"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2010
#, fuzzy, no-c-format
msgid ""
"Also the \"geography\" datatype is supported for BRIN indexing. The syntax "
"for building a BRIN index on a \"geography\" column is as follows:"
msgstr ""
"\"도형\" 열에 대해 GiST 인덱스를 빌드하는 데 필요한 문법은 다음과 같습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2013
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geographyfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:2014
#, fuzzy, no-c-format
msgid ""
"The above syntax will always build a 2D-index for geospatial objects on the "
"spheroid."
msgstr ""
"이 문법은 항상 2D 인덱스를 빌드할 것입니다. 해당 도형 유형에 PostGIS 2.0 이"
"상 버전이 지원하는 n차원 인덱스를 얻으려면, 다음 문법으로 생성할 수 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2016
#, no-c-format
msgid ""
"Currently, just the \"inclusion support\" is considered here, meaning that "
"just <varname>&amp;&amp;</varname>, <varname>~</varname> and <varname>@</"
"varname> operators can be used for the 2D cases (both for \"geometry\" and "
"for \"geography\"), and just the <varname>&amp;&amp;&amp;</varname> operator "
"can be used for the 3D geometries. There is no support for kNN searches at "
"the moment."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2027
#, no-c-format
msgid "Using Indexes"
msgstr "인덱스 활용"

#. Tag: para
#: using_postgis_dataman.xml:2029
#, no-c-format
msgid ""
"Ordinarily, indexes invisibly speed up data access: once the index is built, "
"the query planner transparently decides when to use index information to "
"speed up a query plan. Unfortunately, the PostgreSQL query planner does not "
"optimize the use of GiST indexes well, so sometimes searches which should "
"use a spatial index instead default to a sequence scan of the whole table."
msgstr ""
"일반적인 경우라면 인덱스는 눈에 보이지 않게 데이터 접속 속도를 향상시킵니다. "
"인덱스가 빌드된 후, 쿼리 설계자는 쿼리 설계의 속도를 향상기키는 데 언제 인덱"
"스 정보를 사용할 것인지 투명하게 결정합니다. 안타깝게도 PostgreSQL 쿼리 설계"
"자가 GiST 인덱스의 사용을 제대로 최적화시키지 못 하기 때문에, 종종 공간 인덱"
"스를 활용해야 할 검색이 대신 기본값인 전체 데이터의 순차 스캔을 이용할 때가 "
"있습니다."

#. Tag: para
#: using_postgis_dataman.xml:2036
#, no-c-format
msgid ""
"If you find your spatial indexes are not being used (or your attribute "
"indexes, for that matter) there are a couple things you can do:"
msgstr ""
"사용자의 공간 인덱스가 (또는 사용자의 속성 인덱스가) 활용되지 않고 있다는 사"
"실을 알게 되었다면, 몇 가지 해결 방법이 있습니다:"

#. Tag: para
#: using_postgis_dataman.xml:2042
#, no-c-format
msgid ""
"Firstly, make sure statistics are gathered about the number and "
"distributions of values in a table, to provide the query planner with better "
"information to make decisions around index usage. For PostgreSQL 7.4 "
"installations and below this is done by running "
"<command>update_geometry_stats([table_name, column_name])</command> (compute "
"distribution) and <command>VACUUM ANALYZE [table_name] [column_name]</"
"command> (compute number of values). Starting with PostgreSQL 8.0 running "
"<command>VACUUM ANALYZE</command> will do both operations. You should "
"regularly vacuum your databases anyways -- many PostgreSQL DBAs have "
"<command>VACUUM</command> run as an off-peak cron job on a regular basis."
msgstr ""
"첫 번째, 테이블 안에 있는 값들의 개수 및 분포에 대한 통계를 제대로 수집했는"
"지 확인하십시오. 인덱스 활용에 대한 결정을 내릴 수 있게 하려면 쿼리 설계자에 "
"더 나은 정보를 제공해야 하기 때문입니다. PostgreSQL 7.4 이하 버전에서는 "
"<command>update_geometry_stats([table_name, column_name])</command> (분포 계"
"산) 및 <command>VACUUM ANALYZE [table_name] [column_name]</command> (값의 개"
"수 계산)을 실행하면 됩니다. PostgreSQL 8.0 이상 버전에서는 <command>VACUUM "
"ANALYZE</command> 를 실행하면 두 계산을 동시에 처리할 것입니다. 어쨌든지 간"
"에 사용자 데이터베이스를 주기적으로 빈공간 분석(vacuum analyze)하는 편이 좋습"
"니다 -- 많은 PostgreSQL DBA가 정기적으로 사용량이 적을 때 자동화된 작업으로 "
"<command>VACUUM</command> 을 실행하고 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:2056
#, no-c-format
msgid ""
"If vacuuming does not work, you can force the planner to use the index "
"information by using the <command>SET ENABLE_SEQSCAN=OFF</command> command. "
"You should only use this command sparingly, and only on spatially indexed "
"queries: generally speaking, the planner knows better than you do about when "
"to use normal B-Tree indexes. Once you have run your query, you should "
"consider setting <varname>ENABLE_SEQSCAN</varname> back on, so that other "
"queries will utilize the planner as normal."
msgstr ""
"두 번째, 빈공간 분석으로 해결이 안 될 경우 <command>SET ENABLE_SEQSCAN=OFF</"
"command> 명령어를 통해 강제로 쿼리 설계자가 인덱스 정보를 이용하도록 할 수 있"
"습니다. 이 명령어는 공간 인덱스 쿼리일 경우에 한해 드물게 이용해야 합니다. 일"
"반적으로, 쿼리 설계자는 언제 일반 B-Tree 인덱스를 활용해야 하는지 사용자보다 "
"더 잘 알고 있습니다. 사용자 쿼리 실행 후, 다른 쿼리가 평소처럼 쿼리 설계자를 "
"활용하도록 <varname>ENABLE_SEQSCAN</varname> 을 다시 켤지 고려해봐야 합니다."

#. Tag: para
#: using_postgis_dataman.xml:2066
#, no-c-format
msgid ""
"As of version 0.6, it should not be necessary to force the planner to use "
"the index with <varname>ENABLE_SEQSCAN</varname>."
msgstr ""
"0.6 버전부터, <varname>ENABLE_SEQSCAN</varname> 변수를 통해 강제로 쿼리 설계"
"자가 인덱스를 이용하도록 할 필요는 없을 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:2073
#, no-c-format
msgid ""
"If you find the planner wrong about the cost of sequential vs index scans "
"try reducing the value of random_page_cost in postgresql.conf or using SET "
"random_page_cost=#. Default value for the parameter is 4, try setting it to "
"1 or 2. Decrementing the value makes the planner more inclined of using "
"Index scans."
msgstr ""
"쿼리 설계자가 순차 및 인덱스 스캔의 경중(cost)을 잘못 판단하고 있다면, "
"postgresql.conf 파일의 random_page_cost의 값을 줄여보거나 \"SET "
"random_page_cost=#\"로 써보십시오. 해당 파라미터의 기본값은 4이지만, 1또는 2"
"로 설정해보십시오. 값을 감소시킬수록 점점 더 쿼리 설계자가 인덱스 스캔을 활용"
"하게 될 것입니다."

#. Tag: title
#: using_postgis_dataman.xml:2084
#, no-c-format
msgid "Complex Queries"
msgstr "복잡 쿼리"

#. Tag: para
#: using_postgis_dataman.xml:2086
#, fuzzy, no-c-format
msgid ""
"The <emphasis>raison d'etre</emphasis> of spatial database functionality is "
"performing queries inside the database which would ordinarily require "
"desktop GIS functionality. Using PostGIS effectively requires knowing what "
"spatial functions are available, and ensuring that appropriate indexes are "
"in place to provide good performance. The SRID of 312 used in these examples "
"is purely for demonstration. You should be using a REAL SRID listed in the "
"the spatial_ref_sys table and one that matches the projection of your data. "
"If your data has no spatial reference system specified, you should be "
"THINKING very thoughtfully why it doesn't and maybe it should."
msgstr ""
"공간 데이터베이스 기능성의 <emphasis>존재 이유</emphasis>는 원래 데스크탑 "
"GIS 기능성을 필요로 하는 데이터베이스의 내부에서 쿼리를 실행하는 것입니다. "
"GIS를 효율적으로 활용하려면 어떤 공간 함수를 사용할 수 있는지 알아야 하고, 훌"
"륭한 수행을 제공하기 위한 적절한 인덱스가 준비되어 있는지 보장해야 합니다. "
"이 단원의 예시에서 사용된 SRID 312는 오직 시연을 위한 것입니다. 사용자는 "
"<varname>spatial_ref_sys</varname> 테이블에 정리되어 있으며 사용자 데이터의 "
"투영체와 일치하는 실제 SRID를 사용해야 합니다. 사용자의 데이터가 어떤 공간 참"
"조 시스템도 지정하고 있지 않을 경우, 어째서 지정하고 있지 않은지 그리고 지정"
"해야 할지를 매우 신중하게 생각해봐야 할 것입니다. 분자 내부 구조 또는 핵전쟁 "
"발발로 인해 인류를 화성으로 이주시키는 데 적합한 화성 상의 위치 등과 같이 정"
"의된 지리 공간 참조 시스템이 없는 대상을 모델링하고 있기 때문이라면, 그냥 "
"SRID를 비워두거나 또는 하나 만들어내서 <varname>spatial_ref_sys</varname> 테"
"이블에 삽입하십시오."

#. Tag: para
#: using_postgis_dataman.xml:2094
#, no-c-format
msgid ""
"If your reason is because you are modeling something that doesn't have a "
"geographic spatial reference system defined such as the internals of a "
"molecule or the floorplan of a not yet built amusement park then that's "
"fine. If the location of the amusement park has been planned however, then "
"it would make sense to use a suitable planar coordinate system for that "
"location if nothing more than to ensure the amusement part is not "
"trespassing on already existing structures."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:2098
#, no-c-format
msgid ""
"Even in the case where you are planning a Mars expedition to transport the "
"human race in the event of a nuclear holocaust and you want to map out the "
"Mars planet for rehabitation, you can use a non-earthly coordinate system "
"such as <ulink url=\"http://spatialreference.org/ref/iau2000/mars-2000/"
"\">Mars 2000</ulink> make one up and insert it in the "
"<varname>spatial_ref_sys</varname> table. Though this Mars coordinate system "
"is a non-planar one (it's in degrees spheroidal), you can use it with the "
"geography type to have your length and proximity measurements in meters "
"instead of degrees."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:2104
#, no-c-format
msgid "Taking Advantage of Indexes"
msgstr "인덱스의 장점을 활용하기"

#. Tag: para
#: using_postgis_dataman.xml:2106
#, no-c-format
msgid ""
"When constructing a query it is important to remember that only the bounding-"
"box-based operators such as &amp;&amp; can take advantage of the GiST "
"spatial index. Functions such as <varname>ST_Distance()</varname> cannot use "
"the index to optimize their operation. For example, the following query "
"would be quite slow on a large table:"
msgstr ""
"쿼리 작성시 &amp;&amp; 와 같은 경계 상자 기반 연산자만이 GiST 공간 인덱스의 "
"장점을 취할 수 있다는 사실을 기억해야 합니다. <varname>ST_Distance()</"
"varname> 같은 함수는 자체 연산을 최적화하는 데 인덱스를 활용할 수 없습니다. "
"예를 들어, 다음 쿼리는 대용량 테이블 대상일 경우 꽤 느릴 겁니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2113
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) "
"&lt; 100"
msgstr ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) "
"&lt; 100"

#. Tag: para
#: using_postgis_dataman.xml:2115
#, no-c-format
msgid ""
"This query is selecting all the geometries in geom_table which are within "
"100 units of the point (100000, 200000). It will be slow because it is "
"calculating the distance between each point in the table and our specified "
"point, ie. one <varname>ST_Distance()</varname> calculation for each row in "
"the table. We can avoid this by using the &amp;&amp; operator to reduce the "
"number of distance calculations required:"
msgstr ""
"이 쿼리는 geom_table 안에서 포인트 (100000, 200000)로부터 100단위 안에 있는 "
"모든 도형을 선택하고 있습니다. 지정된 포인트와 테이블이 담고 있는 모든 포인"
"트 사이의 거리를 각각 계산하기 때문에, 예를 들어 테이블의 각 행마다 "
"<varname>ST_Distance()</varname> 계산을 실행하기 때문에 느릴 수밖에 없습니"
"다. &amp;&amp; 연산자를 통해 필요한 거리 계산의 개수를 줄여 속도를 향상시킬 "
"수 있습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2122
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, "
"200100,312), 100)"
msgstr ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, "
"200100,312), 100)"

#. Tag: para
#: using_postgis_dataman.xml:2124
#, no-c-format
msgid ""
"This query selects the same geometries, but it does it in a more efficient "
"way. Assuming there is a GiST index on the_geom, the query planner will "
"recognize that it can use the index to reduce the number of rows before "
"calculating the result of the <varname>ST_distance()</varname> function. "
"Notice that the <varname>ST_MakeEnvelope</varname> geometry which is used in "
"the &amp;&amp; operation is a 200 unit square box centered on the original "
"point - this is our \"query box\". The &amp;&amp; operator uses the index to "
"quickly reduce the result set down to only those geometries which have "
"bounding boxes that overlap the \"query box\". Assuming that our query box "
"is much smaller than the extents of the entire geometry table, this will "
"drastically reduce the number of distance calculations that need to be done."
msgstr ""
"이 쿼리는 동일한 도형을 선택하지만, 더 효율적인 방식을 쓰고 있습니다. "
"the_geom에 대한 GiST 인덱스가 있다고 가정하면, <varname>ST_distance()</"
"varname> 함수의 결과를 계산하기 전에 쿼리 설계자가 인덱스를 활용해서 행의 개"
"수를 줄일 수 있다는 사실을 알아차릴 것입니다. &amp;&amp; 연산에 사용된 "
"<varname>ST_MakeEnvelope</varname> 도형이 원래 포인트가 중심에 있는 200단위 "
"정사각형이라는 점을 주의하십시오. 이것이 \"쿼리 상자\"입니다. &amp;&amp; 연산"
"자는 \"쿼리 상자\"와 겹치는 경계 상자를 가진 도형들만으로 결과 집합을 신속하"
"게 줄이기 위해 인덱스를 활용합니다. 이 쿼리 상자가 전체 도형 테이블의 범위보"
"다 훨씬 작다고 가정할 때, 필요한 거리 계산의 개수가 극단적으로 줄어들 것입니"
"다."

#. Tag: title
#: using_postgis_dataman.xml:2138
#, no-c-format
msgid "Change in Behavior"
msgstr "작동 방식의 변화"

#. Tag: para
#: using_postgis_dataman.xml:2140
#, no-c-format
msgid ""
"As of PostGIS 1.3.0, most of the Geometry Relationship Functions, with the "
"notable exceptions of ST_Disjoint and ST_Relate, include implicit bounding "
"box overlap operators."
msgstr ""
"PostGIS 1.3.0 버전부터, 주목할 만한 ST_Disjoint 및 ST_Relate를 제외한 도형 관"
"계 함수 대부분은 내포된 경계 상자 중첩(overlap) 연산자를 포함하고 있습니다."

#. Tag: title
#: using_postgis_dataman.xml:2147
#, no-c-format
msgid "Examples of Spatial SQL"
msgstr "공간 SQL 예시"

#. Tag: para
#: using_postgis_dataman.xml:2149
#, no-c-format
msgid ""
"The examples in this section will make use of two tables, a table of linear "
"roads, and a table of polygonal municipality boundaries. The table "
"definitions for the <varname>bc_roads</varname> table is:"
msgstr ""
"이 단원의 예시들은 선형 도로 테이블 및 폴리곤형 지자체 경계 테이블을 활용할 "
"것입니다. <varname>bc_roads</varname> 테이블은 다음과 같이 정의됩니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2153
#, no-c-format
msgid ""
"Column      | Type              | Description\n"
"------------+-------------------+-------------------\n"
"gid         | integer           | Unique ID\n"
"name        | character varying | Road Name\n"
"the_geom    | geometry          | Location Geometry (Linestring)"
msgstr ""
"Column      | Type              | Description\n"
"------------+-------------------+-------------------\n"
"gid         | integer           | Unique ID\n"
"name        | character varying | Road Name\n"
"the_geom    | geometry          | Location Geometry (Linestring)"

#. Tag: para
#: using_postgis_dataman.xml:2155
#, no-c-format
msgid ""
"The table definition for the <varname>bc_municipality</varname> table is:"
msgstr "<varname>bc_municipality</varname> 테이블은 다음과 같이 정의됩니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2158
#, no-c-format
msgid ""
"Column     | Type              | Description\n"
"-----------+-------------------+-------------------\n"
"gid        | integer           | Unique ID\n"
"code       | integer           | Unique ID\n"
"name       | character varying | City / Town Name\n"
"the_geom   | geometry          | Location Geometry (Polygon)"
msgstr ""
"Column     | Type              | Description\n"
"-----------+-------------------+-------------------\n"
"gid        | integer           | Unique ID\n"
"code       | integer           | Unique ID\n"
"name       | character varying | City / Town Name\n"
"the_geom   | geometry          | Location Geometry (Polygon)"

#. Tag: para
#: using_postgis_dataman.xml:2163
#, no-c-format
msgid "What is the total length of all roads, expressed in kilometers?"
msgstr "모든 도로들의 총연장이 몇 킬로미터입니까?"

#. Tag: para
#: using_postgis_dataman.xml:2168
#, no-c-format
msgid "You can answer this question with a very simple piece of SQL:"
msgstr "매우 단순한 SQL로 이 질문에 답할 수 있습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2171
#, no-c-format
msgid ""
"SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
"\n"
"km_roads\n"
"------------------\n"
"70842.1243039643\n"
"(1 row)"
msgstr ""
"SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
"\n"
"km_roads\n"
"------------------\n"
"70842.1243039643\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2177
#, no-c-format
msgid "How large is the city of Prince George, in hectares?"
msgstr "프린스 조지(Prince George) 시의 면적이 몇 헥타르입니까?"

#. Tag: para
#: using_postgis_dataman.xml:2181
#, no-c-format
msgid ""
"This query combines an attribute condition (on the municipality name) with a "
"spatial calculation (of the area):"
msgstr ""
"이 쿼리는 속성 조건(지자체 명칭)과 공간 계산(면적)을 결합하고 있습니다."

#. Tag: programlisting
#: using_postgis_dataman.xml:2185
#, no-c-format
msgid ""
"SELECT\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM bc_municipality\n"
"WHERE name = 'PRINCE GEORGE';\n"
"\n"
"hectares\n"
"------------------\n"
"32657.9103824927\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM bc_municipality\n"
"WHERE name = 'PRINCE GEORGE';\n"
"\n"
"hectares\n"
"------------------\n"
"32657.9103824927\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2191
#, no-c-format
msgid "What is the largest municipality in the province, by area?"
msgstr "해당 지역에서 가장 면적이 넓은 지자체는 어디입니까?"

#. Tag: para
#: using_postgis_dataman.xml:2196
#, no-c-format
msgid ""
"This query brings a spatial measurement into the query condition. There are "
"several ways of approaching this problem, but the most efficient is below:"
msgstr ""
"이 쿼리는 쿼리 조건에 공간 측정을 넣어야 합니다. 이 문제에 접근하는 데에는 "
"몇 가지 방법이 있지만, 가장 효율적인 방법은 다음과 같습니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2200
#, no-c-format
msgid ""
"SELECT\n"
"  name,\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM\n"
"  bc_municipality\n"
"ORDER BY hectares DESC\n"
"LIMIT 1;\n"
"\n"
"name           | hectares\n"
"---------------+-----------------\n"
"TUMBLER RIDGE  | 155020.02556131\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  name,\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM\n"
"  bc_municipality\n"
"ORDER BY hectares DESC\n"
"LIMIT 1;\n"
"\n"
"name           | hectares\n"
"---------------+-----------------\n"
"TUMBLER RIDGE  | 155020.02556131\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2202
#, no-c-format
msgid ""
"Note that in order to answer this query we have to calculate the area of "
"every polygon. If we were doing this a lot it would make sense to add an "
"area column to the table that we could separately index for performance. By "
"ordering the results in a descending direction, and them using the "
"PostgreSQL \"LIMIT\" command we can easily pick off the largest value "
"without using an aggregate function like max()."
msgstr ""
"이 문제에 답하기 위해 모든 폴리곤의 면적을 계산해야 한다는 점에 주의하십시"
"오. 이런 작업을 많이 해야 한다면, 테이블에 비교를 위해 별도로 인덱스 작업을 "
"한 면적 열을 추가하는 편이 좋을 것입니다. 면적이 넓은 순으로 결과값을 정렬한 "
"다음 PostgreSQL의 \"LIMIT\" 명령어를 사용해서 max() 같은 종합 함수를 이용하"
"지 않고도 가장 넓은 값을 쉽게 골라낼 수 있습니다."

#. Tag: para
#: using_postgis_dataman.xml:2214
#, no-c-format
msgid "What is the length of roads fully contained within each municipality?"
msgstr "각 지자체 안에 완전히 들어가 있는 도로의 총연장은 얼마나 됩니까?"

#. Tag: para
#: using_postgis_dataman.xml:2219
#, no-c-format
msgid ""
"This is an example of a \"spatial join\", because we are bringing together "
"data from two tables (doing a join) but using a spatial interaction "
"condition (\"contained\") as the join condition rather than the usual "
"relational approach of joining on a common key:"
msgstr ""
"이 문제는 \"공간 연결(spatial join)\"의 예시입니다. 두 테이블로부터 데이터를 "
"함께 모으지만(연결), 연결 조건으로 흔히 쓰이는 공통 키(common key)를 기반으"
"로 연결하는 관계 접근법 대신 공간 교차 조건(\"들어가 있는\")을 이용하기 때문"
"입니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2225
#, no-c-format
msgid ""
"SELECT\n"
"  m.name,\n"
"  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  ST_Contains(m.the_geom,r.the_geom)\n"
"GROUP BY m.name\n"
"ORDER BY roads_km;\n"
"\n"
"name                        | roads_km\n"
"----------------------------+------------------\n"
"SURREY                      | 1539.47553551242\n"
"VANCOUVER                   | 1450.33093486576\n"
"LANGLEY DISTRICT            | 833.793392535662\n"
"BURNABY                     | 773.769091404338\n"
"PRINCE GEORGE               | 694.37554369147\n"
"..."
msgstr ""
"SELECT\n"
"  m.name,\n"
"  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  ST_Contains(m.the_geom,r.the_geom)\n"
"GROUP BY m.name\n"
"ORDER BY roads_km;\n"
"\n"
"name                        | roads_km\n"
"----------------------------+------------------\n"
"SURREY                      | 1539.47553551242\n"
"VANCOUVER                   | 1450.33093486576\n"
"LANGLEY DISTRICT            | 833.793392535662\n"
"BURNABY                     | 773.769091404338\n"
"PRINCE GEORGE               | 694.37554369147\n"
"..."

#. Tag: para
#: using_postgis_dataman.xml:2227
#, no-c-format
msgid ""
"This query takes a while, because every road in the table is summarized into "
"the final result (about 250K roads for our particular example table). For "
"smaller overlays (several thousand records on several hundred) the response "
"can be very fast."
msgstr ""
"테이블에 있는 모든 도로를 최종 결과(현재 예시 테이블의 경우 약 250,000개의 도"
"로)로 요약하기 때문에 이 쿼리는 시간이 걸립니다. 더 작은 오버레이(수백 개의 "
"도로에 대한 수천 레코드 정도)라면, 응답도 매우 빠를 것입니다."

#. Tag: para
#: using_postgis_dataman.xml:2236
#, no-c-format
msgid "Create a new table with all the roads within the city of Prince George."
msgstr ""
"프린스 조지 시 내부에 있는 모든 도로를 가진 새로운 테이블을 생성하십시오."

#. Tag: para
#: using_postgis_dataman.xml:2241
#, no-c-format
msgid ""
"This is an example of an \"overlay\", which takes in two tables and outputs "
"a new table that consists of spatially clipped or cut resultants. Unlike the "
"\"spatial join\" demonstrated above, this query actually creates new "
"geometries. An overlay is like a turbo-charged spatial join, and is useful "
"for more exact analysis work:"
msgstr ""
"이 지시는 \"오버레이\"에 대한 예시입니다. 오버레이 쿼리는 두 테이블을 읽어들"
"여 공간적으로 오려내거나 잘라낸 결과값으로 이루어진 새로운 테이블을 산출합니"
"다. 앞에서 나온 \"공간 연결\"과는 달리, 이 쿼리는 실제로 새 도형을 생성합니"
"다. 오버레이는 터보차저가 달린 공간 연결이라 할 수 있고, 더 정확한 분석 작업"
"에 유용합니다:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2248
#, no-c-format
msgid ""
"CREATE TABLE pg_roads as\n"
"SELECT\n"
"  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
"  ST_Length(r.the_geom) AS rd_orig_length,\n"
"  r.*\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);"
msgstr ""
"CREATE TABLE pg_roads as\n"
"SELECT\n"
"  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
"  ST_Length(r.the_geom) AS rd_orig_length,\n"
"  r.*\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);"

#. Tag: para
#: using_postgis_dataman.xml:2254
#, no-c-format
msgid "What is the length in kilometers of \"Douglas St\" in Victoria?"
msgstr ""
"빅토리아 시의 \"더글러스 거리(Douglas St)\"의 길이는 몇 킬로미터입니까?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2259
#, no-c-format
msgid ""
"SELECT\n"
"  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
"FROM\n"
"  bc_roads r,\n"
"  bc_municipality m\n"
"WHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA'\n"
"        AND ST_Contains(m.the_geom, r.the_geom) ;\n"
"\n"
"kilometers\n"
"------------------\n"
"4.89151904172838\n"
"(1 row)"
msgstr ""
"SELECT\n"
"  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
"FROM\n"
"  bc_roads r,\n"
"  bc_municipality m\n"
"WHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA'\n"
"        AND ST_Contains(m.the_geom, r.the_geom) ;\n"
"\n"
"kilometers\n"
"------------------\n"
"4.89151904172838\n"
"(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2265
#, no-c-format
msgid "What is the largest municipality polygon that has a hole?"
msgstr "구멍이 있는 지자체 폴리곤 가운데 가장 넓은 곳은 어디입니까?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2270
#, no-c-format
msgid ""
"SELECT gid, name, ST_Area(the_geom) AS area\n"
"FROM bc_municipality\n"
"WHERE ST_NRings(the_geom) &gt; 1\n"
"ORDER BY area DESC LIMIT 1;\n"
"\n"
"gid  | name         | area\n"
"-----+--------------+------------------\n"
"12   | SPALLUMCHEEN | 257374619.430216\n"
"(1 row)"
msgstr ""
"SELECT gid, name, ST_Area(the_geom) AS area\n"
"FROM bc_municipality\n"
"WHERE ST_NRings(the_geom) &gt; 1\n"
"ORDER BY area DESC LIMIT 1;\n"
"\n"
"gid  | name         | area\n"
"-----+--------------+------------------\n"
"12   | SPALLUMCHEEN | 257374619.430216\n"
"(1 row)"

#~ msgid ""
#~ "Examples of the text representations (EWKT) of the extended spatial "
#~ "objects of the features are as follows. The * ones are new in this "
#~ "version of PostGIS:"
#~ msgstr ""
#~ "다음은 확장 공간 객체 피처의 텍스트 문자열 표현식(EWKT)의 예시입니다. * 표"
#~ "시는 이번 PostGIS 버전에 새로 추가되었다는 의미입니다."

#~ msgid ""
#~ "However they may be registered as a generic geometry column if the column "
#~ "was not defined as a specific type during creation."
#~ msgstr ""
#~ "하지만 생성시 특정 유형으로 정의하지 않은 열이라면 일반 도형 열로 등록될 "
#~ "수도 있습니다."
