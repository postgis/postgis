# SOME DESCRIPTIVE TITLE.
#
# Translators:
# Andreas Schild <andreas.schild@bfw.gv.at>, 2017,2019
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2020-12-15 04:51+0000\n"
"PO-Revision-Date: 2019-03-11 15:08+0000\n"
"Last-Translator: Andreas Schild <andreas.schild@bfw.gv.at>\n"
"Language-Team: German (http://www.transifex.com/postgis/postgis/language/"
"de/)\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. Tag: para
#: reference_processing.xml:5
#, no-c-format
msgid ""
"These functions compute geometric constructions, or alter geometry size or "
"shape."
msgstr ""

#. Tag: title
#: reference_processing.xml:11
#, no-c-format
msgid "Geometry Processing"
msgstr "Geometrieverarbeitung"

#. Tag: refname
#: reference_processing.xml:15
#, no-c-format
msgid "ST_Buffer"
msgstr "ST_Buffer"

#. Tag: refpurpose
#: reference_processing.xml:17
#, fuzzy, no-c-format
msgid ""
"Returns a geometry covering all points within a given distance from a "
"geometry."
msgstr ""
"(T) Gibt eine Geometrie zurück, welche alle Punkte innerhalb einer gegebenen "
"Entfernung von der Eingabegeometrie beinhaltet."

#. Tag: funcsynopsis
#: reference_processing.xml:23
#, fuzzy, no-c-format
msgid ""
"<funcprototype> <funcdef>geometry <function>ST_Buffer</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></"
"paramdef> <paramdef choice=\"opt\"><type>text </type> "
"<parameter>buffer_style_parameters = ''</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>geometry <function>ST_Buffer</"
"function></funcdef> <paramdef><type>geometry </type> <parameter>g1</"
"parameter></paramdef> <paramdef><type>float </type> "
"<parameter>radius_of_buffer</parameter></paramdef> <paramdef><type>integer </"
"type> <parameter>num_seg_quarter_circle</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>geography <function>ST_Buffer</"
"function></funcdef> <paramdef><type>geography </type> <parameter>g1</"
"parameter></paramdef> <paramdef><type>float </type> "
"<parameter>radius_of_buffer</parameter></paramdef> <paramdef choice=\"opt"
"\"><type>text </type> <parameter>buffer_style_parameters</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>geography "
"<function>ST_Buffer</function></funcdef> <paramdef><type>geography </type> "
"<parameter>g1</parameter></paramdef> <paramdef><type>float </type> "
"<parameter>radius_of_buffer</parameter></paramdef> <paramdef><type>integer </"
"type> <parameter>num_seg_quarter_circle</parameter></paramdef> </"
"funcprototype>"
msgstr ""
"<funcprototype> <funcdef>geometry <function>ST_Buffer</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
"<function>ST_Buffer</function></funcdef> <paramdef><type>geometry </type> "
"<parameter>g1</parameter></paramdef> <paramdef><type>float </type> "
"<parameter>radius_of_buffer</parameter></paramdef> <paramdef><type>integer </"
"type> <parameter>num_seg_quarter_circle</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>geometry <function>ST_Buffer</"
"function></funcdef> <paramdef><type>geometry </type> <parameter>g1</"
"parameter></paramdef> <paramdef><type>float </type> "
"<parameter>radius_of_buffer</parameter></paramdef> <paramdef><type>text </"
"type> <parameter>buffer_style_parameters</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>geography <function>ST_Buffer</"
"function></funcdef> <paramdef><type>geography </type> <parameter>g1</"
"parameter></paramdef> <paramdef><type>float </type> "
"<parameter>radius_of_buffer_in_meters</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>geography <function>ST_Buffer</"
"function></funcdef> <paramdef><type>geography </type> <parameter>g1</"
"parameter></paramdef> <paramdef><type>float </type> "
"<parameter>radius_of_buffer</parameter></paramdef> <paramdef><type>integer </"
"type> <parameter>num_seg_quarter_circle</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>geography <function>ST_Buffer</"
"function></funcdef> <paramdef><type>geography </type> <parameter>g1</"
"parameter></paramdef> <paramdef><type>float </type> "
"<parameter>radius_of_buffer</parameter></paramdef> <paramdef><type>text </"
"type> <parameter>buffer_style_parameters</parameter></paramdef> </"
"funcprototype>"

#. Tag: title
#: reference_processing.xml:57 reference_processing.xml:291
#: reference_processing.xml:373 reference_processing.xml:488
#: reference_processing.xml:641 reference_processing.xml:715
#: reference_processing.xml:814 reference_processing.xml:873
#: reference_processing.xml:948 reference_processing.xml:1021
#: reference_processing.xml:1082 reference_processing.xml:1136
#: reference_processing.xml:1173 reference_processing.xml:1232
#: reference_processing.xml:1389 reference_processing.xml:1436
#: reference_processing.xml:1494 reference_processing.xml:1532
#: reference_processing.xml:1608 reference_processing.xml:1658
#: reference_processing.xml:1699 reference_processing.xml:1740
#: reference_processing.xml:1787 reference_processing.xml:1855
#: reference_processing.xml:1943
#, no-c-format
msgid "Description"
msgstr "Beschreibung"

#. Tag: para
#: reference_processing.xml:59
#, no-c-format
msgid ""
"Returns a geometry/geography that represents all points whose distance from "
"this Geometry/geography is less than or equal to distance."
msgstr ""
"Gibt eine Geometrie/Geographie zurück, die alle Punkte repräsentiert, deren "
"Entfernung von dieser Geometrie/Geographie kleiner oder gleich der gegebenen "
"Entfernung ist."

#. Tag: para
#: reference_processing.xml:61
#, no-c-format
msgid ""
"Geometry: Calculations are in the Spatial Reference System of the geometry. "
"Introduced in 1.5 support for different end cap and mitre settings to "
"control shape."
msgstr ""
"Geometrie: Berechnungen werden im Koordinatenreferenzsystem der Geometrie "
"durchgeführt. Mit 1.5 wurde die Unterstützung unterschiedlicher "
"Abschlussstücke/end-cap und Gehrungen/mitre eingeführt, um die Gestalt zu "
"kontrollieren."

#. Tag: para
#: reference_processing.xml:64
#, no-c-format
msgid ""
"Negative radii: For polygons, a negative radius can be used, which will "
"shrink the polygon rather than expanding it."
msgstr ""
"Negative Radien: Bei Polygonen kann ein negativer Radius vergewendet werden, "
"wodurch das Polygon geschrumpft anstatt vergrößert wird."

#. Tag: para
#: reference_processing.xml:65
#, no-c-format
msgid ""
"Geography: For geography this is really a thin wrapper around the geometry "
"implementation. It first determines the best SRID that fits the bounding box "
"of the geography object (favoring UTM, Lambert Azimuthal Equal Area (LAEA) "
"north/south pole, and falling back on mercator in worst case scenario) and "
"then buffers in that planar spatial ref and retransforms back to WGS84 "
"geography."
msgstr ""
"Geographie: Beim geographischen Datentyp handelt es sich lediglich um einen "
"schlanken Adapter, der um die geometrische Implementation herumgelegt wurde. "
"Zuerst wird die passenste SRID für das Umgebungsrechteck des geographischen "
"Objektes bestimmt (bevorzugt UTM, Lambert Azimuthal Equal Area (LAEA) Nord/"
"Süd Pol, im schlimmsten Fall wird auf Mercator zurückgegriffen), dann im "
"planaren Koordinatenreferenzsystem gepuffert und anschließend nach WGS84 "
"Geographie zurück transformiert."

#. Tag: para
#: reference_processing.xml:67
#, no-c-format
msgid ""
"For geography this may not behave as expected if object is sufficiently "
"large that it falls between two UTM zones or crosses the dateline"
msgstr ""
"Beim geographischen Datentyp kann sich dies anders verhalten als erwartet, "
"nämlich dann, wenn das Objekt entrsprechend groß ist und zwischen zwei UTM-"
"Zonen fällt oder eine Datumsgrenze überschreitet."

#. Tag: para
#: reference_processing.xml:69
#, no-c-format
msgid ""
"Enhanced: 2.5.0 - ST_Buffer geometry support was enhanced to allow for side "
"buffering specification <code>side=both|left|right</code>."
msgstr ""

#. Tag: para
#: reference_processing.xml:70
#, fuzzy, no-c-format
msgid ""
"Availability: 1.5 - ST_Buffer was enhanced to support different endcaps and "
"join types. These are useful for example to convert road linestrings into "
"polygon roads with flat or square edges instead of rounded edges. Thin "
"wrapper for geography was added."
msgstr ""
"Verfügbarkeit: 1.5 - ST_Buffer wurde um die Unterstützung von "
"Abschlusstücken/endcaps und Join-Typen erweitert. Diese können zum Beispiel "
"dazu verwendet werden, um Linienzüge von Straßen in Straßenpolygone mit "
"flachen oder rechtwinkeligen Abschlüssen anstatt mit runden Enden "
"umzuwandeln. Ein schlanker Adapter für den geographischen Datentyp wurde "
"hinzugefügt. - benötigt GEOS &gt;= 3.2 um diese erweiterte geometrische "
"Funktionalität auszunutzen."

#. Tag: para
#: reference_processing.xml:73
#, no-c-format
msgid ""
"The optional third parameter (currently only applies to geometry) can either "
"specify number of segments used to approximate a quarter circle (integer "
"case, defaults to 8) or a list of blank-separated key=value pairs (string "
"case) to tweak operations as follows:"
msgstr ""
"Der optionale dritte Parameter (zurzeit nur auf den geometrischen Datentyp "
"anwendbar) ermöglicht es die Anzahl der Segmente zur Näherung eines "
"Viertelkreises (Ganzzahl, standardmäßig 8) oder eine Liste von "
"leerzeichengetrennten key=value Paaren (string case) festzulegen, um die "
"Berechnungen wie folgt zu optimieren:"

#. Tag: para
#: reference_processing.xml:77 reference_processing.xml:1259
#, no-c-format
msgid ""
"'quad_segs=#' : number of segments used to approximate a quarter circle "
"(defaults to 8)."
msgstr ""
"'quad_segs=#' : Anzahl der Segmente die verwendet werden um einen "
"Viertelkreis anzunähern (standardmäßig 8)."

#. Tag: para
#: reference_processing.xml:80
#, fuzzy, no-c-format
msgid ""
"'endcap=round|flat|square' : endcap style (defaults to \"round\"). 'butt' is "
"also accepted as a synonym for 'flat'."
msgstr ""
"'endcap=round|flat|square' : endcap style (standardmäßig \"round\", benötigt "
"GEOS-3.2 oder höher für andere Werte). 'butt' kann auch als Synonym für "
"'flat' verwendet werden."

#. Tag: para
#: reference_processing.xml:83 reference_processing.xml:1262
#, no-c-format
msgid ""
"'join=round|mitre|bevel' : join style (defaults to \"round\"). 'miter' is "
"also accepted as a synonym for 'mitre'."
msgstr ""
"'join=round|mitre|bevel' : join style (defaults to \"round\"). 'miter' kann "
"auch als Synonym für 'mitre' verwendet werden."

#. Tag: para
#: reference_processing.xml:86
#, no-c-format
msgid ""
"'mitre_limit=#.#' : mitre ratio limit (only affects mitered join style). "
"'miter_limit' is also accepted as a synonym for 'mitre_limit'."
msgstr ""
"'mitre_limit=#.#' : Gehrungsobergrenze (beeinflusst nur "
"Gehrungsverbindungen). 'miter_limit' kann auch als Synonym von 'mitre_limit' "
"verwendet werden."

#. Tag: para
#: reference_processing.xml:89
#, no-c-format
msgid ""
"'side=both|left|right' : 'left' or 'right' performs a single-sided buffer on "
"the geometry, with the buffered side relative to the direction of the line. "
"This is only really relevant to LINESTRING geometry and does not affect "
"POINT or POLYGON geometries. By default end caps are square."
msgstr ""

#. Tag: para
#: reference_processing.xml:95
#, no-c-format
msgid "Units of radius are measured in units of the spatial reference system."
msgstr ""
"Die Einheiten des Radius werden in den Einheiten des "
"Koordinatenreferenzsystems gemessen."

#. Tag: para
#: reference_processing.xml:96
#, no-c-format
msgid ""
"The inputs can be POINTS, MULTIPOINTS, LINESTRINGS, MULTILINESTRINGS, "
"POLYGONS, MULTIPOLYGONS, and GeometryCollections."
msgstr ""
"Es können POINTS, MULTIPOINTS, LINESTRINGS, MULTILINESTRINGS, POLYGONS, "
"MULTIPOLYGONS, und Sammelgeometrien/GeometryCollections eingegeben werden."

#. Tag: para
#: reference_processing.xml:97
#, no-c-format
msgid ""
"This function ignores the third dimension (z) and will always give a 2-d "
"buffer even when presented with a 3d-geometry."
msgstr ""
"Diese Funktion ignoriert die dritte Dimension (z) und gibt immer einen 2-D "
"Buffer zurück, sogar dann wenn eine 3D-Geometrie überreicht wird."

#. Tag: para
#: reference_processing.xml:99 reference_processing.xml:725
#: reference_processing.xml:1092 reference_processing.xml:1250
#: reference_processing.xml:1274 reference_processing.xml:1454
#: reference_processing.xml:1537 reference_processing.xml:1667
#: reference_processing.xml:1873 reference_processing.xml:1964
#, no-c-format
msgid "Performed by the GEOS module."
msgstr "Wird vom GEOS Modul ausgeführt"

#. Tag: para
#: reference_processing.xml:100 reference_processing.xml:663
#, no-c-format
msgid "&sfs_compliant; s2.1.1.3"
msgstr "&sfs_compliant; s2.1.1.3"

#. Tag: para
#: reference_processing.xml:101
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.17"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.17"

#. Tag: para
#: reference_processing.xml:103
#, no-c-format
msgid ""
"People often make the mistake of using this function to try to do radius "
"searches. Creating a buffer to a radius search is slow and pointless. Use "
"<xref linkend=\"ST_DWithin\"/> instead."
msgstr ""
"Fälschlicherweise wird diese Funktion oft zur Umkreissuche verwendet. Die "
"Erzeugung eines Puffers zur Umkreissuche ist langsam und witzlos. Benutzen "
"Sie bitte stattdessen <xref linkend=\"ST_DWithin\"/>."

#. Tag: title
#: reference_processing.xml:108 reference_processing.xml:309
#: reference_processing.xml:401 reference_processing.xml:531
#: reference_processing.xml:669 reference_processing.xml:832
#: reference_processing.xml:887 reference_processing.xml:977
#: reference_processing.xml:1038 reference_processing.xml:1102
#: reference_processing.xml:1148 reference_processing.xml:1193
#: reference_processing.xml:1283 reference_processing.xml:1401
#: reference_processing.xml:1503 reference_processing.xml:1630
#: reference_processing.xml:1672 reference_processing.xml:1712
#: reference_processing.xml:1757 reference_processing.xml:1814
#: reference_processing.xml:1879 reference_processing.xml:1970
#, no-c-format
msgid "Examples"
msgstr "Beispiele"

#. Tag: para
#: reference_processing.xml:119
#, no-c-format
msgid "quad_segs=8 (default)"
msgstr "quad_segs=8 (Standardwert)"

#. Tag: programlisting
#: reference_processing.xml:122
#, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText('POINT(100 90)'),\n"
" 50, 'quad_segs=8');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText('POINT(100 90)'),\n"
" 50, 'quad_segs=8');"

#. Tag: para
#: reference_processing.xml:130
#, no-c-format
msgid "quad_segs=2 (lame)"
msgstr "quad_segs=2 (lahme Ente)"

#. Tag: programlisting
#: reference_processing.xml:133
#, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText('POINT(100 90)'),\n"
" 50, 'quad_segs=2');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText('POINT(100 90)'),\n"
" 50, 'quad_segs=2');"

#. Tag: para
#: reference_processing.xml:142
#, no-c-format
msgid "endcap=round join=round (default)"
msgstr "endcap=round join=round (Standardwert)"

#. Tag: programlisting
#: reference_processing.xml:145
#, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'endcap=round join=round');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'endcap=round join=round');"

#. Tag: para
#: reference_processing.xml:153
#, no-c-format
msgid "endcap=square"
msgstr "endcap=square"

#. Tag: programlisting
#: reference_processing.xml:156
#, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'endcap=square join=round');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'endcap=square join=round');"

#. Tag: para
#: reference_processing.xml:164
#, no-c-format
msgid "endcap=flat"
msgstr "endcap=flat"

#. Tag: programlisting
#: reference_processing.xml:167
#, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'endcap=flat join=round');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'endcap=flat join=round');"

#. Tag: para
#: reference_processing.xml:176
#, no-c-format
msgid "join=bevel"
msgstr "join=bevel"

#. Tag: programlisting
#: reference_processing.xml:179
#, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=bevel');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=bevel');"

#. Tag: para
#: reference_processing.xml:187
#, no-c-format
msgid "join=mitre mitre_limit=5.0 (default mitre limit)"
msgstr "join=mitre mitre_limit=5.0 (default mitre limit)"

#. Tag: programlisting
#: reference_processing.xml:190
#, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=mitre mitre_limit=5.0');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=mitre mitre_limit=5.0');"

#. Tag: para
#: reference_processing.xml:198
#, no-c-format
msgid "join=mitre mitre_limit=1"
msgstr "join=mitre mitre_limit=1"

#. Tag: programlisting
#: reference_processing.xml:201
#, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=mitre mitre_limit=1.0');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=mitre mitre_limit=1.0');"

#. Tag: para
#: reference_processing.xml:210
#, no-c-format
msgid "side=left"
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:213
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'side=left');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=bevel');"

#. Tag: para
#: reference_processing.xml:221
#, no-c-format
msgid "side=right"
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:224
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'side=right');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=bevel');"

#. Tag: para
#: reference_processing.xml:232
#, no-c-format
msgid "side=left join=mitre"
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:235
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'side=left join=mitre');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=bevel');"

#. Tag: para
#: reference_processing.xml:244
#, no-c-format
msgid "right-hand-winding, polygon boundary side=left"
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:247
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
"ST_ForceRHR(\n"
"ST_Boundary(\n"
" ST_GeomFromText(\n"
"'POLYGON ((50 50, 50 150, 150 150, 150 50, 50 50))'))),\n"
" ), 20, 'side=left');"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=bevel');"

#. Tag: para
#: reference_processing.xml:254
#, no-c-format
msgid "right-hand-winding, polygon boundary side=right"
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:257
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Buffer(\n"
"ST_ForceRHR(\n"
"ST_Boundary(\n"
" ST_GeomFromText(\n"
"'POLYGON ((50 50, 50 150, 150 150, 150 50, 50 50))'))\n"
"), 20,'side=right')"
msgstr ""
"SELECT ST_Buffer(\n"
" ST_GeomFromText(\n"
"  'LINESTRING(50 50,150 150,150 50)'\n"
" ), 10, 'join=bevel');"

#. Tag: programlisting
#: reference_processing.xml:264
#, fuzzy, no-c-format
msgid ""
"--A buffered point approximates a circle\n"
"-- A buffered point forcing approximation of (see diagram)\n"
"-- 2 points per quarter circle is poly with 8 sides (see diagram)\n"
"SELECT ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As "
"promisingcircle_pcount,\n"
"ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50, 2)) As "
"lamecircle_pcount;\n"
"\n"
"promisingcircle_pcount | lamecircle_pcount\n"
"------------------------+-------------------\n"
"             33 |                9\n"
"\n"
"--A lighter but lamer circle\n"
"-- only 2 points per quarter circle is an octagon\n"
"--Below is a 100 meter octagon\n"
"-- Note coordinates are in NAD 83 long lat which we transform\n"
"to Mass state plane meter and then buffer to get measurements in meters;\n"
"SELECT ST_AsText(ST_Buffer(\n"
"ST_Transform(\n"
"ST_SetSRID(ST_MakePoint(-71.063526, 42.35785),4269), 26986)\n"
",100,2)) As octagon;\n"
"----------------------\n"
"POLYGON((236057.59057465 900908.759918696,236028.301252769 "
"900838.049240578,235\n"
"957.59057465 900808.759918696,235886.879896532 "
"900838.049240578,235857.59057465\n"
"900908.759918696,235886.879896532 900979.470596815,235957.59057465 "
"901008.759918\n"
"696,236028.301252769 900979.470596815,236057.59057465 900908.759918696))"
msgstr ""
"-- Ein gepufferter Punkt nähert sich einem Kreis an (sh. Abbildung)\n"
"-- Ein gepufferter Punkt der die Annäherung mit 2 Punkten pro Viertelkreis "
"erzwingt\n"
"-- ist ein Polygon mit 8 Seiten  (sh. Abbildung)\n"
"SELECT ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As "
"promisingcircle_pcount,\n"
"ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50, 2)) As "
"lamecircle_pcount;\n"
"\n"
"promisingcircle_pcount | lamecircle_pcount\n"
"------------------------+-------------------\n"
"                         33 |                9\n"
"\n"
"-- Ein leichterer aber lahmer Kreis mit 2 Punkten pro Viertelkreis ist ein "
"Achteck\n"
"-- Unterhalb ein 100 Meter Achteck\n"
"-- Die Koordinaten sind in NAD 83 Länge/Breite und werden nach\n"
"-- Mass state plane Meter transformiert um Messungen in Meter zu bekommen\n"
"-- und anschließend gepuffert\n"
"\n"
"SELECT ST_AsText(ST_Buffer(\n"
"ST_Transform(\n"
"ST_SetSRID(ST_MakePoint(-71.063526, 42.35785),4269), 26986)\n"
",100,2)) As octagon;\n"
"----------------------\n"
"POLYGON((236057.59057465 900908.759918696,236028.301252769 "
"900838.049240578,235\n"
"957.59057465 900808.759918696,235886.879896532 "
"900838.049240578,235857.59057465\n"
"900908.759918696,235886.879896532 900979.470596815,235957.59057465 "
"901008.759918\n"
"696,236028.301252769 900979.470596815,236057.59057465 900908.759918696))"

#. Tag: title
#: reference_processing.xml:268 reference_processing.xml:333
#: reference_processing.xml:464 reference_processing.xml:620
#: reference_processing.xml:689 reference_processing.xml:789
#: reference_processing.xml:837 reference_processing.xml:998
#: reference_processing.xml:1033 reference_processing.xml:1060
#: reference_processing.xml:1097 reference_processing.xml:1115
#: reference_processing.xml:1143 reference_processing.xml:1185
#: reference_processing.xml:1365 reference_processing.xml:1407
#: reference_processing.xml:1465 reference_processing.xml:1509
#: reference_processing.xml:1580 reference_processing.xml:1635
#: reference_processing.xml:1677 reference_processing.xml:1717
#: reference_processing.xml:1762 reference_processing.xml:1821
#: reference_processing.xml:1904 reference_processing.xml:2023
#, no-c-format
msgid "See Also"
msgstr "Siehe auch"

#. Tag: para
#: reference_processing.xml:270
#, no-c-format
msgid ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_SetSRID\"/>, <xref "
"linkend=\"ST_Transform\"/>, <xref linkend=\"ST_Union\"/>"
msgstr ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_SetSRID\"/>, <xref "
"linkend=\"ST_Transform\"/>, <xref linkend=\"ST_Union\"/>"

#. Tag: refname
#: reference_processing.xml:276
#, no-c-format
msgid "ST_BuildArea"
msgstr "ST_BuildArea"

#. Tag: refpurpose
#: reference_processing.xml:278
#, fuzzy, no-c-format
msgid "Creates a polygonal geometry formed by the linework of a geometry."
msgstr ""
"Erzeugt eine Flächengeometrie aus den einzelnen Linien einer gegebenen "
"Geometrie"

#. Tag: funcprototype
#: reference_processing.xml:283
#, fuzzy, no-c-format
msgid ""
"<funcdef>geometry <function>ST_BuildArea</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_BuildArea</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>A</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:293
#, fuzzy, no-c-format
msgid ""
"Creates an areal geometry formed by the constituent linework of the input "
"geometry. The input can be LINESTRINGS, MULTILINESTRINGS, POLYGONS, "
"MULTIPOLYGONS, and GeometryCollections. The result is a Polygon or "
"MultiPolygon, depending on input. If the input linework does not form "
"polygons, NULL is returned."
msgstr ""
"Erzeugt eine Flächengeometrie aus den einzelnen Linien einer gegebenen "
"Geometrie. Der zurückgegebene Datentyp ist, abhängig von der Eingabe, ein "
"Polygon oder ein MultiPolygon. Wenn das Eingabe-Liniennetz keine Polygone "
"bildet, wird NULL zurückgegeben. Die Eingabe können LineStrings, "
"MultiLinestrings, Polygons, MultiPolygons und GeometryCollections sein."

#. Tag: para
#: reference_processing.xml:299
#, fuzzy, no-c-format
msgid "This function assumes all inner geometries represent holes"
msgstr ""
"Diese Funktion nimmt an, dass alle inneren Geometrien Lücken/Inseln "
"darstellen."

#. Tag: para
#: reference_processing.xml:302
#, no-c-format
msgid ""
"Input linework must be correctly noded for this function to work properly"
msgstr ""
"Damit diese Funktion korrekt arbeitet, müssen die Knoten des eingegebenen "
"Liniennetzes richtig angeordnet sein"

#. Tag: para
#: reference_processing.xml:305
#, fuzzy, no-c-format
msgid "Availability: 1.1.0"
msgstr "Verfügbarkeit: 1.5.0"

#. Tag: para
#: reference_processing.xml:319
#, fuzzy, no-c-format
msgid "These will create a donut"
msgstr "Erzeugt einen Donut"

#. Tag: programlisting
#: reference_processing.xml:322
#, fuzzy, no-c-format
msgid ""
"--using polygons\n"
"SELECT ST_BuildArea(ST_Collect(smallc,bigc))\n"
"FROM (SELECT\n"
"    ST_Buffer(\n"
"      ST_GeomFromText('POINT(100 90)'), 25) As smallc,\n"
"    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As bigc) As foo;"
msgstr ""
"SELECT ST_BuildArea(ST_Collect(smallc,bigc))\n"
"FROM (SELECT\n"
"        ST_Buffer(\n"
"          ST_GeomFromText('POINT(100 90)'), 25) As smallc,\n"
"        ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As bigc) As foo;"

#. Tag: programlisting
#: reference_processing.xml:324
#, fuzzy, no-c-format
msgid ""
"--using linestrings\n"
"SELECT ST_BuildArea(ST_Collect(smallc,bigc))\n"
"FROM (SELECT\n"
"    ST_ExteriorRing(ST_Buffer(\n"
"      ST_GeomFromText('POINT(100 90)'), 25)) As smallc,\n"
"    ST_ExteriorRing(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As "
"bigc) As foo;"
msgstr ""
"SELECT ST_BuildArea(ST_Collect(smallc,bigc))\n"
"FROM (SELECT\n"
"        ST_Buffer(\n"
"          ST_GeomFromText('POINT(100 90)'), 25) As smallc,\n"
"        ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As bigc) As foo;"

#. Tag: para
#: reference_processing.xml:335
#, fuzzy, no-c-format
msgid ""
", <xref linkend=\"ST_MakePolygon\"/>, <xref linkend=\"ST_MakeValid\"/>, "
"<xref linkend=\"ST_BdPolyFromText\"/>, <xref linkend=\"ST_BdMPolyFromText\"/"
"> (wrappers to this function with standard OGC interface)"
msgstr ""
", <xref linkend=\"ST_MakePolygon\"/>, <xref linkend=\"ST_BdPolyFromText\"/>, "
"<xref linkend=\"ST_BdMPolyFromText\"/> Adapter für diese Funktion mit der "
"OGC-Standardschnittstelle"

#. Tag: refname
#: reference_processing.xml:347
#, no-c-format
msgid "ST_Centroid"
msgstr ""

#. Tag: refpurpose
#: reference_processing.xml:349
#, fuzzy, no-c-format
msgid "Returns the geometric center of a geometry."
msgstr ""
"Gibt eine Sammelgeometrie zurück, die beim Auftrennen einer Geometrie "
"entsteht."

#. Tag: funcsynopsis
#: reference_processing.xml:353
#, fuzzy, no-c-format
msgid ""
"<funcprototype> <funcdef>geometry <function>ST_Centroid</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>geography <function>ST_Centroid</"
"function></funcdef> <paramdef><type>geography </type> <parameter>g1</"
"parameter></paramdef> <paramdef choice=\"opt\"><type>boolean </type> "
"<parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>geometry <function>ST_Intersection</function></"
"funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
"paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
"paramdef> </funcprototype> <funcprototype> <funcdef>geography "
"<function>ST_Intersection</function></funcdef> <paramdef> <type>geography</"
"type> <parameter>geogA</parameter> </paramdef> <paramdef> <type>geography</"
"type> <parameter>geogB</parameter> </paramdef> </funcprototype>"

#. Tag: para
#: reference_processing.xml:375
#, no-c-format
msgid ""
"Computes a point which is the geometric center of mass of a geometry. For "
"[<varname>MULTI</varname>]<varname>POINT</varname>s, the centroid is the "
"arithmetic mean of the input coordinates. For [<varname>MULTI</"
"varname>]<varname>LINESTRING</varname>s, the centroid is computed using the "
"weighted length of each line segment. For [<varname>MULTI</"
"varname>]<varname>POLYGON</varname>s, the centroid is computed in terms of "
"area. If an empty geometry is supplied, an empty "
"<varname>GEOMETRYCOLLECTION</varname> is returned. If <varname>NULL</"
"varname> is supplied, <varname>NULL</varname> is returned. If "
"<varname>CIRCULARSTRING</varname> or <varname>COMPOUNDCURVE</varname> are "
"supplied, they are converted to linestring wtih CurveToLine first, then same "
"than for <varname>LINESTRING</varname>"
msgstr ""

#. Tag: para
#: reference_processing.xml:388
#, no-c-format
msgid ""
"For mixed-dimension input, the result is equal to the centroid of the "
"component Geometries of highest dimension (since the lower-dimension "
"geometries contribute zero \"weight\" to the centroid)."
msgstr ""

#. Tag: para
#: reference_processing.xml:392
#, no-c-format
msgid ""
"New in 2.3.0 : support <varname>CIRCULARSTRING</varname> and "
"<varname>COMPOUNDCURVE</varname> (using CurveToLine)"
msgstr ""

#. Tag: para
#: reference_processing.xml:394
#, fuzzy, no-c-format
msgid "Availability: 2.4.0 support for geography was introduced."
msgstr ""
"Verfügbarkeit: 1.5 die Unterstützung des geograpischen Datentyps wurde "
"eingeführt"

#. Tag: para
#: reference_processing.xml:396
#, no-c-format
msgid "&sfs_compliant;"
msgstr "&sfs_compliant;"

#. Tag: para
#: reference_processing.xml:397
#, fuzzy, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 8.1.4, 9.5.5"
msgstr "&sqlmm_compliant; SQL-MM 3: 7.1.7"

#. Tag: para
#: reference_processing.xml:403
#, no-c-format
msgid ""
"In the following illustrations the green dot is the centroid of the source "
"geometry."
msgstr ""

#. Tag: para
#: reference_processing.xml:416
#, no-c-format
msgid "Centroid of a <varname>MULTIPOINT</varname>"
msgstr ""

#. Tag: para
#: reference_processing.xml:427
#, no-c-format
msgid "Centroid of a <varname>LINESTRING</varname>"
msgstr ""

#. Tag: para
#: reference_processing.xml:440
#, no-c-format
msgid "Centroid of a <varname>POLYGON</varname>"
msgstr ""

#. Tag: para
#: reference_processing.xml:451
#, fuzzy, no-c-format
msgid "Centroid of a <varname>GEOMETRYCOLLECTION</varname>"
msgstr ""
"Bitte nicht mit einer <varname>GEOMETRYCOLLECTION</varname> als Parameter "
"aufrufen"

#. Tag: programlisting
#: reference_processing.xml:460
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_Centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, 0 "
"1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'));\n"
"                st_astext\n"
"------------------------------------------\n"
" POINT(2.30769230769231 3.30769230769231)\n"
"(1 row)\n"
"\n"
"SELECT ST_AsText(ST_centroid(g))\n"
"FROM  ST_GeomFromText('CIRCULARSTRING(0 2, -1 1,0 0, 0.5 0, 1 0, 2 1, 1 2, "
"0.5 2, 0 2)')  AS g ;\n"
"------------------------------------------\n"
"POINT(0.5 1)\n"
"\n"
"\n"
"SELECT ST_AsText(ST_centroid(g))\n"
"FROM  ST_GeomFromText('COMPOUNDCURVE(CIRCULARSTRING(0 2, -1 1,0 0),(0 0, 0.5 "
"0, 1 0),CIRCULARSTRING( 1 0, 2 1, 1 2),(1 2, 0.5 2, 0 2))' ) AS g;\n"
"------------------------------------------\n"
"POINT(0.5 1)"
msgstr ""

#. Tag: para
#: reference_processing.xml:466
#, fuzzy, no-c-format
msgid ", <xref linkend=\"ST_GeometricMedian\"/>"
msgstr ", <xref linkend=\"ST_Union\"/>"

#. Tag: refname
#: reference_processing.xml:472
#, no-c-format
msgid "ST_ConcaveHull"
msgstr "ST_ConcaveHull"

#. Tag: refpurpose
#: reference_processing.xml:473
#, no-c-format
msgid ""
"Computes a possibly concave geometry that encloses all input geometry "
"vertices"
msgstr ""

#. Tag: funcprototype
#: reference_processing.xml:478
#, fuzzy, no-c-format
msgid ""
"<funcdef>geometry <function>ST_ConcaveHull</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>target_percent</parameter></"
"paramdef> <paramdef choice=\"opt\"><type>boolean </type> "
"<parameter>allow_holes = false</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_ConcaveHull</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>target_percent</parameter></"
"paramdef> <paramdef choice=\"opt\"><type>boolean </type> "
"<parameter>allow_holes=false</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:489
#, fuzzy, no-c-format
msgid ""
"The concave hull of a geometry represents a possibly concave geometry that "
"encloses the input geometry. The result is a single polygon, line or point. "
"It will not contain holes unless the optional <varname>allow_holes</varname> "
"argument is specified as true."
msgstr ""
"Die konkave Hülle einer Geometrie stellt eine möglicherweise konkave "
"Geometrie dar, welche alle Geometrien der Menge einschließt. Ob Polygone "
"Lücken aufweisen dürfen ist standardmäßig auf FALSE gesetzt. Das Ergebnis "
"ist niemals mehr als ein einzelnes Polygon."

#. Tag: para
#: reference_processing.xml:495
#, fuzzy, no-c-format
msgid ""
"The <varname>target_percent</varname> is the target percent of area of "
"convex hull the PostGIS solution will try to approach before giving up or "
"exiting. One can think of the concave hull as the geometry you get by vacuum "
"sealing a set of geometries. The target_percent of 1 will give you the same "
"answer as the convex hull. A target_percent between 0 and 0.99 will give you "
"something that should have a smaller area than the convex hull. This is "
"different from a convex hull which is more like wrapping a rubber band "
"around the set of geometries."
msgstr ""
"Der Eingabeparameter \"target_percent\" ist der Flächenanteil der konvexen "
"Hülle für den PostGIS eine Lösung annähert bevor es aufgibt oder beendet. "
"Man kann sich eine konkave Hülle als eine Geometrie vorstellen, die man "
"erhält wenn man einen Satz an Geometrien vakuumversiegelt. Ein "
"target_percent von 1 führt zum selben Ergebnis wie die konvexe Hülle. Ein "
"target_percent zwischen 0 und 0.99 ergibt eine kleinere Fläche als die "
"konvexe Hülle. Dies unterscheidet sich von der konvexen Hülle, welche eher "
"einem Gummiband entspricht, das den Satz an Geometrien umwickelt."

#. Tag: para
#: reference_processing.xml:501
#, fuzzy, no-c-format
msgid ""
"It is usually used with MULTI and Geometry Collections. It is not an "
"aggregate function, but can be used with <xref linkend=\"ST_Collect\"/> or "
"<xref linkend=\"ST_Union\"/> to get the concave hull of a set of points/"
"linestring/polygons (e.g. <code>ST_ConcaveHull(ST_Collect(somepointfield), "
"0.80)</code>."
msgstr ""
"Wird üblicherweise auf Mehrfach/MULTI- und Sammelgeometrien/"
"GeometryCollections angewandt. Obwohl es sich nicht um eine Aggregatfunktion "
"handelt, können Sie es in Verbindung mit ST_Collect oder ST_Union verwenden "
"um die konkave Hülle eines Satzes an Points/Linestrings/Polygons zu erhalten "
"- ST_ConcaveHull(ST_Collect(somepointfield), 0.80)."

#. Tag: para
#: reference_processing.xml:506
#, no-c-format
msgid ""
"It is slower to compute than the convex hull but generally has a smaller "
"result area and represents a more natural bounds of the input geometry."
msgstr ""

#. Tag: para
#: reference_processing.xml:510
#, no-c-format
msgid ""
"Note - If you are using with points, linestrings, or geometry collections "
"use ST_Collect. If you are using with polygons, use ST_Union since it may "
"fail with invalid geometries."
msgstr ""
"Anmerkung - Wenn Sie es auf Punkte, Linienzüge oder Sammelgeometrien "
"anwenden, werwenden Sie bitte ST_Collect. Bei Polygonen verwenden Sie bitte "
"ST_Union, da es bei invaliden Geometrien fehlschlagen kann."

#. Tag: para
#: reference_processing.xml:513
#, no-c-format
msgid ""
"Note - The smaller you make the target percent, the longer it takes to "
"process the concave hull and more likely to run into topological exceptions. "
"Also the more floating points and number of points you accrue. First try a "
"0.99 which does a first hop, is usually very fast, sometimes as fast as "
"computing the convex hull, and usually gives much better than 99% of shrink "
"since it almost always overshoots. Second hope of 0.98 it slower, others get "
"slower usually quadratically. To reduce precision and float points, use "
"<xref linkend=\"ST_SimplifyPreserveTopology\"/> or <xref linkend="
"\"ST_SnapToGrid\"/> after ST_ConcaveHull. ST_SnapToGrid is a bit faster, but "
"could result in invalid geometries where as ST_SimplifyPreserveTopology "
"almost always preserves the validity of the geometry."
msgstr ""
"Anmerkung - Umso kleiner Sie die target_percent ansetzen, desto länger "
"dauert die Berechnung der konkaven Hülle und desto wahrscheinlicher ist es, "
"das topologische Fehler auftreten. Dies gilt auch umso größer die Anzahl der "
"Kommastellen und die Anzahl der Punkte ist. Versuchen Sie zuerst eine 0.99, "
"dies ist üblicherweise sehr schnell, manchmal so schnell wie die Berechnung "
"der konvexen Hülle und ergibt meist einen viel besseren Wert als 99% "
"Schrumpfung, da es fast immer über das Ziel hinausschießt. Als nächstes "
"versuchen Sie 0.98; üblicherweise verlangsamt sich die Berechnung "
"quadratisch. Um die Präzision und Kommastellen zu verringern, verwenden Sie "
"bitte <xref linkend=\"ST_SimplifyPreserveTopology\"/> oder<xref linkend="
"\"ST_SnapToGrid\"/> nach ST_ConcaveHull. ST_SnapToGrid ist ein wenig "
"schneller, kann allerdings zu invaliden Geometrien führen, während "
"ST_SimplifyPreserveTopology meist die Validität der Geometrie erhält."

#. Tag: para
#: reference_processing.xml:518
#, no-c-format
msgid ""
"More real world examples and brief explanation of the technique are shown "
"<ulink url=\"http://www.bostongis.com/postgis_concavehull.snippet\">http://"
"www.bostongis.com/postgis_concavehull.snippet</ulink>"
msgstr ""
"Ein konkreteres Beispiel und eine kurze Erklärung der Technik finden Sie "
"unter <ulink url=\"http://www.bostongis.com/postgis_concavehull.snippet"
"\">http://www.bostongis.com/postgis_concavehull.snippet</ulink>"

#. Tag: para
#: reference_processing.xml:521
#, no-c-format
msgid ""
"Also check out Simon Greener's article on demonstrating ConcaveHull "
"introduced in Oracle 11G R2. <ulink url=\"http://www.spatialdbadvisor.com/"
"oracle_spatial_tips_tricks/172/concave-hull-geometries-in-"
"oracle-11gr2\">http://www.spatialdbadvisor.com/"
"oracle_spatial_tips_tricks/172/concave-hull-geometries-in-oracle-11gr2</"
"ulink>. The solution we get at 0.75 target percent of convex hull is similar "
"to the shape Simon gets with Oracle SDO_CONCAVEHULL_BOUNDARY."
msgstr ""
"Siehe auch Simon Greeners Artikel über ConcaveHull, die in Oracle 11G-R2 "
"eingeführt wurde. <ulink url=\"http://www.spatialdbadvisor.com/"
"oracle_spatial_tips_tricks/172/concave-hull-geometries-in-"
"oracle-11gr2\">http://www.spatialdbadvisor.com/"
"oracle_spatial_tips_tricks/172/concave-hull-geometries-in-oracle-11gr2</"
"ulink>. Die Lösung, die wir mit 0.75 target_percent der konvexen Hülle "
"erhalten ähnelt der Geometrieform, die Simon mit Oracle "
"SDO_CONCAVEHULL_BOUNDARY erhält."

#. Tag: para
#: reference_processing.xml:525 reference_processing.xml:661
#, no-c-format
msgid "Performed by the GEOS module"
msgstr "Wird vom GEOS Modul ausgeführt"

#. Tag: para
#: reference_processing.xml:527 reference_processing.xml:1538
#, no-c-format
msgid "Availability: 2.0.0"
msgstr "Verfügbarkeit: 2.0.0"

#. Tag: programlisting
#: reference_processing.xml:532
#, fuzzy, no-c-format
msgid ""
"--Get estimate of infected area based on point observations\n"
"SELECT d.disease_type,\n"
"    ST_ConcaveHull(ST_Collect(d.pnt_geom), 0.99) As geom\n"
"    FROM disease_obs As d\n"
"    GROUP BY d.disease_type;"
msgstr ""
"--Abschätzung der infizierten Fläche aus Punktbeobachtungen\n"
"SELECT d.disease_type,\n"
"        ST_ConcaveHull(ST_Collect(d.pnt_geom), 0.99) As geom\n"
"        FROM disease_obs As d\n"
"        GROUP BY d.disease_type;"

#. Tag: para
#: reference_processing.xml:542
#, no-c-format
msgid "ST_ConcaveHull of 2 polygons encased in target 100% shrink concave hull"
msgstr ""
"ST_ConcaveHull von 2 Polygonen die von einer konkaven Hülle mit 100% "
"Schrumpfung umhüllt werden."

#. Tag: programlisting
#: reference_processing.xml:545
#, fuzzy, no-c-format
msgid ""
"-- geometries overlaid with concavehull\n"
"-- at target 100% shrink (this is the same as convex hull - since no "
"shrink)\n"
"SELECT\n"
"    ST_ConcaveHull(\n"
"        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"            50 60, 125 100, 175 150))'),\n"
"        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"        ), 1)\n"
"     As convexhull;"
msgstr ""
"-- Geometrien mit konkaver Hülle überlagert\n"
"-- Ziel 100% Schrumpfung (dies entspricht der konvexen Hülle - keine "
"Schrumpfung)\n"
"SELECT\n"
"        ST_ConcaveHull(\n"
"                ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"                        50 60, 125 100, 175 150))'),\n"
"                ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                ), 1)\n"
"         As convexhull;"

#. Tag: para
#: reference_processing.xml:552
#, no-c-format
msgid ""
"-- geometries overlaid with concavehull at target 90% of convex hull area"
msgstr ""
"-- Geometrien überlagert mit der konkaven Hülle mit einem Zielwert von 90% "
"der konvexen Hülle"

#. Tag: programlisting
#: reference_processing.xml:556
#, fuzzy, no-c-format
msgid ""
"-- geometries overlaid with concavehull at target 90% shrink\n"
"SELECT\n"
"    ST_ConcaveHull(\n"
"        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"            50 60, 125 100, 175 150))'),\n"
"        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"        ), 0.9)\n"
"     As target_90;"
msgstr ""
"-- Geometrien überlagert mit der konkaven Hülle, die einen Zielwert von 90% "
"Schrumpfung hat\n"
"SELECT\n"
"        ST_ConcaveHull(\n"
"                ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"                        50 60, 125 100, 175 150))'),\n"
"                ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                ), 0.9)\n"
"         As target_90;"

#. Tag: para
#: reference_processing.xml:565
#, no-c-format
msgid "L Shape points overlaid with convex hull"
msgstr "Als L angeordnete Punkte mit der konvexen Hülle überlagert."

#. Tag: programlisting
#: reference_processing.xml:568
#, fuzzy, no-c-format
msgid ""
"-- this produces a table of 42 points that form an L shape\n"
"SELECT (ST_DumpPoints(ST_GeomFromText(\n"
"'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,\n"
"150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,\n"
"14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,\n"
"6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,\n"
"14 94,14 74,14 54,14 34,14 14)'))).geom\n"
"    INTO TABLE l_shape;\n"
"\n"
"SELECT ST_ConvexHull(ST_Collect(geom))\n"
"FROM l_shape;"
msgstr ""
"-- Erzeugt eine Tabelle mit 42 Punkten, die eine L-Form bilden\n"
"SELECT (ST_DumpPoints(ST_GeomFromText(\n"
"'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,\n"
"150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,\n"
"14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,\n"
"6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,\n"
"14 94,14 74,14 54,14 34,14 14)'))).geom\n"
"        INTO TABLE l_shape;\n"
"\n"
"SELECT ST_ConvexHull(ST_Collect(geom))\n"
"FROM l_shape;"

#. Tag: para
#: reference_processing.xml:575
#, no-c-format
msgid "ST_ConcaveHull of L points at target 99% of convex hull"
msgstr ""
"ST_ConcaveHull der als L angeordneten Punkte mit einem Zielwert von 99% der "
"konvexen Hülle"

#. Tag: programlisting
#: reference_processing.xml:578
#, fuzzy, no-c-format
msgid ""
"SELECT ST_ConcaveHull(ST_Collect(geom), 0.99)\n"
"    FROM l_shape;"
msgstr ""
"SELECT ST_ConcaveHull(ST_Collect(geom), 0.99)\n"
"        FROM l_shape;"

#. Tag: para
#: reference_processing.xml:587
#, no-c-format
msgid "Concave Hull of L points at target 80% convex hull area"
msgstr ""
"ST_ConcaveHull der als L angeordneten Punkte mit einem Zielwert von 80% der "
"Fläche der konvexen Hülle"

#. Tag: programlisting
#: reference_processing.xml:590
#, fuzzy, no-c-format
msgid ""
"-- Concave Hull L shape points\n"
"    -- at target 80% of convexhull\n"
"    SELECT ST_ConcaveHull(ST_Collect(geom), 0.80)\n"
"    FROM l_shape;"
msgstr ""
"-- Konkave Hülle derals L angeordneten Punkte\n"
"        -- mit einem Zielwert von 80% der konvexen Hülle\n"
"        SELECT ST_ConcaveHull(ST_Collect(geom), 0.80)\n"
"        FROM l_shape;"

#. Tag: para
#: reference_processing.xml:599
#, no-c-format
msgid "multilinestring overlaid with Convex hull"
msgstr "MultiLinestring überlagert mit konvexer Hülle "

#. Tag: para
#: reference_processing.xml:607
#, no-c-format
msgid ""
"multilinestring with overlaid with Concave hull of linestrings at 99% target "
"-- first hop"
msgstr ""
"MultiLineString überlagert mit der konkaven Hülle der LineStrings mit einem "
"Zielwert von 99% - erster Versuch"

#. Tag: programlisting
#: reference_processing.xml:611
#, fuzzy, no-c-format
msgid ""
"SELECT ST_ConcaveHull(ST_GeomFromText('MULTILINESTRING((106 164,30 112,74 "
"70,82 112,130 94,\n"
"    130 62,122 40,156 32,162 76,172 88),\n"
"(132 178,134 148,128 136,96 128,132 108,150 130,\n"
"170 142,174 110,156 96,158 90,158 88),\n"
"(22 64,66 28,94 38,94 68,114 76,112 30,\n"
"132 10,168 18,178 34,186 52,184 74,190 100,\n"
"190 122,182 148,178 170,176 184,156 164,146 178,\n"
"132 186,92 182,56 158,36 150,62 150,76 128,88 118))'),0.99)"
msgstr ""
"SELECT ST_ConcaveHull(ST_GeomFromText('MULTILINESTRING((106 164,30 112,74 "
"70,82 112,130 94,\n"
"        130 62,122 40,156 32,162 76,172 88),\n"
"(132 178,134 148,128 136,96 128,132 108,150 130,\n"
"170 142,174 110,156 96,158 90,158 88),\n"
"(22 64,66 28,94 38,94 68,114 76,112 30,\n"
"132 10,168 18,178 34,186 52,184 74,190 100,\n"
"190 122,182 148,178 170,176 184,156 164,146 178,\n"
"132 186,92 182,56 158,36 150,62 150,76 128,88 118))'),0.99)"

#. Tag: para
#: reference_processing.xml:621
#, no-c-format
msgid ""
", <xref linkend=\"ST_ConvexHull\"/>, <xref linkend="
"\"ST_SimplifyPreserveTopology\"/>, <xref linkend=\"ST_SnapToGrid\"/>"
msgstr ""
", <xref linkend=\"ST_ConvexHull\"/>, <xref linkend="
"\"ST_SimplifyPreserveTopology\"/>, <xref linkend=\"ST_SnapToGrid\"/>"

#. Tag: refname
#: reference_processing.xml:627
#, no-c-format
msgid "ST_ConvexHull"
msgstr "ST_ConvexHull"

#. Tag: refpurpose
#: reference_processing.xml:628
#, no-c-format
msgid "Computes the convex hull of a geometry."
msgstr ""

#. Tag: funcprototype
#: reference_processing.xml:633
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_ConvexHull</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_ConvexHull</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:642
#, fuzzy, no-c-format
msgid ""
"Computes the convex hull of a geometry. The convex hull is the smallest "
"convex geometry that encloses all geometries in the input."
msgstr ""
"<para>Die konvexe Hülle einer Geometrie stell die kleinste konvexe Geometrie "
"dar, welche den Satz von Geometrien umschließt.</para>"

#. Tag: para
#: reference_processing.xml:646
#, no-c-format
msgid ""
"In the general case the convex hull is a Polygon. The convex hull of two or "
"more collinear points is a two-point LineString. The convex hull of one or "
"more identical points is a Point."
msgstr ""

#. Tag: para
#: reference_processing.xml:650
#, fuzzy, no-c-format
msgid ""
"It is usually used with Multi* and GeometryCollections. It is not an "
"aggregate function. To compute the convex hull of a set of geometries, use "
"<xref linkend=\"ST_Collect\"/> to aggregate them."
msgstr ""
"Wird üblicherweise auf Mehrfach/MULTI- und Sammelgeometrien/"
"GeometryCollections angewandt. Obwohl es sich nicht um eine Aggregatfunktion "
"handelt, können Sie es in Verbindung mit ST_Collect verwenden um die konvexe "
"Hülle einer Punktmenge zu erhalten. "
"ST_ConvexHull(ST_Collect(somepointfield))."

#. Tag: para
#: reference_processing.xml:655
#, fuzzy, no-c-format
msgid ""
"One can think of the convex hull as the geometry obtained by wrapping an "
"elastic band around a set of geometries. This is different from a concave "
"hull which is analogous to \"shrink-wrapping\" the geometries. A convex hull "
"is often used to determine an affected area based on a set of point "
"observations."
msgstr ""
"Man kann sich die konvexe Hülle als eine Geometrie vorstellen, die man "
"erhält wenn man ein elastisches Band um einen Satz von Geometrien wickelt. "
"Dies unterscheidet sich von der konkaven Hülle, die analog dem "
"Vakuumverpacken von Geometrien ist."

#. Tag: para
#: reference_processing.xml:664
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.16"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.16"

#. Tag: para
#: reference_processing.xml:665 reference_processing.xml:727
#: reference_processing.xml:973 reference_processing.xml:1397
#, no-c-format
msgid "&Z_support;"
msgstr "&Z_support;"

#. Tag: para
#: reference_processing.xml:677
#, fuzzy, no-c-format
msgid "Convex Hull of a MultiLinestring and a MultiPoint"
msgstr ""
"Konvexe Hülle eines MultiLineString und eines MultiPoint gemeinsam mit dem "
"MultiLineString und dem MultiPoint"

#. Tag: programlisting
#: reference_processing.xml:680
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(ST_ConvexHull(\n"
"    ST_Collect(\n"
"        ST_GeomFromText('MULTILINESTRING((100 190,10 8),(150 10, 20 30))'),\n"
"            ST_GeomFromText('MULTIPOINT(50 5, 150 30, 50 10, 10 10)')\n"
"            )) );\n"
"---st_astext--\n"
"POLYGON((50 5,10 8,10 10,100 190,150 30,150 10,50 5))"
msgstr ""
"SELECT ST_AsText(ST_ConvexHull(\n"
"        ST_Collect(\n"
"                ST_GeomFromText('MULTILINESTRING((100 190,10 8),(150 10, 20 "
"30))'),\n"
"                        ST_GeomFromText('MULTIPOINT(50 5, 150 30, 50 10, 10 "
"10)')\n"
"                        )) );\n"
"---st_astext--\n"
"POLYGON((50 5,10 8,10 10,100 190,150 30,150 10,50 5))"

#. Tag: para
#: reference_processing.xml:683
#, no-c-format
msgid "Using with ST_Collect to compute the convex hulls of geometry sets."
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:685
#, fuzzy, no-c-format
msgid ""
"--Get estimate of infected area based on point observations\n"
"SELECT d.disease_type,\n"
"    ST_ConvexHull(ST_Collect(d.the_geom)) As the_geom\n"
"    FROM disease_obs As d\n"
"    GROUP BY d.disease_type;"
msgstr ""
"-- Abschätzung des infizierten Gebietes aus Punktbeobachtungen\n"
"SELECT d.disease_type,\n"
"        ST_ConvexHull(ST_Collect(d.the_geom)) As the_geom\n"
"        FROM disease_obs As d\n"
"        GROUP BY d.disease_type;"

#. Tag: para
#: reference_processing.xml:690
#, no-c-format
msgid ""
", <xref linkend=\"ST_ConcaveHull\"/>, <xref linkend="
"\"ST_MinimumBoundingCircle\"/>"
msgstr ""
", <xref linkend=\"ST_ConcaveHull\"/>, <xref linkend="
"\"ST_MinimumBoundingCircle\"/>"

#. Tag: refname
#: reference_processing.xml:696
#, no-c-format
msgid "ST_DelaunayTriangles"
msgstr "ST_DelaunayTriangles"

#. Tag: refpurpose
#: reference_processing.xml:698
#, fuzzy, no-c-format
msgid "Returns the Delaunay triangulation of the vertices of a geometry."
msgstr ""
"Gibt die Zellen des Voronoi Diagramms zurück, die aus den Knoten der "
"Geometrie erzeugt wurden."

#. Tag: funcprototype
#: reference_processing.xml:705
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_DelaunayTriangles</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>tolerance</parameter></paramdef> "
"<paramdef><type>int4 </type> <parameter>flags</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_DelaunayTriangles</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>tolerance</parameter></paramdef> "
"<paramdef><type>int4 </type> <parameter>flags</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:717
#, fuzzy, no-c-format
msgid ""
"Return the <ulink url=\"http://en.wikipedia.org/wiki/Delaunay_triangulation"
"\">Delaunay triangulation</ulink> of the vertices of the input geometry. "
"Output is a COLLECTION of polygons (for flags=0) or a MULTILINESTRING (for "
"flags=1) or TIN (for flags=2). The tolerance, if any, is used to snap input "
"vertices together."
msgstr ""
"Gibt eine <ulink url=\"http://en.wikipedia.org/wiki/Delaunay_triangulation"
"\">Delaunay-Triangulierung</ulink> rund um die Knoten der Eingabegeometrie "
"zurück. Die Ausgabe ist eine COLLECTION von Polygonen (flags=0), ein "
"MultiLineString (flags=1) oder ein TIN (flags=2). Die Toleranz, sofern "
"angegeben, wird zum Zusammenfangen von Knoten verwendet."

#. Tag: para
#: reference_processing.xml:726
#, fuzzy, no-c-format
msgid "Availability: 2.1.0"
msgstr "Verfügbarkeit: 2.0.0"

#. Tag: para
#: reference_processing.xml:728
#, no-c-format
msgid "&T_support;"
msgstr "&T_support;"

#. Tag: title
#: reference_processing.xml:732
#, no-c-format
msgid "2D Examples"
msgstr "2D Beispiele"

#. Tag: para
#: reference_processing.xml:741
#, no-c-format
msgid "Original polygons"
msgstr "Ursprüngliche Polygone"

#. Tag: programlisting
#: reference_processing.xml:744
#, fuzzy, no-c-format
msgid ""
"-- our original geometry --\n"
"    ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"            50 60, 125 100, 175 150))'),\n"
"        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"        )"
msgstr ""
"-- Unsere ursprüngliche Geometrie --\n"
"        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"                        50 60, 125 100, 175 150))'),\n"
"                ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                )"

#. Tag: para
#: reference_processing.xml:752
#, no-c-format
msgid ""
"ST_DelaunayTriangles of 2 polygons: delaunay triangle polygons each triangle "
"themed in different color"
msgstr ""
"ST_DelaunayTriangles von 2 Polygonen: delaunay triangulierte Polygone, jedes "
"der Dreiecke ist in einer eigenen Farbe dargestellt"

#. Tag: programlisting
#: reference_processing.xml:755
#, fuzzy, no-c-format
msgid ""
"-- geometries overlaid multilinestring triangles\n"
"SELECT\n"
"    ST_DelaunayTriangles(\n"
"        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"            50 60, 125 100, 175 150))'),\n"
"        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"        ))\n"
"     As  dtriag;"
msgstr ""
"-- geometries overlaid multilinestring triangles\n"
"SELECT\n"
"        ST_DelaunayTriangles(\n"
"                ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"                        50 60, 125 100, 175 150))'),\n"
"                ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                ))\n"
"         As  dtriag;"

#. Tag: para
#: reference_processing.xml:762
#, no-c-format
msgid "-- delaunay triangles as multilinestring"
msgstr "-- Delaunay-Dreiecke als MultiLinestring"

#. Tag: programlisting
#: reference_processing.xml:765
#, fuzzy, no-c-format
msgid ""
"SELECT\n"
"    ST_DelaunayTriangles(\n"
"        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"            50 60, 125 100, 175 150))'),\n"
"        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"        ),0.001,1)\n"
"     As  dtriag;"
msgstr ""
"SELECT\n"
"        ST_DelaunayTriangles(\n"
"                ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"                        50 60, 125 100, 175 150))'),\n"
"                ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                ),0.001,1)\n"
"         As  dtriag;"

#. Tag: para
#: reference_processing.xml:773
#, no-c-format
msgid "-- delaunay triangles of 45 points as 55 triangle polygons"
msgstr "-- Delaunay Dreiecke von 45 Punkten als 55 Dreieckspolygone"

#. Tag: programlisting
#: reference_processing.xml:776
#, fuzzy, no-c-format
msgid ""
"-- this produces a table of 42 points that form an L shape\n"
"SELECT (ST_DumpPoints(ST_GeomFromText(\n"
"'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,\n"
"150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,\n"
"14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,\n"
"6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,\n"
"14 94,14 74,14 54,14 34,14 14)'))).geom\n"
"    INTO TABLE l_shape;\n"
"-- output as individual polygon triangles\n"
"SELECT ST_AsText((ST_Dump(geom)).geom) As wkt\n"
"FROM ( SELECT ST_DelaunayTriangles(ST_Collect(geom)) As geom\n"
"FROM l_shape) As foo;\n"
"\n"
"---wkt ---\n"
"POLYGON((6 194,6 190,14 194,6 194))\n"
"POLYGON((14 194,6 190,14 174,14 194))\n"
"POLYGON((14 194,14 174,154 14,14 194))\n"
"POLYGON((154 14,14 174,14 154,154 14))\n"
"POLYGON((154 14,14 154,150 14,154 14))\n"
"POLYGON((154 14,150 14,154 6,154 14))\n"
":\n"
":"
msgstr ""
"-- erzeugt eine Tabelle mit 42 Punkten die eine L-Form bilden\n"
"SELECT (ST_DumpPoints(ST_GeomFromText(\n"
"'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,\n"
"150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,\n"
"14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,\n"
"6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,\n"
"14 94,14 74,14 54,14 34,14 14)'))).geom\n"
"        INTO TABLE l_shape;\n"
"-- Ausgabe als einzelne Dreieckspolygone\n"
"SELECT ST_AsText((ST_Dump(geom)).geom) As wkt\n"
"FROM ( SELECT ST_DelaunayTriangles(ST_Collect(geom)) As geom\n"
"FROM l_shape) As foo;\n"
"\n"
"---wkt ---\n"
"POLYGON((6 194,6 190,14 194,6 194))\n"
"POLYGON((14 194,6 190,14 174,14 194))\n"
"POLYGON((14 194,14 174,154 14,14 194))\n"
"POLYGON((154 14,14 174,14 154,154 14))\n"
"POLYGON((154 14,14 154,150 14,154 14))\n"
"POLYGON((154 14,150 14,154 6,154 14))\n"
":\n"
":"

#. Tag: title
#: reference_processing.xml:785
#, no-c-format
msgid "3D Examples"
msgstr "3D Beispiele"

#. Tag: programlisting
#: reference_processing.xml:786
#, no-c-format
msgid ""
"-- 3D multipoint --\n"
"SELECT ST_AsText(ST_DelaunayTriangles(ST_GeomFromText(\n"
"'MULTIPOINT Z(14 14 10,\n"
"150 14 100,34 6 25, 20 10 150)'))) As wkt;\n"
"\n"
"-----wkt----\n"
"GEOMETRYCOLLECTION Z (POLYGON Z ((14 14 10,20 10 150,34 6 25,14 14 10))\n"
" ,POLYGON Z ((14 14 10,34 6 25,150 14 100,14 14 10)))"
msgstr ""
"-- 3D-MULTIPOINT --\n"
"SELECT ST_AsText(ST_DelaunayTriangles(ST_GeomFromText(\n"
"'MULTIPOINT Z(14 14 10,\n"
"150 14 100,34 6 25, 20 10 150)'))) As wkt;\n"
"\n"
"-----wkt----\n"
"GEOMETRYCOLLECTION Z (POLYGON Z ((14 14 10,20 10 150,34 6 25,14 14 10))\n"
" ,POLYGON Z ((14 14 10,34 6 25,150 14 100,14 14 10)))"

#. Tag: para
#: reference_processing.xml:790
#, fuzzy, no-c-format
msgid ""
", <xref linkend=\"ST_ConcaveHull\"/>, <xref linkend=\"ST_Dump\"/>, <xref "
"linkend=\"ST_Tesselate\"/>"
msgstr ""
", <xref linkend=\"ST_MemUnion\"/>, <xref linkend=\"ST_Collect\"/>, <xref "
"linkend=\"ST_Node\"/>"

#. Tag: refname
#: reference_processing.xml:797
#, no-c-format
msgid "ST_FilterByM"
msgstr ""

#. Tag: refpurpose
#: reference_processing.xml:798
#, no-c-format
msgid "Removes vertices based on their M value"
msgstr ""

#. Tag: funcprototype
#: reference_processing.xml:803
#, fuzzy, no-c-format
msgid ""
"<funcdef>geometry <function>ST_FilterByM</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
"<paramdef><type>double precision</type> <parameter>min</parameter></"
"paramdef> <paramdef><type>double precision</type> <parameter>max = null</"
"parameter></paramdef> <paramdef><type>boolean</type> <parameter>returnM = "
"false</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_Simplify</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef> "
"<paramdef><type>boolean</type> <parameter>preserveCollapsed</parameter></"
"paramdef>"

#. Tag: para
#: reference_processing.xml:815
#, no-c-format
msgid ""
"Filters out vertex points based on their M-value. Returns a geometry with "
"only vertex points that have a M-value larger or equal to the min value and "
"smaller or equal to the max value. If max-value argument is left out only "
"min value is considered. If fourth argument is left out the m-value will not "
"be in the resulting geometry. If resulting geometry have too few vertex "
"points left for its geometry type an empty geometry will be returned. In a "
"geometry collection geometries without enough points will just be left out "
"silently."
msgstr ""

#. Tag: para
#: reference_processing.xml:821
#, no-c-format
msgid ""
"This function is mainly intended to be used in conjunction with "
"ST_SetEffectiveArea. ST_EffectiveArea sets the effective area of a vertex in "
"its m-value. With ST_FilterByM it then is possible to get a simplified "
"version of the geometry without any calculations, just by filtering"
msgstr ""

#. Tag: para
#: reference_processing.xml:824
#, no-c-format
msgid ""
"There is a difference in what ST_SimplifyVW returns when not enough points "
"meet the criteria compared to ST_FilterByM. ST_SimplifyVW returns the "
"geometry with enough points while ST_FilterByM returns an empty geometry"
msgstr ""

#. Tag: para
#: reference_processing.xml:826
#, no-c-format
msgid "Note that the returned geometry might be invalid"
msgstr ""

#. Tag: para
#: reference_processing.xml:827
#, no-c-format
msgid "This function returns all dimensions, including the Z and M values"
msgstr ""

#. Tag: para
#: reference_processing.xml:828 reference_processing.xml:1179
#: reference_processing.xml:1753
#, fuzzy, no-c-format
msgid "Availability: 2.5.0"
msgstr "Verfügbarkeit: 2.0.0"

#. Tag: para
#: reference_processing.xml:833
#, no-c-format
msgid "A linestring is filtered"
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:834
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(ST_FilterByM(geom,30)) simplified\n"
"FROM (SELECT  ST_SetEffectiveArea('LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::"
"geometry) geom) As foo;\n"
"-result\n"
"         simplified\n"
"----------------------------\n"
" LINESTRING(5 2,7 25,10 10)"
msgstr ""
"select ST_AsText(ST_SimplifyVW(geom,30)) simplified\n"
"FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As "
"foo;\n"
"-result\n"
" simplified\n"
"-----------+-------------------+\n"
"LINESTRING(5 2,7 25,10 10)"

#. Tag: para
#: reference_processing.xml:838 reference_processing.xml:1763
#, fuzzy, no-c-format
msgid ", <xref linkend=\"ST_SimplifyVW\"/>"
msgstr ", <xref linkend=\"ST_Dump\"/>"

#. Tag: refname
#: reference_processing.xml:844
#, no-c-format
msgid "ST_GeneratePoints"
msgstr "ST_GeneratePoints"

#. Tag: refpurpose
#: reference_processing.xml:846
#, no-c-format
msgid "Generates random points contained in a Polygon or MultiPolygon."
msgstr ""

#. Tag: funcsynopsis
#: reference_processing.xml:850
#, fuzzy, no-c-format
msgid ""
"<funcprototype> <funcdef>geometry <function>ST_GeneratePoints</function></"
"funcdef> <paramdef> <parameter>g</parameter> <type>geometry</type> </"
"paramdef> <paramdef> <parameter>npoints</parameter> <type>integer</type> </"
"paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
"<function>ST_GeneratePoints</function></funcdef> <paramdef> <type>geometry</"
"type> <parameter>g</parameter> </paramdef> <paramdef> <type>integer</type> "
"<parameter>npoints</parameter> </paramdef> <paramdef> <type>integer</type> "
"<parameter>seed</parameter> </paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>geometry <function>ST_Intersection</function></"
"funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
"paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
"paramdef> </funcprototype> <funcprototype> <funcdef>geography "
"<function>ST_Intersection</function></funcdef> <paramdef> <type>geography</"
"type> <parameter>geogA</parameter> </paramdef> <paramdef> <type>geography</"
"type> <parameter>geogB</parameter> </paramdef> </funcprototype>"

#. Tag: para
#: reference_processing.xml:875
#, fuzzy, no-c-format
msgid ""
"ST_GeneratePoints generates a given number of pseudo-random points which lie "
"within the input area. The optional <code>seed</code> is used to regenerate "
"a deterministic sequence of points, and must be greater than zero."
msgstr ""
"ST_GeneratePoints erzeugt solange pseudomäßige Zufallspunkte, bis die "
"angefragte Anzahl innerhalb der Eingabefläche gefunden wurde."

#. Tag: para
#: reference_processing.xml:882 reference_processing.xml:971
#: reference_processing.xml:1874 reference_processing.xml:1965
#, no-c-format
msgid "Availability: 2.3.0"
msgstr "Verfügbarkeit: 2.3.0"

#. Tag: para
#: reference_processing.xml:883
#, no-c-format
msgid "Enhanced: 3.0.0, added seed parameter"
msgstr ""

#. Tag: para
#: reference_processing.xml:899
#, no-c-format
msgid "Original Polygon"
msgstr "Ursprüngliches Polygon"

#. Tag: para
#: reference_processing.xml:910
#, fuzzy, no-c-format
msgid ""
"Generated 12 Points overlaid on top of original polygon using a random seed "
"value 1996"
msgstr "Ursprungspolygon mit 12 erzeugten Punkte überlagert"

#. Tag: programlisting
#: reference_processing.xml:913
#, fuzzy, no-c-format
msgid ""
"SELECT ST_GeneratePoints(geom, 12, 1996)\n"
"FROM (\n"
"    SELECT ST_Buffer(\n"
"        ST_GeomFromText(\n"
"        'LINESTRING(50 50,150 150,150 50)'),\n"
"        10, 'endcap=round join=round') AS geom\n"
") AS s;"
msgstr ""
"SELECT ST_GeneratePoints(\n"
"        ST_Buffer(\n"
"                ST_GeomFromText(\n"
"                'LINESTRING(50 50,150 150,150 50)'\n"
"                ), 10, 'endcap=round join=round'), 12);"

#. Tag: refname
#: reference_processing.xml:924
#, no-c-format
msgid "ST_GeometricMedian"
msgstr ""

#. Tag: refpurpose
#: reference_processing.xml:928
#, no-c-format
msgid "Returns the geometric median of a MultiPoint."
msgstr ""

#. Tag: funcprototype
#: reference_processing.xml:935
#, fuzzy, no-c-format
msgid ""
"<funcdef>geometry <function>ST_GeometricMedian</function> </funcdef> "
"<paramdef> <type>geometry</type> <parameter>geom</parameter></paramdef> "
"<paramdef choice=\"opt\"><type>float8</type> <parameter>tolerance = NULL</"
"parameter></paramdef> <paramdef choice=\"opt\"><type>int</type> "
"<parameter>max_iter = 10000</parameter></paramdef> <paramdef choice=\"opt"
"\"><type>boolean</type> <parameter>fail_if_not_converged = false</"
"parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_DelaunayTriangles</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>tolerance</parameter></paramdef> "
"<paramdef><type>int4 </type> <parameter>flags</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:950
#, no-c-format
msgid ""
"Computes the approximate geometric median of a MultiPoint geometry using the "
"Weiszfeld algorithm. The geometric median is the point minimizing the sum of "
"distances to the input points. It provides a centrality measure that is less "
"sensitive to outlier points than the centroid (center of mass)."
msgstr ""

#. Tag: para
#: reference_processing.xml:957
#, no-c-format
msgid ""
"The algorithm iterates until the distance change between successive "
"iterations is less than the supplied <varname>tolerance</varname> parameter. "
"If this condition has not been met after <varname>max_iterations</varname> "
"iterations, the function produces an error and exits, unless "
"<varname>fail_if_not_converged</varname> is set to <code>false</code> (the "
"default)."
msgstr ""

#. Tag: para
#: reference_processing.xml:964
#, no-c-format
msgid ""
"If a <varname>tolerance</varname> argument is not provided, the tolerance "
"value is calculated based on the extent of the input geometry."
msgstr ""

#. Tag: para
#: reference_processing.xml:968
#, no-c-format
msgid ""
"If present, the input point M values are interpreted as their relative "
"weights."
msgstr ""

#. Tag: para
#: reference_processing.xml:972
#, no-c-format
msgid "Enhanced: 2.5.0 Added support for M as weight of points."
msgstr ""

#. Tag: para
#: reference_processing.xml:974
#, no-c-format
msgid "&M_support;"
msgstr "&M_support;"

#. Tag: para
#: reference_processing.xml:986
#, no-c-format
msgid ""
"Comparison of the centroid (turquoise point) and geometric median (red "
"point) of a four-point MultiPoint (yellow points)."
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:994
#, no-c-format
msgid ""
"WITH test AS (\n"
"SELECT 'MULTIPOINT((0 0), (1 1), (2 2), (200 200))'::geometry geom)\n"
"SELECT\n"
"  ST_AsText(ST_Centroid(geom)) centroid,\n"
"  ST_AsText(ST_GeometricMedian(geom)) median\n"
"FROM test;\n"
"      centroid      |                 median\n"
"--------------------+----------------------------------------\n"
" POINT(50.75 50.75) | POINT(1.9761550281255 1.9761550281255)\n"
"(1 row)"
msgstr ""

#. Tag: refname
#: reference_processing.xml:1007
#, fuzzy, no-c-format
msgid "ST_MaximumInscribedCircle"
msgstr "ST_MinimumBoundingCircle"

#. Tag: refpurpose
#: reference_processing.xml:1008
#, fuzzy, no-c-format
msgid "Computes the largest circle that is fully contained within a geometry."
msgstr ""
"Gibt das kleinstmögliche Kreispolygon zurück, welches eine Geometrie zur "
"Gänze beinhaltet."

#. Tag: funcprototype
#: reference_processing.xml:1013
#, fuzzy, no-c-format
msgid ""
"<funcdef>(geometry, geometry, double precision) "
"<function>ST_MaximumInscribedCircle</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"
msgstr ""
"<funcdef>(geometry, double precision) <function>ST_MinimumBoundingRadius</"
"function></funcdef> <paramdef><type>geometry</type> <parameter>geom</"
"parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1022
#, no-c-format
msgid ""
"Finds the largest circle that is fully contained within a geometry. Returns "
"a record with the center point of the circle, a point on the geometry that "
"is nearest to the center, and the radius of the circle."
msgstr ""

#. Tag: para
#: reference_processing.xml:1026
#, no-c-format
msgid ""
"For polygonal inputs, the circle is inscribed within the external ring, "
"using the internal rings as boundaries. For linear and point inputs, the "
"circle is inscribed within the convex hull of the input, using the input as "
"further boundaries."
msgstr ""

#. Tag: para
#: reference_processing.xml:1029
#, fuzzy, no-c-format
msgid "Availability: 3.1.0 - requires GEOS &gt;= 3.9.0."
msgstr "Verfügbarkeit: 2.1.0 - benötigt GEOS &gt;= 3.4.0."

#. Tag: programlisting
#: reference_processing.xml:1039
#, no-c-format
msgid ""
"SELECT radius, ST_AsText(center) AS center, ST_AsText(nearest) AS nearest\n"
"    FROM ST_MaximumInscribedCircle('POLYGON ((50 50, 150 50, 150 150, 50 "
"150, 50 50))')\n"
"\n"
" radius |     center     |    nearest\n"
"--------+----------------+---------------\n"
"     50 | POINT(100 100) | POINT(100 50)"
msgstr ""

#. Tag: para
#: reference_processing.xml:1045
#, no-c-format
msgid ""
"Maximum inscribed circle of a triangle polygon. Center, nearest point, and "
"radius are returned."
msgstr ""

#. Tag: para
#: reference_processing.xml:1054
#, no-c-format
msgid ""
"Maximum inscribed circle of a multi-linestring. Center, nearest point, and "
"radius are returned."
msgstr ""

#. Tag: para
#: reference_processing.xml:1061 reference_processing.xml:1098
#: reference_processing.xml:1116
#, no-c-format
msgid ", <xref linkend=\"ST_MinimumBoundingRadius\"/>"
msgstr ", <xref linkend=\"ST_MinimumBoundingRadius\"/>"

#. Tag: refname
#: reference_processing.xml:1067
#, no-c-format
msgid "ST_MinimumBoundingCircle"
msgstr "ST_MinimumBoundingCircle"

#. Tag: refpurpose
#: reference_processing.xml:1068
#, fuzzy, no-c-format
msgid ""
"<refpurpose>Returns the smallest circle polygon that contains a geometry.</"
"refpurpose>"
msgstr ""
"Gibt das kleinstmögliche Kreispolygon zurück, welches eine Geometrie zur "
"Gänze beinhaltet."

#. Tag: funcprototype
#: reference_processing.xml:1073
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_MinimumBoundingCircle</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef choice=\"opt\"><type>integer </type> "
"<parameter>num_segs_per_qt_circ=48</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_MinimumBoundingCircle</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef choice=\"opt\"><type>integer </type> "
"<parameter>num_segs_per_qt_circ=48</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1083
#, fuzzy, no-c-format
msgid ""
"<para>Returns the smallest circle polygon that contains a geometry.</para>"
msgstr ""
"Gibt das kleinstmögliche Kreispolygon zurück, welches eine Geometrie zur "
"Gänze beinhaltet."

#. Tag: para
#: reference_processing.xml:1084
#, no-c-format
msgid ""
"The circle is approximated by a polygon with a default of 48 segments per "
"quarter circle. Because the polygon is an approximation of the minimum "
"bounding circle, some points in the input geometry may not be contained "
"within the polygon. The approximation can be improved by increasing the "
"number of segments, with little performance penalty. For applications where "
"a polygonal approximation is not suitable, ST_MinimumBoundingRadius may be "
"used."
msgstr ""
"Der Kreis wird standardmäßig durch ein Polygon mit 48 Segmenten pro "
"Viertelkreis angenähert. Da das Polygon eine Annäherung an den minimalen "
"Umgebungskreis ist, können einige Punkte der Eingabegeometrie nicht in dem "
"Polygon enthalten sein. Die Annäherung kann durch Erhöhung der Anzahl der "
"Segmente mit geringen Einbußen bei der Rechenleistung verbessert werden. Bei "
"Anwendungen wo eine polygonale Annäherung nicht ausreicht, kann "
"ST_MinimumBoundingRadius verwendet werden."

#. Tag: para
#: reference_processing.xml:1086
#, no-c-format
msgid ""
"It is often used with MULTI and Geometry Collections. Although it is not an "
"aggregate - you can use it in conjunction with ST_Collect to get the minimum "
"bounding circle of a set of geometries. "
"ST_MinimumBoundingCircle(ST_Collect(somepointfield))."
msgstr ""
"Wird üblicherweise auf Mehrfach/MULTI- und Sammelgeometrien/"
"GeometryCollections angewandt. Obwohl es sich nicht um eine Aggregatfunktion "
"handelt, können Sie es in Verbindung mit ST_Collect verwenden um den "
"kleinstmöglichen Umgebungskreis eines Satzes an Geometrien zu erhalten. "
"ST_MinimumBoundingCircle(ST_Collect(somepointfield))."

#. Tag: para
#: reference_processing.xml:1091
#, no-c-format
msgid ""
"The ratio of the area of a polygon divided by the area of its Minimum "
"Bounding Circle is often referred to as the Roeck test."
msgstr ""
"Das Verhältnis zwischen der Fläche des Polygons und der Fläche ihres "
"kleinstmöglichen Umgebungskreises wird öfter als Roeck Test bezeichnet."

#. Tag: para
#: reference_processing.xml:1093
#, fuzzy, no-c-format
msgid "Availability: 1.4.0"
msgstr "Verfügbarkeit: 1.5.0"

#. Tag: programlisting
#: reference_processing.xml:1103
#, fuzzy, no-c-format
msgid ""
"SELECT d.disease_type,\n"
"    ST_MinimumBoundingCircle(ST_Collect(d.the_geom)) As the_geom\n"
"    FROM disease_obs As d\n"
"    GROUP BY d.disease_type;"
msgstr ""
"SELECT d.disease_type,\n"
"        ST_MinimumBoundingCircle(ST_Collect(d.the_geom)) As the_geom\n"
"        FROM disease_obs As d\n"
"        GROUP BY d.disease_type;"

#. Tag: para
#: reference_processing.xml:1109
#, no-c-format
msgid ""
"Minimum bounding circle of a point and linestring. Using 8 segs to "
"approximate a quarter circle"
msgstr ""
"Minimaler Umgebungskreis eines Punktes und eines Linienzuges. Verwendet 8 "
"Segmente um einen Viertelkreis anzunähern."

#. Tag: programlisting
#: reference_processing.xml:1112
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(ST_MinimumBoundingCircle(\n"
"        ST_Collect(\n"
"            ST_GeomFromText('LINESTRING(55 75,125 150)'),\n"
"                ST_Point(20, 80)), 8\n"
"                )) As wktmbc;\n"
"wktmbc\n"
"-----------\n"
"POLYGON((135.59714732062 115,134.384753327498 "
"102.690357210921,130.79416296937 90.8537670908995,124.963360620072 "
"79.9451031602111,117.116420743937 70.3835792560632,107.554896839789 "
"62.5366393799277,96.6462329091006 56.70583703063,84.8096427890789 "
"53.115246672502,72.5000000000001 51.9028526793802,60.1903572109213 "
"53.1152466725019,48.3537670908996 56.7058370306299,37.4451031602112 "
"62.5366393799276,27.8835792560632 70.383579256063,20.0366393799278 "
"79.9451031602109,14.20583703063 90.8537670908993,10.615246672502 "
"102.690357210921,9.40285267938019 115,10.6152466725019 "
"127.309642789079,14.2058370306299 139.1462329091,20.0366393799275 "
"150.054896839789,27.883579256063 159.616420743937,\n"
"37.4451031602108 167.463360620072,48.3537670908992 "
"173.29416296937,60.190357210921 176.884753327498,\n"
"72.4999999999998 178.09714732062,84.8096427890786 "
"176.884753327498,96.6462329091003 173.29416296937,107.554896839789 "
"167.463360620072,\n"
"117.116420743937 159.616420743937,124.963360620072 "
"150.054896839789,130.79416296937 139.146232909101,134.384753327498 "
"127.309642789079,135.59714732062 115))"
msgstr ""
"SELECT ST_AsText(ST_MinimumBoundingCircle(\n"
"                ST_Collect(\n"
"                        ST_GeomFromEWKT('LINESTRING(55 75,125 150)'),\n"
"                                ST_Point(20, 80)), 8\n"
"                                )) As wktmbc;\n"
"wktmbc\n"
"-----------\n"
"POLYGON((135.59714732062 115,134.384753327498 "
"102.690357210921,130.79416296937 90.8537670908995,124.963360620072 "
"79.9451031602111,117.116420743937 70.3835792560632,107.554896839789 "
"62.5366393799277,96.6462329091006 56.70583703063,84.8096427890789 "
"53.115246672502,72.5000000000001 51.9028526793802,60.1903572109213 "
"53.1152466725019,48.3537670908996 56.7058370306299,37.4451031602112 "
"62.5366393799276,27.8835792560632 70.383579256063,20.0366393799278 "
"79.9451031602109,14.20583703063 90.8537670908993,10.615246672502 "
"102.690357210921,9.40285267938019 115,10.6152466725019 "
"127.309642789079,14.2058370306299 139.1462329091,20.0366393799275 "
"150.054896839789,27.883579256063 159.616420743937,\n"
"37.4451031602108 167.463360620072,48.3537670908992 "
"173.29416296937,60.190357210921 176.884753327498,\n"
"72.4999999999998 178.09714732062,84.8096427890786 "
"176.884753327498,96.6462329091003 173.29416296937,107.554896839789 "
"167.463360620072,\n"
"117.116420743937 159.616420743937,124.963360620072 "
"150.054896839789,130.79416296937 139.146232909101,134.384753327498 "
"127.309642789079,135.59714732062 115))"

#. Tag: refname
#: reference_processing.xml:1122
#, no-c-format
msgid "ST_MinimumBoundingRadius"
msgstr "ST_MinimumBoundingRadius"

#. Tag: refpurpose
#: reference_processing.xml:1123
#, fuzzy, no-c-format
msgid ""
"Returns the center point and radius of the smallest circle that contains a "
"geometry."
msgstr ""
"Gibt den Mittelpunkt und den Radius des kleinstmöglichen Kreises zurück, der "
"die gesamte Geometrie beinhaltet."

#. Tag: funcprototype
#: reference_processing.xml:1128
#, no-c-format
msgid ""
"<funcdef>(geometry, double precision) <function>ST_MinimumBoundingRadius</"
"function></funcdef> <paramdef><type>geometry</type> <parameter>geom</"
"parameter></paramdef>"
msgstr ""
"<funcdef>(geometry, double precision) <function>ST_MinimumBoundingRadius</"
"function></funcdef> <paramdef><type>geometry</type> <parameter>geom</"
"parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1137
#, fuzzy, no-c-format
msgid ""
"Returns a record containing the center point and radius of the smallest "
"circle that contains a geometry."
msgstr ""
"Gibt einen Datensatz zurück, der aus dem Mittelpunkt und dem Radius des "
"kleinstmöglichen Kreises, der die gesamte Geometrie beinhaltet, besteht."

#. Tag: para
#: reference_processing.xml:1138
#, fuzzy, no-c-format
msgid ""
"Use in conjunction with <xref linkend=\"ST_Collect\"/> to get the minimum "
"bounding circle of a set of geometries."
msgstr ""
"Kann in Verbindung mit <xref linkend=\"ST_Collect\"/> verwendet werden, um "
"den minimalen Umgebungskreis einer Menge von Geometrien zu erhalten."

#. Tag: para
#: reference_processing.xml:1139
#, no-c-format
msgid "Availability - 2.3.0"
msgstr "Verfügbarkeit: 2.3.0"

#. Tag: para
#: reference_processing.xml:1144
#, no-c-format
msgid ", <xref linkend=\"ST_MinimumBoundingCircle\"/>"
msgstr ", <xref linkend=\"ST_MinimumBoundingCircle\"/>"

#. Tag: programlisting
#: reference_processing.xml:1149
#, no-c-format
msgid ""
"SELECT ST_AsText(center), radius FROM "
"ST_MinimumBoundingRadius('POLYGON((26426 65078,26531 65242,26075 65136,26096 "
"65427,26426 65078))');\n"
"\n"
"                st_astext                 |      radius\n"
"------------------------------------------+------------------\n"
" POINT(26284.8418027133 65267.1145090825) | 247.436045591407"
msgstr ""
"SELECT ST_AsText(center), radius FROM "
"ST_MinimumBoundingRadius('POLYGON((26426 65078,26531 65242,26075 65136,26096 "
"65427,26426 65078))');\n"
"\n"
"                st_astext                 |      radius\n"
"------------------------------------------+------------------\n"
" POINT(26284.8418027133 65267.1145090825) | 247.436045591407"

#. Tag: refname
#: reference_processing.xml:1156
#, no-c-format
msgid "ST_OrientedEnvelope"
msgstr ""

#. Tag: refpurpose
#: reference_processing.xml:1157
#, fuzzy, no-c-format
msgid "Returns a minimum-area rectangle containing a geometry."
msgstr ""
"Gibt eine Sammelgeometrie zurück, die beim Auftrennen einer Geometrie "
"entsteht."

#. Tag: funcprototype
#: reference_processing.xml:1162
#, fuzzy, no-c-format
msgid ""
"<funcdef>geometry <function>ST_OrientedEnvelope</function></funcdef> "
"<paramdef> <type>geometry</type> <parameter>geom</parameter> </paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_Node</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1174
#, no-c-format
msgid ""
"Returns the mimimum-area rotated rectangle enclosing a geometry. Note that "
"more than one such rectangle may exist. May return a Point or LineString in "
"the case of degenerate inputs."
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:1194
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_OrientedEnvelope('MULTIPOINT ((0 0), (-1 -1), (3 "
"2))'));\n"
"\n"
"                st_astext\n"
"                ------------------------------------------------\n"
"                POLYGON((3 2,2.88 2.16,-1.12 -0.84,-1 -1,3 2))"
msgstr ""

#. Tag: para
#: reference_processing.xml:1201
#, no-c-format
msgid "Oriented envelope of a point and linestring."
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:1204
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_OrientedEnvelope(\n"
"        ST_Collect(\n"
"            ST_GeomFromText('LINESTRING(55 75,125 150)'),\n"
"                ST_Point(20, 80))\n"
"                )) As wktenv;\n"
"wktenv\n"
"-----------\n"
"POLYGON((19.9999999999997 79.9999999999999,33.0769230769229 "
"60.3846153846152,138.076923076924 130.384615384616,125.000000000001 "
"150.000000000001,19.9999999999997 79.9999999999999))"
msgstr ""

#. Tag: refname
#: reference_processing.xml:1211
#, no-c-format
msgid "ST_OffsetCurve"
msgstr "ST_OffsetCurve"

#. Tag: refpurpose
#: reference_processing.xml:1213
#, fuzzy, no-c-format
msgid "Returns an offset line at a given distance and side from an input line."
msgstr ""
"Gibt eine Linie zurück, die um eine gegebenen Entfernung und Seite von der "
"Eingabelinie versetzt ist. Nützlich zur Berechnung von Linien, die zu einer "
"Mittellinie parallel verlaufen"

#. Tag: funcprototype
#: reference_processing.xml:1221
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_OffsetCurve</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>line</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>signed_distance</parameter></"
"paramdef> <paramdef choice=\"opt\"><type>text </type> "
"<parameter>style_parameters=''</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_OffsetCurve</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>line</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>signed_distance</parameter></"
"paramdef> <paramdef choice=\"opt\"><type>text </type> "
"<parameter>style_parameters=''</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1234
#, fuzzy, no-c-format
msgid ""
"Return an offset line at a given distance and side from an input line. All "
"points of the returned geometries are not further than the given distance "
"from the input geometry. Useful for computing parallel lines about a center "
"line."
msgstr ""
"Gibt eine versetzte Linie zurück; in der gegebenen Entfernung und auf der "
"Seite der Eingabelinie, die angegebenen wurden. Alle Punkte der "
"Ausgabegeometrie liegen nicht weiter weg, als die zur Eingangsgeometrie "
"angegebene Entfernung."

#. Tag: para
#: reference_processing.xml:1241
#, fuzzy, no-c-format
msgid ""
"For positive distance the offset is on the left side of the input line and "
"retains the same direction. For a negative distance it is on the right side "
"and in the opposite direction."
msgstr ""
"Bei positiven Entfernungsangaben/distance findet der Versatz auf der linken "
"Seite der Eingabelinie statt und die Richtung wird beibehalten. Bei "
"negativen Entfernungsangaben auf der rechten Seite und in entgegengesetzter "
"Richtung."

#. Tag: para
#: reference_processing.xml:1246
#, no-c-format
msgid ""
"Note that output may be a MULTILINESTRING or EMPTY for some jigsaw-shaped "
"input geometries."
msgstr ""

#. Tag: para
#: reference_processing.xml:1251
#, fuzzy, no-c-format
msgid "Availability: 2.0"
msgstr "Verfügbarkeit: 2.0.0"

#. Tag: para
#: reference_processing.xml:1252
#, fuzzy, no-c-format
msgid ""
"Enhanced: 2.5 - added support for GEOMETRYCOLLECTION and MULTILINESTRING"
msgstr ""
"Erweiterung: 2.1.0 die Unterstützung von GeometryCollection und MultiPoint "
"hinzugefügt."

#. Tag: para
#: reference_processing.xml:1254
#, no-c-format
msgid ""
"The optional third parameter allows specifying a list of blank-separated "
"key=value pairs to tweak operations as follows:"
msgstr ""
"Der optionale dritte Parameter ermöglicht es eine Liste von "
"leerzeichengetrennten key=value Paaren anzulegen, um die Berechnungen wie "
"folgt zu optimieren:"

#. Tag: para
#: reference_processing.xml:1265
#, no-c-format
msgid ""
"'mitre_limit=#.#' : mitre ratio limit (only affects mitred join style). "
"'miter_limit' is also accepted as a synonym for 'mitre_limit'."
msgstr ""
"'mitre_limit=#.#' : Gehrungsobergrenze (beeinflusst nur "
"Gehrungsverbindungen). 'miter_limit' kann auch als Synonym von 'mitre_limit' "
"verwendet werden."

#. Tag: para
#: reference_processing.xml:1270
#, no-c-format
msgid ""
"Units of distance are measured in units of the spatial reference system."
msgstr ""
"Die Einheiten der Entfernung werden in den Einheiten des "
"Koordinatenreferenzsystems gemessen."

#. Tag: para
#: reference_processing.xml:1276
#, no-c-format
msgid ""
"This function ignores the third dimension (z) and will always give a 2-d "
"result even when presented with a 3d-geometry."
msgstr ""
"Diese Funktion ignoriert die dritte Dimension (z) und gibt immer ein 2-D "
"Ergebnis zurück, sogar dann wenn eine 3D-Geometrie überreicht wird."

#. Tag: para
#: reference_processing.xml:1284
#, no-c-format
msgid "Compute an open buffer around roads"
msgstr "Einen offenen Puffer um die Straßen rechnen"

#. Tag: programlisting
#: reference_processing.xml:1285
#, no-c-format
msgid ""
"SELECT ST_Union(\n"
" ST_OffsetCurve(f.the_geom,  f.width/2, 'quad_segs=4 join=round'),\n"
" ST_OffsetCurve(f.the_geom, -f.width/2, 'quad_segs=4 join=round')\n"
") as track\n"
"FROM someroadstable;"
msgstr ""
"SELECT ST_Union(\n"
" ST_OffsetCurve(f.the_geom,  f.width/2, 'quad_segs=4 join=round'),\n"
" ST_OffsetCurve(f.the_geom, -f.width/2, 'quad_segs=4 join=round')\n"
") as track\n"
"FROM someroadstable;"

#. Tag: para
#: reference_processing.xml:1295
#, no-c-format
msgid "15, 'quad_segs=4 join=round' original line and its offset 15 units."
msgstr ""
"15, 'quad_segs=4 join=round' Ausgangslinie und die um 15 Einheiten versetzte "
"Parallele."

#. Tag: programlisting
#: reference_processing.xml:1299
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"    44 16,24 16,20 16,18 16,17 17,\n"
"    16 18,16 20,16 40,16 60,16 80,16 100,\n"
"    16 120,16 140,16 160,16 180,16 195)'),\n"
"    15, 'quad_segs=4 join=round'));\n"
"--output --\n"
"LINESTRING(164 1,18 1,12.2597485145237 2.1418070123307,\n"
"    7.39339828220179 5.39339828220179,\n"
"    5.39339828220179 7.39339828220179,\n"
"    2.14180701233067 12.2597485145237,1 18,1 195)"
msgstr ""
"SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"        44 16,24 16,20 16,18 16,17 17,\n"
"        16 18,16 20,16 40,16 60,16 80,16 100,\n"
"        16 120,16 140,16 160,16 180,16 195)'),\n"
"        15, 'quad_segs=4 join=round'));\n"
"--output --\n"
"LINESTRING(164 1,18 1,12.2597485145237 2.1418070123307,\n"
"        7.39339828220179 5.39339828220179,\n"
"        5.39339828220179 7.39339828220179,\n"
"        2.14180701233067 12.2597485145237,1 18,1 195)"

#. Tag: para
#: reference_processing.xml:1306
#, no-c-format
msgid "-15, 'quad_segs=4 join=round' original line and its offset -15 units"
msgstr ""
"-15, 'quad_segs=4 join=round' Ausgangslinie und die um -15 Einheiten "
"versetzte Parallele."

#. Tag: programlisting
#: reference_processing.xml:1310
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(ST_OffsetCurve(geom,\n"
"    -15, 'quad_segs=4 join=round')) As notsocurvy\n"
"    FROM ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"    44 16,24 16,20 16,18 16,17 17,\n"
"    16 18,16 20,16 40,16 60,16 80,16 100,\n"
"    16 120,16 140,16 160,16 180,16 195)') As geom;\n"
"-- notsocurvy --\n"
"LINESTRING(31 195,31 31,164 31)"
msgstr ""
"SELECT ST_AsText(ST_OffsetCurve(geom,\n"
"        -15, 'quad_segs=4 join=round')) As notsocurvy\n"
"        FROM ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"        44 16,24 16,20 16,18 16,17 17,\n"
"        16 18,16 20,16 40,16 60,16 80,16 100,\n"
"        16 120,16 140,16 160,16 180,16 195)') As geom;\n"
"-- notsocurvy --\n"
"LINESTRING(31 195,31 31,164 31)"

#. Tag: para
#: reference_processing.xml:1319
#, no-c-format
msgid ""
"double-offset to get more curvy, note the first reverses direction, so -30 + "
"15 = -15"
msgstr ""
"doppelter Versatz um es kurviger zu bekommen; beachte die Richtungsänderung, "
"also -30 + 15 = -15"

#. Tag: programlisting
#: reference_processing.xml:1322
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(ST_OffsetCurve(ST_OffsetCurve(geom,\n"
"    -30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')) As "
"morecurvy\n"
"    FROM ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"    44 16,24 16,20 16,18 16,17 17,\n"
"    16 18,16 20,16 40,16 60,16 80,16 100,\n"
"    16 120,16 140,16 160,16 180,16 195)') As geom;\n"
"-- morecurvy --\n"
"LINESTRING(164 31,46 31,40.2597485145236 32.1418070123307,\n"
"35.3933982822018 35.3933982822018,\n"
"32.1418070123307 40.2597485145237,31 46,31 195)"
msgstr ""
"SELECT ST_AsText(ST_OffsetCurve(ST_OffsetCurve(geom,\n"
"        -30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')) As "
"morecurvy\n"
"        FROM ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"        44 16,24 16,20 16,18 16,17 17,\n"
"        16 18,16 20,16 40,16 60,16 80,16 100,\n"
"        16 120,16 140,16 160,16 180,16 195)') As geom;\n"
"-- morecurvy --\n"
"LINESTRING(164 31,46 31,40.2597485145236 32.1418070123307,\n"
"35.3933982822018 35.3933982822018,\n"
"32.1418070123307 40.2597485145237,31 46,31 195)"

#. Tag: para
#: reference_processing.xml:1329
#, no-c-format
msgid ""
"double-offset to get more curvy,combined with regular offset 15 to get "
"parallel lines. Overlaid with original."
msgstr ""
"Doppelter Versatz um es kurviger zu bekommen, kombiniert mit einem normalen "
"Versatz von 15 um parallele Linien zu erhalten. Überlagert mit dem Original."

#. Tag: programlisting
#: reference_processing.xml:1332
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(ST_Collect(\n"
"    ST_OffsetCurve(geom, 15, 'quad_segs=4 join=round'),\n"
"    ST_OffsetCurve(ST_OffsetCurve(geom,\n"
"    -30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')\n"
"    )\n"
") As parallel_curves\n"
"    FROM ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"    44 16,24 16,20 16,18 16,17 17,\n"
"    16 18,16 20,16 40,16 60,16 80,16 100,\n"
"    16 120,16 140,16 160,16 180,16 195)') As geom;\n"
"-- parallel curves  --\n"
"MULTILINESTRING((164 1,18 1,12.2597485145237 2.1418070123307,\n"
"7.39339828220179 5.39339828220179,5.39339828220179 7.39339828220179,\n"
"2.14180701233067 12.2597485145237,1 18,1 195),\n"
"(164 31,46 31,40.2597485145236 32.1418070123307,35.3933982822018 "
"35.3933982822018,\n"
"32.1418070123307 40.2597485145237,31 46,31 195))"
msgstr ""
"SELECT ST_AsText(ST_Collect(\n"
"        ST_OffsetCurve(geom, 15, 'quad_segs=4 join=round'),\n"
"        ST_OffsetCurve(ST_OffsetCurve(geom,\n"
"        -30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')\n"
"        )\n"
") As parallel_curves\n"
"        FROM ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"        44 16,24 16,20 16,18 16,17 17,\n"
"        16 18,16 20,16 40,16 60,16 80,16 100,\n"
"        16 120,16 140,16 160,16 180,16 195)') As geom;\n"
"-- parallel curves  --\n"
"MULTILINESTRING((164 1,18 1,12.2597485145237 2.1418070123307,\n"
"7.39339828220179 5.39339828220179,5.39339828220179 7.39339828220179,\n"
"2.14180701233067 12.2597485145237,1 18,1 195),\n"
"(164 31,46 31,40.2597485145236 32.1418070123307,35.3933982822018 "
"35.3933982822018,\n"
"32.1418070123307 40.2597485145237,31 46,31 195))"

#. Tag: para
#: reference_processing.xml:1341
#, no-c-format
msgid "15, 'quad_segs=4 join=bevel' shown with original line"
msgstr "15, 'quad_segs=4 join=bevel' gemeinsam mit der Ausgangslinie"

#. Tag: programlisting
#: reference_processing.xml:1344
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"    44 16,24 16,20 16,18 16,17 17,\n"
"    16 18,16 20,16 40,16 60,16 80,16 100,\n"
"    16 120,16 140,16 160,16 180,16 195)'),\n"
"        15, 'quad_segs=4 join=bevel'));\n"
"-- output --\n"
"LINESTRING(164 1,18 1,7.39339828220179 5.39339828220179,\n"
"    5.39339828220179 7.39339828220179,1 18,1 195)"
msgstr ""
"SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"        44 16,24 16,20 16,18 16,17 17,\n"
"        16 18,16 20,16 40,16 60,16 80,16 100,\n"
"        16 120,16 140,16 160,16 180,16 195)'),\n"
"                15, 'quad_segs=4 join=bevel'));\n"
"-- output --\n"
"LINESTRING(164 1,18 1,7.39339828220179 5.39339828220179,\n"
"        5.39339828220179 7.39339828220179,1 18,1 195)"

#. Tag: para
#: reference_processing.xml:1352
#, no-c-format
msgid "15,-15 collected, join=mitre mitre_limit=2.1"
msgstr "15,-15 collected, join=mitre mitre_limit=2.1"

#. Tag: programlisting
#: reference_processing.xml:1355
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(ST_Collect(\n"
"    ST_OffsetCurve(geom, 15, 'quad_segs=4 join=mitre mitre_limit=2.2'),\n"
"    ST_OffsetCurve(geom, -15, 'quad_segs=4 join=mitre mitre_limit=2.2')\n"
"    ) )\n"
"    FROM ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"    44 16,24 16,20 16,18 16,17 17,\n"
"    16 18,16 20,16 40,16 60,16 80,16 100,\n"
"    16 120,16 140,16 160,16 180,16 195)') As geom;\n"
"-- output --\n"
"MULTILINESTRING((164 1,11.7867965644036 1,1 11.7867965644036,1 195),\n"
"    (31 195,31 31,164 31))"
msgstr ""
"SELECT ST_AsText(ST_Collect(\n"
"        ST_OffsetCurve(geom, 15, 'quad_segs=4 join=mitre mitre_limit=2.2'),\n"
"        ST_OffsetCurve(geom, -15, 'quad_segs=4 join=mitre mitre_limit=2.2')\n"
"        ) )\n"
"        FROM ST_GeomFromText(\n"
"'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,\n"
"        44 16,24 16,20 16,18 16,17 17,\n"
"        16 18,16 20,16 40,16 60,16 80,16 100,\n"
"        16 120,16 140,16 160,16 180,16 195)') As geom;\n"
"-- output --\n"
"MULTILINESTRING((164 1,11.7867965644036 1,1 11.7867965644036,1 195),\n"
"        (31 195,31 31,164 31))"

#. Tag: refname
#: reference_processing.xml:1372
#, no-c-format
msgid "ST_PointOnSurface"
msgstr ""

#. Tag: refpurpose
#: reference_processing.xml:1374
#, fuzzy, no-c-format
msgid "Returns a point guaranteed to lie in a polygon or on a geometry."
msgstr ""
"Gibt eine Sammelgeometrie zurück, die beim Auftrennen einer Geometrie "
"entsteht."

#. Tag: funcprototype
#: reference_processing.xml:1379
#, fuzzy, no-c-format
msgid ""
"<funcdef>geometry <function>ST_PointOnSurface</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_Node</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1391
#, no-c-format
msgid "Returns a <varname>POINT</varname> guaranteed to intersect a surface."
msgstr ""

#. Tag: para
#: reference_processing.xml:1393
#, fuzzy, no-c-format
msgid "&sfs_compliant; s3.2.14.2 // s3.2.18.2"
msgstr "&sfs_compliant; s2.1.1.3"

#. Tag: para
#: reference_processing.xml:1394
#, no-c-format
msgid ""
"&sqlmm_compliant; SQL-MM 3: 8.1.5, 9.5.6. According to the specs, "
"ST_PointOnSurface works for surface geometries (POLYGONs, MULTIPOLYGONS, "
"CURVED POLYGONS). So PostGIS seems to be extending what the spec allows "
"here. Most databases Oracle,DB II, ESRI SDE seem to only support this "
"function for surfaces. SQL Server 2008 like PostGIS supports for all common "
"geometries."
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:1403
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_PointOnSurface('POINT(0 5)'::geometry));\n"
" st_astext\n"
"------------\n"
" POINT(0 5)\n"
"(1 row)\n"
"\n"
"SELECT ST_AsText(ST_PointOnSurface('LINESTRING(0 5, 0 10)'::geometry));\n"
" st_astext\n"
"------------\n"
" POINT(0 5)\n"
"(1 row)\n"
"\n"
"SELECT ST_AsText(ST_PointOnSurface('POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))'::"
"geometry));\n"
"   st_astext\n"
"----------------\n"
" POINT(2.5 2.5)\n"
"(1 row)\n"
"\n"
"SELECT ST_AsEWKT(ST_PointOnSurface(ST_GeomFromEWKT('LINESTRING(0 5 1, 0 0 1, "
"0 10 2)')));\n"
"   st_asewkt\n"
"----------------\n"
" POINT(0 0 1)\n"
"(1 row)"
msgstr ""

#. Tag: para
#: reference_processing.xml:1409
#, fuzzy, no-c-format
msgid ", <xref linkend=\"ST_PointInsideCircle\"/>"
msgstr ", <xref linkend=\"ST_MinimumBoundingCircle\"/>"

#. Tag: refname
#: reference_processing.xml:1415
#, no-c-format
msgid "ST_Polygonize"
msgstr "ST_Polygonize"

#. Tag: refpurpose
#: reference_processing.xml:1417
#, fuzzy, no-c-format
msgid ""
"Computes a collection of polygons formed from the linework of a set of "
"geometries."
msgstr ""
"Erzeugt eine Sammelgeometrie/GeometryCollection, welche Polygone enthält, "
"die aus den einzelnen Linien einer Menge von Geometrien gebildet werden "
"können."

#. Tag: funcsynopsis
#: reference_processing.xml:1422
#, no-c-format
msgid ""
"<funcprototype> <funcdef>geometry <function>ST_Polygonize</function></"
"funcdef> <paramdef><type>geometry set</type> <parameter>geomfield</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
"<function>ST_Polygonize</function></funcdef> <paramdef><type>geometry[]</"
"type> <parameter>geom_array</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>geometry <function>ST_Polygonize</function></"
"funcdef> <paramdef><type>geometry set</type> <parameter>geomfield</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
"<function>ST_Polygonize</function></funcdef> <paramdef><type>geometry[]</"
"type> <parameter>geom_array</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_processing.xml:1438
#, fuzzy, no-c-format
msgid ""
"Creates a GeometryCollection containing the polygons formed by the "
"constituent linework of a set of geometries. Input linework must be "
"correctly noded for this function to work properly."
msgstr ""
"Erzeugt eine Sammelgeometrie/GeometryCollection, welche Polygone enthält, "
"die aus den einzelnen Linien einer Menge von Geometrien gebildet werden "
"können."

#. Tag: para
#: reference_processing.xml:1443
#, no-c-format
msgid ""
"To ensure input is fully noded use <xref linkend=\"ST_Node\"/> on the input "
"geometry before polygonizing."
msgstr ""

#. Tag: para
#: reference_processing.xml:1450
#, fuzzy, no-c-format
msgid ""
"GeometryCollections are often difficult to deal with with third party tools. "
"Use <xref linkend=\"ST_Dump\"/> to convert the polygonize result into "
"separate polygons."
msgstr ""
"Tools von Drittanbietern haben öfters Probleme mit einer Sammelgeometrie. "
"Verwenden Sie daher ST_Polygonize in Verbindung mit <xref linkend=\"ST_Dump"
"\"/>, um die Polygone in Einzelpoygone zu zerlegen."

#. Tag: para
#: reference_processing.xml:1456
#, fuzzy, no-c-format
msgid "Availability: 1.0.0RC1"
msgstr "Verfügbarkeit: 1.5.0"

#. Tag: title
#: reference_processing.xml:1460
#, no-c-format
msgid "Examples: Polygonizing single linestrings"
msgstr "Beispiele: Einzelne Linienzüge in ein Polygon umwandeln."

#. Tag: programlisting
#: reference_processing.xml:1461
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_Polygonize(the_geom_4269)) As geomtextrep\n"
"FROM (SELECT the_geom_4269 FROM ma.suffolk_edges ORDER BY tlid LIMIT 45) As "
"foo;\n"
"\n"
"geomtextrep\n"
"-------------------------------------\n"
" SRID=4269;GEOMETRYCOLLECTION(POLYGON((-71.040878 42.285678,-71.040943 "
"42.2856,-71.04096 42.285752,-71.040878 42.285678)),\n"
" POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 "
"42.354358,-71.171794 42.354971,-71.170511 42.354855,\n"
" -71.17112 42.354238,-71.17166 42.353675)))\n"
"(1 row)\n"
"\n"
"--Use ST_Dump to dump out the polygonize geoms into individual polygons\n"
"SELECT ST_AsEWKT((ST_Dump(foofoo.polycoll)).geom) As geomtextrep\n"
"FROM (SELECT ST_Polygonize(the_geom_4269) As polycoll\n"
"    FROM (SELECT the_geom_4269 FROM ma.suffolk_edges\n"
"        ORDER BY tlid LIMIT 45) As foo) As foofoo;\n"
"\n"
"geomtextrep\n"
"------------------------\n"
" SRID=4269;POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 "
"42.285752,\n"
"-71.040878 42.285678))\n"
" SRID=4269;POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 "
"42.354358\n"
",-71.171794 42.354971,-71.170511 42.354855,-71.17112 42.354238,-71.17166 "
"42.353675))\n"
"(2 rows)"
msgstr ""
"SELECT ST_AsEWKT(ST_Polygonize(the_geom_4269)) As geomtextrep\n"
"FROM (SELECT the_geom_4269 FROM ma.suffolk_edges ORDER BY tlid LIMIT 45) As "
"foo;\n"
"\n"
"geomtextrep\n"
"-------------------------------------\n"
" SRID=4269;GEOMETRYCOLLECTION(POLYGON((-71.040878 42.285678,-71.040943 "
"42.2856,-71.04096 42.285752,-71.040878 42.285678)),\n"
" POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 "
"42.354358,-71.171794 42.354971,-71.170511 42.354855,\n"
" -71.17112 42.354238,-71.17166 42.353675)))\n"
"(1 row)\n"
"\n"
"--Verwendung von ST_Dump um die polygonisierten Geometrien in einzelne "
"Polygone auszuladen\n"
"SELECT ST_AsEWKT((ST_Dump(foofoo.polycoll)).geom) As geomtextrep\n"
"FROM (SELECT ST_Polygonize(the_geom_4269) As polycoll\n"
"        FROM (SELECT the_geom_4269 FROM ma.suffolk_edges\n"
"                ORDER BY tlid LIMIT 45) As foo) As foofoo;\n"
"\n"
"geomtextrep\n"
"------------------------\n"
" SRID=4269;POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 "
"42.285752,\n"
"-71.040878 42.285678))\n"
" SRID=4269;POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 "
"42.354358\n"
",-71.171794 42.354971,-71.170511 42.354855,-71.17112 42.354238,-71.17166 "
"42.353675))\n"
"(2 rows)"

#. Tag: para
#: reference_processing.xml:1466
#, no-c-format
msgid ", <xref linkend=\"ST_Dump\"/>"
msgstr ", <xref linkend=\"ST_Dump\"/>"

#. Tag: refname
#: reference_processing.xml:1475
#, no-c-format
msgid "ST_ReducePrecision"
msgstr ""

#. Tag: refpurpose
#: reference_processing.xml:1477
#, no-c-format
msgid ""
"Returns a valid geometry with all points rounded to the provided grid "
"tolerance."
msgstr ""

#. Tag: funcprototype
#: reference_processing.xml:1482
#, fuzzy, no-c-format
msgid ""
"<funcdef>geometry <function>ST_ReducePrecision</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g</parameter></paramdef> "
"<paramdef><type>float8 </type> <parameter>gridsize</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_Difference</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1496
#, no-c-format
msgid ""
"Returns a valid geometry with all points rounded to the provided grid "
"tolerance, and features below the tolerance removed."
msgstr ""

#. Tag: para
#: reference_processing.xml:1498
#, no-c-format
msgid ""
"Unlike <xref linkend=\"ST_SnapToGrid\"/> the returned geometry will be "
"valid, with no ring self-intersections or collapsed components."
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:1505
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_ReducePrecision('POINT(1.412 19.323)', 0.1));\n"
"    st_astext\n"
"-----------------\n"
" POINT(1.4 19.3)\n"
"\n"
"SELECT ST_AsText(ST_ReducePrecision('POINT(1.412 19.323)', 1.0));\n"
"  st_astext\n"
"-------------\n"
" POINT(1 19)\n"
"\n"
" SELECT ST_AsText(ST_ReducePrecision('POINT(1.412 19.323)', 10));\n"
"  st_astext\n"
"-------------\n"
" POINT(0 20)"
msgstr ""

#. Tag: para
#: reference_processing.xml:1511
#, fuzzy, no-c-format
msgid ", <xref linkend=\"ST_Simplify\"/>, <xref linkend=\"ST_SimplifyVW\"/>"
msgstr ""
", <xref linkend=\"ST_SimplifyPreserveTopology\"/>, Topologie <xref linkend="
"\"TP_ST_Simplify\"/>"

#. Tag: refname
#: reference_processing.xml:1517
#, no-c-format
msgid "ST_SharedPaths"
msgstr "ST_SharedPaths"

#. Tag: refpurpose
#: reference_processing.xml:1518
#, no-c-format
msgid ""
"Returns a collection containing paths shared by the two input linestrings/"
"multilinestrings."
msgstr ""
"Gibt eine Sammelgeometrie zurück, welche die gemeinsamen Strecken der beiden "
"eingegebenen LineStrings/MultiLinestrings enthält."

#. Tag: funcprototype
#: reference_processing.xml:1523
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_SharedPaths</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>lineal1</parameter></paramdef> "
"<paramdef><type>geometry</type> <parameter>lineal2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_SharedPaths</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>lineal1</parameter></paramdef> "
"<paramdef><type>geometry</type> <parameter>lineal2</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1533
#, no-c-format
msgid ""
"Returns a collection containing paths shared by the two input geometries. "
"Those going in the same direction are in the first element of the "
"collection, those going in the opposite direction are in the second element. "
"The paths themselves are given in the direction of the first geometry."
msgstr ""
"Gibt eine Sammelgeometrie zurück, die die gemeinsamen Pfade zweier "
"Eingabegeometrie enthält. Jene, die in derselben Richtung orientiert sind, "
"werden im ersten Element der Sammelgeometrie, jene die in die "
"entgegengesetzte Richtung orientiert sind, werden im zweiten Element "
"gespeichert. Die Pfade selbst befinden sich in der ersten Geometrie."

#. Tag: title
#: reference_processing.xml:1541
#, no-c-format
msgid "Examples: Finding shared paths"
msgstr "Beispiele: Gemeinsame Strecken finden"

#. Tag: para
#: reference_processing.xml:1551
#, no-c-format
msgid "A multilinestring and a linestring"
msgstr "Ein MultiLinestring und ein LineString"

#. Tag: para
#: reference_processing.xml:1562
#, no-c-format
msgid ""
"The shared path of multilinestring and linestring overlaid with original "
"geometries."
msgstr ""
"Die gemeinsame Strecke eines MultiLinestring und Linestring mit überlagerter "
"Ursprungsgeometrie."

#. Tag: programlisting
#: reference_processing.xml:1565
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"  ST_SharedPaths(\n"
"    ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 "
"125),\n"
"       (51 150,101 150,76 175,51 150))'),\n"
"    ST_GeomFromText('LINESTRING(151 100,126 156.25,126 125,90 161, 76 "
"175)')\n"
"    )\n"
"  ) As wkt\n"
"\n"
"                                wkt\n"
"-------------------------------------------------------------\n"
"GEOMETRYCOLLECTION(MULTILINESTRING((126 156.25,126 125),\n"
" (101 150,90 161),(90 161,76 175)),MULTILINESTRING EMPTY)"
msgstr ""
"SELECT ST_AsText(\n"
"  ST_SharedPaths(\n"
"    ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 "
"125),\n"
"           (51 150,101 150,76 175,51 150))'),\n"
"        ST_GeomFromText('LINESTRING(151 100,126 156.25,126 125,90 161, 76 "
"175)')\n"
"        )\n"
"  ) As wkt\n"
"\n"
"                                wkt\n"
"-------------------------------------------------------------\n"
"GEOMETRYCOLLECTION(MULTILINESTRING((126 156.25,126 125),\n"
" (101 150,90 161),(90 161,76 175)),MULTILINESTRING EMPTY)"

#. Tag: programlisting
#: reference_processing.xml:1571
#, fuzzy, no-c-format
msgid ""
"-- same example but linestring orientation flipped\n"
"SELECT ST_AsText(\n"
"  ST_SharedPaths(\n"
"   ST_GeomFromText('LINESTRING(76 175,90 161,126 125,126 156.25,151 100)'),\n"
"   ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),\n"
"       (51 150,101 150,76 175,51 150))')\n"
"    )\n"
"  ) As wkt\n"
"\n"
"                                wkt\n"
"-------------------------------------------------------------\n"
"GEOMETRYCOLLECTION(MULTILINESTRING EMPTY,\n"
"MULTILINESTRING((76 175,90 161),(90 161,101 150),(126 125,126 156.25)))"
msgstr ""
"-- Das selbe Beispiel, aber die Richtung des Linienzuges ist umgedreht/"
"flipped\n"
"SELECT ST_AsText(\n"
"  ST_SharedPaths(\n"
"   ST_GeomFromText('LINESTRING(76 175,90 161,126 125,126 156.25,151 100)'),\n"
"   ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),\n"
"           (51 150,101 150,76 175,51 150))')\n"
"        )\n"
"  ) As wkt\n"
"\n"
"                                wkt\n"
"-------------------------------------------------------------\n"
"GEOMETRYCOLLECTION(MULTILINESTRING EMPTY,\n"
"MULTILINESTRING((76 175,90 161),(90 161,101 150),(126 125,126 156.25)))"

#. Tag: para
#: reference_processing.xml:1581
#, no-c-format
msgid ""
", <xref linkend=\"ST_GeometryN\"/>, <xref linkend=\"ST_NumGeometries\"/>"
msgstr ""
", <xref linkend=\"ST_GeometryN\"/>, <xref linkend=\"ST_NumGeometries\"/>"

#. Tag: refname
#: reference_processing.xml:1591
#, no-c-format
msgid "ST_Simplify"
msgstr "ST_Simplify"

#. Tag: refpurpose
#: reference_processing.xml:1592
#, fuzzy, no-c-format
msgid ""
"Returns a simplified version of a geometry, using the Douglas-Peucker "
"algorithm."
msgstr ""
"Gibt eine vereinfachte Version der Ausgangsgeometrie zurück. Verwendet den "
"Douglas-Peucker Algorithmus."

#. Tag: funcprototype
#: reference_processing.xml:1598
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_Simplify</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef> "
"<paramdef><type>boolean</type> <parameter>preserveCollapsed</parameter></"
"paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_Simplify</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef> "
"<paramdef><type>boolean</type> <parameter>preserveCollapsed</parameter></"
"paramdef>"

#. Tag: para
#: reference_processing.xml:1609
#, no-c-format
msgid ""
"Returns a \"simplified\" version of the given geometry using the Douglas-"
"Peucker algorithm. Will actually do something only with (multi)lines and "
"(multi)polygons but you can safely call it with any kind of geometry. Since "
"simplification occurs on a object-by-object basis you can also feed a "
"GeometryCollection to this function."
msgstr ""
"Gibt eine \"vereinfachte\" Version der gegebenen Geometrie zurück. Verwendet "
"den Douglas-Peucker Algorithmus. Tut zurzeit nur mit (Multi)Lines und "
"(Multi)Polygons etwas, kann aber gefahrlos mit jedem geometrischen Datentyp "
"verwendet werden. Da die Vereinfachung auf einer Objekt zu Objekt Basis "
"passiert, können Sie diese Funktion auch mit einer Sammelgeometrie speisen."

#. Tag: para
#: reference_processing.xml:1616
#, no-c-format
msgid ""
"The \"preserve collapsed\" flag will retain objects that would otherwise be "
"too small given the tolerance. For example, a 1m long line simplified with a "
"10m tolerance. If the preserve flag is given, the line will not disappear. "
"This flag is useful for rendering engines, to avoid having large numbers of "
"very small objects disappear from a map leaving surprising gaps."
msgstr ""
"Der Flag \"preservve collapsed\" erhält Geoobjekte, die andernfalls zu klein "
"für die gegebene Toleranz wären. Zum Beispiel eine 1m lange Linie die mit "
"10m Toleranz vereinfacht wurde. Wenn die Flag \"preserve collapsed\" "
"angegeben ist, wird die Linie erhalten. Dieser Flag ist nützlich für "
"Rendering-Engines, um in Kartendarstellungen das Verlorengehen einer großen "
"Anzahl von kleinen Objekten und die dadurch entstehende Lücken zu vermeiden."

#. Tag: para
#: reference_processing.xml:1622 reference_processing.xml:1704
#: reference_processing.xml:1805
#, no-c-format
msgid ""
"Note that returned geometry might lose its simplicity (see <xref linkend="
"\"ST_IsSimple\"/>)"
msgstr ""
"Bemerke, dass die zurückgegebene Geometrie ihre Simplizität verlieren kann "
"(siehe <xref linkend=\"ST_IsSimple\"/>)."

#. Tag: para
#: reference_processing.xml:1624 reference_processing.xml:1706
#: reference_processing.xml:1807
#, no-c-format
msgid ""
"Note topology may not be preserved and may result in invalid geometries. Use "
"(see <xref linkend=\"ST_SimplifyPreserveTopology\"/>) to preserve topology."
msgstr ""
"Beachten Sie bitte, das die Topologie möglicherweise nicht erhalten bleibt "
"und ungültige Geometrien entstehen können. Benutzen Sie bitte (see <xref "
"linkend=\"ST_SimplifyPreserveTopology\"/>) um die Topologie zu erhalten."

#. Tag: para
#: reference_processing.xml:1626
#, no-c-format
msgid "Availability: 1.2.2"
msgstr "Verfügbarkeit: 1.2.2"

#. Tag: para
#: reference_processing.xml:1631
#, no-c-format
msgid "A circle simplified too much becomes a triangle, medium an octagon,"
msgstr ""
"Ein zu stark vereinfachter Kreis wird zu einem Dreieck, mittelmäßig "
"vereinfacht zum Achteck:"

#. Tag: programlisting
#: reference_processing.xml:1632
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Npoints(the_geom) AS np_before,\n"
"       ST_NPoints(ST_Simplify(the_geom,0.1)) AS np01_notbadcircle,\n"
"       ST_NPoints(ST_Simplify(the_geom,0.5)) AS np05_notquitecircle,\n"
"       ST_NPoints(ST_Simplify(the_geom,1)) AS np1_octagon,\n"
"       ST_NPoints(ST_Simplify(the_geom,10)) AS np10_triangle,\n"
"       (ST_Simplify(the_geom,100) is null) AS  np100_geometrygoesaway\n"
"  FROM\n"
"    (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) AS foo;\n"
"\n"
" np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | "
"np10_triangle | np100_geometrygoesaway\n"
"-----------+-------------------+---------------------+-------------"
"+---------------+------------------------\n"
"        49 |                33 |                  17 |           9 "
"|             4 | t"
msgstr ""
"SELECT ST_Npoints(the_geom) As np_before, "
"ST_NPoints(ST_Simplify(the_geom,0.1)) As np01_notbadcircle, "
"ST_NPoints(ST_Simplify(the_geom,0.5)) As np05_notquitecircle,\n"
"ST_NPoints(ST_Simplify(the_geom,1)) As np1_octagon, "
"ST_NPoints(ST_Simplify(the_geom,10)) As np10_triangle,\n"
"(ST_Simplify(the_geom,100) is null) As  np100_geometrygoesaway\n"
"FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) As foo;\n"
"-result\n"
" np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | "
"np10_triangle | np100_geometrygoesaway\n"
"-----------+-------------------+---------------------+-------------"
"+---------------+------------------------\n"
"                49 |                33 |                  17 |           9 "
"|             4 | t"

#. Tag: para
#: reference_processing.xml:1636
#, no-c-format
msgid ""
", <xref linkend=\"ST_SimplifyPreserveTopology\"/>, Topology <xref linkend="
"\"TP_ST_Simplify\"/>"
msgstr ""
", <xref linkend=\"ST_SimplifyPreserveTopology\"/>, Topologie <xref linkend="
"\"TP_ST_Simplify\"/>"

#. Tag: refname
#: reference_processing.xml:1642
#, no-c-format
msgid "ST_SimplifyPreserveTopology"
msgstr "ST_SimplifyPreserveTopology"

#. Tag: refpurpose
#: reference_processing.xml:1643
#, fuzzy, no-c-format
msgid ""
"Returns a simplified and valid version of a geometry, using the Douglas-"
"Peucker algorithm."
msgstr ""
"Gibt eine vereinfachte Version der Ausgangsgeometrie zurück. Verwendet den "
"Douglas-Peucker Algorithmus."

#. Tag: funcprototype
#: reference_processing.xml:1649
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_SimplifyPreserveTopology</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_SimplifyPreserveTopology</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1659
#, no-c-format
msgid ""
"Returns a \"simplified\" version of the given geometry using the Douglas-"
"Peucker algorithm. Will avoid creating derived geometries (polygons in "
"particular) that are invalid. Will actually do something only with "
"(multi)lines and (multi)polygons but you can safely call it with any kind of "
"geometry. Since simplification occurs on a object-by-object basis you can "
"also feed a GeometryCollection to this function."
msgstr ""
"Gibt eine \"vereinfachte\" Version der gegebenen Geometrie zurück. Verwendet "
"den Douglas-Peucker Algorithmus. Vermeidet es, eine invalide Geometrie "
"(insbesondere Polygone) zu erzeugen. Tut zurzeit nur mit (Multi)Lines und "
"(Multi)Polygons etwas, kann aber gefahrlos mit jedem geometrischen Datentyp "
"verwendet werden. Da die Vereinfachung auf einer Objekt zu Objekt Basis "
"passiert, können Sie diese Funktion auch mit einer Sammelgeometrie speisen."

#. Tag: para
#: reference_processing.xml:1668
#, no-c-format
msgid "Availability: 1.3.3"
msgstr "Verfügbarkeit: 1.3.3"

#. Tag: para
#: reference_processing.xml:1673
#, no-c-format
msgid ""
"Same example as Simplify, but we see Preserve Topology prevents "
"oversimplification. The circle can at most become a square."
msgstr ""
"Das gleiche Beispiel wie mit ST_Simplify, aber wir sehen, dass "
"ST_SimplifyPreserveTopology übermäßige Vereinfachung verhindert. Der Kreis "
"kann maximal ein Quadrat werden."

#. Tag: programlisting
#: reference_processing.xml:1674
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Npoints(the_geom) As np_before, "
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.1)) As np01_notbadcircle, "
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.5)) As "
"np05_notquitecircle,\n"
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,1)) As np1_octagon, "
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,10)) As np10_square,\n"
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,100)) As  np100_stillsquare\n"
"FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) As foo;\n"
"\n"
"--result--\n"
" np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | "
"np10_square | np100_stillsquare\n"
"-----------+-------------------+---------------------+-------------"
"+---------------+-------------------\n"
"        49 |                33 |                  17 |           9 "
"|             5 |                 5"
msgstr ""
"SELECT ST_Npoints(the_geom) As np_before, "
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.1)) As np01_notbadcircle, "
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.5)) As "
"np05_notquitecircle,\n"
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,1)) As np1_octagon, "
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,10)) As np10_square,\n"
"ST_NPoints(ST_SimplifyPreserveTopology(the_geom,100)) As  np100_stillsquare\n"
"FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) As foo;\n"
"\n"
"--result--\n"
" np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | "
"np10_square | np100_stillsquare\n"
"-----------+-------------------+---------------------+-------------"
"+---------------+-------------------\n"
"                49 |                33 |                  17 |           9 "
"|             5 |                 5"

#. Tag: refname
#: reference_processing.xml:1684
#, no-c-format
msgid "ST_SimplifyVW"
msgstr "ST_SimplifyVW"

#. Tag: refpurpose
#: reference_processing.xml:1685
#, fuzzy, no-c-format
msgid ""
"Returns a simplified version of a geometry, using the Visvalingam-Whyatt "
"algorithm"
msgstr ""
"Gibt eine vereinfachte Version der Ausgangsgeometrie zurück. Verwendet den "
"Visvalingam-Whyatt Algorithmus."

#. Tag: funcprototype
#: reference_processing.xml:1690
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_SimplifyVW</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_SimplifyVW</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1700
#, no-c-format
msgid ""
"Returns a \"simplified\" version of the given geometry using the Visvalingam-"
"Whyatt algorithm. Will actually do something only with (multi)lines and "
"(multi)polygons but you can safely call it with any kind of geometry. Since "
"simplification occurs on a object-by-object basis you can also feed a "
"GeometryCollection to this function."
msgstr ""
"Gibt eine \"vereinfachte\" Version der gegebenen Geometrie zurück. Verwendet "
"den Visvalingam-Whyatt Algorithmus. Tut zurzeit nur mit (Multi)Lines und "
"(Multi)Polygons etwas, kann aber gefahrlos mit jedem geometrischen Datentyp "
"verwendet werden. Da die Vereinfachung auf einer Objekt zu Objekt Basis "
"passiert, können Sie diese Funktion auch mit einer Sammelgeometrie speisen."

#. Tag: para
#: reference_processing.xml:1707 reference_processing.xml:1749
#, no-c-format
msgid ""
"This function handles 3D and the third dimension will affect the result."
msgstr ""
"Diese Funktion kann mit 3D umgehen und die dritte Dimension beeinflusst auch "
"das Ergebnis."

#. Tag: para
#: reference_processing.xml:1708 reference_processing.xml:1810
#, no-c-format
msgid "Availability: 2.2.0"
msgstr "Verfügbarkeit: 2.2.0"

#. Tag: para
#: reference_processing.xml:1713
#, no-c-format
msgid "A LineString is simplified with a minimum area threshold of 30."
msgstr ""
"Ein Linienzug vereinfacht mit einem Schwellenwert von 30 für die minimale "
"Fläche."

#. Tag: programlisting
#: reference_processing.xml:1714
#, fuzzy, no-c-format
msgid ""
"select ST_AsText(ST_SimplifyVW(geom,30)) simplified\n"
"FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As "
"foo;\n"
"-result\n"
" simplified\n"
"------------------------------\n"
"LINESTRING(5 2,7 25,10 10)"
msgstr ""
"select ST_AsText(ST_SimplifyVW(geom,30)) simplified\n"
"FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As "
"foo;\n"
"-result\n"
" simplified\n"
"-----------+-------------------+\n"
"LINESTRING(5 2,7 25,10 10)"

#. Tag: para
#: reference_processing.xml:1718
#, no-c-format
msgid ""
", <xref linkend=\"ST_Simplify\"/>, <xref linkend="
"\"ST_SimplifyPreserveTopology\"/>, Topology <xref linkend=\"TP_ST_Simplify\"/"
">"
msgstr ""
", <xref linkend=\"ST_Simplify\"/>, <xref linkend="
"\"ST_SimplifyPreserveTopology\"/>, Topology <xref linkend=\"TP_ST_Simplify\"/"
">"

#. Tag: refname
#: reference_processing.xml:1724
#, no-c-format
msgid "ST_ChaikinSmoothing"
msgstr ""

#. Tag: refpurpose
#: reference_processing.xml:1725
#, fuzzy, no-c-format
msgid "Returns a smoothed version of a geometry, using the Chaikin algorithm"
msgstr ""
"Gibt eine vereinfachte Version der Ausgangsgeometrie zurück. Verwendet den "
"Visvalingam-Whyatt Algorithmus."

#. Tag: funcprototype
#: reference_processing.xml:1730
#, fuzzy, no-c-format
msgid ""
"<funcdef>geometry <function>ST_ChaikinSmoothing</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
"<paramdef><type>integer</type> <parameter>nIterations = 1</parameter></"
"paramdef> <paramdef><type>boolean</type> <parameter>preserveEndPoints = "
"false</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_Simplify</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef> "
"<paramdef><type>boolean</type> <parameter>preserveCollapsed</parameter></"
"paramdef>"

#. Tag: para
#: reference_processing.xml:1741
#, no-c-format
msgid ""
"Returns a \"smoothed\" version of the given geometry using the Chaikin "
"algorithm. See <ulink url=\"http://www.idav.ucdavis.edu/education/CAGDNotes/"
"Chaikins-Algorithm/Chaikins-Algorithm.html\">Chaikins-Algorithm</ulink> for "
"an explanation of the process. For each iteration the number of vertex "
"points will double. The function puts new vertex points at 1/4 of the line "
"before and after each point and removes the original point. To reduce the "
"number of points use one of the simplification functions on the result. The "
"new points gets interpolated values for all included dimensions, also z and "
"m."
msgstr ""

#. Tag: para
#: reference_processing.xml:1747
#, no-c-format
msgid "Second argument, number of iterations is limited to max 5 iterations"
msgstr ""

#. Tag: para
#: reference_processing.xml:1748
#, no-c-format
msgid ""
"Note third argument is only valid for polygons, and will be ignored for "
"linestrings"
msgstr ""

#. Tag: para
#: reference_processing.xml:1750
#, no-c-format
msgid ""
"Note that returned geometry will get more points than the original. To "
"reduce the number of points again use one of the simplification functions on "
"the result. (see <xref linkend=\"ST_Simplify\"/> and <xref linkend="
"\"ST_SimplifyVW\"/>)"
msgstr ""

#. Tag: para
#: reference_processing.xml:1758
#, no-c-format
msgid "A triangle is smoothed"
msgstr ""

#. Tag: programlisting
#: reference_processing.xml:1759
#, no-c-format
msgid ""
"select ST_AsText(ST_ChaikinSmoothing(geom)) smoothed\n"
"FROM (SELECT  'POLYGON((0 0, 8 8, 0 16, 0 0))'::geometry geom) As foo;\n"
"┌───────────────────────────────────────────┐\n"
"│                 smoothed                  │\n"
"├───────────────────────────────────────────┤\n"
"│ POLYGON((2 2,6 6,6 10,2 14,0 12,0 4,2 2)) │\n"
"└───────────────────────────────────────────┘"
msgstr ""

#. Tag: refname
#: reference_processing.xml:1769
#, no-c-format
msgid "ST_SetEffectiveArea"
msgstr "ST_SetEffectiveArea"

#. Tag: refpurpose
#: reference_processing.xml:1770
#, fuzzy, no-c-format
msgid ""
"Sets the effective area for each vertex, using the Visvalingam-Whyatt "
"algorithm."
msgstr ""
"Gibt eine vereinfachte Version der Ausgangsgeometrie zurück. Verwendet den "
"Visvalingam-Whyatt Algorithmus."

#. Tag: funcprototype
#: reference_processing.xml:1777
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_SetEffectiveArea</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>threshold = 0</parameter></paramdef> "
"<paramdef><type>integer</type> <parameter>set_area = 1</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_SetEffectiveArea</function></funcdef> "
"<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>threshold = 0</parameter></paramdef> "
"<paramdef><type>integer</type> <parameter>set_area = 1</parameter></paramdef>"

#. Tag: para
#: reference_processing.xml:1788
#, no-c-format
msgid ""
"Sets the effective area for each vertex, using the Visvalingam-Whyatt "
"algorithm. The effective area is stored as the M-value of the vertex. If the "
"optional \"theshold\" parameter is used, a simplified geometry will be "
"returned, containing only vertices with an effective area greater than or "
"equal to the threshold value."
msgstr ""
"Setzt die Nutzfläche für jeden Knoten. Verwendet den Visvalingam-Whyatt "
"Algorithmus. Die Nutzfläche wird als M-Wert des Knoten gespeichert. Wird der "
"optionale Parameter \"threshold\" verwendet, so wird eine vereinfachte "
"Geometrie zurückgegeben, die nur jene Knoten enthält, deren Nutzfläche "
"größer oder gleich dem Schwellenwert ist."

#. Tag: para
#: reference_processing.xml:1793
#, no-c-format
msgid ""
"This function can be used for server-side simplification when a threshold is "
"specified. Another option is to use a threshold value of zero. In this case, "
"the full geometry will be returned with effective areas as M-values, which "
"can be used by the client to simplify very quickly."
msgstr ""
"Diese Funktion kann für die serverseitige Vereinfachung, mittels eines "
"Schwellenwerts verwendet werden. Eine andere Möglichkeit besteht darin, "
"einen Schwellenwert von null anzugeben. In diesem Fall wird die gesamte "
"Geometrie inklusive der Nutzflächen als M-Werte zurückgegeben, welche dann "
"am Client für eine rasche Vereinfachung genutzt werden können."

#. Tag: para
#: reference_processing.xml:1796
#, no-c-format
msgid ""
"Will actually do something only with (multi)lines and (multi)polygons but "
"you can safely call it with any kind of geometry. Since simplification "
"occurs on a object-by-object basis you can also feed a GeometryCollection to "
"this function."
msgstr ""
"Tut zurzeit nur mit (Multi)Lines und (Multi)Polygons etwas, kann aber "
"gefahrlos mit jedem geometrischen Datentyp verwendet werden. Da die "
"Vereinfachung auf einer Objekt zu Objekt Basis passiert, können Sie diese "
"Funktion auch mit einer Sammelgeometrie speisen."

#. Tag: para
#: reference_processing.xml:1808
#, no-c-format
msgid "The output geometry will lose all previous information in the M-values"
msgstr ""
"Die Ausgabegeometrie verliert die gesamte vorhandene Information über die M-"
"Werte"

#. Tag: para
#: reference_processing.xml:1809
#, no-c-format
msgid ""
"This function handles 3D and the third dimension will affect the effective "
"area"
msgstr ""
"Diese Funktion kann mit 3D umgehen und die dritte Dimension beeinflusst auch "
"die tatsächliche Fläche"

#. Tag: para
#: reference_processing.xml:1815
#, no-c-format
msgid ""
"Calculating the effective area of a LineString. Because we use a threshold "
"value of zero, all vertices in the input geometry are returned."
msgstr ""
"Berechnung der Nutzfläche eines Linienzugs. Da wir einen Schwellenwert von "
"null verwenden, werden alle Knoten der Eingabegeomettrie zurückgegeben."

#. Tag: programlisting
#: reference_processing.xml:1818
#, no-c-format
msgid ""
"select ST_AsText(ST_SetEffectiveArea(geom)) all_pts, "
"ST_AsText(ST_SetEffectiveArea(geom,30) ) thrshld_30\n"
"FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As "
"foo;\n"
"-result\n"
" all_pts | thrshld_30\n"
"-----------+-------------------+\n"
"LINESTRING M (5 2 3.40282346638529e+38,3 8 29,6 20 1.5,7 25 49.5,10 10 "
"3.40282346638529e+38) | LINESTRING M (5 2 3.40282346638529e+38,7 25 49.5,10 "
"10 3.40282346638529e+38)"
msgstr ""
"select ST_AsText(ST_SetEffectiveArea(geom)) all_pts, "
"ST_AsText(ST_SetEffectiveArea(geom,30) ) thrshld_30\n"
"FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As "
"foo;\n"
"-result\n"
" all_pts | thrshld_30\n"
"-----------+-------------------+\n"
"LINESTRING M (5 2 3.40282346638529e+38,3 8 29,6 20 1.5,7 25 49.5,10 10 "
"3.40282346638529e+38) | LINESTRING M (5 2 3.40282346638529e+38,7 25 49.5,10 "
"10 3.40282346638529e+38)"

#. Tag: refname
#: reference_processing.xml:1828
#, no-c-format
msgid "ST_VoronoiLines"
msgstr "ST_VoronoiLines"

#. Tag: refpurpose
#: reference_processing.xml:1830
#, fuzzy, no-c-format
msgid ""
"Returns the boundaries of the Voronoi diagram of the vertices of a geometry."
msgstr ""
"Gibt die Zellen des Voronoi Diagramms zurück, die aus den Knoten der "
"Geometrie erzeugt wurden."

#. Tag: funcprototype
#: reference_processing.xml:1835
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_VoronoiLines</function></funcdef> <paramdef> "
"<parameter>g1</parameter> <type>geometry</type> </paramdef> <paramdef choice="
"\"opt\"> <parameter>tolerance</parameter> <type>float8</type> </paramdef> "
"<paramdef choice=\"opt\"> <parameter>extend_to</parameter> <type>geometry</"
"type> </paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_VoronoiLines</function></funcdef> <paramdef> "
"<parameter>g1</parameter> <type>geometry</type> </paramdef> <paramdef choice="
"\"opt\"> <parameter>tolerance</parameter> <type>float8</type> </paramdef> "
"<paramdef choice=\"opt\"> <parameter>extend_to</parameter> <type>geometry</"
"type> </paramdef>"

#. Tag: para
#: reference_processing.xml:1856
#, fuzzy, no-c-format
msgid ""
"ST_VoronoiLines computes a two-dimensional <ulink url=\"https://en.wikipedia."
"org/wiki/Voronoi_diagram\">Voronoi diagram</ulink> from the vertices of the "
"supplied geometry and returns the boundaries between cells in that diagram "
"as a MultiLineString. Returns null if input geometry is null. Returns an "
"empty geometry collection if the input geometry contains only one vertex. "
"Returns an empty geometry collection if the extend_to envelope has zero area."
msgstr ""
"ST_VoronoiLines berechnet ein zweidimensonales <ulink url=\"https://en."
"wikipedia.org/wiki/Voronoi_diagram\">Voronoi Diagramm</ulink> aus den Knoten "
"der gegebenen Geometrie und stellt die Grenzen zwischen den Zellen des "
"Diagramms als MultiLineString dar."

#. Tag: para
#: reference_processing.xml:1861 reference_processing.xml:1951
#, no-c-format
msgid "Optional parameters:"
msgstr "Optionale Parameter:"

#. Tag: para
#: reference_processing.xml:1865 reference_processing.xml:1955
#, no-c-format
msgid ""
"'tolerance' : The distance within which vertices will be considered "
"equivalent. Robustness of the algorithm can be improved by supplying a "
"nonzero tolerance distance. (default = 0.0)"
msgstr ""
"'tolerance' : Die Entfernung innerhalb derer Knoten als ident betrachtet "
"werden. Die Robustheit des Algorithmus kann verbessert werden, wenn die "
"Entfernungstoleranz nicht mit Null angegeben wird. (Standardwert = 0.0)"

#. Tag: para
#: reference_processing.xml:1868 reference_processing.xml:1958
#, fuzzy, no-c-format
msgid ""
"'extend_to' : If a geometry is supplied as the \"extend_to\" parameter, the "
"diagram will be extended to cover the envelope of the \"extend_to\" "
"geometry, unless that envelope is smaller than the default envelope (default "
"= NULL, default envelope is boundingbox of input geometry extended by about "
"50% in each direction)."
msgstr ""
"'extend_to' : Wird eine Geometrie als \"extend_to\" Parameter zur Verfügung "
"gestellt, so wird das Diagramm erweitert, um die Einhüllende der \"extend_to"
"\"-Geometrie zu erfassen. Dies geschieht solange die Einhüllende nicht "
"kleiner als die Standardeinhüllende ist. (Standardwert = NULL) "

#. Tag: para
#: reference_processing.xml:1889
#, no-c-format
msgid "Voronoi lines with tolerance of 30 units"
msgstr "Voronoi Linien mit einer Toleranz von 30 Einheiten"

#. Tag: programlisting
#: reference_processing.xml:1892 reference_processing.xml:2011
#, no-c-format
msgid ""
"SELECT ST_VoronoiLines(geom, 30) As geom\n"
"FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry "
"As geom ) As g"
msgstr ""
"SELECT ST_VoronoiLines(geom, 30) As geom\n"
"FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry "
"As geom ) As g"

#. Tag: screen
#: reference_processing.xml:1893 reference_processing.xml:2012
#, no-c-format
msgid ""
"-- ST_AsText output\n"
"MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),"
"(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 "
"-45.7142857142858,36.8181818181818 92.2727272727273))"
msgstr ""
"-- ST_AsText output\n"
"MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),"
"(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 "
"-45.7142857142858,36.8181818181818 92.2727272727273))"

#. Tag: para
#: reference_processing.xml:1906
#, no-c-format
msgid ""
", <xref linkend=\"ST_VoronoiPolygons\"/>, <xref linkend=\"ST_Collect\"/>"
msgstr ""
", <xref linkend=\"ST_VoronoiPolygons\"/>, <xref linkend=\"ST_Collect\"/>"

#. Tag: refname
#: reference_processing.xml:1916
#, no-c-format
msgid "ST_VoronoiPolygons"
msgstr "ST_VoronoiPolygons"

#. Tag: refpurpose
#: reference_processing.xml:1918
#, fuzzy, no-c-format
msgid "Returns the cells of the Voronoi diagram of the vertices of a geometry."
msgstr ""
"Gibt die Zellen des Voronoi Diagramms zurück, die aus den Knoten der "
"Geometrie erzeugt wurden."

#. Tag: funcprototype
#: reference_processing.xml:1923
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_VoronoiPolygons</function></funcdef> "
"<paramdef> <parameter>g1</parameter> <type>geometry</type> </paramdef> "
"<paramdef choice=\"opt\"> <parameter>tolerance</parameter> <type>float8</"
"type> </paramdef> <paramdef choice=\"opt\"> <parameter>extend_to</parameter> "
"<type>geometry</type> </paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_VoronoiPolygons</function></funcdef> "
"<paramdef> <parameter>g1</parameter> <type>geometry</type> </paramdef> "
"<paramdef choice=\"opt\"> <parameter>tolerance</parameter> <type>float8</"
"type> </paramdef> <paramdef choice=\"opt\"> <parameter>extend_to</parameter> "
"<type>geometry</type> </paramdef>"

#. Tag: para
#: reference_processing.xml:1945
#, fuzzy, no-c-format
msgid ""
"ST_VoronoiPolygons computes a two-dimensional <ulink url=\"https://en."
"wikipedia.org/wiki/Voronoi_diagram\">Voronoi diagram</ulink> from the "
"vertices of the supplied geometry. The result is a GeometryCollection of "
"Polygons that covers an envelope larger than the extent of the input "
"vertices. Returns null if input geometry is null. Returns an empty geometry "
"collection if the input geometry contains only one vertex. Returns an empty "
"geometry collection if the extend_to envelope has zero area."
msgstr ""
"ST_VoronoiPolygons berechnet ein zweidimensionales <ulink url=\"https://en."
"wikipedia.org/wiki/Voronoi_diagram\">Voronoi diagram</ulink> aus den Knoten "
"der gegebenen Geometrie. Das Ergebnis ist eine Sammelgeometrie/"
"GeometryCollection von Polygonen, deren Einhüllende größer ist als die "
"Ausdehnung der Ausgangsknoten."

#. Tag: para
#: reference_processing.xml:1981
#, no-c-format
msgid "Points overlaid on top of Voronoi diagram"
msgstr "Punkte über dem Voronoi Diagramm "

#. Tag: programlisting
#: reference_processing.xml:1984
#, fuzzy, no-c-format
msgid ""
"SELECT\n"
"    ST_VoronoiPolygons(geom) As geom\n"
"FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry "
"As geom ) As g;"
msgstr ""
"SELECT\n"
"        ST_VoronoiPolygons(geom) As geom\n"
"FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry "
"As geom ) As g;"

#. Tag: screen
#: reference_processing.xml:1985
#, no-c-format
msgid ""
"-- ST_AsText output\n"
"GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 "
"270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 "
"43.3333333333333)),\n"
"POLYGON((55 -90,-110 -90,-110 43.3333333333333,36.8181818181818 "
"92.2727272727273,55 79.2857142857143,55 -90)),\n"
"POLYGON((230 47.5,230 -20.7142857142857,55 79.2857142857143,36.8181818181818 "
"92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 "
"-20.7142857142857,230 -90,55 -90,55 79.2857142857143,230 "
"-20.7142857142857)),\n"
"POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 "
"270)))"
msgstr ""
"-- Ausgabe mit ST_AsText\n"
"GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 "
"270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 "
"43.3333333333333)),\n"
"POLYGON((55 -90,-110 -90,-110 43.3333333333333,36.8181818181818 "
"92.2727272727273,55 79.2857142857143,55 -90)),\n"
"POLYGON((230 47.5,230 -20.7142857142857,55 79.2857142857143,36.8181818181818 "
"92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 "
"-20.7142857142857,230 -90,55 -90,55 79.2857142857143,230 "
"-20.7142857142857)),\n"
"POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 "
"270)))"

#. Tag: para
#: reference_processing.xml:1995
#, no-c-format
msgid "Voronoi with tolerance of 30 units"
msgstr "Voronoi mit einer Toleranz von 30 Einheiten"

#. Tag: programlisting
#: reference_processing.xml:1998
#, no-c-format
msgid ""
"SELECT ST_VoronoiPolygons(geom, 30) As geom\n"
"FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry "
"As geom ) As g;"
msgstr ""
"SELECT ST_VoronoiPolygons(geom, 30) As geom\n"
"FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry "
"As geom ) As g;"

#. Tag: screen
#: reference_processing.xml:1999
#, no-c-format
msgid ""
"-- ST_AsText output\n"
"GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 "
"270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 "
"43.3333333333333)),\n"
"POLYGON((230 47.5,230 -45.7142857142858,36.8181818181818 "
"92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 "
"-45.7142857142858,230 -90,-110 -90,-110 43.3333333333333,36.8181818181818 "
"92.2727272727273,230 -45.7142857142858)),\n"
"POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 "
"270)))"
msgstr ""
"-- Ausgabe mit ST_AsText\n"
"GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 "
"270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 "
"43.3333333333333)),\n"
"POLYGON((230 47.5,230 -45.7142857142858,36.8181818181818 "
"92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 "
"-45.7142857142858,230 -90,-110 -90,-110 43.3333333333333,36.8181818181818 "
"92.2727272727273,230 -45.7142857142858)),\n"
"POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 "
"270)))"

#. Tag: para
#: reference_processing.xml:2008
#, no-c-format
msgid "Voronoi with tolerance of 30 units as MultiLineString"
msgstr "Voronoi als MultiLinestring mit einer Toleranz von 30 Einheiten"

#. Tag: para
#: reference_processing.xml:2025
#, no-c-format
msgid ", <xref linkend=\"ST_VoronoiLines\"/>, <xref linkend=\"ST_Collect\"/>"
msgstr ", <xref linkend=\"ST_VoronoiLines\"/>, <xref linkend=\"ST_Collect\"/>"

#~ msgid ""
#~ "This will create a gaping hole inside the circle with prongs sticking out"
#~ msgstr ""
#~ "Dies erzeugt eine auseinanderklaffende Lücke innerhalb des Kreises mit "
#~ "herausstehenden Zacken"

#, fuzzy
#~ msgid ""
#~ "SELECT ST_BuildArea(ST_Collect(line,circle))\n"
#~ "FROM (SELECT\n"
#~ "    ST_Buffer(\n"
#~ "        ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)),\n"
#~ "                5)  As line,\n"
#~ "    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;\n"
#~ "\n"
#~ "--this creates the same gaping hole\n"
#~ "--but using linestrings instead of polygons\n"
#~ "SELECT ST_BuildArea(\n"
#~ "    ST_Collect(ST_ExteriorRing(line),ST_ExteriorRing(circle))\n"
#~ "    )\n"
#~ "FROM (SELECT ST_Buffer(\n"
#~ "    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190))\n"
#~ "        ,5)  As line,\n"
#~ "    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;"
#~ msgstr ""
#~ "SELECT ST_BuildArea(ST_Collect(line,circle))\n"
#~ "FROM (SELECT\n"
#~ "        ST_Buffer(\n"
#~ "                ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, "
#~ "190)),\n"
#~ "                                5)  As line,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As "
#~ "foo;\n"
#~ "\n"
#~ "--dies erzeugt dieselbe auseinanderklaffende Lücke\n"
#~ "--allerdings aus Linienzügen anstelle von Polygonen\n"
#~ "SELECT ST_BuildArea(\n"
#~ "        ST_Collect(ST_ExteriorRing(line),ST_ExteriorRing(circle))\n"
#~ "        )\n"
#~ "FROM (SELECT ST_Buffer(\n"
#~ "        ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190))\n"
#~ "                ,5)  As line,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;"

#~ msgid "ST_ClipByBox2D"
#~ msgstr "ST_ClipByBox2D"

#~ msgid "Returns the portion of a geometry falling within a rectangle."
#~ msgstr ""
#~ "Gibt jenen Teil der Geometrie zurück, der innerhalb eines Rechteckes "
#~ "liegt."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_ClipByBox2D</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef><type>box2d</type> <parameter>box</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_ClipByBox2D</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef><type>box2d</type> <parameter>box</parameter></paramdef>"

#~ msgid ""
#~ "Clips a geometry by a 2D box in a fast but possibly dirty way. The output "
#~ "geometry is not guaranteed to be valid (self-intersections for a polygon "
#~ "may be introduced). Topologically invalid input geometries do not result "
#~ "in exceptions being thrown."
#~ msgstr ""
#~ "Schneidet eine Geometrie mittels einer 2D-Box aus; eine schnelle aber "
#~ "möglicherweise unsaubere Methode. Es ist nicht garantiert, dass die "
#~ "Ausgabegeometrie valide ist (bei Polygonen kann es zu "
#~ "Selbstüberschneidungen kommen). Topologisch invalide Eingabegeometrien "
#~ "führen zu keiner Fehlermeldung."

#~ msgid ""
#~ "-- Rely on implicit cast from geometry to box2d for the second parameter\n"
#~ "SELECT ST_ClipByBox2D(the_geom, ST_MakeEnvelope(0,0,10,10)) FROM mytab;"
#~ msgstr ""
#~ "-- Der zweite Eingabeparameter baut auf die implizite Typumwandlung von "
#~ "Geometrie nach Box2D auf\n"
#~ "SELECT ST_ClipByBox2D(the_geom, ST_MakeEnvelope(0,0,10,10)) FROM mytab;"

#~ msgid ""
#~ ", <xref linkend=\"ST_MakeBox2D\"/>, <xref linkend=\"ST_MakeEnvelope\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_MakeBox2D\"/>, <xref linkend=\"ST_MakeEnvelope\"/>"

#~ msgid ""
#~ "The concave hull of a geometry represents a possibly concave geometry "
#~ "that encloses all geometries within the set. You can think of it as "
#~ "shrink wrapping."
#~ msgstr ""
#~ "Die konkave Hülle einer Geometrie stellt eine möglicherweise konkave "
#~ "Geometrie dar, welche alle Geometrien der Menge einschließt. Sie können "
#~ "es sich wie in Folie einpacken vorstellen."

#~ msgid ""
#~ "It is much slower to compute than convex hull but encloses the geometry "
#~ "better and is also useful for image recognition."
#~ msgstr ""
#~ "Die Berechnung der konkaven Hülle ist wesentlich langsamer als bei der "
#~ "konvexen Hülle, aber die Geometrie wird besser umhüllt und ist auch "
#~ "nützlich bei der Bilderkennung."

#~ msgid "ST_CurveToLine"
#~ msgstr "ST_CurveToLine"

#, fuzzy
#~ msgid ""
#~ "Converts a CIRCULARSTRING/CURVEPOLYGON/MULTISURFACE to a LINESTRING/"
#~ "POLYGON/MULTIPOLYGON"
#~ msgstr ""
#~ "Wandelt einen CIRCULARSTRING/CURVEPOLYGON in ein LINESTRING/POLYGON um"

#, fuzzy
#~ msgid ""
#~ "<funcdef>geometry <function>ST_CurveToLine</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>curveGeom</parameter></"
#~ "paramdef> <paramdef><type>float</type> <parameter>tolerance</parameter></"
#~ "paramdef> <paramdef choice=\"opt\"><type>integer</type> "
#~ "<parameter>tolerance_type</parameter></paramdef> <paramdef choice=\"opt"
#~ "\"><type>integer</type> <parameter>flags</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_OffsetCurve</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>line</parameter></paramdef> "
#~ "<paramdef><type>float </type> <parameter>signed_distance</parameter></"
#~ "paramdef> <paramdef choice=\"opt\"><type>text </type> "
#~ "<parameter>style_parameters=''</parameter></paramdef>"

#, fuzzy
#~ msgid ""
#~ "Converts a CIRCULAR STRING to regular LINESTRING or CURVEPOLYGON to "
#~ "POLYGON or MULTISURFACE to MULTIPOLYGON. Useful for outputting to devices "
#~ "that can't support CIRCULARSTRING geometry types"
#~ msgstr ""
#~ "Konvertiert einen Kreisbogen/CircularString in einen normalen LineString "
#~ "oder ein CurvePolygon in ein Polygon. Nützlich zur Ausgabe an Geräten, "
#~ "die Kreisbögen nicht unterstützen."

#~ msgid ""
#~ "Converts a given geometry to a linear geometry. Each curved geometry or "
#~ "segment is converted into a linear approximation using the given "
#~ "`tolerance` and options (32 segments per quadrant and no options by "
#~ "default)."
#~ msgstr ""
#~ "Wandelt eine gegebene Geometrie in eine lineare Geometrie um. Jede "
#~ "Kurvengeometrie und jedes Kurvensegment wird in linearer Näherung mit der "
#~ "gegebenen Toleranz und Optionen konvertiert ( Standardmäßig 32 Segmenten "
#~ "pro Viertelkreis und keine Optionen)."

#~ msgid ""
#~ "The 'tolerance_type' argument determines interpretation of the "
#~ "`tolerance` argument. It can take the following values:"
#~ msgstr ""
#~ "Der Übergabewert 'tolerance_type' gibt den Toleranztyp an. Er kann die "
#~ "folgenden Werte annehmen:"

#~ msgid "0 (default): Tolerance is max segments per quadrant."
#~ msgstr ""
#~ "0 (default): die Toleranz wird über die maximale Anzahl der Segmente pro "
#~ "Viertelkreis angegeben."

#~ msgid "1: Tolerance is max-deviation of line from curve, in source units."
#~ msgstr ""
#~ "1: Die Toleranz wird als maximale Abweichung der Linie von der Kurve in "
#~ "der Einheit der Herkunftsdaten angegeben."

#~ msgid "2: Tolerance is max-angle, in radians, between generating radii."
#~ msgstr ""
#~ "2: Die Toleranz entspricht dem maximalen Winkel zwischen zwei erzeugten "
#~ "Radien."

#~ msgid ""
#~ "The 'flags' argument is a bitfield. 0 by default. Supported bits are:"
#~ msgstr ""
#~ "Der Parameter 'flags' ist ein Bitfeld mit dem Standardwert 0. Es werden "
#~ "folgende Bits unterstützt:"

#~ msgid "1: Symmetric (orientation idependent) output."
#~ msgstr "1: Symmetrische (orientierungsunabhängige) Ausgabe."

#~ msgid ""
#~ "2: Retain angle, avoids reducing angles (segment lengths) when producing "
#~ "symmetric output. Has no effect when Symmetric flag is off."
#~ msgstr ""
#~ "2: Erhält den Winkel, vermeidet die Winkel (Segmentlängen) bei der "
#~ "symmetrischen Ausgabe zu reduzieren. Hat keine Auswirkung, wenn die "
#~ "Symmetrie-Flag nicht aktiviert ist."

#, fuzzy
#~ msgid "Availability: 1.3.0"
#~ msgstr "Verfügbarkeit: 1.3.3"

#~ msgid ""
#~ "Enhanced: 2.4.0 added support for max-deviation and max-angle tolerance, "
#~ "and for symmetric output."
#~ msgstr ""
#~ "Erweiterung: ab 2.4.0 kann die Toleranz über die 'maximale Abweichung' "
#~ "und den 'maximalen Winkel' angegeben werden. Die symmetrische Ausgabe "
#~ "wurde hinzugefügt."

#~ msgid "&sqlmm_compliant; SQL-MM 3: 7.1.7"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 7.1.7"

#~ msgid "&curve_support;"
#~ msgstr "&curve_support;"

#, fuzzy
#~ msgid ""
#~ "SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 "
#~ "150415,220227 150505,220227 150406)')));\n"
#~ "\n"
#~ "--Result --\n"
#~ " LINESTRING(220268 150415,220269.95064912 "
#~ "150416.539364228,220271.823415575 150418.17258804,220273.613787707 "
#~ "150419.895736857,\n"
#~ " 220275.317452352 150421.704659462,220276.930305234 "
#~ "150423.594998003,220278.448460847 150425.562198489,\n"
#~ " 220279.868261823 150427.60152176,220281.186287736 "
#~ "150429.708054909,220282.399363347 150431.876723113,\n"
#~ " 220283.50456625 150434.10230186,220284.499233914 "
#~ "150436.379429536,220285.380970099 150438.702620341,220286.147650624 "
#~ "150441.066277505,\n"
#~ " 220286.797428488 150443.464706771,220287.328738321 "
#~ "150445.892130112,220287.740300149 150448.342699654,\n"
#~ " 220288.031122486 150450.810511759,220288.200504713 "
#~ "150453.289621251,220288.248038775 150455.77405574,\n"
#~ " 220288.173610157 150458.257830005,220287.977398166 "
#~ "150460.734960415,220287.659875492 150463.199479347,\n"
#~ " 220287.221807076 150465.64544956,220286.664248262 "
#~ "150468.066978495,220285.988542259 150470.458232479,220285.196316903 "
#~ "150472.81345077,\n"
#~ " 220284.289480732 150475.126959442,220283.270218395 "
#~ "150477.39318505,220282.140985384 150479.606668057,\n"
#~ " 220280.90450212 150481.762075989,220279.5637474 "
#~ "150483.85421628,220278.12195122 150485.87804878,\n"
#~ " 220276.582586992 150487.828697901,220274.949363179 "
#~ "150489.701464356,220273.226214362 150491.491836488,\n"
#~ " 220271.417291757 150493.195501133,220269.526953216 "
#~ "150494.808354014,220267.559752731 150496.326509628,\n"
#~ " 220265.520429459 150497.746310603,220263.41389631 "
#~ "150499.064336517,220261.245228106 150500.277412127,\n"
#~ " 220259.019649359 150501.38261503,220256.742521683 "
#~ "150502.377282695,220254.419330878 150503.259018879,\n"
#~ " 220252.055673714 150504.025699404,220249.657244448 "
#~ "150504.675477269,220247.229821107 150505.206787101,\n"
#~ " 220244.779251566 150505.61834893,220242.311439461 "
#~ "150505.909171266,220239.832329968 150506.078553494,\n"
#~ " 220237.347895479 150506.126087555,220234.864121215 "
#~ "150506.051658938,220232.386990804 150505.855446946,\n"
#~ " 220229.922471872 150505.537924272,220227.47650166 "
#~ "150505.099855856,220225.054972724 150504.542297043,\n"
#~ " 220222.663718741 150503.86659104,220220.308500449 150503.074365683,\n"
#~ " 220217.994991777 150502.167529512,220215.72876617 150501.148267175,\n"
#~ " 220213.515283163 150500.019034164,220211.35987523 150498.7825509,\n"
#~ " 220209.267734939 150497.441796181,220207.243902439 150496,\n"
#~ " 220205.293253319 150494.460635772,220203.420486864 "
#~ "150492.82741196,220201.630114732 150491.104263143,\n"
#~ " 220199.926450087 150489.295340538,220198.313597205 "
#~ "150487.405001997,220196.795441592 150485.437801511,\n"
#~ " 220195.375640616 150483.39847824,220194.057614703 "
#~ "150481.291945091,220192.844539092 150479.123276887,220191.739336189 "
#~ "150476.89769814,\n"
#~ " 220190.744668525 150474.620570464,220189.86293234 "
#~ "150472.297379659,220189.096251815 150469.933722495,\n"
#~ " 220188.446473951 150467.535293229,220187.915164118 "
#~ "150465.107869888,220187.50360229 150462.657300346,\n"
#~ " 220187.212779953 150460.189488241,220187.043397726 "
#~ "150457.710378749,220186.995863664 150455.22594426,\n"
#~ " 220187.070292282 150452.742169995,220187.266504273 "
#~ "150450.265039585,220187.584026947 150447.800520653,\n"
#~ " 220188.022095363 150445.35455044,220188.579654177 "
#~ "150442.933021505,220189.25536018 150440.541767521,\n"
#~ " 220190.047585536 150438.18654923,220190.954421707 "
#~ "150435.873040558,220191.973684044 150433.60681495,\n"
#~ " 220193.102917055 150431.393331943,220194.339400319 "
#~ "150429.237924011,220195.680155039 150427.14578372,220197.12195122 "
#~ "150425.12195122,\n"
#~ " 220198.661315447 150423.171302099,220200.29453926 "
#~ "150421.298535644,220202.017688077 150419.508163512,220203.826610682 "
#~ "150417.804498867,\n"
#~ " 220205.716949223 150416.191645986,220207.684149708 "
#~ "150414.673490372,220209.72347298 150413.253689397,220211.830006129 "
#~ "150411.935663483,\n"
#~ " 220213.998674333 150410.722587873,220216.22425308 "
#~ "150409.61738497,220218.501380756 150408.622717305,220220.824571561 "
#~ "150407.740981121,\n"
#~ " 220223.188228725 150406.974300596,220225.586657991 "
#~ "150406.324522731,220227 150406)\n"
#~ "\n"
#~ "--3d example\n"
#~ "SELECT ST_AsEWKT(ST_CurveToLine(ST_GeomFromEWKT('CIRCULARSTRING(220268 "
#~ "150415 1,220227 150505 2,220227 150406 3)')));\n"
#~ "Output\n"
#~ "------\n"
#~ " LINESTRING(220268 150415 1,220269.95064912 150416.539364228 "
#~ "1.0181172856673,\n"
#~ " 220271.823415575 150418.17258804 1.03623457133459,220273.613787707 "
#~ "150419.895736857 1.05435185700189,....AD INFINITUM ....\n"
#~ "    220225.586657991 150406.324522731 1.32611114201132,220227 150406 3)\n"
#~ "\n"
#~ "--use only 2 segments to approximate quarter circle\n"
#~ "SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 "
#~ "150415,220227 150505,220227 150406)'),2));\n"
#~ "st_astext\n"
#~ "------------------------------\n"
#~ " LINESTRING(220268 150415,220287.740300149 "
#~ "150448.342699654,220278.12195122 150485.87804878,\n"
#~ " 220244.779251566 150505.61834893,220207.243902439 150496,220187.50360229 "
#~ "150462.657300346,\n"
#~ " 220197.12195122 150425.12195122,220227 150406)\n"
#~ "\n"
#~ "-- Ensure approximated line is no further than 20 units away from\n"
#~ "-- original curve, and make the result direction-neutral\n"
#~ "SELECT ST_AsText(ST_CurveToLine(\n"
#~ " 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,\n"
#~ "    20, -- Tolerance\n"
#~ "    1, -- Above is max distance between curve and line\n"
#~ "    1  -- Symmetric flag\n"
#~ "));\n"
#~ "st_astext\n"
#~ "-------------------------------------------------------------------------------------------\n"
#~ " LINESTRING(0 0,50 -86.6025403784438,150 -86.6025403784439,200 "
#~ "-1.1331077795296e-13,200 0)"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 "
#~ "150415,220227 150505,220227 150406)')));\n"
#~ "\n"
#~ "--Result --\n"
#~ " LINESTRING(220268 150415,220269.95064912 "
#~ "150416.539364228,220271.823415575 150418.17258804,220273.613787707 "
#~ "150419.895736857,\n"
#~ " 220275.317452352 150421.704659462,220276.930305234 "
#~ "150423.594998003,220278.448460847 150425.562198489,\n"
#~ " 220279.868261823 150427.60152176,220281.186287736 "
#~ "150429.708054909,220282.399363347 150431.876723113,\n"
#~ " 220283.50456625 150434.10230186,220284.499233914 "
#~ "150436.379429536,220285.380970099 150438.702620341,220286.147650624 "
#~ "150441.066277505,\n"
#~ " 220286.797428488 150443.464706771,220287.328738321 "
#~ "150445.892130112,220287.740300149 150448.342699654,\n"
#~ " 220288.031122486 150450.810511759,220288.200504713 "
#~ "150453.289621251,220288.248038775 150455.77405574,\n"
#~ " 220288.173610157 150458.257830005,220287.977398166 "
#~ "150460.734960415,220287.659875492 150463.199479347,\n"
#~ " 220287.221807076 150465.64544956,220286.664248262 "
#~ "150468.066978495,220285.988542259 150470.458232479,220285.196316903 "
#~ "150472.81345077,\n"
#~ " 220284.289480732 150475.126959442,220283.270218395 "
#~ "150477.39318505,220282.140985384 150479.606668057,\n"
#~ " 220280.90450212 150481.762075989,220279.5637474 "
#~ "150483.85421628,220278.12195122 150485.87804878,\n"
#~ " 220276.582586992 150487.828697901,220274.949363179 "
#~ "150489.701464356,220273.226214362 150491.491836488,\n"
#~ " 220271.417291757 150493.195501133,220269.526953216 "
#~ "150494.808354014,220267.559752731 150496.326509628,\n"
#~ " 220265.520429459 150497.746310603,220263.41389631 "
#~ "150499.064336517,220261.245228106 150500.277412127,\n"
#~ " 220259.019649359 150501.38261503,220256.742521683 "
#~ "150502.377282695,220254.419330878 150503.259018879,\n"
#~ " 220252.055673714 150504.025699404,220249.657244448 "
#~ "150504.675477269,220247.229821107 150505.206787101,\n"
#~ " 220244.779251566 150505.61834893,220242.311439461 "
#~ "150505.909171266,220239.832329968 150506.078553494,\n"
#~ " 220237.347895479 150506.126087555,220234.864121215 "
#~ "150506.051658938,220232.386990804 150505.855446946,\n"
#~ " 220229.922471872 150505.537924272,220227.47650166 "
#~ "150505.099855856,220225.054972724 150504.542297043,\n"
#~ " 220222.663718741 150503.86659104,220220.308500449 150503.074365683,\n"
#~ " 220217.994991777 150502.167529512,220215.72876617 150501.148267175,\n"
#~ " 220213.515283163 150500.019034164,220211.35987523 150498.7825509,\n"
#~ " 220209.267734939 150497.441796181,220207.243902439 150496,\n"
#~ " 220205.293253319 150494.460635772,220203.420486864 "
#~ "150492.82741196,220201.630114732 150491.104263143,\n"
#~ " 220199.926450087 150489.295340538,220198.313597205 "
#~ "150487.405001997,220196.795441592 150485.437801511,\n"
#~ " 220195.375640616 150483.39847824,220194.057614703 "
#~ "150481.291945091,220192.844539092 150479.123276887,220191.739336189 "
#~ "150476.89769814,\n"
#~ " 220190.744668525 150474.620570464,220189.86293234 "
#~ "150472.297379659,220189.096251815 150469.933722495,\n"
#~ " 220188.446473951 150467.535293229,220187.915164118 "
#~ "150465.107869888,220187.50360229 150462.657300346,\n"
#~ " 220187.212779953 150460.189488241,220187.043397726 "
#~ "150457.710378749,220186.995863664 150455.22594426,\n"
#~ " 220187.070292282 150452.742169995,220187.266504273 "
#~ "150450.265039585,220187.584026947 150447.800520653,\n"
#~ " 220188.022095363 150445.35455044,220188.579654177 "
#~ "150442.933021505,220189.25536018 150440.541767521,\n"
#~ " 220190.047585536 150438.18654923,220190.954421707 "
#~ "150435.873040558,220191.973684044 150433.60681495,\n"
#~ " 220193.102917055 150431.393331943,220194.339400319 "
#~ "150429.237924011,220195.680155039 150427.14578372,220197.12195122 "
#~ "150425.12195122,\n"
#~ " 220198.661315447 150423.171302099,220200.29453926 "
#~ "150421.298535644,220202.017688077 150419.508163512,220203.826610682 "
#~ "150417.804498867,\n"
#~ " 220205.716949223 150416.191645986,220207.684149708 "
#~ "150414.673490372,220209.72347298 150413.253689397,220211.830006129 "
#~ "150411.935663483,\n"
#~ " 220213.998674333 150410.722587873,220216.22425308 "
#~ "150409.61738497,220218.501380756 150408.622717305,220220.824571561 "
#~ "150407.740981121,\n"
#~ " 220223.188228725 150406.974300596,220225.586657991 "
#~ "150406.324522731,220227 150406)\n"
#~ "\n"
#~ "--3D Beispiel\n"
#~ "SELECT ST_AsEWKT(ST_CurveToLine(ST_GeomFromEWKT('CIRCULARSTRING(220268 "
#~ "150415 1,220227 150505 2,220227 150406 3)')));\n"
#~ "Output\n"
#~ "------\n"
#~ " LINESTRING(220268 150415 1,220269.95064912 150416.539364228 "
#~ "1.0181172856673,\n"
#~ " 220271.823415575 150418.17258804 1.03623457133459,220273.613787707 "
#~ "150419.895736857 1.05435185700189,....AD INFINITUM ....\n"
#~ "        220225.586657991 150406.324522731 1.32611114201132,220227 150406 "
#~ "3)\n"
#~ "\n"
#~ "--nur 2 Segmente zur Annäherung des Viertelkreises\n"
#~ "SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 "
#~ "150415,220227 150505,220227 150406)'),2));\n"
#~ "st_astext\n"
#~ "------------------------------\n"
#~ " LINESTRING(220268 150415,220287.740300149 "
#~ "150448.342699654,220278.12195122 150485.87804878,\n"
#~ " 220244.779251566 150505.61834893,220207.243902439 150496,220187.50360229 "
#~ "150462.657300346,\n"
#~ " 220197.12195122 150425.12195122,220227 150406)\n"
#~ "\n"
#~ "-- Sicherstellen, dass die angenäherte Linie nicht weiter als 20 "
#~ "Einheiten\n"
#~ "-- von der ursprünglichen Kurve entfernt liegt, und das Ergebnis "
#~ "richtungsunabhängig machen\n"
#~ "SELECT ST_AsText(ST_CurveToLine(\n"
#~ " 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,\n"
#~ "        20, -- Tolerance\n"
#~ "        1, -- oberhalb die maximale Entfernung zwischen Kurve und Linie\n"
#~ "        1  -- Symmetrie Flag\n"
#~ "));\n"
#~ "st_astext\n"
#~ "-------------------------------------------------------------------------------------------\n"
#~ " LINESTRING(0 0,50 -86.6025403784438,150 -86.6025403784439,200 "
#~ "-1.1331077795296e-13,200 0)"

#~ msgid "Return a Delaunay triangulation around the given input points."
#~ msgstr "Gibt die Delaunay-Triangulierung für gegebene Punkte zurück."

#~ msgid "ST_Difference"
#~ msgstr "ST_Difference"

#~ msgid ""
#~ "Returns a geometry that represents that part of geometry A that does not "
#~ "intersect with geometry B."
#~ msgstr ""
#~ "Gibt eine Geometrie zurück, die jenen Teil der Geometrie A abbildet, der "
#~ "sich nicht mit der Geometrie B überschneidet."

#~ msgid ""
#~ "Returns a geometry that represents that part of geometry A that does not "
#~ "intersect with geometry B. One can think of this as GeometryA - "
#~ "ST_Intersection(A,B). If A is completely contained in B then an empty "
#~ "geometry collection is returned."
#~ msgstr ""
#~ "Gibt eine Geometrie zurück, die jenen Teil der Geometrie A abbildet, der "
#~ "sich nicht mit der Geometrie B überschneidet. Man kann sich das als "
#~ "GeometryA - ST_Intersection(A,B) vorstellen. Wenn A zur Gänze in B "
#~ "enthalten ist wird eine leere GeometryCollection zurückgegeben."

#, fuzzy
#~ msgid "Order matters. B - A will always return a portion of B"
#~ msgstr ""
#~ "Anmerkung: Die Reihenfolge spielt eine Rolle. B - A gibt immer einen Teil "
#~ "von B zurück"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.20"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.20"

#~ msgid ""
#~ "&Z_support; However it seems to only consider x y when doing the "
#~ "difference and tacks back on the Z-Index"
#~ msgstr ""
#~ "&Z_support; Allerdings scheint nur x y bei der Berechnung der Differenz "
#~ "herangezogen und anschließend an den Z-Index zurückgeheftet zu werden"

#~ msgid "The original linestrings shown together."
#~ msgstr "Die ursprünglichen Linienzüge zusammen."

#~ msgid "The difference of the two linestrings"
#~ msgstr "Die Differenz der beiden Linienzüge"

#, fuzzy
#~ msgid ""
#~ "SELECT ST_AsText(\n"
#~ "    ST_Difference(\n"
#~ "            'LINESTRING(50 100, 50 200)'::geometry,\n"
#~ "            'LINESTRING(50 50, 50 150)'::geometry\n"
#~ "        )\n"
#~ "    );\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "LINESTRING(50 150,50 200)"
#~ msgstr ""
#~ "--Sicher bei 2D. Dies sind dieselben Geometrien als bei st_symdifference "
#~ "angezeigt\n"
#~ "SELECT ST_AsText(\n"
#~ "        ST_Difference(\n"
#~ "                        ST_GeomFromText('LINESTRING(50 100, 50 200)'),\n"
#~ "                        ST_GeomFromText('LINESTRING(50 50, 50 150)')\n"
#~ "                )\n"
#~ "        );\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "LINESTRING(50 150,50 200)"

#, fuzzy
#~ msgid ""
#~ "select ST_AsEWKT(\n"
#~ "           ST_Difference(\n"
#~ "               'MULTIPOINT(-118.58 38.38 5,-118.60 38.329 6,-118.614 "
#~ "38.281 7)' :: geometry,\n"
#~ "               'POINT(-118.614 38.281 5)' :: geometry\n"
#~ "               )\n"
#~ "    );\n"
#~ "st_asewkt\n"
#~ "---------\n"
#~ "MULTIPOINT(-118.6 38.329 6,-118.58 38.38 5)"
#~ msgstr ""
#~ "--verhält sich bei 3D nicht richtig\n"
#~ "SELECT ST_AsEWKT(ST_Difference(ST_GeomFromEWKT('MULTIPOINT(-118.58 38.38 "
#~ "5,-118.60 38.329 6,-118.614 38.281 7)'), ST_GeomFromEWKT('POINT(-118.614 "
#~ "38.281 5)')));\n"
#~ "st_asewkt\n"
#~ "---------\n"
#~ "MULTIPOINT(-118.6 38.329 6,-118.58 38.38 5)"

#~ msgid ", <xref linkend=\"ST_Intersection\"/>, <xref linkend=\"ST_Union\"/>"
#~ msgstr ", <xref linkend=\"ST_Intersection\"/>, <xref linkend=\"ST_Union\"/>"

#~ msgid "ST_FlipCoordinates"
#~ msgstr "ST_FlipCoordinates"

#~ msgid ""
#~ "Returns a version of the given geometry with X and Y axis flipped. Useful "
#~ "for people who have built latitude/longitude features and need to fix "
#~ "them."
#~ msgstr ""
#~ "Gibt eine Version der gegebenen Geometrie zurück, wobei die X und Y Achse "
#~ "vertauscht sind. Nützlich wenn man Geoobjekte in Breite/Länge vorliegen "
#~ "hat und dies beheben möchte."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_FlipCoordinates</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_FlipCoordinates</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>"

#~ msgid "Returns a version of the given geometry with X and Y axis flipped."
#~ msgstr ""
#~ "Gibt eine Version der gegebenen Geometrie zurück, wobei die X und Y Achse "
#~ "vertauscht sind."

#~ msgid "&P_support;"
#~ msgstr "&P_support;"

#~ msgid "Example"
#~ msgstr "Beispiel"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[\n"
#~ "SELECT ST_AsEWKT(ST_FlipCoordinates(GeomFromEWKT('POINT(1 2)')));\n"
#~ " st_asewkt\n"
#~ "------------\n"
#~ "POINT(2 1)\n"
#~ "         ]]>"
#~ msgstr ""
#~ "<![CDATA[\n"
#~ "SELECT ST_AsEWKT(ST_FlipCoordinates(GeomFromEWKT('POINT(1 2)')));\n"
#~ " st_asewkt\n"
#~ "------------\n"
#~ "POINT(2 1)\n"
#~ "                 ]]>"

#~ msgid ""
#~ "Converts a polygon or multi-polygon into a multi-point composed of "
#~ "randomly location points within the original areas."
#~ msgstr ""
#~ "Wandelt ein Polygon oder ein MultiPolygon in einen MultiPoint um, welcher "
#~ "aus wahllos angeordeten, innerhalb der ursprünglichen Flächen liegenden "
#~ "Punkten besteht."

#~ msgid "ST_Intersection"
#~ msgstr "ST_Intersection"

#~ msgid ""
#~ "(T) Returns a geometry that represents the shared portion of geomA and "
#~ "geomB."
#~ msgstr ""
#~ "(T) Gibt eine Geometrie zurück, welche den gemeinsamen Anteil von geomA "
#~ "und geomB repräsentiert."

#~ msgid ""
#~ "<funcprototype> <funcdef>geometry <function>ST_Intersection</function></"
#~ "funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
#~ "paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>geography "
#~ "<function>ST_Intersection</function></funcdef> <paramdef> "
#~ "<type>geography</type> <parameter>geogA</parameter> </paramdef> "
#~ "<paramdef> <type>geography</type> <parameter>geogB</parameter> </"
#~ "paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>geometry <function>ST_Intersection</function></"
#~ "funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
#~ "paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>geography "
#~ "<function>ST_Intersection</function></funcdef> <paramdef> "
#~ "<type>geography</type> <parameter>geogA</parameter> </paramdef> "
#~ "<paramdef> <type>geography</type> <parameter>geogB</parameter> </"
#~ "paramdef> </funcprototype>"

#~ msgid ""
#~ "Returns a geometry that represents the point set intersection of the "
#~ "Geometries."
#~ msgstr ""
#~ "Gibt eine Geometrie zurück, welche der mengentheoretischen Verschneidung "
#~ "der Geometrien entspricht."

#~ msgid ""
#~ "In other words - that portion of geometry A and geometry B that is shared "
#~ "between the two geometries."
#~ msgstr ""
#~ "Mit anderen Worten - jener Teil von der Geometrie A und der Geometrie B "
#~ "den sich die beiden Geometrien teilen."

#~ msgid ""
#~ "If the geometries do not share any space (are disjoint), then an empty "
#~ "geometry collection is returned."
#~ msgstr ""
#~ "Wenn sich die Geometrien keinen gemeinsamen Raum teilen (sind getrennt), "
#~ "so wird eine leere GeometryCollection zurückgegeben."

#~ msgid ""
#~ "ST_Intersection in conjunction with ST_Intersects is very useful for "
#~ "clipping geometries such as in bounding box, buffer, region queries where "
#~ "you only want to return that portion of a geometry that sits in a country "
#~ "or region of interest."
#~ msgstr ""
#~ "ST_Intersection ist in Verbindung mit ST_Intersects zum Ausscchneiden von "
#~ "Geometrien sehr nützlich. Wie bei einem Umgebungsrechteck, einem Buffer, "
#~ "oder bei regionalen Abfragen, bei denen nur jener Teil der Geometrie "
#~ "zurückgegeben werden soll, der in einem bestimmten Staat oder einer "
#~ "bestimmten Interessensregion liegt."

#~ msgid ""
#~ "Geography: For geography this is really a thin wrapper around the "
#~ "geometry implementation. It first determines the best SRID that fits the "
#~ "bounding box of the 2 geography objects (if geography objects are within "
#~ "one half zone UTM but not same UTM will pick one of those) (favoring UTM "
#~ "or Lambert Azimuthal Equal Area (LAEA) north/south pole, and falling back "
#~ "on mercator in worst case scenario) and then intersection in that best "
#~ "fit planar spatial ref and retransforms back to WGS84 geography."
#~ msgstr ""
#~ "Geographie: Beim geographischen Datentyp handelt es sich lediglich um "
#~ "einen schlanken Adapter, der um die geometrische Implementation "
#~ "herumgelegt wurde. Zuerst wird die passenste SRID für das "
#~ "Umgebungsrechteck der beiden geographischen Objekte bestimmt (wenn die "
#~ "geographischen Objekte innerhalb eines UTM Überlappungsbereichs, aber "
#~ "nicht in derselben UTM Zone liegen, wird eine Zone herausgepickt) "
#~ "(bevorzugt UTM oder Lambert Azimuthal Equal Area (LAEA) Nord/Süd Pol, im "
#~ "schlimmsten Fall wird auf Mercator zurückgegriffen), dann im planaren "
#~ "Koordinatenreferenzsystem verschnitten und anschließend nach WGS84 "
#~ "Geographie zurück transformiert."

#~ msgid "This function will drop the M coordinate values if present."
#~ msgstr "Diese Funktion löscht die Werte der M-Koordinate, falls vorhanden."

#, fuzzy
#~ msgid ""
#~ "If working with 3D geometries, you may want to use SFGCAL based <xref "
#~ "linkend=\"ST_3DIntersection\"/> which does a proper 3D intersection for "
#~ "3D geometries. Although this function works with Z-coordinate, it does an "
#~ "averaging of Z-Coordinate."
#~ msgstr ""
#~ "Wenn Sie mit 3D-Geometrie arbeiten kann es sinnvoll sein die SFGCAL "
#~ "basierte Funktion <xref linkend=\"ST_3DIntersection\"/> zu verwenden, da "
#~ "diese eine korrekte 3D Verschneidung mit 3D Geometrie ausführt. Obwohl "
#~ "die Funktion mit der Z-Koordinate arbeitet, führt sie eine Mittelung der "
#~ "Z-Koordinatenwerte durch, wenn <code>postgis.backend=geos</code>. Auch "
#~ "wenn <code>postgis.backend=sfcgal</code> wird die Z-Koordinate ignoriert "
#~ "und eine 2D-Geometrie ausgegeben. Siehe <xref linkend=\"postgis_backend\"/"
#~ "> für Details."

#~ msgid "Availability: 1.5 support for geography data type was introduced."
#~ msgstr ""
#~ "Verfügbarkeit: 1.5 die Unterstützung des geograpischen Datentyps wurde "
#~ "eingeführt"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.18"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.18"

#~ msgid "Examples: 2.5Dish"
#~ msgstr "Beispiele: 2.5D-isch"

#, fuzzy
#~ msgid ""
#~ "Note this is not a true intersection, compare to the same example using "
#~ "<xref linkend=\"ST_3DIntersection\"/>."
#~ msgstr ""
#~ "GEOS ist standardmäßig das Back-end, falls nicht anders gesetzt. Beachten "
#~ "Sie bitte, das dies keine richtige Verschneidung ist. Vergleiche das "
#~ "gleiche Beispiel mit <xref linkend=\"ST_3DIntersection\"/>."

#, fuzzy
#~ msgid ""
#~ "select ST_AsText(ST_Intersection(linestring, polygon)) As wkt\n"
#~ "from  ST_GeomFromText('LINESTRING Z (2 2 6,1.5 1.5 7,1 1 8,0.5 0.5 8,0 0 "
#~ "10)') AS linestring\n"
#~ " CROSS JOIN ST_GeomFromText('POLYGON((0 0 8, 0 1 8, 1 1 8, 1 0 8, 0 0 "
#~ "8))') AS polygon;\n"
#~ "\n"
#~ "               st_astext\n"
#~ "---------------------------------------\n"
#~ " LINESTRING Z (1 1 8,0.5 0.5 8,0 0 10)"
#~ msgstr ""
#~ "set postgis.backend=geos;\n"
#~ "select ST_AsText(ST_Intersection(linestring, polygon)) As wkt\n"
#~ "from  ST_GeomFromText('LINESTRING Z (2 2 6,1.5 1.5 7,1 1 8,0.5 0.5 8,0 0 "
#~ "10)') AS linestring\n"
#~ " CROSS JOIN ST_GeomFromText('POLYGON((0 0 8, 0 1 8, 1 1 8, 1 0 8, 0 0 "
#~ "8))') AS polygon;\n"
#~ "\n"
#~ "               st_astext\n"
#~ "---------------------------------------\n"
#~ " LINESTRING Z (1 1 8,0.5 0.5 8,0 0 10)"

#, fuzzy
#~ msgid ""
#~ ", <xref linkend=\"ST_Difference\"/>, <xref linkend=\"ST_Union\"/>, <xref "
#~ "linkend=\"ST_Dimension\"/>, <xref linkend=\"ST_Dump\"/>, <xref linkend="
#~ "\"ST_Force2D\"/>, <xref linkend=\"ST_SymDifference\"/>, <xref linkend="
#~ "\"ST_Intersects\"/>, <xref linkend=\"ST_Multi\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_Difference\"/>, <xref linkend=\"ST_Dimension\"/>, "
#~ "<xref linkend=\"ST_Dump\"/>, <xref linkend=\"ST_Force2D\"/>, <xref "
#~ "linkend=\"ST_SymDifference\"/>, <xref linkend=\"ST_Intersects\"/>, <xref "
#~ "linkend=\"ST_Multi\"/>"

#~ msgid "ST_LineToCurve"
#~ msgstr "ST_LineToCurve"

#~ msgid "Converts a LINESTRING/POLYGON to a CIRCULARSTRING, CURVEPOLYGON"
#~ msgstr ""
#~ "Wandelt einen LINESTRING/POLYGON in einen CIRCULARSTRING, CURVEPOLYGON um"

#~ msgid ""
#~ "<funcdef>geometry <function>ST_LineToCurve</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomANoncircular</parameter></"
#~ "paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_LineToCurve</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomANoncircular</parameter></"
#~ "paramdef>"

#~ msgid ""
#~ "Converts plain LINESTRING/POLYGON to CIRCULAR STRINGs and Curved "
#~ "Polygons. Note much fewer points are needed to describe the curved "
#~ "equivalent."
#~ msgstr ""
#~ "Wandelt einen einfachen LineString/Polygon in Kreisbögen/CIRCULARSTRINGs "
#~ "und Kurvenpolygone um. Beachten Sie, dass wesentlich weniger Punkte zur "
#~ "Beschreibung des Kurvenäquivalents benötigt werden."

#~ msgid ""
#~ "If the input LINESTRING/POLYGON is not curved enough to clearly represent "
#~ "a curve, the function will return the same input geometry."
#~ msgstr ""
#~ "Wenn der gegebene LINESTRING/POLYGON nicht genug gekrümmt ist um eine "
#~ "deutliche Kurve zu repräsentieren, wird die Geometrie von der Funktion "
#~ "unverändert zurückgegeben."

#, fuzzy
#~ msgid ""
#~ "-- 2D Example\n"
#~ "SELECT ST_AsText(ST_LineToCurve(foo.the_geom)) As curvedastext,"
#~ "ST_AsText(foo.the_geom) As non_curvedastext\n"
#~ "    FROM (SELECT ST_Buffer('POINT(1 3)'::geometry, 3) As the_geom) As "
#~ "foo;\n"
#~ "\n"
#~ "curvedatext                                                            "
#~ "non_curvedastext\n"
#~ "--------------------------------------------------------------------|-----------------------------------------------------------------\n"
#~ "CURVEPOLYGON(CIRCULARSTRING(4 3,3.12132034355964 0.878679656440359, | "
#~ "POLYGON((4 3,3.94235584120969 2.41472903395162,3.77163859753386 "
#~ "1.85194970290473,\n"
#~ "1 0,-1.12132034355965 5.12132034355963,4 3))                        |  "
#~ "3.49440883690764 1.33328930094119,3.12132034355964 0.878679656440359,\n"
#~ "                                                                    |  "
#~ "2.66671069905881 0.505591163092366,2.14805029709527 0.228361402466141,\n"
#~ "                                                                    |  "
#~ "1.58527096604839 0.0576441587903094,1 0,\n"
#~ "                                                                    |  "
#~ "0.414729033951621 0.0576441587903077,-0.148050297095264 "
#~ "0.228361402466137,\n"
#~ "                                                                    |  "
#~ "-0.666710699058802 0.505591163092361,-1.12132034355964 "
#~ "0.878679656440353,\n"
#~ "                                                                    |  "
#~ "-1.49440883690763 1.33328930094119,-1.77163859753386 1.85194970290472\n"
#~ "                                                                    |  --"
#~ "ETC-- ,3.94235584120969 3.58527096604839,4 3))\n"
#~ "\n"
#~ "--3D example\n"
#~ "SELECT ST_AsText(ST_LineToCurve(geom)) As curved, ST_AsText(geom) AS "
#~ "not_curved\n"
#~ "FROM (SELECT ST_Translate(ST_Force3D(ST_Boundary(ST_Buffer(ST_Point(1,3), "
#~ "2,2))),0,0,3) AS geom) AS foo;\n"
#~ "\n"
#~ "                        curved                        |               "
#~ "not_curved\n"
#~ "------------------------------------------------------"
#~ "+---------------------------------------------------------------------\n"
#~ " CIRCULARSTRING Z (3 3 3,-1 2.99999999999999 3,3 3 3) | LINESTRING Z (3 3 "
#~ "3,2.4142135623731 1.58578643762691 3,1 1 3,\n"
#~ "                                                      | "
#~ "-0.414213562373092 1.5857864376269 3,-1 2.99999999999999 3,\n"
#~ "                                                      | "
#~ "-0.414213562373101 4.41421356237309 3,\n"
#~ "                                                      | 0.999999999999991 "
#~ "5 3,2.41421356237309 4.4142135623731 3,3 3 3)\n"
#~ "(1 row)"
#~ msgstr ""
#~ "-- 2D-Beispiel\n"
#~ "SELECT ST_AsText(ST_LineToCurve(foo.the_geom)) As curvedastext,"
#~ "ST_AsText(foo.the_geom) As non_curvedastext\n"
#~ "        FROM (SELECT ST_Buffer('POINT(1 3)'::geometry, 3) As the_geom) As "
#~ "foo;\n"
#~ "\n"
#~ "curvedatext                                                            "
#~ "non_curvedastext\n"
#~ "--------------------------------------------------------------------|-----------------------------------------------------------------\n"
#~ "CURVEPOLYGON(CIRCULARSTRING(4 3,3.12132034355964 0.878679656440359, | "
#~ "POLYGON((4 3,3.94235584120969 2.41472903395162,3.77163859753386 "
#~ "1.85194970290473,\n"
#~ "1 0,-1.12132034355965 5.12132034355963,4 3))                        |  "
#~ "3.49440883690764 1.33328930094119,3.12132034355964 0.878679656440359,\n"
#~ "                                                                    |  "
#~ "2.66671069905881 0.505591163092366,2.14805029709527 0.228361402466141,\n"
#~ "                                                                    |  "
#~ "1.58527096604839 0.0576441587903094,1 0,\n"
#~ "                                                                    |  "
#~ "0.414729033951621 0.0576441587903077,-0.148050297095264 "
#~ "0.228361402466137,\n"
#~ "                                                                    |  "
#~ "-0.666710699058802 0.505591163092361,-1.12132034355964 "
#~ "0.878679656440353,\n"
#~ "                                                                    |  "
#~ "-1.49440883690763 1.33328930094119,-1.77163859753386 1.85194970290472\n"
#~ "                                                                    |  --"
#~ "ETC-- ,3.94235584120969 3.58527096604839,4 3))\n"
#~ "\n"
#~ "--3D-Beispiel\n"
#~ "SELECT ST_AsText(ST_LineToCurve(geom)) As curved, ST_AsText(geom) AS "
#~ "not_curved\n"
#~ "FROM (SELECT ST_Translate(ST_Force3D(ST_Boundary(ST_Buffer(ST_Point(1,3), "
#~ "2,2))),0,0,3) AS geom) AS foo;\n"
#~ "\n"
#~ "                        curved                        |               "
#~ "not_curved\n"
#~ "------------------------------------------------------"
#~ "+---------------------------------------------------------------------\n"
#~ " CIRCULARSTRING Z (3 3 3,-1 2.99999999999999 3,3 3 3) | LINESTRING Z (3 3 "
#~ "3,2.4142135623731 1.58578643762691 3,1 1 3,\n"
#~ "                                                      |        "
#~ "-0.414213562373092 1.5857864376269 3,-1 2.99999999999999 3,\n"
#~ "                                                      | "
#~ "-0.414213562373101 4.41421356237309 3,\n"
#~ "                                                      |        "
#~ "0.999999999999991 5 3,2.41421356237309 4.4142135623731 3,3 3 3)\n"
#~ "(1 row)"

#~ msgid "ST_MakeValid"
#~ msgstr "ST_MakeValid"

#~ msgid "Attempts to make an invalid geometry valid without losing vertices."
#~ msgstr ""
#~ "Versucht eine ungültige Geometrie, ohne den Verlust an Knoten zu "
#~ "bereinigen."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_MakeValid</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>input</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_MakeValid</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>input</parameter></paramdef>"

#~ msgid ""
#~ "The function attempts to create a valid representation of a given invalid "
#~ "geometry without losing any of the input vertices. Already-valid "
#~ "geometries are returned without further intervention."
#~ msgstr ""
#~ "Diese Funktion versucht aus einer invaliden Geometrie eine valide "
#~ "Darstellung zu erzeugen, ohne irgendeinen gegebenen Knoten zu verlieren. "
#~ "Geometrien, die bereits valide sind, werden ohne weiteren Eingriff "
#~ "zurückgegeben."

#~ msgid ""
#~ "Supported inputs are: POINTS, MULTIPOINTS, LINESTRINGS, MULTILINESTRINGS, "
#~ "POLYGONS, MULTIPOLYGONS and GEOMETRYCOLLECTIONS containing any mix of "
#~ "them."
#~ msgstr ""
#~ "Unterstützte Eingaben sind: POINTS, MULTIPOINTS, LINESTRINGS, "
#~ "MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS und GEOMETRYCOLLECTIONS aus "
#~ "einer Mischung der Vorigen."

#~ msgid ""
#~ "In case of full or partial dimensional collapses, the output geometry may "
#~ "be a collection of lower-to-equal dimension geometries or a geometry of "
#~ "lower dimension."
#~ msgstr ""
#~ "Im Falle eines völligen oder teilweisen dimensionalen Kollapses kann die "
#~ "Ausgabegeometrie eine Sammelgeometrie von niedriger oder gleicher "
#~ "geometrischer Dimension oder eine Geometrie mit niedrigerer geometrischer "
#~ "Dimension sein."

#~ msgid ""
#~ "Single polygons may become multi-geometries in case of self-intersections."
#~ msgstr ""
#~ "Im Fall von Selbstüberschneidungen können Polygone zu Mehrfachgeometrien "
#~ "werden."

#, fuzzy
#~ msgid "Enhanced: 2.0.1, speed improvements"
#~ msgstr ""
#~ "Erweiterung: 2.0.1, Geschwindigkeitsverbesserungen, benötigt GEOS-3.3.4"

#, fuzzy
#~ msgid ""
#~ "Enhanced: 2.1.0, added support for GEOMETRYCOLLECTION and MULTIPOINT."
#~ msgstr ""
#~ "Erweiterung: 2.1.0 die Unterstützung von GeometryCollection und "
#~ "MultiPoint hinzugefügt."

#~ msgid "ST_MemUnion"
#~ msgstr "ST_MemUnion"

#~ msgid ""
#~ "Same as ST_Union, only memory-friendly (uses less memory and more "
#~ "processor time)."
#~ msgstr ""
#~ "Das gleiche wie ST_Union, nur freundlicher zum Arbeitsspeicher (verwendet "
#~ "weniger Arbeitsspeicher und mehr Rechnerzeit)."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_MemUnion</function></funcdef> "
#~ "<paramdef><type>geometry set</type> <parameter>geomfield</parameter></"
#~ "paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_MemUnion</function></funcdef> "
#~ "<paramdef><type>geometry set</type> <parameter>geomfield</parameter></"
#~ "paramdef>"

#~ msgid "Some useful description here."
#~ msgstr "Hier fehlt eine brauchbare Beschreibung."

#~ msgid ""
#~ "Same as ST_Union, only memory-friendly (uses less memory and more "
#~ "processor time). This aggregate function works by unioning the geometries "
#~ "one at a time to previous result as opposed to ST_Union aggregate which "
#~ "first creates an array and then unions"
#~ msgstr ""
#~ "Das gleiche wie ST_Union, nur freundlicher zum Arbeitsspeicher (verwendet "
#~ "weniger Arbeitsspeicher und mehr Rechnerzeit). Diese Aggregatfunktion "
#~ "vereingt eine Geometrie nach der anderen zu dem vorhergegangenen "
#~ "Ergebnis, während die Aggregatfunktion ST_Union zuerst ein Feld erzeugt "
#~ "und anschließend vereinigt"

#~ msgid "See ST_Union"
#~ msgstr "Siehe ST_Union"

#, fuzzy
#~ msgid "Availability: 3.1.0"
#~ msgstr "Verfügbarkeit: 1.5.0"

#~ msgid ""
#~ "Returns the smallest circle polygon that can fully contain a geometry. "
#~ "Default uses 48 segments per quarter circle."
#~ msgstr ""
#~ "Gibt das kleinstmögliche Kreispolygon zurück, welches eine Geometrie zur "
#~ "Gänze beinhaltet. Standardmäßig werden 48 Segmente pro Viertelkreiss "
#~ "verwendet."

#~ msgid ""
#~ "Aggregate. Creates a GeometryCollection containing possible polygons "
#~ "formed from the constituent linework of a set of geometries."
#~ msgstr ""
#~ "Aggregatfunktion. Erzeugt eine Sammelgeometrie/GeometryCollection, welche "
#~ "Polygone enthält, die aus den einzelnen Linien einer Menge von Geometrien "
#~ "gebildet werden können."

#~ msgid "ST_Node"
#~ msgstr "ST_Node"

#~ msgid "Node a set of linestrings."
#~ msgstr "Knotenberechnung für eine Menge von Linienzügen."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_Node</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_Node</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"

#~ msgid ""
#~ "Fully node a set of linestrings using the least possible number of nodes "
#~ "while preserving all of the input ones."
#~ msgstr ""
#~ "Komplette Knotenberechnung für eine Menge von Linienzügen unter "
#~ "Verwendung der kleinstmöglichen Knotenanzahl und Erhaltung aller "
#~ "bestehenden Knoten."

#~ msgid ""
#~ "Changed: 2.4.0 this function uses GEOSNode internally instead of "
#~ "GEOSUnaryUnion. This may cause the resulting linestrings to have a "
#~ "different order and direction compared to Postgis &lt; 2.4."
#~ msgstr ""
#~ "Änderung: Ab 2.4.0 verwendet diese Funktion intern GEOSNode anstatt "
#~ "GEOSUnaryUnion. Dies kann bedingen, dass die resultierenden Linienzüge "
#~ "eine andere Reihenfolge und Ausrichtung haben als bei PostGIS &lt; 2.4."

#, fuzzy
#~ msgid ""
#~ "SELECT ST_AsText(\n"
#~ "        ST_Node('LINESTRINGZ(0 0 0, 10 10 10, 0 10 5, 10 0 3)'::"
#~ "geometry)\n"
#~ "    ) As  output;\n"
#~ "output\n"
#~ "-----------\n"
#~ "MULTILINESTRING Z ((0 0 0,5 5 4.5),(5 5 4.5,10 10 10,0 10 5,5 5 4.5),(5 5 "
#~ "4.5,10 0 3))"
#~ msgstr ""
#~ "SELECT ST_AsText(\n"
#~ "                ST_Node('LINESTRINGZ(0 0 0, 10 10 10, 0 10 5, 10 0 3)'::"
#~ "geometry)\n"
#~ "        ) As  output;\n"
#~ "output\n"
#~ "-----------\n"
#~ "MULTILINESTRING Z ((0 0 0,5 5 4.5),(5 5 4.5,10 10 10,0 10 5,5 5 4.5),(5 5 "
#~ "4.5,10 0 3))"

#~ msgid "ST_RemoveRepeatedPoints"
#~ msgstr "ST_RemoveRepeatedPoints"

#~ msgid ""
#~ "Returns a version of the given geometry with duplicated points removed."
#~ msgstr ""
#~ "Gibt eine Version der Eingabegeometrie zurück, wobei duplizierte Punkte "
#~ "entfernt werden."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_RemoveRepeatedPoints</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef choice=\"opt\"><type>float8</type> <parameter>tolerance</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_RemoveRepeatedPoints</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef choice=\"opt\"><type>float8</type> <parameter>tolerance</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "Returns a version of the given geometry with duplicated points removed. "
#~ "Will actually do something only with (multi)lines, (multi)polygons and "
#~ "multipoints but you can safely call it with any kind of geometry. Since "
#~ "simplification occurs on a object-by-object basis you can also feed a "
#~ "GeometryCollection to this function."
#~ msgstr ""
#~ "Gibt eine Version der gegebenen Geometrie zurück, wobei duplizierte "
#~ "Punkte gelöscht werden. Tut zurzeit nur mit (Multi)Lines, (Multi)Polygons "
#~ "und MultiPoints etwas, kann aber gefahrlos mit jedem geometrischen "
#~ "Datentyp verwendet werden. Da die Vereinfachung auf einer Objekt zu "
#~ "Objekt Basis passiert, können Sie diese Funktion auch mit einer "
#~ "Sammelgeometrie speisen."

#~ msgid ""
#~ "If the tolerance parameter is provided, vertices within the tolerance of "
#~ "one another will be considered the \"same\" for the purposes of removal."
#~ msgstr ""
#~ "Wenn der Parameter \"tolerance\" angegeben ist, werden Knoten, die einen "
#~ "geringeren Abstand untereinander haben zwecks Löschen als ident "
#~ "betrachtet."

#~ msgid "ST_ShiftLongitude"
#~ msgstr "ST_ShiftLongitude"

#~ msgid "Toggle geometry coordinates between -180..180 and 0..360 ranges."
#~ msgstr ""
#~ "Schaltet geometrische Koordinaten zwischen den Bereichen -180..180 und "
#~ "0..360 um."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_ShiftLongitude</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_ShiftLongitude</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"

#~ msgid ""
#~ "Reads every point/vertex in every component of every feature in a "
#~ "geometry, and if the longitude coordinate is &lt;0, adds 360 to it. The "
#~ "result would be a 0-360 version of the data to be plotted in a 180 "
#~ "centric map"
#~ msgstr ""
#~ "Liest jeden Punkt/Knoten jeder Featurekomponente einer Geometrie, und "
#~ "wenn die Längenkoordinate &lt;0 ist wird 360 hinzugezählt. Das Ergebnis "
#~ "ist eine 0-360 Grad Version der Daten, die auf einer bei 180 Grad "
#~ "zentrierten Karte dargestellt werden kann."

#~ msgid "This is only useful for data in long lat e.g. 4326 (WGS 84 long lat)"
#~ msgstr ""
#~ "Dies ist nur sinnvoll bei Längen- und Breitenangabe, z.B.: 4326 (WGS 84 "
#~ "long lat)"

#~ msgid ""
#~ "Pre-1.3.4 bug prevented this from working for MULTIPOINT. 1.3.4+ works "
#~ "with MULTIPOINT as well."
#~ msgstr ""
#~ "Pre-1.3.4 Aufgrund eines Bugs funktionierte dies für MULTIPOINT nicht. "
#~ "Mit 1.3.4+ funktioniert es auch mit MULTIPOINT."

#~ msgid ""
#~ "Enhanced: 2.0.0 support for Polyhedral surfaces and TIN was introduced."
#~ msgstr ""
#~ "Erweiterung: Mit 2.0.0 wurde die Unterstützung für polyedrische "
#~ "Oberflächen und TIN eingeführt."

#~ msgid "NOTE: this function was renamed from \"ST_Shift_Longitude\" in 2.2.0"
#~ msgstr "Anmerkung: Vor 2.2.0 hieß diese Funktion \"ST_Shift_Longitude\""

#, fuzzy
#~ msgid ""
#~ "--3d points\n"
#~ "SELECT ST_AsEWKT(ST_ShiftLongitude(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-118.58 38.38 10)'))) As geomA,\n"
#~ "    ST_AsEWKT(ST_ShiftLongitude(ST_GeomFromEWKT('SRID=4326;POINT(241.42 "
#~ "38.38 10)'))) As geomb\n"
#~ "geomA                             geomB\n"
#~ "----------                        -----------\n"
#~ "SRID=4326;POINT(241.42 38.38 10) SRID=4326;POINT(-118.58 38.38 10)\n"
#~ "\n"
#~ "--regular line string\n"
#~ "SELECT ST_AsText(ST_ShiftLongitude(ST_GeomFromText('LINESTRING(-118.58 "
#~ "38.38, -118.20 38.45)')))\n"
#~ "\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "LINESTRING(241.42 38.38,241.8 38.45)"
#~ msgstr ""
#~ "--3D Punkte\n"
#~ "SELECT ST_AsEWKT(ST_ShiftLongitude(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-118.58 38.38 10)'))) As geomA,\n"
#~ "        ST_AsEWKT(ST_ShiftLongitude(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(241.42 38.38 10)'))) As geomb\n"
#~ "geomA                                                          geomB\n"
#~ "----------                                                  -----------\n"
#~ "SRID=4326;POINT(241.42 38.38 10) SRID=4326;POINT(-118.58 38.38 10)\n"
#~ "\n"
#~ "--normaler Linienzug\n"
#~ "SELECT ST_AsText(ST_ShiftLongitude(ST_GeomFromText('LINESTRING(-118.58 "
#~ "38.38, -118.20 38.45)')))\n"
#~ "\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "LINESTRING(241.42 38.38,241.8 38.45)"

#~ msgid "ST_WrapX"
#~ msgstr "ST_WrapX"

#~ msgid "Wrap a geometry around an X value."
#~ msgstr "Versammelt eine Geometrie um einen X-Wert"

#~ msgid ""
#~ "<funcdef>geometry <function>ST_WrapX</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef><type>float8 </type> <parameter>wrap</parameter></paramdef> "
#~ "<paramdef><type>float8 </type> <parameter>move</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_WrapX</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef><type>float8 </type> <parameter>wrap</parameter></paramdef> "
#~ "<paramdef><type>float8 </type> <parameter>move</parameter></paramdef>"

#~ msgid ""
#~ "This function splits the input geometries and then moves every resulting "
#~ "component falling on the right (for negative 'move') or on the left (for "
#~ "positive 'move') of given 'wrap' line in the direction specified by the "
#~ "'move' parameter, finally re-unioning the pieces togheter."
#~ msgstr ""
#~ "Diese Funktion trennt die Ausgangsgeometrie auf und verschiebt jeden "
#~ "resultierenden Bestandteil der auf die rechte (bei negativem 'move') oder "
#~ "auf die linke Seite (bei positivem 'move) der gegebenen 'wrap'-Linie "
#~ "fällt in die Richtung die durch den 'move' Parameter angegeben ist. "
#~ "Schließlich werden die Teile wieder vereinigt."

#~ msgid ""
#~ "This is useful to \"recenter\" long-lat input to have features of "
#~ "interest not spawned from one side to the other."
#~ msgstr ""
#~ "Nützlich, um eine Eingabe in Länge und Breite neu zu zentrieren, damit "
#~ "die wesentlichen Geoobjekte nicht von einer Seite bis zur anderen "
#~ "abgebildet werden."

#~ msgid ""
#~ "-- Move all components of the given geometries whose bounding box\n"
#~ "-- falls completely on the left of x=0 to +360\n"
#~ "select ST_WrapX(the_geom, 0, 360);\n"
#~ "\n"
#~ "-- Move all components of the given geometries whose bounding box\n"
#~ "-- falls completely on the left of x=-30 to +360\n"
#~ "select ST_WrapX(the_geom, -30, 360);"
#~ msgstr ""
#~ "-- Verschiebt alle Komponenten einer gegebenen Geometrie, deren "
#~ "Umgebungsrechteck\n"
#~ "-- zur Gänze links von x=0 liegen um +360\n"
#~ "select ST_WrapX(the_geom, 0, 360);\n"
#~ "\n"
#~ "-- Verschiebt alle Komponenten einer gegebenen Geometrie, deren "
#~ "Umgebungsrechteck\n"
#~ "-- zur Gänze links von x=30 liegen um +360\n"
#~ "select ST_WrapX(the_geom, -30, 360);"

#~ msgid ""
#~ "Returns a \"simplified\" version of the given geometry using the Douglas-"
#~ "Peucker algorithm. Will avoid creating derived geometries (polygons in "
#~ "particular) that are invalid."
#~ msgstr ""
#~ "Gibt eine vereinfachte Version der Ausgangsgeometrie zurück. Verwendet "
#~ "den Douglas-Peucker Algorithmus. Vermeidet es abgeleitete Geometrien zu "
#~ "erzeugen (insbesondere Polygone), die invalide sind."

#~ msgid ""
#~ "Sets the effective area for each vertex, storing the value in the M "
#~ "ordinate. A simplified geometry can then be generated by filtering on the "
#~ "M ordinate."
#~ msgstr ""
#~ "Setzt die Nutzfläche für jeden Knoten und speichert den Wert in der M-"
#~ "Ordinate. Eine vereinfachte Geometrie kann dann über einen Filter auf die "
#~ "M-Ordinate erzeugt werden."

#~ msgid "ST_Split"
#~ msgstr "ST_Split"

#~ msgid ""
#~ "Returns a collection of geometries resulting by splitting a geometry."
#~ msgstr ""
#~ "Gibt eine Sammelgeometrie zurück, die beim Auftrennen einer Geometrie "
#~ "entsteht."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_Split</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>input</parameter></paramdef> "
#~ "<paramdef><type>geometry</type> <parameter>blade</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_Split</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>input</parameter></paramdef> "
#~ "<paramdef><type>geometry</type> <parameter>blade</parameter></paramdef>"

#~ msgid ""
#~ "The function supports splitting a line by (multi)point, (multi)line or "
#~ "(multi)polygon boundary, a (multi)polygon by line. The returned geometry "
#~ "is always a collection."
#~ msgstr ""
#~ "Diese Funktion unterstützt das Auftrennen einer Linie durch einen "
#~ "MultiPoint, eine MultiLine  oder eine (Multi)Polygongrenze und das "
#~ "Auftrennen eines (Multi)Polygons durch eine Linie. Die zurückgegebene "
#~ "Geometrie ist immer eine Sammelgeometrie."

#~ msgid ""
#~ "Think of this function as the opposite of ST_Union. Theoretically "
#~ "applying ST_Union to the elements of the returned collection should "
#~ "always yield the original geometry."
#~ msgstr ""
#~ "Diese Funktion ist das Gegenstück zu ST_Union. Theoretisch sollte die "
#~ "Anwendung von ST_Union auf die Elemente der zurückgegebenen "
#~ "Sammelgeometrie immer zur ursprünglichen Geometrie führen."

#, fuzzy
#~ msgid ""
#~ "Enhanced: 2.2.0 support for splitting a line by a multiline, a multipoint "
#~ "or (multi)polygon boundary was introduced."
#~ msgstr ""
#~ "Änderung: 2.2.0 Unterstützung für das Auftrennen von Linien durch eine "
#~ "MultiLine, einen MultiPoint oder eine (Multi)Polygongrenze eingeführt"

#, fuzzy
#~ msgid ""
#~ "Enhanced: 2.5.0 support for splitting a polygon by a multiline was "
#~ "introduced."
#~ msgstr ""
#~ "Änderung: 2.2.0 Unterstützung für das Auftrennen von Linien durch eine "
#~ "MultiLine, einen MultiPoint oder eine (Multi)Polygongrenze eingeführt"

#~ msgid ""
#~ "To improve the robustness of ST_Split it may be convenient to <xref "
#~ "linkend=\"ST_Snap\"/> the input to the blade in advance using a very low "
#~ "tolerance. Otherwise the internally used coordinate grid may cause "
#~ "tolerance problems, where coordinates of input and blade do not fall onto "
#~ "each other and the input is not being split correctly (see <ulink url="
#~ "\"http://trac.osgeo.org/postgis/ticket/2192\">#2192</ulink>)."
#~ msgstr ""
#~ "Um die Robustheit von ST_Split zu erhöhen, kann es zweckmäßig sein ein "
#~ "<xref linkend=\"ST_Snap\"/> mit einem sehr niedrigen Toleranzwert "
#~ "auszuführen, bevor die Eingabe an die \"Schneide\" erfolgt. Andernfalls "
#~ "kann das intern verwendete Koordinatengitter Toleranzprobleme "
#~ "verursachen, wodurch die Koordinaten der Eingabe und der \"Schneide\" "
#~ "nicht zusammenfallen und die Eingabegeometrie nicht korrekt aufgetrennt "
#~ "wird (siehe <ulink url=\"http://trac.osgeo.org/postgis/"
#~ "ticket/2192\">#2192</ulink>)."

#~ msgid ""
#~ "When a (multi)polygon is passed as as the blade, its linear component "
#~ "(the boundary) is used for cutting the input."
#~ msgstr ""
#~ "Wenn ein Mehrfachpolygon als \"Schneide\" übergeben wird, so wird deren "
#~ "linearer Bestandteil (die Begrenzung) verwendet, um die Eingabegeometrie "
#~ "aufzutrennen."

#~ msgid "Polygon Cut by Line"
#~ msgstr "Polygon aufgetrennt durch eine Linie"

#~ msgid "Before Split"
#~ msgstr "Vor der Teilungsoperation"

#~ msgid "After split"
#~ msgstr "Nach der Teilungsoperation"

#~ msgid ""
#~ "-- this creates a geometry collection consisting of the 2 halves of the "
#~ "polygon\n"
#~ "-- this is similar to the example we demonstrated in ST_BuildArea\n"
#~ "SELECT ST_Split(circle, line)\n"
#~ "FROM (SELECT\n"
#~ "    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,\n"
#~ "    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;\n"
#~ "\n"
#~ "-- result --\n"
#~ " GEOMETRYCOLLECTION(POLYGON((150 90,149.039264020162 "
#~ "80.2454838991936,146.193976625564 70.8658283817455,..), POLYGON(..)))\n"
#~ "\n"
#~ "-- To convert to individual polygons, you can use ST_Dump or "
#~ "ST_GeometryN\n"
#~ "SELECT ST_AsText((ST_Dump(ST_Split(circle, line))).geom) As wkt\n"
#~ "FROM (SELECT\n"
#~ "    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,\n"
#~ "    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;\n"
#~ "\n"
#~ "-- result --\n"
#~ "wkt\n"
#~ "---------------\n"
#~ "POLYGON((150 90,149.039264020162 80.2454838991936,..))\n"
#~ "POLYGON((60.1371179574584 60.1371179574584,58.4265193848728 "
#~ "62.2214883490198,53.8060233744357 ..))"
#~ msgstr ""
#~ "-- erzeugt eine Sammelgeometrie die aus 2 Hälften des Polygons besteht\n"
#~ "-- ähnlich dem Beispiel unter ST_BuildArea\n"
#~ "SELECT ST_Split(circle, line)\n"
#~ "FROM (SELECT\n"
#~ "    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,\n"
#~ "    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;\n"
#~ "\n"
#~ "-- result --\n"
#~ " GEOMETRYCOLLECTION(POLYGON((150 90,149.039264020162 "
#~ "80.2454838991936,146.193976625564 70.8658283817455,..), POLYGON(..)))\n"
#~ "\n"
#~ "-- Um in einzelne Polygone umzurechnen können Sie ST_Dump oder "
#~ "ST_GeometryN verwenden\n"
#~ "SELECT ST_AsText((ST_Dump(ST_Split(circle, line))).geom) As wkt\n"
#~ "FROM (SELECT\n"
#~ "    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,\n"
#~ "    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;\n"
#~ "\n"
#~ "-- result --\n"
#~ "wkt\n"
#~ "---------------\n"
#~ "POLYGON((150 90,149.039264020162 80.2454838991936,..))\n"
#~ "POLYGON((60.1371179574584 60.1371179574584,58.4265193848728 "
#~ "62.2214883490198,53.8060233744357 ..))"

#~ msgid "Multilinestring Cut by point"
#~ msgstr "Ein MultiLiniestring durch einen Punkt aufgetrennt"

#~ msgid ""
#~ "SELECT ST_AsText(ST_Split(mline, pt)) As wktcut\n"
#~ "        FROM (SELECT\n"
#~ "    ST_GeomFromText('MULTILINESTRING((10 10, 190 190), (15 15, 30 30, 100 "
#~ "90))') As mline,\n"
#~ "    ST_Point(30,30) As pt) As foo;\n"
#~ "\n"
#~ "wktcut\n"
#~ "------\n"
#~ "GEOMETRYCOLLECTION(\n"
#~ "    LINESTRING(10 10,30 30),\n"
#~ "    LINESTRING(30 30,190 190),\n"
#~ "    LINESTRING(15 15,30 30),\n"
#~ "    LINESTRING(30 30,100 90)\n"
#~ ")"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_Split(mline, pt)) As wktcut\n"
#~ "        FROM (SELECT\n"
#~ "    ST_GeomFromText('MULTILINESTRING((10 10, 190 190), (15 15, 30 30, 100 "
#~ "90))') As mline,\n"
#~ "    ST_Point(30,30) As pt) As foo;\n"
#~ "\n"
#~ "wktcut\n"
#~ "------\n"
#~ "GEOMETRYCOLLECTION(\n"
#~ "    LINESTRING(10 10,30 30),\n"
#~ "    LINESTRING(30 30,190 190),\n"
#~ "    LINESTRING(15 15,30 30),\n"
#~ "    LINESTRING(30 30,100 90)\n"
#~ ")"

#, fuzzy
#~ msgid ""
#~ ", <xref linkend=\"ST_BuildArea\"/>, <xref linkend=\"ST_CollectionExtract"
#~ "\"/>, <xref linkend=\"ST_Dump\"/>, <xref linkend=\"ST_GeometryN\"/>, "
#~ "<xref linkend=\"ST_Subdivide\"/>, <xref linkend=\"ST_Union\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_BuildArea\"/>, <xref linkend=\"ST_Dump\"/>, <xref "
#~ "linkend=\"ST_GeometryN\"/>, <xref linkend=\"ST_Union\"/>, <xref linkend="
#~ "\"ST_Subdivide\"/>"

#~ msgid "ST_SymDifference"
#~ msgstr "ST_SymDifference"

#~ msgid ""
#~ "Returns a geometry that represents the portions of A and B that do not "
#~ "intersect. It is called a symmetric difference because ST_SymDifference(A,"
#~ "B) = ST_SymDifference(B,A)."
#~ msgstr ""
#~ "Gibt eine Geometrie zurück, die jene Teile von A und B repräsentiert, die "
#~ "sich nicht überlagern. Wird symmetrische Differenz genannt, da "
#~ "ST_SymDifference(A,B) = ST_SymDifference(B,A)."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_SymDifference</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_SymDifference</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#~ msgid ""
#~ "Returns a geometry that represents the portions of A and B that do not "
#~ "intersect. It is called a symmetric difference because ST_SymDifference(A,"
#~ "B) = ST_SymDifference(B,A). One can think of this as ST_Union(geomA,"
#~ "geomB) - ST_Intersection(A,B)."
#~ msgstr ""
#~ "Gibt eine Geometrie zurück, die jene Teile von A und B repräsentiert, die "
#~ "sich nicht überlagern. Wird symmetrische Differenz genannt, da "
#~ "ST_SymDifference(A,B) = ST_SymDifference(B,A). Man kann sich das auch als "
#~ "ST_Union(geomA,geomB) - ST_Intersection(A,B) vorstellen."

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.21"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.21"

#~ msgid "The original linestrings shown together"
#~ msgstr "Die ursprünglichen Linienzüge gemeinsam dargesellt"

#~ msgid "The symmetric difference of the two linestrings"
#~ msgstr "Die symmetrische Differenz zweier Linienzüge"

#, fuzzy
#~ msgid ""
#~ "--Safe for 2d - symmetric difference of 2 linestrings\n"
#~ "SELECT ST_AsText(\n"
#~ "    ST_SymDifference(\n"
#~ "        ST_GeomFromText('LINESTRING(50 100, 50 200)'),\n"
#~ "        ST_GeomFromText('LINESTRING(50 50, 50 150)')\n"
#~ "    )\n"
#~ ");\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "MULTILINESTRING((50 150,50 200),(50 50,50 100))"
#~ msgstr ""
#~ "--Sicher für 2D - symmetrische Differenz von 2 Linienzügen\n"
#~ "SELECT ST_AsText(\n"
#~ "        ST_SymDifference(\n"
#~ "                ST_GeomFromText('LINESTRING(50 100, 50 200)'),\n"
#~ "                ST_GeomFromText('LINESTRING(50 50, 50 150)')\n"
#~ "        )\n"
#~ ");\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "MULTILINESTRING((50 150,50 200),(50 50,50 100))"

#, fuzzy
#~ msgid ""
#~ "--When used in 3d doesn't quite do the right thing\n"
#~ "SELECT ST_AsEWKT(ST_SymDifference(ST_GeomFromEWKT('LINESTRING(1 2 1, 1 4 "
#~ "2)'),\n"
#~ "    ST_GeomFromEWKT('LINESTRING(1 1 3, 1 3 4)')))\n"
#~ "\n"
#~ "st_astext\n"
#~ "------------\n"
#~ "MULTILINESTRING((1 3 2.75,1 4 2),(1 1 3,1 2 2.25))"
#~ msgstr ""
#~ "--Mit 3D passiert nicht ganz das richtige\n"
#~ "SELECT ST_AsEWKT(ST_SymDifference(ST_GeomFromEWKT('LINESTRING(1 2 1, 1 4 "
#~ "2)'),\n"
#~ "        ST_GeomFromEWKT('LINESTRING(1 1 3, 1 3 4)')))\n"
#~ "\n"
#~ "st_astext\n"
#~ "------------\n"
#~ "MULTILINESTRING((1 3 2.75,1 4 2),(1 1 3,1 2 2.25))"

#~ msgid "ST_Subdivide"
#~ msgstr "ST_Subdivide"

#~ msgid ""
#~ "Returns a set of geometry where no geometry in the set has more than the "
#~ "specified number of vertices."
#~ msgstr ""
#~ "Gibt eine Geometriemenge zurück, wobei keine Geometrie der Menge mehr als "
#~ "die festgelegte Anzahl an Knoten aufweist."

#~ msgid ""
#~ "<funcdef>setof geometry <function>ST_Subdivide</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef><type>integer</type> <parameter>max_vertices=256</parameter></"
#~ "paramdef>"
#~ msgstr ""
#~ "<funcdef>setof geometry <function>ST_Subdivide</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef><type>integer</type> <parameter>max_vertices=256</parameter></"
#~ "paramdef>"

#~ msgid ""
#~ "-- Create a new subdivided table suitable for joining to the original\n"
#~ "CREATE TABLE subdivided_geoms AS\n"
#~ "SELECT pkey, ST_Subdivide(geom) AS geom\n"
#~ "FROM original_geoms;"
#~ msgstr ""
#~ "-- Erzeugt eine neu gegliederte Tabelle, passend um es mit dem Original "
#~ "zu verknüpfen\n"
#~ "CREATE TABLE subdivided_geoms AS\n"
#~ "SELECT pkey, ST_Subdivide(geom) AS geom\n"
#~ "FROM original_geoms;"

#~ msgid "Subdivide max 10 vertices"
#~ msgstr "In maximal 10 Knoten unterteilen"

#~ msgid ""
#~ "SELECT row_number() OVER() As rn, ST_AsText(geom) As wkt\n"
#~ "FROM ( SELECT ST_SubDivide('POLYGON((132 10,119 23,85 35,68 29,66 28,49 "
#~ "42,32 56,22 64,32 110,40 119,36 150,\n"
#~ "57 158,75 171,92 182,114 184,132 186,146 178,176 184,179 162,184 141,190 "
#~ "122,\n"
#~ "190 100,185 79,186 56,186 52,178 34,168 18,147 13,132 10))'::"
#~ "geometry,10))  As f(geom);"
#~ msgstr ""
#~ "SELECT row_number() OVER() As rn, ST_AsText(geom) As wkt\n"
#~ "FROM ( SELECT ST_SubDivide('POLYGON((132 10,119 23,85 35,68 29,66 28,49 "
#~ "42,32 56,22 64,32 110,40 119,36 150,\n"
#~ "57 158,75 171,92 182,114 184,132 186,146 178,176 184,179 162,184 141,190 "
#~ "122,\n"
#~ "190 100,185 79,186 56,186 52,178 34,168 18,147 13,132 10))'::"
#~ "geometry,10))  As f(geom);"

#, fuzzy
#~ msgid ""
#~ "Useful in conjunction with ST_Segmentize(geography) to create additional "
#~ "vertices that can then be used for splitting."
#~ msgstr ""
#~ "Nützlich in Verbindung mit ST_Segmentize um zusätzliche Knoten zu "
#~ "erzeugen, die dann zum Auftrennen verwendet werden können"

#, fuzzy
#~ msgid ""
#~ "SELECT ST_AsText(ST_Subdivide(ST_Segmentize('LINESTRING(0 0, 85 85)'::"
#~ "geography,1200000)::geometry,8));"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_SubDivide(ST_Segmentize('LINESTRING(0 0, 100 100, 150 "
#~ "150)'::geometry,10),8));"

#, fuzzy
#~ msgid ""
#~ ", <xref linkend=\"ST_ClipByBox2D\"/>, <xref linkend=\"ST_Segmentize\"/>, "
#~ "<xref linkend=\"ST_Split\"/>, <xref linkend=\"ST_NPoints\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ClipByBox2D\"/>, <xref linkend=\"ST_Segmentize\"/>, "
#~ "<xref linkend=\"ST_Split\"/>"

#~ msgid "ST_Union"
#~ msgstr "ST_Union"

#~ msgid ""
#~ "Returns a geometry that represents the point set union of the Geometries."
#~ msgstr ""
#~ "Gibt eine Geometrie zurück, welche der mengentheoretischen Vereinigung "
#~ "der Geometrien entspricht."

#~ msgid ""
#~ "<funcprototype> <funcdef>geometry <function>ST_Union</function></funcdef> "
#~ "<paramdef><type>geometry set</type> <parameter>g1field</parameter></"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
#~ "<function>ST_Union</function></funcdef> <paramdef><type>geometry</type> "
#~ "<parameter>g1</parameter></paramdef> <paramdef><type>geometry</type> "
#~ "<parameter>g2</parameter></paramdef> </funcprototype> <funcprototype> "
#~ "<funcdef>geometry <function>ST_Union</function></funcdef> "
#~ "<paramdef><type>geometry[]</type> <parameter>g1_array</parameter></"
#~ "paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>geometry <function>ST_Union</function></funcdef> "
#~ "<paramdef><type>geometry set</type> <parameter>g1field</parameter></"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
#~ "<function>ST_Union</function></funcdef> <paramdef><type>geometry</type> "
#~ "<parameter>g1</parameter></paramdef> <paramdef><type>geometry</type> "
#~ "<parameter>g2</parameter></paramdef> </funcprototype> <funcprototype> "
#~ "<funcdef>geometry <function>ST_Union</function></funcdef> "
#~ "<paramdef><type>geometry[]</type> <parameter>g1_array</parameter></"
#~ "paramdef> </funcprototype>"

#~ msgid ""
#~ "Output type can be a MULTI*, single geometry, or Geometry Collection. "
#~ "Comes in 2 variants. Variant 1 unions 2 geometries resulting in a new "
#~ "geometry with no intersecting regions. Variant 2 is an aggregate function "
#~ "that takes a set of geometries and unions them into a single ST_Geometry "
#~ "resulting in no intersecting regions."
#~ msgstr ""
#~ "Der Ausgabetyp kann eine MULTI*/Mehrfach-, eine Einzel- oder eine "
#~ "Sammelgeometrie sein. Hat 2 Varianten. Variante 1 vereinigt 2 Geometrien "
#~ "zu einer neuen Geometrie, welche keine überschneidenden Bereiche mehr "
#~ "aufweist. Variante 2 ist eine Aggregatfunktion, die eine Geometriemenge "
#~ "entgegennimmt und diese zu einer einzelnen ST_Geometry vereinigt, welche "
#~ "ebenfalls keine überschneidenden Bereiche mehr aufweist. "

#~ msgid ""
#~ "Aggregate version: This function returns a MULTI geometry or NON-MULTI "
#~ "geometry from a set of geometries. The ST_Union() function is an "
#~ "\"aggregate\" function in the terminology of PostgreSQL. That means that "
#~ "it operates on rows of data, in the same way the SUM() and AVG() "
#~ "functions do and like most aggregates, it also ignores NULL geometries."
#~ msgstr ""
#~ "Aggregat Version:: Diese Funktion gibt eine Mehrfachgeometrie oder eine "
#~ "Einzelgeometrie von einem Satz an Geometrien zurück. Die Funktion "
#~ "ST_Union() ist in der Terminologie von PostgreSQL eine Aggregatfunktion. "
#~ "Dies bedeutet, dass sie so wie die SUM() und AVG() Funktionen und so wie "
#~ "die meisten Aggregatfunktionen mit Datenzeilen arbeitet. Eine NULL-"
#~ "Geometrie wird ignoriert."

#~ msgid ""
#~ "Non-Aggregate version: This function returns a geometry being a union of "
#~ "two input geometries. Output type can be a MULTI*, NON-MULTI or "
#~ "GEOMETRYCOLLECTION. If any are NULL, then NULL is returned."
#~ msgstr ""
#~ "Nicht-Aggregat Version: Diese Funktion gibt eine Geometrie zurück, die "
#~ "eine Vereinigung von zwei Eingabegeometrien darstellt. Der Ausgabetyp "
#~ "kann eine MULTI*, NON-MULTI oder eine GEOMETRYCOLLECTION sein. Wenn eine "
#~ "der beiden Geometrien NULL ist, so wird NULL zurückgegeben."

#~ msgid ""
#~ "ST_Collect and ST_Union are often interchangeable. ST_Union is in general "
#~ "orders of magnitude slower than ST_Collect because it tries to dissolve "
#~ "boundaries and reorder geometries to ensure that a constructed Multi* "
#~ "doesn't have intersecting regions."
#~ msgstr ""
#~ "ST_Collect und ST_Union sind oftmals untereinander austauschbar. ST_Union "
#~ "ist im Allgemeinen um Größenordnungen langsamer als ST_Collect, da es "
#~ "versucht die Grenzen aufzulösen und die Geometrie neu zu sortieren um "
#~ "sicherzustellen, dass eine erzeugte MULTI* keine überschneidenden "
#~ "Bereiche aufweist."

#, fuzzy
#~ msgid ""
#~ "ST_Union will use the faster Cascaded Union algorithm described in <ulink "
#~ "url=\"http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-"
#~ "postgis-14.html\">http://blog.cleverelephant.ca/2009/01/must-faster-"
#~ "unions-in-postgis-14.html</ulink>"
#~ msgstr ""
#~ "Verfügbarkeit: 1.4.0 - ST_Union wurde erweitert. ST_Union(geomarray) "
#~ "wurde eingeführt und ebenso wurde die Aggragatfunktion in PostgreSQL "
#~ "schneller gemacht. Wenn Sie GEOS 3.1.0+ verwenden, so verwendet ST_Union "
#~ "den schnelleren, kaskadierenden Algorithmus für die Vereinigung. "
#~ "Letzterer ist unter <ulink url=\"http://blog.cleverelephant.ca/2009/01/"
#~ "must-faster-unions-in-postgis-14.html\">http://blog.cleverelephant."
#~ "ca/2009/01/must-faster-unions-in-postgis-14.html</ulink> beschrieben"

#~ msgid ""
#~ "NOTE: this function was formerly called GeomUnion(), which was renamed "
#~ "from \"Union\" because UNION is an SQL reserved word."
#~ msgstr ""
#~ "Anmerkung: diese Funktion wurde früher GeomUnion() genannt und wurde von "
#~ "\"Union\" umbenannt, da UNION ein reserviertes SQL-Wort ist."

#, fuzzy
#~ msgid ""
#~ "Availability: 1.4.0 - ST_Union was enhanced. ST_Union(geomarray) was "
#~ "introduced and also faster aggregate collection in PostgreSQL."
#~ msgstr ""
#~ "Verfügbarkeit: 1.4.0 - ST_Collect(geomarray) wurde eingeführt. ST_Collect "
#~ "wurde verbessert, um mehrere Geometrien schneller handhaben zu können."

#~ msgid "Aggregate version is not explicitly defined in OGC SPEC."
#~ msgstr ""
#~ "Die Aggregatversion ist in der OGC SPEC nicht ausdrücklich definiert."

#~ msgid ""
#~ "&sqlmm_compliant; SQL-MM 3: 5.1.19 the z-index (elevation) when polygons "
#~ "are involved."
#~ msgstr ""
#~ "&sqlmm_compliant; SQL-MM 3: 5.1.19 der Z-Index (Höhe) wenn Polygone "
#~ "beteiligt sind."

#~ msgid "Aggregate example"
#~ msgstr "Aggregat Beispiel"

#, fuzzy
#~ msgid ""
#~ "SELECT stusps,\n"
#~ "       ST_Union(f.geom) as singlegeom\n"
#~ "FROM sometable f\n"
#~ "GROUP BY stusps"
#~ msgstr ""
#~ "SELECT stusps,\n"
#~ "           ST_Multi(ST_Union(f.the_geom)) as singlegeom\n"
#~ "         FROM sometable As f\n"
#~ "GROUP BY stusps"

#~ msgid "Non-Aggregate example"
#~ msgstr "Nicht-Aggregat Beispiel"

#, fuzzy
#~ msgid ""
#~ ", <xref linkend=\"ST_UnaryUnion\"/>, <xref linkend=\"ST_Intersection\"/>, "
#~ "<xref linkend=\"ST_Difference\"/> <xref linkend=\"ST_SymDifference\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_SetSRID\"/>, <xref "
#~ "linkend=\"ST_Transform\"/>, <xref linkend=\"ST_Union\"/>"

#~ msgid "ST_UnaryUnion"
#~ msgstr "ST_UnaryUnion"

#~ msgid "Like ST_Union, but working at the geometry component level."
#~ msgstr ""
#~ "Wie ST_Union, arbeitet aber auf der Ebene der Geometriebestandteile."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_UnaryUnion</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_UnaryUnion</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"

#~ msgid ""
#~ "Unlike ST_Union, ST_UnaryUnion does dissolve boundaries between "
#~ "components of a multipolygon (invalid) and does perform union between the "
#~ "components of a geometrycollection. Each components of the input geometry "
#~ "is assumed to be valid, so you won't get a valid multipolygon out of a "
#~ "bow-tie polygon (invalid)."
#~ msgstr ""
#~ "Anders als ST_union löst ST_UnaryUnion die Grenzen zwischen den "
#~ "Bestandteilen des Mehrfachpolygons (invalid) auf und führt eine "
#~ "Vereinigung der Komponenten einer Sammelgeometrie durch. Alle "
#~ "Bestandteile der Eingabegeometrie werden als valide angenommen, sodass "
#~ "Sie kein valides Mehrfachpolygon von einem invaliden, sich selbst "
#~ "überschneidenden Polygon erhalten können."

#~ msgid ""
#~ "You may use this function to node a set of linestrings. You may mix "
#~ "ST_UnaryUnion with ST_Collect to fine-tune how many geometries at once "
#~ "you want to dissolve to be nice on both memory size and CPU time, finding "
#~ "the balance between ST_Union and ST_MemUnion."
#~ msgstr ""
#~ "Diese Funktion kann für Knotenberechnungen an einer Menge von Linienzügen "
#~ "verwendet werden. Sie können ST_UnaryUnion und ST_Collect mischen, um die "
#~ "Anzahl der Geometrien, bei denen die Grenzen auf einmal aufgelöst werden "
#~ "abzustimmen. Auf diese Weise kann eine Balance zwischen ST_Union und "
#~ "ST_MemUnion gefunden werden, die sowohl den Arbeitsspeicher als auch die "
#~ "CPU-Zeit schont."

#~ msgid ""
#~ ", <xref linkend=\"ST_MemUnion\"/>, <xref linkend=\"ST_Collect\"/>, <xref "
#~ "linkend=\"ST_Node\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_MemUnion\"/>, <xref linkend=\"ST_Collect\"/>, <xref "
#~ "linkend=\"ST_Node\"/>"

#~ msgid ""
#~ "Returns the boundaries between the cells of the Voronoi diagram "
#~ "constructed from the vertices of a geometry."
#~ msgstr ""
#~ "Gibt die Grenzen zwischen den Zellen des Voronoi Diagramms aus, das aus "
#~ "den Knoten der Geometrie konstruiert wurde."

#, fuzzy
#~ msgid ", <xref linkend=\"ST_ConcaveHull\"/>, <xref linkend=\"ST_Dump\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ConcaveHull\"/>, <xref linkend="
#~ "\"ST_MinimumBoundingCircle\"/>"

#~ msgid ""
#~ "'join=round|mitre|bevel' : join style (defaults to \"round\", needs "
#~ "GEOS-3.2 or higher for a different value). 'miter' is also accepted as a "
#~ "synonym for 'mitre'."
#~ msgstr ""
#~ "'join=round|mitre|bevel' : join style (standardmäßig \"round\", benötigt "
#~ "GEOS-3.2 oder höher für andere Werte). 'miter' kann auch als Synonym für "
#~ "'mitre' verwendet werden."

#~ msgid "Availability: 1.1.0 - requires GEOS &gt;= 2.1.0."
#~ msgstr "Verfügbarkeit: 1.1.0 - benötigt GEOS &gt;= 2.1.0."

#~ msgid "Requires GEOS 3.5.0+"
#~ msgstr "Benötigt GEOS 3.5.0+"

#~ msgid "Availability: 2.2.0 - requires GEOS &gt;= 3.5.0."
#~ msgstr "Verfügbarkeit: 2.2.0 - benötigt GEOS &gt;= 3.5.0."

#~ msgid "ST_Collect"
#~ msgstr "ST_Collect"

#~ msgid ""
#~ "Return a specified ST_Geometry value from a collection of other "
#~ "geometries."
#~ msgstr ""
#~ "Gibt einen festgelegten ST_Geometry Wert aus einer Sammlung anderer "
#~ "Geometrien zurück."

#~ msgid ""
#~ "<funcprototype> <funcdef>geometry <function>ST_Collect</function></"
#~ "funcdef> <paramdef><type>geometry set</type> <parameter>g1field</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
#~ "<function>ST_Collect</function></funcdef> <paramdef><type>geometry</type> "
#~ "<parameter>g1</parameter></paramdef> <paramdef><type>geometry</type> "
#~ "<parameter>g2</parameter></paramdef> </funcprototype> <funcprototype> "
#~ "<funcdef>geometry <function>ST_Collect</function></funcdef> "
#~ "<paramdef><type>geometry[]</type> <parameter>g1_array</parameter></"
#~ "paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>geometry <function>ST_Collect</function></"
#~ "funcdef> <paramdef><type>geometry set</type> <parameter>g1field</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
#~ "<function>ST_Collect</function></funcdef> <paramdef><type>geometry</type> "
#~ "<parameter>g1</parameter></paramdef> <paramdef><type>geometry</type> "
#~ "<parameter>g2</parameter></paramdef> </funcprototype> <funcprototype> "
#~ "<funcdef>geometry <function>ST_Collect</function></funcdef> "
#~ "<paramdef><type>geometry[]</type> <parameter>g1_array</parameter></"
#~ "paramdef> </funcprototype>"

#~ msgid ""
#~ "Output type can be a MULTI* or a GEOMETRYCOLLECTION. Comes in 2 variants. "
#~ "Variant 1 collects 2 geometries. Variant 2 is an aggregate function that "
#~ "takes a set of geometries and collects them into a single ST_Geometry."
#~ msgstr ""
#~ "Der Ausgabetyp kann eine MULTI* oder eine GEOMETRYCOLLECTION sein. Hat 2 "
#~ "Varianten. Variante 1 sammelt 2 Geometrien ein. Variante 2 ist eine "
#~ "Aggregatfunktion, die einen Satz an Geometrien entgegennimmt und diese in "
#~ "einer einzelnen ST_Geometry versammelt."

#~ msgid ""
#~ "Aggregate version: This function returns a GEOMETRYCOLLECTION or a MULTI "
#~ "object from a set of geometries. The ST_Collect() function is an "
#~ "\"aggregate\" function in the terminology of PostgreSQL. That means that "
#~ "it operates on rows of data, in the same way the SUM() and AVG() "
#~ "functions do. For example, \"SELECT ST_Collect(GEOM) FROM GEOMTABLE GROUP "
#~ "BY ATTRCOLUMN\" will return a separate GEOMETRYCOLLECTION for each "
#~ "distinct value of ATTRCOLUMN."
#~ msgstr ""
#~ "Aggregat Version:: Diese Funktion gibt eine GEOMETRYCOLLECTION oder ein "
#~ "MULTI Objekt aus einem Satz an Geometrien. Die Funktion ST_Collect() ist "
#~ "in der Terminologie von PostgreSQL eine Aggregatfunktion. Dies bedeutet, "
#~ "dass sie so wie die SUM() und AVG() Funktionen mit Datenzeilen arbeitet. "
#~ "Zum Beispiel, \"SELECT ST_Collect(GEOM) FROM GEOMTABLE GROUP BY ATTRCOLUMN"
#~ "\" gibt eine einzelne GEOMETRYCOLLECTION für jeden eindeutigen Wert von "
#~ "ATTRCOLUMN zurück."

#~ msgid ""
#~ "Non-Aggregate version: This function returns a geometry being a "
#~ "collection of two input geometries. Output type can be a MULTI* or a "
#~ "GEOMETRYCOLLECTION."
#~ msgstr ""
#~ "Nicht-Aggregat Version: Diese Funktion gibt eine Geometrie zurück, die "
#~ "aus der Ansammlung zweier Eingabegeometrien besteht. Der Ausgabetyp kann "
#~ "eine Mehrfach-/MULTI* oder eine Sammelgeometrie/GEOMETRYCOLLECTION sein."

#~ msgid ""
#~ "ST_Collect and ST_Union are often interchangeable except that ST_Collect "
#~ "will always return a GeometryCollection or MULTI geometry and ST_Union "
#~ "may return single geometries when it dissolves boundaries. ST_Union will "
#~ "also split linestrings at node intersections, whereas ST_Collect will "
#~ "never split linestrings and in turn just return as MULTILINESTRING. To "
#~ "prevent ST_Collect from returning a Geometry Collection when collecting "
#~ "MULTI geometries, one can use the below trick that utilizes <xref linkend="
#~ "\"ST_Dump\"/> to expand the MULTIs out to singles and then regroup them."
#~ msgstr ""
#~ "ST_Collect und ST_Union sind oftmals gegeneinander austauschbar, außer "
#~ "das ST_Collect immer eine GeometryCollection oder MULTI-Geometrie "
#~ "zurückgibt und ST_Union kann Einzelgeometrien zurückgeben, wenn es die "
#~ "Grenzlinien auflöst. ST_Union teilt Linienzüge an Überschneidungsknoten, "
#~ "während ST_Collect Linienzüge niemals auftrennt und nur einen "
#~ "MULTILINESTRING zurückgibt. Um ST_Collect von der Ausgabe einer "
#~ "GeometryCollection bei der Sammlung von MULTI-Geometrien abzuhalten, kann "
#~ "man den unteren Trick anwenden, der <xref linkend=\"ST_Dump\"/> nützt, um "
#~ "die MULTIs in Einzelgeometrien zu zerlegen und diese anschließend neu "
#~ "gruppiert."

#~ msgid ""
#~ "&curve_support; This method supports Circular Strings and Curves, but "
#~ "will never return a MULTICURVE or MULTI as one would expect and PostGIS "
#~ "does not currently support those."
#~ msgstr ""
#~ "&curve_support; Diese Methode unterstützt Kreisbögen und Kurven, gibt "
#~ "aber niemals eine MULTICURVE oder MULTI* zurück, so wie man es sich "
#~ "erwarten würde und PostGIS unterstützt diese auch nicht."

#~ msgid ""
#~ "SELECT stusps, ST_Collect(f.the_geom) as singlegeom\n"
#~ "         FROM (SELECT stusps, (ST_Dump(the_geom)).geom As the_geom\n"
#~ "                                FROM\n"
#~ "                                somestatetable ) As f\n"
#~ "GROUP BY stusps"
#~ msgstr ""
#~ "SELECT stusps, ST_Collect(f.the_geom) as singlegeom\n"
#~ "         FROM (SELECT stusps, (ST_Dump(the_geom)).geom As the_geom\n"
#~ "                                FROM\n"
#~ "                                somestatetable ) As f\n"
#~ "GROUP BY stusps"

#~ msgid ""
#~ "SELECT ST_AsText(ST_Collect(ST_GeomFromText('POINT(1 2)'),\n"
#~ "        ST_GeomFromText('POINT(-2 3)') ));\n"
#~ "\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "MULTIPOINT(1 2,-2 3)\n"
#~ "\n"
#~ "--Collect 2 d points\n"
#~ "SELECT ST_AsText(ST_Collect(ST_GeomFromText('POINT(1 2)'),\n"
#~ "                ST_GeomFromText('POINT(1 2)') ) );\n"
#~ "\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "MULTIPOINT(1 2,1 2)\n"
#~ "\n"
#~ "--Collect 3d points\n"
#~ "SELECT ST_AsEWKT(ST_Collect(ST_GeomFromEWKT('POINT(1 2 3)'),\n"
#~ "                ST_GeomFromEWKT('POINT(1 2 4)') ) );\n"
#~ "\n"
#~ "                st_asewkt\n"
#~ "-------------------------\n"
#~ " MULTIPOINT(1 2 3,1 2 4)\n"
#~ "\n"
#~ " --Example with curves\n"
#~ "SELECT ST_AsText(ST_Collect(ST_GeomFromText('CIRCULARSTRING(220268 "
#~ "150415,220227 150505,220227 150406)'),\n"
#~ "ST_GeomFromText('CIRCULARSTRING(220227 150406,2220227 150407,220227 "
#~ "150406)')));\n"
#~ "                                                                                                                                st_astext\n"
#~ "------------------------------------------------------------------------------------\n"
#~ " GEOMETRYCOLLECTION(CIRCULARSTRING(220268 150415,220227 150505,220227 "
#~ "150406),\n"
#~ " CIRCULARSTRING(220227 150406,2220227 150407,220227 150406))\n"
#~ "\n"
#~ "--New ST_Collect array construct\n"
#~ "SELECT ST_Collect(ARRAY(SELECT the_geom FROM sometable));\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_Collect(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 "
#~ "4)'),\n"
#~ "                        ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As "
#~ "wktcollect;\n"
#~ "\n"
#~ "--wkt collect --\n"
#~ "MULTILINESTRING((1 2,3 4),(3 4,4 5))"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_Collect(ST_GeomFromText('POINT(1 2)'),\n"
#~ "        ST_GeomFromText('POINT(-2 3)') ));\n"
#~ "\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "MULTIPOINT(1 2,-2 3)\n"
#~ "\n"
#~ "--2D-Punkte sammeln\n"
#~ "SELECT ST_AsText(ST_Collect(ST_GeomFromText('POINT(1 2)'),\n"
#~ "                ST_GeomFromText('POINT(1 2)') ) );\n"
#~ "\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "MULTIPOINT(1 2,1 2)\n"
#~ "\n"
#~ "--3D-Punkte sammeln\n"
#~ "SELECT ST_AsEWKT(ST_Collect(ST_GeomFromEWKT('POINT(1 2 3)'),\n"
#~ "                ST_GeomFromEWKT('POINT(1 2 4)') ) );\n"
#~ "\n"
#~ "                st_asewkt\n"
#~ "-------------------------\n"
#~ " MULTIPOINT(1 2 3,1 2 4)\n"
#~ "\n"
#~ " --Beispiel mit Kurven\n"
#~ "SELECT ST_AsText(ST_Collect(ST_GeomFromText('CIRCULARSTRING(220268 "
#~ "150415,220227 150505,220227 150406)'),\n"
#~ "ST_GeomFromText('CIRCULARSTRING(220227 150406,2220227 150407,220227 "
#~ "150406)')));\n"
#~ "                                                                                                                                st_astext\n"
#~ "------------------------------------------------------------------------------------\n"
#~ " GEOMETRYCOLLECTION(CIRCULARSTRING(220268 150415,220227 150505,220227 "
#~ "150406),\n"
#~ " CIRCULARSTRING(220227 150406,2220227 150407,220227 150406))\n"
#~ "\n"
#~ "--Neues ST_Collect-Array Konstrukt\n"
#~ "SELECT ST_Collect(ARRAY(SELECT the_geom FROM sometable));\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_Collect(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 "
#~ "4)'),\n"
#~ "                        ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As "
#~ "wktcollect;\n"
#~ "\n"
#~ "--wkt collect --\n"
#~ "MULTILINESTRING((1 2,3 4),(3 4,4 5))"

#~ msgid ""
#~ "<refpurpose>The convex hull of a geometry represents the minimum convex "
#~ "geometry that encloses all geometries within the set.</refpurpose>"
#~ msgstr ""
#~ "<refpurpose>Die konvexe Hülle einer Geometrie stellt die kleinste konvexe "
#~ "Geometrie dar, welche die gesamte Menge der Geometrie umhüllt.</"
#~ "refpurpose>"

#~ msgid ""
#~ "It is often used to determine an affected area based on a set of point "
#~ "observations."
#~ msgstr ""
#~ "Wird oft zur Bestimmung einer beeinträchtigten Fläche aus einem Satz von "
#~ "Beobachtungspunkten verwendet."

#~ msgid ""
#~ "<funcprototype> <funcdef>geometry <function>ST_CurveToLine</function></"
#~ "funcdef> <paramdef><type>geometry</type> <parameter>curveGeom</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
#~ "<function>ST_CurveToLine</function></funcdef> <paramdef><type>geometry</"
#~ "type> <parameter>curveGeom</parameter></paramdef> "
#~ "<paramdef><type>integer</type> <parameter>segments_per_qtr_circle</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
#~ "<function>ST_CurveToLine</function></funcdef> <paramdef><type>geometry</"
#~ "type> <parameter>curveGeom</parameter></paramdef> <paramdef><type>float</"
#~ "type> <parameter>tolerance</parameter></paramdef> "
#~ "<paramdef><type>integer</type> <parameter>tolerance_type</parameter></"
#~ "paramdef> <paramdef><type>integer</type> <parameter>flags</parameter></"
#~ "paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>geometry <function>ST_CurveToLine</function></"
#~ "funcdef> <paramdef><type>geometry</type> <parameter>curveGeom</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
#~ "<function>ST_CurveToLine</function></funcdef> <paramdef><type>geometry</"
#~ "type> <parameter>curveGeom</parameter></paramdef> "
#~ "<paramdef><type>integer</type> <parameter>segments_per_qtr_circle</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>geometry "
#~ "<function>ST_CurveToLine</function></funcdef> <paramdef><type>geometry</"
#~ "type> <parameter>curveGeom</parameter></paramdef> <paramdef><type>float</"
#~ "type> <parameter>tolerance</parameter></paramdef> "
#~ "<paramdef><type>integer</type> <parameter>tolerance_type</parameter></"
#~ "paramdef> <paramdef><type>integer</type> <parameter>flags</parameter></"
#~ "paramdef> </funcprototype>"

#~ msgid "Availability: 1.2.2?"
#~ msgstr "Verfügbarkeit: 1.2.2?"

#~ msgid "Do not call with a GeometryCollection as an argument"
#~ msgstr "Nicht mit einer GeometryCollection als Übergabewert aufrufen"

#~ msgid "ST_Dump"
#~ msgstr "ST_Dump"

#~ msgid ""
#~ "Returns a set of geometry_dump (geom,path) rows, that make up a geometry "
#~ "g1."
#~ msgstr ""
#~ "Gibt einen Satz an geometry_dump (geom,path) Zeilen zurück, aus denen die "
#~ "Geometrie g1 zusammengesetzt ist."

#~ msgid ""
#~ "<funcdef>geometry_dump[] <function>ST_Dump</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry_dump[] <function>ST_Dump</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>"

#~ msgid ""
#~ "This is a set-returning function (SRF). It returns a set of geometry_dump "
#~ "rows, formed by a geometry (geom) and an array of integers (path). When "
#~ "the input geometry is a simple type (POINT,LINESTRING,POLYGON) a single "
#~ "record will be returned with an empty path array and the input geometry "
#~ "as geom. When the input geometry is a collection or multi it will return "
#~ "a record for each of the collection components, and the path will express "
#~ "the position of the component inside the collection."
#~ msgstr ""
#~ "Dies ist eine Funktion mit Ergebnismege (set-returning function, SRF). "
#~ "Sie gibt eine Menge an geometry_dump Zeilen zurück, welche aus einer "
#~ "Geometrie (geom) und einem Feld aus Ganzzahlen (path) gebildet werden. "
#~ "Wenn die Eingabegeometrie ein einfacher Typ (POINT,LINESTRING,POLYGON) "
#~ "ist, wird ein einzelner Datensatz, mit einem leeren path-Feld und der "
#~ "Eingabegeometrie als geom, zurückgegeben. Falls die Eingabegeometrie eine "
#~ "COLLECTION oder eine MULTI* ist, wird für jede Komponente der COLLECTION "
#~ "ein Datensatz ausgegeben, wobei der path die Lage der Komponente in der "
#~ "COLLECTION angibt."

#~ msgid ""
#~ "ST_Dump is useful for expanding geometries. It is the reverse of a GROUP "
#~ "BY in that it creates new rows. For example it can be use to expand "
#~ "MULTIPOLYGONS into POLYGONS."
#~ msgstr ""
#~ "ST_Dump ist nütlich beim Ausladen von Geometrien. Es ist das Gegenteil "
#~ "von GROUP BY, insofern als neue Zeilen erzeugt werden. Es kann zum "
#~ "Beispiel verwendet werden um MultiPolygone in Polygone überzuführen."

#~ msgid ""
#~ "Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was "
#~ "introduced."
#~ msgstr ""
#~ "Erweiterung: 2.0.0 Unterstützung für polyedrische Oberflächen, Dreiecke "
#~ "und TIN eingeführt."

#~ msgid "Availability: PostGIS 1.0.0RC1. Requires PostgreSQL 7.3 or higher."
#~ msgstr ""
#~ "Verfügbarkeit: PostGIS 1.0.0RC1. Benötigt PostgreSQL 7.3 oder höher."

#~ msgid ""
#~ "Prior to 1.3.4, this function crashes if used with geometries that "
#~ "contain CURVES. This is fixed in 1.3.4+"
#~ msgstr ""
#~ "Vor 1.3.4 ist diese Funktion abgestürzt, wenn die Geometrien KURVEN/"
#~ "CURVES enthalten. Dies wurde mit 1.3.4+ behoben"

#~ msgid "Standard Examples"
#~ msgstr "Standardbeispiele"

#~ msgid ""
#~ "SELECT sometable.field1, sometable.field1,\n"
#~ "      (ST_Dump(sometable.the_geom)).geom AS the_geom\n"
#~ "FROM sometable;\n"
#~ "\n"
#~ "-- Break a compound curve into its constituent linestrings and "
#~ "circularstrings\n"
#~ "SELECT ST_AsEWKT(a.geom), ST_HasArc(a.geom)\n"
#~ "  FROM ( SELECT (ST_Dump(p_geom)).geom AS geom\n"
#~ "         FROM (SELECT ST_GeomFromEWKT('COMPOUNDCURVE(CIRCULARSTRING(0 0, "
#~ "1 1, 1 0),(1 0, 0 1))') AS p_geom) AS b\n"
#~ "        ) AS a;\n"
#~ "          st_asewkt          | st_hasarc\n"
#~ "-----------------------------+----------\n"
#~ " CIRCULARSTRING(0 0,1 1,1 0) | t\n"
#~ " LINESTRING(1 0,0 1)         | f\n"
#~ "(2 rows)"
#~ msgstr ""
#~ "SELECT sometable.field1, sometable.field1,\n"
#~ "      (ST_Dump(sometable.the_geom)).geom AS the_geom\n"
#~ "FROM sometable;\n"
#~ "\n"
#~ "-- Einen zusammengesetzten Bogen in seine Linienzüge und Kreisbögen "
#~ "aufbrechen\n"
#~ "SELECT ST_AsEWKT(a.geom), ST_HasArc(a.geom)\n"
#~ "  FROM ( SELECT (ST_Dump(p_geom)).geom AS geom\n"
#~ "         FROM (SELECT ST_GeomFromEWKT('COMPOUNDCURVE(CIRCULARSTRING(0 0, "
#~ "1 1, 1 0),(1 0, 0 1))') AS p_geom) AS b\n"
#~ "        ) AS a;\n"
#~ "          st_asewkt          | st_hasarc\n"
#~ "-----------------------------+----------\n"
#~ " CIRCULARSTRING(0 0,1 1,1 0) | t\n"
#~ " LINESTRING(1 0,0 1)         | f\n"
#~ "(2 rows)"

#~ msgid "Polyhedral Surfaces, TIN and Triangle Examples"
#~ msgstr "Beispiele für polyedrische Oberflächen, TIN und Dreiecke"

#~ msgid ""
#~ "-- Polyhedral surface example\n"
#~ "-- Break a Polyhedral surface into its faces\n"
#~ "SELECT (a.p_geom).path[1] As path, ST_AsEWKT((a.p_geom).geom) As "
#~ "geom_ewkt\n"
#~ "  FROM (SELECT ST_Dump(ST_GeomFromEWKT('POLYHEDRALSURFACE(\n"
#~ "((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),\n"
#~ "((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 "
#~ "0)),  ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),\n"
#~ "((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)),  ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 "
#~ "1))\n"
#~ ")') ) AS p_geom )  AS a;\n"
#~ "\n"
#~ " path |                geom_ewkt\n"
#~ "------+------------------------------------------\n"
#~ "    1 | POLYGON((0 0 0,0 0 1,0 1 1,0 1 0,0 0 0))\n"
#~ "    2 | POLYGON((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))\n"
#~ "    3 | POLYGON((0 0 0,1 0 0,1 0 1,0 0 1,0 0 0))\n"
#~ "    4 | POLYGON((1 1 0,1 1 1,1 0 1,1 0 0,1 1 0))\n"
#~ "    5 | POLYGON((0 1 0,0 1 1,1 1 1,1 1 0,0 1 0))\n"
#~ "    6 | POLYGON((0 0 1,1 0 1,1 1 1,0 1 1,0 0 1))"
#~ msgstr ""
#~ "-- Beispiel für eine polyedrische Oberfläche\n"
#~ "-- Eine polyedrische Oberfläche in Einzelflächen zerlegen\n"
#~ "SELECT (a.p_geom).path[1] As path, ST_AsEWKT((a.p_geom).geom) As "
#~ "geom_ewkt\n"
#~ "  FROM (SELECT ST_Dump(ST_GeomFromEWKT('POLYHEDRALSURFACE(\n"
#~ "((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),\n"
#~ "((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 "
#~ "0)),  ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),\n"
#~ "((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)),  ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 "
#~ "1))\n"
#~ ")') ) AS p_geom )  AS a;\n"
#~ "\n"
#~ " path |                geom_ewkt\n"
#~ "------+------------------------------------------\n"
#~ "    1 | POLYGON((0 0 0,0 0 1,0 1 1,0 1 0,0 0 0))\n"
#~ "    2 | POLYGON((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))\n"
#~ "    3 | POLYGON((0 0 0,1 0 0,1 0 1,0 0 1,0 0 0))\n"
#~ "    4 | POLYGON((1 1 0,1 1 1,1 0 1,1 0 0,1 1 0))\n"
#~ "    5 | POLYGON((0 1 0,0 1 1,1 1 1,1 1 0,0 1 0))\n"
#~ "    6 | POLYGON((0 0 1,1 0 1,1 1 1,0 1 1,0 0 1))"

#~ msgid ""
#~ "-- TIN --\n"
#~ "SELECT (g.gdump).path, ST_AsEWKT((g.gdump).geom) as wkt\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       ST_Dump( ST_GeomFromEWKT('TIN (((\n"
#~ "                0 0 0,\n"
#~ "                0 0 1,\n"
#~ "                0 1 0,\n"
#~ "                0 0 0\n"
#~ "            )), ((\n"
#~ "                0 0 0,\n"
#~ "                0 1 0,\n"
#~ "                1 1 0,\n"
#~ "                0 0 0\n"
#~ "            ))\n"
#~ "            )') ) AS gdump\n"
#~ "    ) AS g;\n"
#~ "-- result --\n"
#~ " path |                 wkt\n"
#~ "------+-------------------------------------\n"
#~ " {1}  | TRIANGLE((0 0 0,0 0 1,0 1 0,0 0 0))\n"
#~ " {2}  | TRIANGLE((0 0 0,0 1 0,1 1 0,0 0 0))"
#~ msgstr ""
#~ "-- TIN --\n"
#~ "SELECT (g.gdump).path, ST_AsEWKT((g.gdump).geom) as wkt\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       ST_Dump( ST_GeomFromEWKT('TIN (((\n"
#~ "                0 0 0,\n"
#~ "                0 0 1,\n"
#~ "                0 1 0,\n"
#~ "                0 0 0\n"
#~ "            )), ((\n"
#~ "                0 0 0,\n"
#~ "                0 1 0,\n"
#~ "                1 1 0,\n"
#~ "                0 0 0\n"
#~ "            ))\n"
#~ "            )') ) AS gdump\n"
#~ "    ) AS g;\n"
#~ "-- result --\n"
#~ " path |                 wkt\n"
#~ "------+-------------------------------------\n"
#~ " {1}  | TRIANGLE((0 0 0,0 0 1,0 1 0,0 0 0))\n"
#~ " {2}  | TRIANGLE((0 0 0,0 1 0,1 1 0,0 0 0))"

#~ msgid ""
#~ ", <xref linkend=\"PostGIS_Geometry_DumpFunctions\"/>, <xref linkend="
#~ "\"ST_Collect\"/>, <xref linkend=\"ST_Collect\"/>, <xref linkend="
#~ "\"ST_GeometryN\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"PostGIS_Geometry_DumpFunctions\"/>, <xref linkend="
#~ "\"ST_Collect\"/>, <xref linkend=\"ST_Collect\"/>, <xref linkend="
#~ "\"ST_GeometryN\"/>"

#~ msgid "ST_DumpPoints"
#~ msgstr "ST_DumpPoints"

#~ msgid ""
#~ "Returns a set of geometry_dump (geom,path) rows of all points that make "
#~ "up a geometry."
#~ msgstr ""
#~ "Gibt eine Menge von geometry_dump (geom,path) Zeilen aller Punkte zurück, "
#~ "aus denen die Geometrie zusammengesetzt ist."

#~ msgid ""
#~ "<funcdef>geometry_dump[]<function>ST_DumpPoints</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry_dump[]<function>ST_DumpPoints</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>"

#~ msgid ""
#~ "This set-returning function (SRF) returns a set of "
#~ "<varname>geometry_dump</varname> rows formed by a geometry "
#~ "(<varname>geom</varname>) and an array of integers (<varname>path</"
#~ "varname>)."
#~ msgstr ""
#~ "Diese Funktion mit Ergebnismenge (set-returning function, SRF) gibt eine "
#~ "Menge an <varname>geometry_dump</varname> Zeilen zurück, die aus einer "
#~ "Geometrie (<varname>geom</varname>) und einem Feld aus Ganzzahlen "
#~ "(<varname>path</varname>) aufgebaut ist."

#~ msgid ""
#~ "The <parameter>geom</parameter> component of <varname>geometry_dump</"
#~ "varname> are all the <varname>POINT</varname>s that make up the supplied "
#~ "geometry"
#~ msgstr ""
#~ "Die <parameter>geom</parameter> Komponente des <varname>geometry_dump</"
#~ "varname> besteht aus allen <varname>POINT</varname>s aus denen die "
#~ "eingegebene Geometrie besteht"

#~ msgid ""
#~ "The <parameter>path</parameter> component of <varname>geometry_dump</"
#~ "varname> (an <varname>integer[]</varname>) is an index reference "
#~ "enumerating the <varname>POINT</varname>s of the supplied geometry. For "
#~ "example, if a <varname>LINESTRING</varname> is supplied, a path of "
#~ "<varname>{i}</varname> is returned where <varname>i</varname> is the "
#~ "<varname>nth</varname> coordinate in the <varname>LINESTRING</varname>. "
#~ "If a <varname>POLYGON</varname> is supplied, a path of <varname>{i,j}</"
#~ "varname> is returned where <varname>i</varname> is the ring number (1 is "
#~ "outer; inner rings follow) and <varname>j</varname> enumerates the "
#~ "<varname>POINT</varname>s (again 1-based index)."
#~ msgstr ""
#~ "Die <parameter>path</parameter> Komponente des <varname>geometry_dump</"
#~ "varname> (ein <varname>integer[]</varname>) ist eine Indexreferenz, "
#~ "welche die <varname>POINT</varname>s der eingegebenen Geometrie abzählt. "
#~ "Wenn zum Beispiel ein <varname>LINESTRING</varname> eingegeben wird, wird "
#~ "ein path von <varname>{i}</varname> zurückgegeben, wobei <varname>i</"
#~ "varname> die <varname>nte</varname> Koordinate in dem "
#~ "<varname>LINESTRING</varname> ist. Falls ein <varname>POLYGON</varname> "
#~ "eingegeben wird, wird ein Pfad von <varname>{i,j}</varname> "
#~ "zurückgegeben, wobei <varname>i</varname> die Ringnummer ist (1 ist "
#~ "äußerer Ring; die inneren Ringe folgen) und <varname>j</varname> zählt "
#~ "die <varname>POINT</varname>s ab (Index beginnt mit 1)."

#~ msgid "Enhanced: 2.1.0 Faster speed. Reimplemented as native-C."
#~ msgstr ""
#~ "Erweiterung: 2.1.0 Schnellere Geschwindigkeit. In nativem C neu "
#~ "implementiert."

#~ msgid "Classic Explode a Table of LineStrings into nodes"
#~ msgstr "Eine Tabelle von LineStrings auf klassische Art in Knoten zerlegen"

#~ msgid ""
#~ "SELECT edge_id, (dp).path[1] As index, ST_AsText((dp).geom) As wktnode\n"
#~ "FROM (SELECT 1 As edge_id\n"
#~ "        , ST_DumpPoints(ST_GeomFromText('LINESTRING(1 2, 3 4, 10 10)')) "
#~ "AS dp\n"
#~ "     UNION ALL\n"
#~ "     SELECT 2 As edge_id\n"
#~ "        , ST_DumpPoints(ST_GeomFromText('LINESTRING(3 5, 5 6, 9 10)')) AS "
#~ "dp\n"
#~ "   ) As foo;\n"
#~ " edge_id | index |    wktnode\n"
#~ "---------+-------+--------------\n"
#~ "       1 |     1 | POINT(1 2)\n"
#~ "       1 |     2 | POINT(3 4)\n"
#~ "       1 |     3 | POINT(10 10)\n"
#~ "       2 |     1 | POINT(3 5)\n"
#~ "       2 |     2 | POINT(5 6)\n"
#~ "       2 |     3 | POINT(9 10)"
#~ msgstr ""
#~ "SELECT edge_id, (dp).path[1] As index, ST_AsText((dp).geom) As wktnode\n"
#~ "FROM (SELECT 1 As edge_id\n"
#~ "        , ST_DumpPoints(ST_GeomFromText('LINESTRING(1 2, 3 4, 10 10)')) "
#~ "AS dp\n"
#~ "     UNION ALL\n"
#~ "     SELECT 2 As edge_id\n"
#~ "        , ST_DumpPoints(ST_GeomFromText('LINESTRING(3 5, 5 6, 9 10)')) AS "
#~ "dp\n"
#~ "   ) As foo;\n"
#~ " edge_id | index |    wktnode\n"
#~ "---------+-------+--------------\n"
#~ "       1 |     1 | POINT(1 2)\n"
#~ "       1 |     2 | POINT(3 4)\n"
#~ "       1 |     3 | POINT(10 10)\n"
#~ "       2 |     1 | POINT(3 5)\n"
#~ "       2 |     2 | POINT(5 6)\n"
#~ "       2 |     3 | POINT(9 10)"

#~ msgid "Standard Geometry Examples"
#~ msgstr "Geometrische Standardbeispiele"

#~ msgid ""
#~ "SELECT path, ST_AsText(geom)\n"
#~ "FROM (\n"
#~ "  SELECT (ST_DumpPoints(g.geom)).*\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       'GEOMETRYCOLLECTION(\n"
#~ "          POINT ( 0 1 ),\n"
#~ "          LINESTRING ( 0 3, 3 4 ),\n"
#~ "          POLYGON (( 2 0, 2 3, 0 2, 2 0 )),\n"
#~ "          POLYGON (( 3 0, 3 3, 6 3, 6 0, 3 0 ),\n"
#~ "                   ( 5 1, 4 2, 5 2, 5 1 )),\n"
#~ "          MULTIPOLYGON (\n"
#~ "                  (( 0 5, 0 8, 4 8, 4 5, 0 5 ),\n"
#~ "                   ( 1 6, 3 6, 2 7, 1 6 )),\n"
#~ "                  (( 5 4, 5 8, 6 7, 5 4 ))\n"
#~ "          )\n"
#~ "        )'::geometry AS geom\n"
#~ "    ) AS g\n"
#~ "  ) j;\n"
#~ "\n"
#~ "   path    | st_astext\n"
#~ "-----------+------------\n"
#~ " {1,1}     | POINT(0 1)\n"
#~ " {2,1}     | POINT(0 3)\n"
#~ " {2,2}     | POINT(3 4)\n"
#~ " {3,1,1}   | POINT(2 0)\n"
#~ " {3,1,2}   | POINT(2 3)\n"
#~ " {3,1,3}   | POINT(0 2)\n"
#~ " {3,1,4}   | POINT(2 0)\n"
#~ " {4,1,1}   | POINT(3 0)\n"
#~ " {4,1,2}   | POINT(3 3)\n"
#~ " {4,1,3}   | POINT(6 3)\n"
#~ " {4,1,4}   | POINT(6 0)\n"
#~ " {4,1,5}   | POINT(3 0)\n"
#~ " {4,2,1}   | POINT(5 1)\n"
#~ " {4,2,2}   | POINT(4 2)\n"
#~ " {4,2,3}   | POINT(5 2)\n"
#~ " {4,2,4}   | POINT(5 1)\n"
#~ " {5,1,1,1} | POINT(0 5)\n"
#~ " {5,1,1,2} | POINT(0 8)\n"
#~ " {5,1,1,3} | POINT(4 8)\n"
#~ " {5,1,1,4} | POINT(4 5)\n"
#~ " {5,1,1,5} | POINT(0 5)\n"
#~ " {5,1,2,1} | POINT(1 6)\n"
#~ " {5,1,2,2} | POINT(3 6)\n"
#~ " {5,1,2,3} | POINT(2 7)\n"
#~ " {5,1,2,4} | POINT(1 6)\n"
#~ " {5,2,1,1} | POINT(5 4)\n"
#~ " {5,2,1,2} | POINT(5 8)\n"
#~ " {5,2,1,3} | POINT(6 7)\n"
#~ " {5,2,1,4} | POINT(5 4)\n"
#~ "(29 rows)"
#~ msgstr ""
#~ "SELECT path, ST_AsText(geom)\n"
#~ "FROM (\n"
#~ "  SELECT (ST_DumpPoints(g.geom)).*\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       'GEOMETRYCOLLECTION(\n"
#~ "          POINT ( 0 1 ),\n"
#~ "          LINESTRING ( 0 3, 3 4 ),\n"
#~ "          POLYGON (( 2 0, 2 3, 0 2, 2 0 )),\n"
#~ "          POLYGON (( 3 0, 3 3, 6 3, 6 0, 3 0 ),\n"
#~ "                   ( 5 1, 4 2, 5 2, 5 1 )),\n"
#~ "          MULTIPOLYGON (\n"
#~ "                  (( 0 5, 0 8, 4 8, 4 5, 0 5 ),\n"
#~ "                   ( 1 6, 3 6, 2 7, 1 6 )),\n"
#~ "                  (( 5 4, 5 8, 6 7, 5 4 ))\n"
#~ "          )\n"
#~ "        )'::geometry AS geom\n"
#~ "    ) AS g\n"
#~ "  ) j;\n"
#~ "\n"
#~ "   path    | st_astext\n"
#~ "-----------+------------\n"
#~ " {1,1}     | POINT(0 1)\n"
#~ " {2,1}     | POINT(0 3)\n"
#~ " {2,2}     | POINT(3 4)\n"
#~ " {3,1,1}   | POINT(2 0)\n"
#~ " {3,1,2}   | POINT(2 3)\n"
#~ " {3,1,3}   | POINT(0 2)\n"
#~ " {3,1,4}   | POINT(2 0)\n"
#~ " {4,1,1}   | POINT(3 0)\n"
#~ " {4,1,2}   | POINT(3 3)\n"
#~ " {4,1,3}   | POINT(6 3)\n"
#~ " {4,1,4}   | POINT(6 0)\n"
#~ " {4,1,5}   | POINT(3 0)\n"
#~ " {4,2,1}   | POINT(5 1)\n"
#~ " {4,2,2}   | POINT(4 2)\n"
#~ " {4,2,3}   | POINT(5 2)\n"
#~ " {4,2,4}   | POINT(5 1)\n"
#~ " {5,1,1,1} | POINT(0 5)\n"
#~ " {5,1,1,2} | POINT(0 8)\n"
#~ " {5,1,1,3} | POINT(4 8)\n"
#~ " {5,1,1,4} | POINT(4 5)\n"
#~ " {5,1,1,5} | POINT(0 5)\n"
#~ " {5,1,2,1} | POINT(1 6)\n"
#~ " {5,1,2,2} | POINT(3 6)\n"
#~ " {5,1,2,3} | POINT(2 7)\n"
#~ " {5,1,2,4} | POINT(1 6)\n"
#~ " {5,2,1,1} | POINT(5 4)\n"
#~ " {5,2,1,2} | POINT(5 8)\n"
#~ " {5,2,1,3} | POINT(6 7)\n"
#~ " {5,2,1,4} | POINT(5 4)\n"
#~ "(29 rows)"

#~ msgid ""
#~ "-- Polyhedral surface cube --\n"
#~ "SELECT (g.gdump).path, ST_AsEWKT((g.gdump).geom) as wkt\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       ST_DumpPoints(ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, "
#~ "0 1 1, 0 1 0, 0 0 0)),\n"
#~ "((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 "
#~ "0)),\n"
#~ "((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),\n"
#~ "((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 "
#~ "1)) )') ) AS gdump\n"
#~ "    ) AS g;\n"
#~ "-- result --\n"
#~ "  path   |     wkt\n"
#~ "---------+--------------\n"
#~ " {1,1,1} | POINT(0 0 0)\n"
#~ " {1,1,2} | POINT(0 0 1)\n"
#~ " {1,1,3} | POINT(0 1 1)\n"
#~ " {1,1,4} | POINT(0 1 0)\n"
#~ " {1,1,5} | POINT(0 0 0)\n"
#~ " {2,1,1} | POINT(0 0 0)\n"
#~ " {2,1,2} | POINT(0 1 0)\n"
#~ " {2,1,3} | POINT(1 1 0)\n"
#~ " {2,1,4} | POINT(1 0 0)\n"
#~ " {2,1,5} | POINT(0 0 0)\n"
#~ " {3,1,1} | POINT(0 0 0)\n"
#~ " {3,1,2} | POINT(1 0 0)\n"
#~ " {3,1,3} | POINT(1 0 1)\n"
#~ " {3,1,4} | POINT(0 0 1)\n"
#~ " {3,1,5} | POINT(0 0 0)\n"
#~ " {4,1,1} | POINT(1 1 0)\n"
#~ " {4,1,2} | POINT(1 1 1)\n"
#~ " {4,1,3} | POINT(1 0 1)\n"
#~ " {4,1,4} | POINT(1 0 0)\n"
#~ " {4,1,5} | POINT(1 1 0)\n"
#~ " {5,1,1} | POINT(0 1 0)\n"
#~ " {5,1,2} | POINT(0 1 1)\n"
#~ " {5,1,3} | POINT(1 1 1)\n"
#~ " {5,1,4} | POINT(1 1 0)\n"
#~ " {5,1,5} | POINT(0 1 0)\n"
#~ " {6,1,1} | POINT(0 0 1)\n"
#~ " {6,1,2} | POINT(1 0 1)\n"
#~ " {6,1,3} | POINT(1 1 1)\n"
#~ " {6,1,4} | POINT(0 1 1)\n"
#~ " {6,1,5} | POINT(0 0 1)\n"
#~ "(30 rows)"
#~ msgstr ""
#~ "-- polyedrische Würfeloberfläche --\n"
#~ "SELECT (g.gdump).path, ST_AsEWKT((g.gdump).geom) as wkt\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       ST_DumpPoints(ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, "
#~ "0 1 1, 0 1 0, 0 0 0)),\n"
#~ "((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 "
#~ "0)),\n"
#~ "((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),\n"
#~ "((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 "
#~ "1)) )') ) AS gdump\n"
#~ "    ) AS g;\n"
#~ "-- result --\n"
#~ "  path   |     wkt\n"
#~ "---------+--------------\n"
#~ " {1,1,1} | POINT(0 0 0)\n"
#~ " {1,1,2} | POINT(0 0 1)\n"
#~ " {1,1,3} | POINT(0 1 1)\n"
#~ " {1,1,4} | POINT(0 1 0)\n"
#~ " {1,1,5} | POINT(0 0 0)\n"
#~ " {2,1,1} | POINT(0 0 0)\n"
#~ " {2,1,2} | POINT(0 1 0)\n"
#~ " {2,1,3} | POINT(1 1 0)\n"
#~ " {2,1,4} | POINT(1 0 0)\n"
#~ " {2,1,5} | POINT(0 0 0)\n"
#~ " {3,1,1} | POINT(0 0 0)\n"
#~ " {3,1,2} | POINT(1 0 0)\n"
#~ " {3,1,3} | POINT(1 0 1)\n"
#~ " {3,1,4} | POINT(0 0 1)\n"
#~ " {3,1,5} | POINT(0 0 0)\n"
#~ " {4,1,1} | POINT(1 1 0)\n"
#~ " {4,1,2} | POINT(1 1 1)\n"
#~ " {4,1,3} | POINT(1 0 1)\n"
#~ " {4,1,4} | POINT(1 0 0)\n"
#~ " {4,1,5} | POINT(1 1 0)\n"
#~ " {5,1,1} | POINT(0 1 0)\n"
#~ " {5,1,2} | POINT(0 1 1)\n"
#~ " {5,1,3} | POINT(1 1 1)\n"
#~ " {5,1,4} | POINT(1 1 0)\n"
#~ " {5,1,5} | POINT(0 1 0)\n"
#~ " {6,1,1} | POINT(0 0 1)\n"
#~ " {6,1,2} | POINT(1 0 1)\n"
#~ " {6,1,3} | POINT(1 1 1)\n"
#~ " {6,1,4} | POINT(0 1 1)\n"
#~ " {6,1,5} | POINT(0 0 1)\n"
#~ "(30 rows)"

#~ msgid ""
#~ "-- Triangle --\n"
#~ "SELECT (g.gdump).path, ST_AsText((g.gdump).geom) as wkt\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       ST_DumpPoints( ST_GeomFromEWKT('TRIANGLE ((\n"
#~ "                0 0,\n"
#~ "                0 9,\n"
#~ "                9 0,\n"
#~ "                0 0\n"
#~ "            ))') ) AS gdump\n"
#~ "    ) AS g;\n"
#~ "-- result --\n"
#~ " path |    wkt\n"
#~ "------+------------\n"
#~ " {1}  | POINT(0 0)\n"
#~ " {2}  | POINT(0 9)\n"
#~ " {3}  | POINT(9 0)\n"
#~ " {4}  | POINT(0 0)"
#~ msgstr ""
#~ "-- Dreieck --\n"
#~ "SELECT (g.gdump).path, ST_AsText((g.gdump).geom) as wkt\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       ST_DumpPoints( ST_GeomFromEWKT('TRIANGLE ((\n"
#~ "                0 0,\n"
#~ "                0 9,\n"
#~ "                9 0,\n"
#~ "                0 0\n"
#~ "            ))') ) AS gdump\n"
#~ "    ) AS g;\n"
#~ "-- result --\n"
#~ " path |    wkt\n"
#~ "------+------------\n"
#~ " {1}  | POINT(0 0)\n"
#~ " {2}  | POINT(0 9)\n"
#~ " {3}  | POINT(9 0)\n"
#~ " {4}  | POINT(0 0)"

#~ msgid ""
#~ "-- TIN --\n"
#~ "SELECT (g.gdump).path, ST_AsEWKT((g.gdump).geom) as wkt\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       ST_DumpPoints( ST_GeomFromEWKT('TIN (((\n"
#~ "                0 0 0,\n"
#~ "                0 0 1,\n"
#~ "                0 1 0,\n"
#~ "                0 0 0\n"
#~ "            )), ((\n"
#~ "                0 0 0,\n"
#~ "                0 1 0,\n"
#~ "                1 1 0,\n"
#~ "                0 0 0\n"
#~ "            ))\n"
#~ "            )') ) AS gdump\n"
#~ "    ) AS g;\n"
#~ "-- result --\n"
#~ "  path   |     wkt\n"
#~ "---------+--------------\n"
#~ " {1,1,1} | POINT(0 0 0)\n"
#~ " {1,1,2} | POINT(0 0 1)\n"
#~ " {1,1,3} | POINT(0 1 0)\n"
#~ " {1,1,4} | POINT(0 0 0)\n"
#~ " {2,1,1} | POINT(0 0 0)\n"
#~ " {2,1,2} | POINT(0 1 0)\n"
#~ " {2,1,3} | POINT(1 1 0)\n"
#~ " {2,1,4} | POINT(0 0 0)\n"
#~ "(8 rows)"
#~ msgstr ""
#~ "-- TIN --\n"
#~ "SELECT (g.gdump).path, ST_AsEWKT((g.gdump).geom) as wkt\n"
#~ "  FROM\n"
#~ "    (SELECT\n"
#~ "       ST_DumpPoints( ST_GeomFromEWKT('TIN (((\n"
#~ "                0 0 0,\n"
#~ "                0 0 1,\n"
#~ "                0 1 0,\n"
#~ "                0 0 0\n"
#~ "            )), ((\n"
#~ "                0 0 0,\n"
#~ "                0 1 0,\n"
#~ "                1 1 0,\n"
#~ "                0 0 0\n"
#~ "            ))\n"
#~ "            )') ) AS gdump\n"
#~ "    ) AS g;\n"
#~ "-- result --\n"
#~ "  path   |     wkt\n"
#~ "---------+--------------\n"
#~ " {1,1,1} | POINT(0 0 0)\n"
#~ " {1,1,2} | POINT(0 0 1)\n"
#~ " {1,1,3} | POINT(0 1 0)\n"
#~ " {1,1,4} | POINT(0 0 0)\n"
#~ " {2,1,1} | POINT(0 0 0)\n"
#~ " {2,1,2} | POINT(0 1 0)\n"
#~ " {2,1,3} | POINT(1 1 0)\n"
#~ " {2,1,4} | POINT(0 0 0)\n"
#~ "(8 rows)"

#~ msgid ""
#~ ", <xref linkend=\"PostGIS_Geometry_DumpFunctions\"/>, <xref linkend="
#~ "\"ST_Dump\"/>, <xref linkend=\"ST_DumpRings\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"PostGIS_Geometry_DumpFunctions\"/>, <xref linkend="
#~ "\"ST_Dump\"/>, <xref linkend=\"ST_DumpRings\"/>"

#~ msgid "ST_DumpRings"
#~ msgstr "ST_DumpRings"

#~ msgid ""
#~ "Returns a set of <varname>geometry_dump</varname> rows, representing the "
#~ "exterior and interior rings of a polygon."
#~ msgstr ""
#~ "Gibt eine Menge an <varname>geometry_dump</varname> Zeilen zurück, welche "
#~ "die äußeren und inneren Ringe eines Polygons darstellen."

#~ msgid ""
#~ "<funcdef>geometry_dump[] <function>ST_DumpRings</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>a_polygon</parameter></"
#~ "paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry_dump[] <function>ST_DumpRings</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>a_polygon</parameter></"
#~ "paramdef>"

#~ msgid ""
#~ "This is a set-returning function (SRF). It returns a set of "
#~ "<varname>geometry_dump</varname> rows, defined as an <varname>integer[]</"
#~ "varname> and a <varname>geometry</varname>, aliased \"path\" and \"geom\" "
#~ "respectively. The \"path\" field holds the polygon ring index containing "
#~ "a single integer: 0 for the shell, >0 for holes. The \"geom\" field "
#~ "contains the corresponding ring as a polygon."
#~ msgstr ""
#~ "Dies ist eine Funktion mit Ergebnismenge (SRF). Sie gibt eine Menge an "
#~ "<varname>geometry_dump</varname> Zeilen zurück, die durch einen "
#~ "<varname>Integer[]</varname> und eine <varname>Geometrie</varname>, "
#~ "beziehungsweise durch die Aliasse \"path\" und \"geom\", definiert sind. "
#~ "Das Attribut \"path\" enthält den Index des Polygonringes als einzelne "
#~ "Ganzzahl: 0 für die Hülle, >0 für Lücken/Inseln. Das Attribut \"geom\" "
#~ "enthält den entsprechenden Ring als Polygon."

#~ msgid "Availability: PostGIS 1.1.3. Requires PostgreSQL 7.3 or higher."
#~ msgstr "Verfügbarkeit: PostGIS 1.1.3. Benötigt PostgreSQL 7.3 oder höher."

#~ msgid ""
#~ "This only works for POLYGON geometries. It will not work for MULTIPOLYGONS"
#~ msgstr ""
#~ "Dies funktioniert nur mit POLYGON Geometrien und nicht mit MULTIPOLYGONS"

#~ msgid ""
#~ "SELECT sometable.field1, sometable.field1,\n"
#~ "          (ST_DumpRings(sometable.the_geom)).geom As the_geom\n"
#~ "FROM sometableOfpolys;\n"
#~ "\n"
#~ "SELECT ST_AsEWKT(geom) As the_geom, path\n"
#~ "        FROM ST_DumpRings(\n"
#~ "                ST_GeomFromEWKT('POLYGON((-8149064 5133092 1,-8149064 "
#~ "5132986 1,-8148996 5132839 1,-8148972 5132767 1,-8148958 5132508 "
#~ "1,-8148941 5132466 1,-8148924 5132394 1,\n"
#~ "                -8148903 5132210 1,-8148930 5131967 1,-8148992 5131978 "
#~ "1,-8149237 5132093 1,-8149404 5132211 1,-8149647 5132310 1,-8149757 "
#~ "5132394 1,\n"
#~ "                -8150305 5132788 1,-8149064 5133092 1),\n"
#~ "                (-8149362 5132394 1,-8149446 5132501 1,-8149548 5132597 "
#~ "1,-8149695 5132675 1,-8149362 5132394 1))')\n"
#~ "                )  as foo;\n"
#~ " path |                                            the_geom\n"
#~ "----------------------------------------------------------------------------------------------------------------\n"
#~ "  {0} | POLYGON((-8149064 5133092 1,-8149064 5132986 1,-8148996 5132839 "
#~ "1,-8148972 5132767 1,-8148958 5132508 1,\n"
#~ "          |          -8148941 5132466 1,-8148924 5132394 1,\n"
#~ "          |          -8148903 5132210 1,-8148930 5131967 1,\n"
#~ "          |          -8148992 5131978 1,-8149237 5132093 1,\n"
#~ "          |          -8149404 5132211 1,-8149647 5132310 1,-8149757 "
#~ "5132394 1,-8150305 5132788 1,-8149064 5133092 1))\n"
#~ "  {1} | POLYGON((-8149362 5132394 1,-8149446 5132501 1,\n"
#~ "          |          -8149548 5132597 1,-8149695 5132675 1,-8149362 "
#~ "5132394 1))"
#~ msgstr ""
#~ "SELECT sometable.field1, sometable.field1,\n"
#~ "          (ST_DumpRings(sometable.the_geom)).geom As the_geom\n"
#~ "FROM sometableOfpolys;\n"
#~ "\n"
#~ "SELECT ST_AsEWKT(geom) As the_geom, path\n"
#~ "        FROM ST_DumpRings(\n"
#~ "                ST_GeomFromEWKT('POLYGON((-8149064 5133092 1,-8149064 "
#~ "5132986 1,-8148996 5132839 1,-8148972 5132767 1,-8148958 5132508 "
#~ "1,-8148941 5132466 1,-8148924 5132394 1,\n"
#~ "                -8148903 5132210 1,-8148930 5131967 1,-8148992 5131978 "
#~ "1,-8149237 5132093 1,-8149404 5132211 1,-8149647 5132310 1,-8149757 "
#~ "5132394 1,\n"
#~ "                -8150305 5132788 1,-8149064 5133092 1),\n"
#~ "                (-8149362 5132394 1,-8149446 5132501 1,-8149548 5132597 "
#~ "1,-8149695 5132675 1,-8149362 5132394 1))')\n"
#~ "                )  as foo;\n"
#~ " path |                                            the_geom\n"
#~ "----------------------------------------------------------------------------------------------------------------\n"
#~ "  {0} | POLYGON((-8149064 5133092 1,-8149064 5132986 1,-8148996 5132839 "
#~ "1,-8148972 5132767 1,-8148958 5132508 1,\n"
#~ "          |          -8148941 5132466 1,-8148924 5132394 1,\n"
#~ "          |          -8148903 5132210 1,-8148930 5131967 1,\n"
#~ "          |          -8148992 5131978 1,-8149237 5132093 1,\n"
#~ "          |          -8149404 5132211 1,-8149647 5132310 1,-8149757 "
#~ "5132394 1,-8150305 5132788 1,-8149064 5133092 1))\n"
#~ "  {1} | POLYGON((-8149362 5132394 1,-8149446 5132501 1,\n"
#~ "          |          -8149548 5132597 1,-8149695 5132675 1,-8149362 "
#~ "5132394 1))"

#~ msgid ""
#~ ", <xref linkend=\"PostGIS_Geometry_DumpFunctions\"/>, <xref linkend="
#~ "\"ST_Dump\"/>, <xref linkend=\"ST_ExteriorRing\"/>, <xref linkend="
#~ "\"ST_InteriorRingN\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"PostGIS_Geometry_DumpFunctions\"/>, <xref linkend="
#~ "\"ST_Dump\"/>, <xref linkend=\"ST_ExteriorRing\"/>, <xref linkend="
#~ "\"ST_InteriorRingN\"/>"

#~ msgid ""
#~ "<funcdef>geometry <function>ST_GeneratePoints</function></funcdef> "
#~ "<paramdef> <parameter>g</parameter> <type>geometry</type> </paramdef> "
#~ "<paramdef> <parameter>npoints</parameter> <type>numeric</type> </paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_GeneratePoints</function></funcdef> "
#~ "<paramdef> <parameter>g</parameter> <type>geometry</type> </paramdef> "
#~ "<paramdef> <parameter>npoints</parameter> <type>numeric</type> </paramdef>"

#~ msgid "&sfcgal_enhanced;"
#~ msgstr "&sfcgal_enhanced;"

#~ msgid ""
#~ "SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 2 "
#~ "0, 0 2 )'::geometry));\n"
#~ " st_astext\n"
#~ "---------------\n"
#~ "GEOMETRYCOLLECTION EMPTY\n"
#~ "(1 row)\n"
#~ "SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 0 "
#~ "0, 0 2 )'::geometry));\n"
#~ " st_astext\n"
#~ "---------------\n"
#~ "POINT(0 0)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "---Clip all lines (trails) by country (here we assume country geom are "
#~ "POLYGON or MULTIPOLYGONS)\n"
#~ "-- NOTE: we are only keeping intersections that result in a LINESTRING or "
#~ "MULTILINESTRING because we don't\n"
#~ "-- care about trails that just share a point\n"
#~ "-- the dump is needed to expand a geometry collection into individual "
#~ "single MULT* parts\n"
#~ "-- the below is fairly generic and will work for polys, etc. by just "
#~ "changing the where clause\n"
#~ "SELECT clipped.gid, clipped.f_name, clipped_geom\n"
#~ "FROM (SELECT trails.gid, trails.f_name, (ST_Dump(ST_Intersection(country."
#~ "the_geom, trails.the_geom))).geom As clipped_geom\n"
#~ "FROM country\n"
#~ "        INNER JOIN trails\n"
#~ "        ON ST_Intersects(country.the_geom, trails.the_geom))  As clipped\n"
#~ "        WHERE ST_Dimension(clipped.clipped_geom) = 1 ;\n"
#~ "\n"
#~ "--For polys e.g. polygon landmarks, you can also use the sometimes faster "
#~ "hack that buffering anything by 0.0\n"
#~ "-- except a polygon results in an empty geometry collection\n"
#~ "--(so a geometry collection containing polys, lines and points)\n"
#~ "-- buffered by 0.0 would only leave the polygons and dissolve the "
#~ "collection shell\n"
#~ "SELECT poly.gid,  ST_Multi(ST_Buffer(\n"
#~ "                                ST_Intersection(country.the_geom, poly."
#~ "the_geom),\n"
#~ "                                0.0)\n"
#~ "                                ) As clipped_geom\n"
#~ "FROM country\n"
#~ "        INNER JOIN poly\n"
#~ "        ON ST_Intersects(country.the_geom, poly.the_geom)\n"
#~ "        WHERE Not ST_IsEmpty(ST_Buffer(ST_Intersection(country.the_geom, "
#~ "poly.the_geom),0.0));"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 2 "
#~ "0, 0 2 )'::geometry));\n"
#~ " st_astext\n"
#~ "---------------\n"
#~ "GEOMETRYCOLLECTION EMPTY\n"
#~ "(1 row)\n"
#~ "SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 0 "
#~ "0, 0 2 )'::geometry));\n"
#~ " st_astext\n"
#~ "---------------\n"
#~ "POINT(0 0)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "---Schneidet alle Linien (Wege) nach dem Staat aus (wir nehmen an, dass "
#~ "es sich bei der Geometrie um Polygone oder MultiPolygone handelt)\n"
#~ "-- Anmerkung: wir behalten nur jene Verschneidungen, die zu einem "
#~ "LineString oder MultiLinestring führen, da wir uns nicht\n"
#~ "-- um jene Wege kümmern, die nur einen Punkt teilen\n"
#~ "-- ST_Dump wird benötigt um eine Sammelgeometrie/GeometryCollection in "
#~ "individuelle einzelne MULTI* Teile zu zerlegen\n"
#~ "-- der untere Code ist sehr generisch und funktioniert auch mit Polygonen "
#~ "etc. indem man die Where-Klausel ändert\n"
#~ "SELECT clipped.gid, clipped.f_name, clipped_geom\n"
#~ "FROM (SELECT trails.gid, trails.f_name, (ST_Dump(ST_Intersection(country."
#~ "the_geom, trails.the_geom))).geom As clipped_geom\n"
#~ "FROM country\n"
#~ "        INNER JOIN trails\n"
#~ "        ON ST_Intersects(country.the_geom, trails.the_geom))  As clipped\n"
#~ "        WHERE ST_Dimension(clipped.clipped_geom) = 1 ;\n"
#~ "\n"
#~ "--Bei Polygonen, z.B. polygonale Landgrenzen, können Sie auch den "
#~ "manchmal schnelleren Hack verwenden, indem Sie alles mit 0.0 puffern\n"
#~ "-- außer ein Polygon führt zu einer leeren Sammelgeometrie/"
#~ "GeometryCollection\n"
#~ "--(wie bei einer Sammelgeometrie, die Polygone, Linien und Punkte "
#~ "enthält)\n"
#~ "-- mit 0.0 gepuffert hinterlässt nur die Polygone und löst die Hülle der "
#~ "Sammelgeometrie auf\n"
#~ "SELECT poly.gid,  ST_Multi(ST_Buffer(\n"
#~ "                                ST_Intersection(country.the_geom, poly."
#~ "the_geom),\n"
#~ "                                0.0)\n"
#~ "                                ) As clipped_geom\n"
#~ "FROM country\n"
#~ "        INNER JOIN poly\n"
#~ "        ON ST_Intersects(country.the_geom, poly.the_geom)\n"
#~ "        WHERE Not ST_IsEmpty(ST_Buffer(ST_Intersection(country.the_geom, "
#~ "poly.the_geom),0.0));"

#~ msgid ""
#~ "If your PostGIS is compiled with sfcgal support, have option of using "
#~ "sfcgal, but note if basically cases down both geometries to 2D before "
#~ "doing intersection and returns the ST_Force2D equivalent result which is "
#~ "a 2D geometry"
#~ msgstr ""
#~ "Wenn PostGIS mit SFCGAL Unterstützung kompiliert wurde, haben Sie die "
#~ "Möglichkeit sfcgal zu verwenden. Beachten Sie aber bitte, dass hierbei "
#~ "beide Geometrien grundsätzlich auf 2D reduziert werden, bevor die "
#~ "Verschneidung ausgeführt wird und das ein Ergebnis äquivalent zu "
#~ "ST_Force2D zurückggegeben wird, welches eine 2D-Geometrie ist."

#~ msgid ""
#~ "set postgis.backend=sfcgal;\n"
#~ "select ST_AsText(ST_Intersection(linestring, polygon)) As wkt\n"
#~ "from  ST_GeomFromText('LINESTRING Z (2 2 6,1.5 1.5 7,1 1 8,0.5 0.5 8,0 0 "
#~ "10)') AS linestring\n"
#~ " CROSS JOIN ST_GeomFromText('POLYGON((0 0 8, 0 1 8, 1 1 8, 1 0 8, 0 0 "
#~ "8))') AS polygon;\n"
#~ "\n"
#~ "                     wkt\n"
#~ "----------------------------------------------\n"
#~ " MULTILINESTRING((0.5 0.5,0 0),(1 1,0.5 0.5))"
#~ msgstr ""
#~ "set postgis.backend=sfcgal;\n"
#~ "select ST_AsText(ST_Intersection(linestring, polygon)) As wkt\n"
#~ "from  ST_GeomFromText('LINESTRING Z (2 2 6,1.5 1.5 7,1 1 8,0.5 0.5 8,0 0 "
#~ "10)') AS linestring\n"
#~ " CROSS JOIN ST_GeomFromText('POLYGON((0 0 8, 0 1 8, 1 1 8, 1 0 8, 0 0 "
#~ "8))') AS polygon;\n"
#~ "\n"
#~ "                     wkt\n"
#~ "----------------------------------------------\n"
#~ " MULTILINESTRING((0.5 0.5,0 0),(1 1,0.5 0.5))"

#~ msgid "Availability: 2.0.0, requires GEOS-3.3.0"
#~ msgstr "Verfügbarkeit: 2.0.0 benötigt GEOS-3.3.0"

#~ msgid "Availability: 1.4.0 - requires GEOS"
#~ msgstr "Verfügbarkeit: 1.4.0 - benötigt GEOS"

#~ msgid "Availability: 1.0.0RC1 - requires GEOS &gt;= 2.1.0."
#~ msgstr "Verfügbarkeit: 1.0 - benötigt GEOS &gt;= 2.1.0."

#~ msgid "Availability: 2.0.0 - requires GEOS &gt;= 3.3.0."
#~ msgstr "Verfügbarkeit: 2.0.0 - benötigt GEOS &gt;= 3.3.0."

#~ msgid ""
#~ "Due to a bug in GEOS up to 3.3.1 this function fails to node self-"
#~ "intersecting lines. This is fixed with GEOS 3.3.2 or higher."
#~ msgstr ""
#~ "Aufgrund eines Fehlers in GEOS &lt; 3.3.1 versagt diese Funktion bei der "
#~ "Knotenberechnung von selbstüberschneidenden Linien. Dies wurde mit GEOS "
#~ "3.3.2 und höher behoben."

#~ msgid ""
#~ "Availability: 2.0 - requires GEOS &gt;= 3.2, improved with GEOS &gt;= 3.3"
#~ msgstr ""
#~ "Verfügbarkeit: 2.0 - benötigt GEOS &gt;= 3.2, verbessert mi GEOS &gt;= 3.3"

#~ msgid "The inputs can only be LINESTRINGS."
#~ msgstr "Als Eingabe gelten nur Linienzüge."

#~ msgid "Availability: 2.0.0 requires GEOS &gt;= 3.3.0."
#~ msgstr "Verfügbarkeit: 2.0.0 benötigt GEOS &gt;= 3.3.0."

#~ msgid "Requires GEOS 3.0.0+"
#~ msgstr "Benötigt GEOS 3.0.0+"

#~ msgid ""
#~ "Turns a single geometry into a set in which each element has fewer than "
#~ "the maximum allowed number of vertices. Useful for converting excessively "
#~ "large polygons and other objects into small portions that fit within the "
#~ "database page size. Uses the same envelope clipping as ST_ClipByBox2D "
#~ "does, recursively subdividing the input geometry until all portions have "
#~ "less than the maximum vertex count. Minimum vertice count allowed is 8 "
#~ "and if you try to specify lower than 8, it will throw an error."
#~ msgstr ""
#~ "Wandelt eine Einzelgeometrie in eine Menge um, bei der jedes Element "
#~ "weniger als die maximal erlaubte Anzahl an Knoten hat. Nützlich für die "
#~ "Konvertierung von übermäßig großen Polygonen und anderen Geoobjekten in "
#~ "kleine Teile, die dann in die Speicherseite der Datenbank passen. "
#~ "Verwendet dieselbe Methode beim Zerschneiden wie ST_ClipByBox2D, indem "
#~ "die Eingabegeometrie solange rekursiv zerteilt wird bis alle Teile "
#~ "weniger als die maximal erlaubte Knotenanzahl aufweisen. Die kleinste "
#~ "erlaubte Knotenanzahl ist 8; wenn Sie weniger als 8 angeben wird eine "
#~ "Fehlermeldung angezeigt."

#~ msgid "Clipping performed by the GEOS module."
#~ msgstr "Das Auftrennen wird durch das GEOS Modul ausgeführt."

#~ msgid "Availability: 2.2.0 requires GEOS &gt;= 3.5.0."
#~ msgstr "Verfügbarkeit: 2.2.0 benötigt GEOS &gt;= 3.5.0."

#~ msgid ""
#~ "rn |                          wkt\n"
#~ "---"
#~ "+---------------------------------------------------------------------------\n"
#~ " 1 | POLYGON((22 64,29.3913043478263 98.000000000001,106.000000000001 "
#~ "98.00000000001,\n"
#~ "        106.000000000001 27.5882352941173,85 35,68 29,66 28,49 42,32 "
#~ "56,22 64))\n"
#~ " 2 | POLYGON((29.3913043478263 98.000000000001,32 110,40 119,36 150,57 "
#~ "158,\n"
#~ "        75 11,92 182,106.000000000001 183.272727272727,106.000000000001 "
#~ "98.000000000001,\n"
#~ "        29.913043478263 98.000000000001))\n"
#~ " 3 | POLYGON((106.000000000001 27.5882352941173,106.000000000001 "
#~ "98.00000000000,\n"
#~ " 189.52380952381 98.000000000001,185 79,186 56,186 52,178 34,168 18,147 "
#~ "13,\n"
#~ " 132 0,119 23,106.000000000001 27.5882352941173))\n"
#~ " 4 | POLYGON((106.000000000001 98.000000000001,106.000000000001 "
#~ "183.27272727272,\n"
#~ "    114 184,132 186,146 178,176 184,179 162,184 141,190 122,190 "
#~ "100,189.5238095238\n"
#~ " 98.000000000001,106.000000000001 98.000000000001))"
#~ msgstr ""
#~ "rn |                          wkt\n"
#~ "---"
#~ "+---------------------------------------------------------------------------\n"
#~ " 1 | POLYGON((22 64,29.3913043478263 98.000000000001,106.000000000001 "
#~ "98.00000000001,\n"
#~ "        106.000000000001 27.5882352941173,85 35,68 29,66 28,49 42,32 "
#~ "56,22 64))\n"
#~ " 2 | POLYGON((29.3913043478263 98.000000000001,32 110,40 119,36 150,57 "
#~ "158,\n"
#~ "        75 11,92 182,106.000000000001 183.272727272727,106.000000000001 "
#~ "98.000000000001,\n"
#~ "        29.913043478263 98.000000000001))\n"
#~ " 3 | POLYGON((106.000000000001 27.5882352941173,106.000000000001 "
#~ "98.00000000000,\n"
#~ " 189.52380952381 98.000000000001,185 79,186 56,186 52,178 34,168 18,147 "
#~ "13,\n"
#~ " 132 0,119 23,106.000000000001 27.5882352941173))\n"
#~ " 4 | POLYGON((106.000000000001 98.000000000001,106.000000000001 "
#~ "183.27272727272,\n"
#~ "    114 184,132 186,146 178,176 184,179 162,184 141,190 122,190 "
#~ "100,189.5238095238\n"
#~ " 98.000000000001,106.000000000001 98.000000000001))"

#~ msgid ""
#~ "LINESTRING(0 0,7.07106781186547 7.07106781186547,14.1421356237309 "
#~ "14.1421356237309,21.2132034355964 21.2132034355964,28.2842712474619 "
#~ "28.2842712474619,35.3553390593274 35.3553390593274,37.499999999998 "
#~ "37.499999999998)\n"
#~ "LINESTRING(37.499999999998 37.499999999998,42.4264068711929 "
#~ "42.4264068711929,49.4974746830583 49.4974746830583,56.5685424949238 "
#~ "56.5685424949238,63.6396103067893 63.6396103067893,70.7106781186548 "
#~ "70.7106781186548,74.999999999998 74.999999999998)\n"
#~ "LINESTRING(74.999999999998 74.999999999998,77.7817459305202 "
#~ "77.7817459305202,84.8528137423857 84.8528137423857,91.9238815542512 "
#~ "91.9238815542512,98.9949493661167 98.9949493661167,100 "
#~ "100,107.071067811865 107.071067811865,112.499999999998 112.499999999998)\n"
#~ "LINESTRING(112.499999999998 112.499999999998,114.142135623731 "
#~ "114.142135623731,121.213203435596 121.213203435596,128.284271247462 "
#~ "128.284271247462,135.355339059327 135.355339059327,142.426406871193 "
#~ "142.426406871193,149.497474683058 149.497474683058,149.999999999998 "
#~ "149.999999999998)"
#~ msgstr ""
#~ "LINESTRING(0 0,7.07106781186547 7.07106781186547,14.1421356237309 "
#~ "14.1421356237309,21.2132034355964 21.2132034355964,28.2842712474619 "
#~ "28.2842712474619,35.3553390593274 35.3553390593274,37.499999999998 "
#~ "37.499999999998)\n"
#~ "LINESTRING(37.499999999998 37.499999999998,42.4264068711929 "
#~ "42.4264068711929,49.4974746830583 49.4974746830583,56.5685424949238 "
#~ "56.5685424949238,63.6396103067893 63.6396103067893,70.7106781186548 "
#~ "70.7106781186548,74.999999999998 74.999999999998)\n"
#~ "LINESTRING(74.999999999998 74.999999999998,77.7817459305202 "
#~ "77.7817459305202,84.8528137423857 84.8528137423857,91.9238815542512 "
#~ "91.9238815542512,98.9949493661167 98.9949493661167,100 "
#~ "100,107.071067811865 107.071067811865,112.499999999998 112.499999999998)\n"
#~ "LINESTRING(112.499999999998 112.499999999998,114.142135623731 "
#~ "114.142135623731,121.213203435596 121.213203435596,128.284271247462 "
#~ "128.284271247462,135.355339059327 135.355339059327,142.426406871193 "
#~ "142.426406871193,149.497474683058 149.497474683058,149.999999999998 "
#~ "149.999999999998)"

#~ msgid "ST_SwapOrdinates"
#~ msgstr "ST_SwapOrdinates"

#~ msgid ""
#~ "Returns a version of the given geometry with given ordinate values "
#~ "swapped."
#~ msgstr ""
#~ "Gibt eine Version der Ausgangsgeometrie zurück, in der die angegebenen "
#~ "Ordinatenwerte ausgetauscht werden."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_SwapOrdinates</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef><type>cstring</type> <parameter>ords</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_SwapOrdinates</function></funcdef> "
#~ "<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef> "
#~ "<paramdef><type>cstring</type> <parameter>ords</parameter></paramdef>"

#~ msgid ""
#~ "Returns a version of the given geometry with given ordinates swapped."
#~ msgstr ""
#~ "Gibt eine Version der Ausgangsgeometrie zurück, in der die angegebenen "
#~ "Ordinaten ausgetauscht werden."

#~ msgid ""
#~ "The <varname>ords</varname> parameter is a 2-characters string naming the "
#~ "ordinates to swap. Valid names are: x,y,z and m."
#~ msgstr ""
#~ "Der <varname>ords</varname> Parameter ist eine Zeichenkette aus 2 "
#~ "Zeichen, welche die Ordinate benennt die getauscht werden soll. Gültige "
#~ "Bezeichnungen sind: x,y,z und m."

#~ msgid ""
#~ "<![CDATA[\n"
#~ "-- Scale M value by 2\n"
#~ "SELECT ST_AsText(\n"
#~ "  ST_SwapOrdinates(\n"
#~ "    ST_Scale(\n"
#~ "      ST_SwapOrdinates(g,'xm'),\n"
#~ "      2, 1\n"
#~ "    ),\n"
#~ "  'xm')\n"
#~ ") FROM ( SELECT 'POINT ZM (0 0 0 2)'::geometry g ) foo;\n"
#~ "     st_astext\n"
#~ "--------------------\n"
#~ " POINT ZM (0 0 0 4)\n"
#~ "                 ]]>"
#~ msgstr ""
#~ "<![CDATA[\n"
#~ "-- Scale M value by 2\n"
#~ "SELECT ST_AsText(\n"
#~ "  ST_SwapOrdinates(\n"
#~ "    ST_Scale(\n"
#~ "      ST_SwapOrdinates(g,'xm'),\n"
#~ "      2, 1\n"
#~ "    ),\n"
#~ "  'xm')\n"
#~ ") FROM ( SELECT 'POINT ZM (0 0 0 2)'::geometry g ) foo;\n"
#~ "     st_astext\n"
#~ "--------------------\n"
#~ " POINT ZM (0 0 0 4)\n"
#~ "                 ]]>"

#~ msgid ""
#~ "SELECT ST_AsText(ST_Union(ST_GeomFromText('POINT(1 2)'),\n"
#~ "        ST_GeomFromText('POINT(-2 3)') ) )\n"
#~ "\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "MULTIPOINT(-2 3,1 2)\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_Union(ST_GeomFromText('POINT(1 2)'),\n"
#~ "                ST_GeomFromText('POINT(1 2)') ) );\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "POINT(1 2)\n"
#~ "\n"
#~ "--3d example - sort of supports 3d (and with mixed dimensions!)\n"
#~ "SELECT ST_AsEWKT(st_union(the_geom))\n"
#~ "FROM\n"
#~ "(SELECT ST_GeomFromEWKT('POLYGON((-7 4.2,-7.1 4.2,-7.1 4.3,\n"
#~ "-7 4.2))') as the_geom\n"
#~ "UNION ALL\n"
#~ "SELECT ST_GeomFromEWKT('POINT(5 5 5)') as the_geom\n"
#~ "UNION ALL\n"
#~ "        SELECT ST_GeomFromEWKT('POINT(-2 3 1)') as the_geom\n"
#~ "UNION ALL\n"
#~ "SELECT ST_GeomFromEWKT('LINESTRING(5 5 5, 10 10 10)') as the_geom ) as "
#~ "foo;\n"
#~ "\n"
#~ "st_asewkt\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 "
#~ "4.2 5,-7.1 4.2 5,-7.1 4.3 5,-7 4.2 5)));\n"
#~ "\n"
#~ "--3d example not mixing dimensions\n"
#~ "SELECT ST_AsEWKT(st_union(the_geom))\n"
#~ "FROM\n"
#~ "(SELECT ST_GeomFromEWKT('POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2,\n"
#~ "-7 4.2 2))') as the_geom\n"
#~ "UNION ALL\n"
#~ "SELECT ST_GeomFromEWKT('POINT(5 5 5)') as the_geom\n"
#~ "UNION ALL\n"
#~ "        SELECT ST_GeomFromEWKT('POINT(-2 3 1)') as the_geom\n"
#~ "UNION ALL\n"
#~ "SELECT ST_GeomFromEWKT('LINESTRING(5 5 5, 10 10 10)') as the_geom ) as "
#~ "foo;\n"
#~ "\n"
#~ "st_asewkt\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 "
#~ "4.2 2,-7.1 4.2 3,-7.1 4.3 2,-7 4.2 2)))\n"
#~ "\n"
#~ "--Examples using new Array construct\n"
#~ "SELECT ST_Union(ARRAY(SELECT the_geom FROM sometable));\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_Union(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 4)'),\n"
#~ "                        ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As "
#~ "wktunion;\n"
#~ "\n"
#~ "--wktunion---\n"
#~ "MULTILINESTRING((3 4,4 5),(1 2,3 4))"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_Union(ST_GeomFromText('POINT(1 2)'),\n"
#~ "        ST_GeomFromText('POINT(-2 3)') ) )\n"
#~ "\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "MULTIPOINT(-2 3,1 2)\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_Union(ST_GeomFromText('POINT(1 2)'),\n"
#~ "                ST_GeomFromText('POINT(1 2)') ) );\n"
#~ "st_astext\n"
#~ "----------\n"
#~ "POINT(1 2)\n"
#~ "\n"
#~ "--3D-Beispiel - Eine Art 3D-Unterstützung (mit gemischten Dimensionen!)\n"
#~ "SELECT ST_AsEWKT(st_union(the_geom))\n"
#~ "FROM\n"
#~ "(SELECT ST_GeomFromEWKT('POLYGON((-7 4.2,-7.1 4.2,-7.1 4.3,\n"
#~ "-7 4.2))') as the_geom\n"
#~ "UNION ALL\n"
#~ "SELECT ST_GeomFromEWKT('POINT(5 5 5)') as the_geom\n"
#~ "UNION ALL\n"
#~ "        SELECT ST_GeomFromEWKT('POINT(-2 3 1)') as the_geom\n"
#~ "UNION ALL\n"
#~ "SELECT ST_GeomFromEWKT('LINESTRING(5 5 5, 10 10 10)') as the_geom ) as "
#~ "foo;\n"
#~ "\n"
#~ "st_asewkt\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 "
#~ "4.2 5,-7.1 4.2 5,-7.1 4.3 5,-7 4.2 5)));\n"
#~ "\n"
#~ "--3D-Beispiel ohne gemischte Dimensionen\n"
#~ "SELECT ST_AsEWKT(st_union(the_geom))\n"
#~ "FROM\n"
#~ "(SELECT ST_GeomFromEWKT('POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2,\n"
#~ "-7 4.2 2))') as the_geom\n"
#~ "UNION ALL\n"
#~ "SELECT ST_GeomFromEWKT('POINT(5 5 5)') as the_geom\n"
#~ "UNION ALL\n"
#~ "        SELECT ST_GeomFromEWKT('POINT(-2 3 1)') as the_geom\n"
#~ "UNION ALL\n"
#~ "SELECT ST_GeomFromEWKT('LINESTRING(5 5 5, 10 10 10)') as the_geom ) as "
#~ "foo;\n"
#~ "\n"
#~ "st_asewkt\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 "
#~ "4.2 2,-7.1 4.2 3,-7.1 4.3 2,-7 4.2 2)))\n"
#~ "\n"
#~ "--Beispiele mit dem neuen Feld/Array Konstrukt\n"
#~ "SELECT ST_Union(ARRAY(SELECT the_geom FROM sometable));\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_Union(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 4)'),\n"
#~ "                        ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As "
#~ "wktunion;\n"
#~ "\n"
#~ "--wktunion---\n"
#~ "MULTILINESTRING((3 4,4 5),(1 2,3 4))"

#~ msgid "Availability: 2.3.0 - requires GEOS &gt;= 3.5.0."
#~ msgstr "Verfügbarkeit: 2.3.0 - benötigt GEOS &gt;= 3.5.0."
