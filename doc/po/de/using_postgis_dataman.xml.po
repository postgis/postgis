# SOME DESCRIPTIVE TITLE.
# 
# Translators:
# Andreas Schild <andreas.schild@bfw.gv.at>, 2017
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2017-09-13 02:45+0000\n"
"PO-Revision-Date: 2017-09-13 08:22+0000\n"
"Last-Translator: Andreas Schild <andreas.schild@bfw.gv.at>\n"
"Language-Team: German (http://www.transifex.com/postgis/postgis/language/de/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: de\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. Tag: title
#: using_postgis_dataman.xml:3
#, no-c-format
msgid "Using PostGIS: Data Management and Queries"
msgstr "PostGIS Anwendung: Datenmanagement und Abfragen"

#. Tag: title
#: using_postgis_dataman.xml:6
#, no-c-format
msgid "GIS Objects"
msgstr "GIS Objekte"

#. Tag: para
#: using_postgis_dataman.xml:8
#, no-c-format
msgid ""
"The GIS objects supported by PostGIS are a superset of the \"Simple "
"Features\" defined by the OpenGIS Consortium (OGC). As of version 0.9, "
"PostGIS supports all the objects and functions specified in the OGC \"Simple"
" Features for SQL\" specification."
msgstr "Die GIS Objekte, die von PostGIS unterstützt werden, sind eine Obermenge der durch das OpenGIS Consortium (OGC) festgelegten \"Simple Features\". Ab der Version 0.9 unterstützt PostGIS sämtliche Objekte und Funktionen, die in der OGC \"Simple Features for SQL\" Spezifikation normiert sind."

#. Tag: para
#: using_postgis_dataman.xml:13
#, no-c-format
msgid ""
"PostGIS extends the standard with support for 3DZ,3DM and 4D coordinates."
msgstr "PostGIS hat den Standard um die Unterstützung für 3DZ-, 3DM -und 4D-Koordinaten erweitert."

#. Tag: title
#: using_postgis_dataman.xml:17
#, no-c-format
msgid "OpenGIS WKB and WKT"
msgstr "OpenGIS WKB und WKT"

#. Tag: para
#: using_postgis_dataman.xml:19
#, no-c-format
msgid ""
"The OpenGIS specification defines two standard ways of expressing spatial "
"objects: the Well-Known Text (WKT) form and the Well-Known Binary (WKB) "
"form. Both WKT and WKB include information about the type of the object and "
"the coordinates which form the object."
msgstr "Die OpenGIS Spezifikation standardisiert zwei Möglichkeiten um Geoobjekte darzustellen: die Well-known-Text (WKT) und die Well-Known-Binary (WKB) Darstellung. Sowohl WKT als auch WKB enthalten Information über den Objekttyp und die Koordinaten, die das Objekt bilden."

#. Tag: para
#: using_postgis_dataman.xml:24
#, no-c-format
msgid ""
"Examples of the text representations (WKT) of the spatial objects of the "
"features are as follows:"
msgstr "Beispiele für die Textdarstellung (WKT) von Geoobjekten:"

#. Tag: para
#: using_postgis_dataman.xml:29
#, no-c-format
msgid "POINT(0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:33
#, no-c-format
msgid "LINESTRING(0 0,1 1,1 2)"
msgstr "LINESTRING(0 0,1 1,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:37
#, no-c-format
msgid "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"
msgstr "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"

#. Tag: para
#: using_postgis_dataman.xml:41
#, no-c-format
msgid "MULTIPOINT((0 0),(1 2))"
msgstr "MULTIPOINT((0 0),(1 2))"

#. Tag: para
#: using_postgis_dataman.xml:45
#, no-c-format
msgid "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"
msgstr "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"

#. Tag: para
#: using_postgis_dataman.xml:49
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2"
" -2,-2 -1,-1 -1)))"
msgstr "MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))"

#. Tag: para
#: using_postgis_dataman.xml:54
#, no-c-format
msgid "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"
msgstr "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"

#. Tag: para
#: using_postgis_dataman.xml:58
#, no-c-format
msgid ""
"The OpenGIS specification also requires that the internal storage format of "
"spatial objects include a spatial referencing system identifier (SRID). The "
"SRID is required when creating spatial objects for insertion into the "
"database."
msgstr "Die OpenGIS Spezifikation verlangt auch, dass das der Identifikator des Koordinatenreferenzsystem (SRID) im internen Format der Geoobjekte mit abgespeichert ist."

#. Tag: para
#: using_postgis_dataman.xml:63 using_postgis_dataman.xml:151
#, no-c-format
msgid ""
"Input/Output of these formats are available using the following interfaces:"
msgstr "Für die Ein- und Ausgabe dieser Formate stehen die folgenden Schnittstellen zur Verfügung"

#. Tag: programlisting
#: using_postgis_dataman.xml:66
#, no-c-format
msgid ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"
msgstr "bytea WKB = ST_AsBinary(geometry);\ntext WKT = ST_AsText(geometry);\ngeometry = ST_GeomFromWKB(bytea WKB, SRID);\ngeometry = ST_GeometryFromText(text WKT, SRID);"

#. Tag: para
#: using_postgis_dataman.xml:68
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert an OGC spatial "
"object would be:"
msgstr "Eine gültige Einfügeanweisung, um ein räumliches OGC-Objekt zu erzeugen und einzufügen, wäre:"

#. Tag: programlisting
#: using_postgis_dataman.xml:71
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"
msgstr "INSERT INTO geotable ( the_geom, the_name )\n  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"

#. Tag: title
#: using_postgis_dataman.xml:75
#, no-c-format
msgid "PostGIS EWKB, EWKT and Canonical Forms"
msgstr "PostGIS EWKB, EWKT und Normalformen/kanonische Formen"

#. Tag: para
#: using_postgis_dataman.xml:77
#, no-c-format
msgid ""
"OGC formats only support 2d geometries, and the associated SRID is *never* "
"embedded in the input/output representations."
msgstr "Das OGC Format unterstützt nur 2D-Geometrien, und die dazugehörige SRID ist *niemals* in den Eingabe/Ausgabe-Darstellungen eingebettet."

#. Tag: para
#: using_postgis_dataman.xml:80
#, no-c-format
msgid ""
"PostGIS extended formats are currently superset of OGC one (every valid "
"WKB/WKT is a valid EWKB/EWKT) but this might vary in the future, "
"specifically if OGC comes out with a new format conflicting with our "
"extensions. Thus you SHOULD NOT rely on this feature!"
msgstr "Zur Zeit sind die erweiterten Formate von PostGIS eine Obermenge von den OGC-Formaten (jeder gültige WKT/WKB ist auch ein gültiger EWKT/EWKB). Dies kann sich in der Zukunft allerdings ändern, insbesondere dann, wenn OGC ein neues Format einführt, welches mit diesen Erweiterungen im Widerspruch steht. Daher sollten SIE sich BITTE NICHT auf diese Eigenschaft verlassen!"

#. Tag: para
#: using_postgis_dataman.xml:85
#, no-c-format
msgid ""
"PostGIS EWKB/EWKT add 3dm,3dz,4d coordinates support and embedded SRID "
"information."
msgstr "PostGIS EWKB/EWKT fügt die Unterstützung von 3DM-,3DZ-,4D-Koordinaten mit eingebetteter SRID Information hinzu."

#. Tag: para
#: using_postgis_dataman.xml:88
#, no-c-format
msgid ""
"Examples of the text representations (EWKT) of the extended spatial objects "
"of the features are as follows."
msgstr "Beispiele für die Textdarstellung (EWKT) von erweiterten Geoobjekten:"

#. Tag: para
#: using_postgis_dataman.xml:93
#, no-c-format
msgid "POINT(0 0 0) -- XYZ"
msgstr "POINT(0 0 0) -- XYZ"

#. Tag: para
#: using_postgis_dataman.xml:97
#, no-c-format
msgid "SRID=32632;POINT(0 0) -- XY with SRID"
msgstr "SRID=32632;POINT(0 0) -- XY mit SRID"

#. Tag: para
#: using_postgis_dataman.xml:101
#, no-c-format
msgid "POINTM(0 0 0) -- XYM"
msgstr "POINTM(0 0 0) -- XYM"

#. Tag: para
#: using_postgis_dataman.xml:105
#, no-c-format
msgid "POINT(0 0 0 0) -- XYZM"
msgstr "POINT(0 0 0 0) -- XYZM"

#. Tag: para
#: using_postgis_dataman.xml:109
#, no-c-format
msgid "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"
msgstr "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM mit SRID"

#. Tag: para
#: using_postgis_dataman.xml:113
#, no-c-format
msgid "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"
msgstr "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"

#. Tag: para
#: using_postgis_dataman.xml:118
#, no-c-format
msgid ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"
msgstr "POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"

#. Tag: para
#: using_postgis_dataman.xml:123
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"
msgstr "MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"

#. Tag: para
#: using_postgis_dataman.xml:128
#, no-c-format
msgid "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"
msgstr "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"

#. Tag: para
#: using_postgis_dataman.xml:132
#, no-c-format
msgid "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"
msgstr "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"

#. Tag: para
#: using_postgis_dataman.xml:136
#, no-c-format
msgid ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"
msgstr "POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )"

#. Tag: para
#: using_postgis_dataman.xml:142
#, no-c-format
msgid "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"
msgstr "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"

#. Tag: para
#: using_postgis_dataman.xml:146
#, no-c-format
msgid "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"
msgstr "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"

#. Tag: programlisting
#: using_postgis_dataman.xml:154
#, no-c-format
msgid ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"
msgstr "bytea EWKB = ST_AsEWKB(geometry);\ntext EWKT = ST_AsEWKT(geometry);\ngeometry = ST_GeomFromEWKB(bytea EWKB);\ngeometry = ST_GeomFromEWKT(text EWKT);"

#. Tag: para
#: using_postgis_dataman.xml:156
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert a PostGIS spatial"
" object would be:"
msgstr "Zum Beispiel würde eine gültige Eingabeanweisung, um räumliche PostGIS Objekte zu erzeugen und einzufügen, wie folgt lauten:"

#. Tag: programlisting
#: using_postgis_dataman.xml:159
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"
msgstr "INSERT INTO geotable ( the_geom, the_name )\n  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"

#. Tag: para
#: using_postgis_dataman.xml:161
#, no-c-format
msgid ""
"The \"canonical forms\" of a PostgreSQL type are the representations you get"
" with a simple query (without any function call) and the one which is "
"guaranteed to be accepted with a simple insert, update or copy. For the "
"postgis 'geometry' type these are:"
msgstr "Die \"kanonische Form\" eines PostgreSQL Datentyps ist jene Darstellung die man mit einer einfachen Abfrage (ohne Funktionsaufruf) erhält und bei der sichergestellt ist, dass sie von einem einfachen INSERT, UPDATE oder COPY angenommen wird. Beim geometrischen Datentyp von PostGIS sind dies:"

#. Tag: programlisting
#: using_postgis_dataman.xml:164
#, no-c-format
msgid ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"
msgstr "- Ausgabe\n  - binary: EWKB\n        ascii: HEXEWKB (EWKB in hex form)\n- Eingabe\n  - binary: EWKB\n        ascii: HEXEWKB|EWKT"

#. Tag: para
#: using_postgis_dataman.xml:166
#, no-c-format
msgid ""
"For example this statement reads EWKT and returns HEXEWKB in the process of "
"canonical ascii input/output:"
msgstr "Zum Beispiel liest die folgende Anweisung EWKT ein und gibt HEXEWKB in Normalform aus:"

#. Tag: programlisting
#: using_postgis_dataman.xml:169
#, no-c-format
msgid ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"
msgstr "=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n\ngeometry\n----------------------------------------------------\n01010000200400000000000000000000000000000000000000\n(1 row)"

#. Tag: title
#: using_postgis_dataman.xml:172
#, no-c-format
msgid "SQL-MM Part 3"
msgstr "SQL-MM Part 3"

#. Tag: para
#: using_postgis_dataman.xml:174
#, no-c-format
msgid ""
"The SQL Multimedia Applications Spatial specification extends the simple "
"features for SQL spec by defining a number of circularly interpolated "
"curves."
msgstr "Die \"SQL Multimedia Applications Spatial\" Spezifikation erweitert die SQL Spezifikation für Simple Features indem es eine Reihe von kreisförmig interpolierten Kurven definiert."

#. Tag: para
#: using_postgis_dataman.xml:178
#, no-c-format
msgid ""
"The SQL-MM definitions include 3dm, 3dz and 4d coordinates, but do not allow"
" the embedding of SRID information."
msgstr "Die Definitionen in SQL-MM schließen 3DM-, 3DZ- und 4D-Koordinaten ein, erlauben allerdings nicht das Einbinden von Information über SRID."

#. Tag: para
#: using_postgis_dataman.xml:181
#, no-c-format
msgid ""
"The well-known text extensions are not yet fully supported. Examples of some"
" simple curved geometries are shown below:"
msgstr "Die Erweiterungen zur Well-known-Text-Darstellung werden zur Zeit noch nicht zur Gänze unterstützt. Im Folgenden werden Beispiele für einige einfache gekrümmte Geometrien gezeigt:"

#. Tag: para
#: using_postgis_dataman.xml:186
#, no-c-format
msgid "CIRCULARSTRING(0 0, 1 1, 1 0)"
msgstr "CIRCULARSTRING(0 0, 1 1, 1 0)"

#. Tag: para
#: using_postgis_dataman.xml:187
#, no-c-format
msgid "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"
msgstr "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"

#. Tag: para
#: using_postgis_dataman.xml:188
#, no-c-format
msgid ""
"The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the "
"linear world. A single segment required three points, the start and end "
"points (first and third) and any other point on the arc. The exception to "
"this is for a closed circle, where the start and end points are the same. In"
" this case the second point MUST be the center of the arc, ie the opposite "
"side of the circle. To chain arcs together, the last point of the previous "
"arc becomes the first point of the next arc, just like in LINESTRING. This "
"means that a valid circular string must have an odd number of points greated"
" than 1."
msgstr "CIRCULARSTRING ist der grundlegende Kurventyp, so wie LINESTRING in der linearen Welt. Ein einziges Segment benötigt drei Punkte, den Anfangs und den Endpunkt (erster und dritter) und irgendein weiterer Punkt auf dem Kreisbogen. Eine Ausnahme ist der geschlossene Kreis, wo Anfangs- und Endpunkt ident sind. In diesem Fall muss der zweite Punkt dem Kreismittelpunkt entsprechen. Um Kreisbögen aneinanderzuketten, wird der Endpunkt des vorangehenden Bogens zum Anfangspunkt des nächstfolgenden Bogens, genauso wie beim LINESTRING. D.h., dass ein Kreisbogen eine ungerade Anzahl an Punkten grösser als 1 aufweisen muss."

#. Tag: para
#: using_postgis_dataman.xml:201
#, no-c-format
msgid "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"
msgstr "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"

#. Tag: para
#: using_postgis_dataman.xml:202
#, no-c-format
msgid ""
"A compound curve is a single, continuous curve that has both curved "
"(circular) segments and linear segments. That means that in addition to "
"having well-formed components, the end point of every component (except the "
"last) must be coincident with the start point of the following component."
msgstr "Eine zusammengesetzte Kurve ist eine einzelne, durchgängige Kurve, die sowohl gekrümmte (kreisförmige) als auch gerade Segmente aufweist. Dies bedeutet, daß die Komponenten nicht nur wohlgeformt sein müssen, sondern auch der Endpunkt einer jeden Komponente (außer der letzten) mit dem Anfangspunkt der nachfolgenden Komponente zusammenfallen muss."

#. Tag: para
#: using_postgis_dataman.xml:210
#, no-c-format
msgid ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"
msgstr "CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"

#. Tag: para
#: using_postgis_dataman.xml:212
#, no-c-format
msgid ""
"Example compound curve in a curve polygon: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5,"
" 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"
msgstr "Beispiel einer zusammengesetzten Kurve in einem Kurvenpolygon: CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, 1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"

#. Tag: para
#: using_postgis_dataman.xml:216
#, no-c-format
msgid ""
"A CURVEPOLYGON is just like a polygon, with an outer ring and zero or more "
"inner rings. The difference is that a ring can take the form of a circular "
"string, linear string or compound string."
msgstr "Ein CurvePolygon hat, genau wie ein Polygon, einen äußeren Ring und keinen oder mehrere innere Ringe. Der Unterschied liegt darin, dass ein Ring aus Kreisbögen, Geraden oder zusammengesetzten Strecken bestehen kann."

#. Tag: para
#: using_postgis_dataman.xml:220
#, no-c-format
msgid "As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon."
msgstr "Ab PostGIS 1.4 werden zusammengesetzte Kurven/CompoundCurve in einem Kurvenpolygon/CurvePolygon unterstützt."

#. Tag: para
#: using_postgis_dataman.xml:224
#, no-c-format
msgid "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"
msgstr "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"

#. Tag: para
#: using_postgis_dataman.xml:225
#, no-c-format
msgid ""
"The MULTICURVE is a collection of curves, which can include linear strings, "
"circular strings or compound strings."
msgstr "Eine MultiCurve ist eine Sammelgeometrie von Kurven, welche aus Geraden, Kreisabschnitte oder zusammengesetzten Abschnitten bestehen kann."

#. Tag: para
#: using_postgis_dataman.xml:230
#, no-c-format
msgid ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3,"
" 3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"
msgstr "MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"

#. Tag: para
#: using_postgis_dataman.xml:233
#, no-c-format
msgid ""
"This is a collection of surfaces, which can be (linear) polygons or curve "
"polygons."
msgstr "Dies ist eine Sammelgeometrie von Oberflächen, welche (lineare) Polygone oder Kurvenpolygone sein können."

#. Tag: para
#: using_postgis_dataman.xml:239
#, no-c-format
msgid ""
"PostGIS prior to 1.4 does not support compound curves in a curve polygon, "
"but PostGIS 1.4 and above do support the use of Compound Curves in a Curve "
"Polygon."
msgstr "Vorgängerversionen von PostGIS 1.4 hatten keine Unterstützung für zusammengesetzte Kurven in einem Kurvenpolygon. Ab PostGIS 1.4 werden zusammengesetzte Kurven in einem Kurvenpolygon unterstützt."

#. Tag: para
#: using_postgis_dataman.xml:245
#, no-c-format
msgid ""
"All floating point comparisons within the SQL-MM implementation are "
"performed to a specified tolerance, currently 1E-8."
msgstr "Alle Gleitpunkt Vergleiche der SQL-MM Implementierung werden mit einer bestimmten Toleranz ausgeführt, zurzeit 1E-8."

#. Tag: title
#: using_postgis_dataman.xml:251
#, no-c-format
msgid "PostGIS Geography Type"
msgstr "PostGIS geographischer Datentyp"

#. Tag: para
#: using_postgis_dataman.xml:253
#, no-c-format
msgid ""
"The geography type provides native support for spatial features represented "
"on \"geographic\" coordinates (sometimes called \"geodetic\" coordinates, or"
" \"lat/lon\", or \"lon/lat\"). Geographic coordinates are spherical "
"coordinates expressed in angular units (degrees)."
msgstr "Der geographische Datentyp bietet native Unterstützung für Geoobjekte die durch \"geographische\" Koordinaten (manchmal auch als \"geodätische\" Koordinaten, \"Länge/Breite\" oder \"Breite/Länge\" bezeichnet) festgelegt sind. Geographische Koordinaten sind Kugelkoordinaten, die durch Winkel (in Grad) angegeben werden."

#. Tag: para
#: using_postgis_dataman.xml:255
#, no-c-format
msgid ""
"The basis for the PostGIS geometry type is a plane. The shortest path "
"between two points on the plane is a straight line. That means calculations "
"on geometries (areas, distances, lengths, intersections, etc) can be "
"calculated using cartesian mathematics and straight line vectors."
msgstr "Der geometrische Datentyp von PostGIS beruht auf der Ebene. Die kürzeste Entfernung zwischen zwei Punkten einer Ebene entspricht einer Gerade. Das bedeutet, dass geometrische Berechnungen (wie Flächen, Distanzen, Längen, Schnittpunkte, etc.) im kartesischen Koordinatensystem mit geradlinigen Vektoren ausgeführt werden können."

#. Tag: para
#: using_postgis_dataman.xml:257
#, no-c-format
msgid ""
"The basis for the PostGIS geographic type is a sphere. The shortest path "
"between two points on the sphere is a great circle arc. That means that "
"calculations on geographies (areas, distances, lengths, intersections, etc) "
"must be calculated on the sphere, using more complicated mathematics. For "
"more accurate measurements, the calculations must take the actual spheroidal"
" shape of the world into account, and the mathematics becomes very "
"complicated indeed."
msgstr "Der geographische Datentyp von PostGIS beruht auf einer Kugel. Die kürzeste Verbindung zwischen zwei Punkten auf einer Kugeloberfläche ist ein Bogenteil eines Großkreises. D.h., dass Berechnungen auf geographische Datentypen (wie Flächen, Distanzen, Längen, Schnittpunkte, etc.) auf der Kugeloberfläche mit einer komplexeren Mathematik durchgeführt werden müssen. Für genauere Messungen müssen die Berechnungen das Rotationsellipsoid der Erde in Betracht ziehen, wodurch die Mathematik so richtig kompliziert wird."

#. Tag: para
#: using_postgis_dataman.xml:259
#, no-c-format
msgid ""
"Because the underlying mathematics is much more complicated, there are fewer"
" functions defined for the geography type than for the geometry type. Over "
"time, as new algorithms are added, the capabilities of the geography type "
"will expand."
msgstr "Da die zugrunde liegende Mathematik wesentlich schwieriger ist, gibt es weniger Funktionen für den geographischen Datentyp, als für den geometrischen Datentyp. Mit der Zeit werden neue Algorithmen hinugefügt und die Möglichkeiten des geographischen Datentyps erweitert werden."

#. Tag: para
#: using_postgis_dataman.xml:262
#, no-c-format
msgid ""
"One restriction is that it only supports WGS 84 long lat (SRID:4326). It "
"uses a new data type called geography. None of the GEOS functions support "
"this new type. As a workaround one can convert back and forth between "
"geometry and geography types."
msgstr "Eine Beschränkung ist, dass nur das geodätische WGS 84 (SRID:4326) unterstützt wird. Es verwendet einen geographischen Datentyp, der Geograpy genannt wird. Keine der GEOS Funktionen unterstützt diesen neuen Datentyp. Als provisorische Lösung kann man zwischen den geometrischen und den geographischen Datentypen hin- und herkonvertieren."

#. Tag: para
#: using_postgis_dataman.xml:266
#, no-c-format
msgid ""
"The new geography type uses the PostgreSQL 8.3+ typmod definition format so "
"that a table with a geography field can be added in a single step. All the "
"standard OGC formats except for curves are supported."
msgstr "Der neue geographische Datentyp verwendet die Typmod-Formatangabe von PostgreSQL 8.3+, sodass eine Tabelle mit einem geographischen Attribut in einem einzigen Schritt erstellt werden kann. Es werden alle Formate des OGC-Standards unterstützt, mit Ausnahme von Kurven."

#. Tag: title
#: using_postgis_dataman.xml:270
#, no-c-format
msgid "Geography Basics"
msgstr "Geograpie Grundlagen"

#. Tag: para
#: using_postgis_dataman.xml:271
#, no-c-format
msgid ""
"The geography type only supports the simplest of simple features. Standard "
"geometry type data will autocast to geography if it is of SRID 4326. You can"
" also use the EWKT and EWKB conventions to insert data."
msgstr "Der geographische Datentyp unterstützt nur die einfachsten \"Simple Features\". Daten vom geometrischen Datentyp, welche eine SRID von 4326 aufweisen, werden implizit in den geographischen Datentyp umgewandelt. Sie können Daten auch entsprechend der EWKT- und EWKB-Konvention einfügen."

#. Tag: para
#: using_postgis_dataman.xml:276
#, no-c-format
msgid "POINT: Creating a table with 2d point geometry:"
msgstr "POINT: Erzeugung einer Tabelle mit 2D-Punktgeometrie:"

#. Tag: programlisting
#: using_postgis_dataman.xml:277
#, no-c-format
msgid ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog geography(POINT,4326)"
" );"
msgstr "CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog geography(POINT,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:278
#, no-c-format
msgid "Creating a table with z coordinate point"
msgstr "Erstellung einer Tabelle für Punkte mit Z-Koordinaten"

#. Tag: programlisting
#: using_postgis_dataman.xml:279
#, no-c-format
msgid ""
"CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog "
"geography(POINTZ,4326) );"
msgstr "CREATE TABLE testgeog(gid serial PRIMARY KEY, the_geog geography(POINTZ,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:282
#, no-c-format
msgid "LINESTRING"
msgstr "LINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:285
#, no-c-format
msgid "POLYGON"
msgstr "POLYGON"

#. Tag: para
#: using_postgis_dataman.xml:288
#, no-c-format
msgid "MULTIPOINT"
msgstr "MULTIPOINT"

#. Tag: para
#: using_postgis_dataman.xml:291
#, no-c-format
msgid "MULTILINESTRING"
msgstr "MULTILINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:294
#, no-c-format
msgid "MULTIPOLYGON"
msgstr "MULTIPOLYGON"

#. Tag: para
#: using_postgis_dataman.xml:297
#, no-c-format
msgid "GEOMETRYCOLLECTION"
msgstr "GEOMETRYCOLLECTION"

#. Tag: para
#: using_postgis_dataman.xml:301
#, no-c-format
msgid ""
"The new geography fields don't get registered in the "
"<varname>geometry_columns</varname>. They get registered in a new view "
"called geography_columns which is a view against the system catalogs so is "
"always automatically kept up to date without need for an AddGeom... like "
"function."
msgstr "Die neuen geographischen Attribute werden nicht in <varname>geometry_columns</varname> registriert. Sie werden in dem neuen View\" geography_columns\" registriert. Da dies ist ein View auf den Systemkatalog ist, wird er automatisch auf dem letzten Stand gehalten und es wird keine Funktion ähnlich wie AddGeom... benötigt."

#. Tag: para
#: using_postgis_dataman.xml:305
#, no-c-format
msgid ""
"Now, check the \"geography_columns\" view and see that your table is listed."
msgstr "Nun überprüfen Sie bitte ob Ihre Tabelle in der gespeicherten Abfrage \"geography_columns\" aufscheint."

#. Tag: para
#: using_postgis_dataman.xml:307
#, no-c-format
msgid ""
"You can create a new table with a GEOGRAPHY column using the CREATE TABLE "
"syntax. Unlike GEOMETRY, there is no need to run a separate "
"AddGeometryColumns() process to register the column in metadata."
msgstr "Eine neue Tabelle mit einer Spalte vom Typ Geometrie kann mit der Syntax CREATE TABLE erstellt werden. Anders als bei der GEOMETRY muss kein eigener AddGeometryColumns() Arbeitsgang ausgeführt werden, um die Spalte in den Metadaten zu registrieren."

#. Tag: programlisting
#: using_postgis_dataman.xml:311
#, no-c-format
msgid ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"
msgstr "CREATE TABLE global_points (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(64),\n    location GEOGRAPHY(POINT,4326)\n  );"

#. Tag: para
#: using_postgis_dataman.xml:314
#, no-c-format
msgid ""
"Note that the location column has type GEOGRAPHY and that geography type "
"supports two optional modifier: a type modifier that restricts the kind of "
"shapes and dimensions allowed in the column; an SRID modifier that restricts"
" the coordinate reference identifier to a particular number."
msgstr "Beachten Sie bitte, dass die Spalte \"location\" den geographischen Datentyp verwendet und dieser zwei optionale Modifikatoren unterstützt: Einen Typmodifikator, der die geometrische Form und die Dimension der Geometriespalte festlegt; ein Modifikator für SRID, der den Identifikator für das Koordinatenreferenzsystem auf eine bestimmte Zahl einschränkt."

#. Tag: para
#: using_postgis_dataman.xml:315
#, no-c-format
msgid ""
"Allowable values for the type modifier are: POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. The modifier also supports "
"dimensionality restrictions through suffixes: Z, M and ZM. So, for example a"
" modifier of 'LINESTRINGM' would only allow line strings with three "
"dimensions in, and would treat the third dimension as a measure. Similarly, "
"'POINTZM' would expect four dimensional data."
msgstr "Für den Typmodifikator sind folgende Werte erlaubt: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. Der Modifikator unterstützt auch Einschränkungen der Dimensionalität durch Nachsilben: Z, M und ZM. So erlaubt zum Beispiel ein Modifikator mit dem Wert 'LINESTRINGM' nur die Eingabe von Linienzügen mit drei Dimensionen, wobei die dritte Dimension als Kilometrierung/measure behandelt wird. Ebenso verlangt 'POINTZM' die Eingabe von vierdimensionalen Daten."

#. Tag: para
#: using_postgis_dataman.xml:317
#, no-c-format
msgid ""
"The SRID modifier is currently of limited use: only 4326 (WGS84) is allowed "
"as a value. If you do not specify an SRID, the a value 0 (undefined "
"spheroid) will be used, and all calculations will proceed using WGS84 "
"anyways."
msgstr "Der Modifikator für SRID ist zurzeit nur von beschränktem Nutzen, da nur 4326 (WGS84) als Eingabewert erlaubt ist. Wenn Sie keine SRID angeben, so wird der Wert auf 0 (undefiniertes Referenzellipsoid) gesetzt, wobei sämtliche Berechnungen jedenfalls in WGS84 ausgeführt werden."

#. Tag: para
#: using_postgis_dataman.xml:318
#, no-c-format
msgid ""
"In the future, alternate SRIDs will allow calculations on spheroids other "
"than WGS84."
msgstr "In der Zukunft werden weitere SRID's eingeführt und Berechnungen auf andere Referenzellipsoide als WGS84 ermöglicht werden."

#. Tag: para
#: using_postgis_dataman.xml:319
#, no-c-format
msgid ""
"Once you have created your table, you can see it in the GEOGRAPHY_COLUMNS "
"table:"
msgstr "Sobald Sie Ihre Tabelle erstellt haben, können Sie diese in der Tabelle \"geography_columns\" sehen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:320
#, no-c-format
msgid ""
"-- See the contents of the metadata view\n"
"SELECT * FROM geography_columns;"
msgstr "-- Metadaten abfragen\nSELECT * FROM geography_columns;"

#. Tag: para
#: using_postgis_dataman.xml:322
#, no-c-format
msgid ""
"You can insert data into the table the same as you would if it was using a "
"GEOMETRY column:"
msgstr "Sie können Daten auf dieselbe Art und Weise in die Tabelle einfügen wie Sie dies bei einer Geometriespalte tun würden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:324
#, no-c-format
msgid ""
"-- Add some data into the test table\n"
"INSERT INTO global_points (name, location) VALUES ('Town', ST_GeographyFromText('SRID=4326;POINT(-110 30)') );\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', ST_GeographyFromText('SRID=4326;POINT(-109 29)') );\n"
"INSERT INTO global_points (name, location) VALUES ('London', ST_GeographyFromText('SRID=4326;POINT(0 49)') );"
msgstr "-- Ein paar Daten in die Testtabelle einfügen\nINSERT INTO global_points (name, location) VALUES ('Town', ST_GeographyFromText('SRID=4326;POINT(-110 30)') );\nINSERT INTO global_points (name, location) VALUES ('Forest', ST_GeographyFromText('SRID=4326;POINT(-109 29)') );\nINSERT INTO global_points (name, location) VALUES ('London', ST_GeographyFromText('SRID=4326;POINT(0 49)') );"

#. Tag: para
#: using_postgis_dataman.xml:326
#, no-c-format
msgid ""
"Creating an index works the same as GEOMETRY. PostGIS will note that the "
"column type is GEOGRAPHY and create an appropriate sphere-based index "
"instead of the usual planar index used for GEOMETRY."
msgstr "Die Erstellung eines Index funktioniert gleich wie beim Datentyp GEOMETRY. PostGIS erkennt, dass es sich um den Datentyp GEOGRAPHY handelt und erzeugt einen entsprechenden, auf einer Kugeloberfläche basierenden Index anstelle des üblichen planaren Index, der für den Datentyp GEOMETRY verwendet wird."

#. Tag: programlisting
#: using_postgis_dataman.xml:329
#, no-c-format
msgid ""
"-- Index the test table with a spherical index\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"
msgstr "-- Einen sphärischen Index auf die Testtabelle legen\n  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"

#. Tag: para
#: using_postgis_dataman.xml:332
#, no-c-format
msgid ""
"Query and measurement functions use units of meters. So distance parameters "
"should be expressed in meters, and return values should be expected in "
"meters (or square meters for areas)."
msgstr "Anfrage und Messfunktionen verwenden die Einheit Meter. Daher sollten Entfernungsparameter in Metern ausgedrückt werden und die Rückgabewerte sollten ebenfalls in Meter (oder Quadratmeter für Flächen) erwartet werden."

#. Tag: programlisting
#: using_postgis_dataman.xml:334
#, no-c-format
msgid ""
"-- Show a distance query and note, London is outside the 1000km tolerance\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);"
msgstr "-- Eine Distanzabfrage; Beachten Sie bitte, dass London ausserhalb der 1000km Toleranz liegt\n  SELECT name FROM global_points WHERE ST_DWithin(location, ST_GeographyFromText('SRID=4326;POINT(-110 29)'), 1000000);"

#. Tag: para
#: using_postgis_dataman.xml:337
#, no-c-format
msgid ""
"You can see the power of GEOGRAPHY in action by calculating the how close a "
"plane flying from Seattle to London (LINESTRING(-122.33 47.606, 0.0 51.5)) "
"comes to Reykjavik (POINT(-21.96 64.15))."
msgstr "Sie können die Mächtigkeit von GEOGRAPHY erleben, indem Sie berechnen, wie nahe ein Flugzeug, das von Seattle nach London (LINESTRING(-122.33 47.606, 0.0 51.5)) fliegt, an Reykjavik (POINT(-21.96 64.15)) vorbeikommt."

#. Tag: programlisting
#: using_postgis_dataman.xml:339
#, no-c-format
msgid ""
"-- Distance calculation using GEOGRAPHY (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, 'POINT(-21.96 64.15)':: geography);"
msgstr "-- Die Entfernung mittels GEOGRAPHY ausrechnen (122.2km)\n  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, 'POINT(-21.96 64.15)':: geography);"

#. Tag: programlisting
#: using_postgis_dataman.xml:342
#, no-c-format
msgid ""
"-- Distance calculation using GEOMETRY (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, 'POINT(-21.96 64.15)':: geometry);"
msgstr "-- Die Entfernung mittels GEOMETRIE ausrechnen (13.3 \"degrees\")\n  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, 'POINT(-21.96 64.15)':: geometry);"

#. Tag: para
#: using_postgis_dataman.xml:345
#, no-c-format
msgid ""
"The GEOGRAPHY type calculates the true shortest distance over the sphere "
"between Reykjavik and the great circle flight path between Seattle and "
"London."
msgstr "Mit dem Datentyp GEOGRAPHY wird die wahre, kürzeste Entfernung auf der Kugeloberfläche zwischen Reykjavik und der Flugstrecke entlang des Großkreises von Seattle nach London errechnet."

#. Tag: para
#: using_postgis_dataman.xml:347
#, no-c-format
msgid ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> The GEOMETRY type calculates a meaningless cartesian distance"
" between Reykjavik and the straight line path from Seattle to London plotted"
" on a flat map of the world. The nominal units of the result might be called"
" \"degrees\", but the result doesn't correspond to any true angular "
"difference between the points, so even calling them \"degrees\" is "
"inaccurate."
msgstr "<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle mapper</ulink> Beim geometrischen Datentyp wird die Entfernung sinnloserweise in einem kartesischen Koordinatensystem zwischen Reykjavik und einer Geraden von Seattle nach London errechnet und auf einer ebenen Weltkarte angezeigt. Dem Namen nach mag das Ergebnis in der Einheit \"Grad\" angegeben sein, da es aber in keiner Weise irgendeinem wahren Winkel zwischen den Punkten entspricht, ist sogar die Verwendung der Bezeichnung \"Grad\" falsch."

#. Tag: title
#: using_postgis_dataman.xml:351
#, no-c-format
msgid "When to use Geography Data type over Geometry data type"
msgstr "Wann sollte man den GEOGRAPHY Datentyp dem GEOMETRY Datentyp vorziehen"

#. Tag: para
#: using_postgis_dataman.xml:352
#, no-c-format
msgid ""
"The new GEOGRAPHY type allows you to store data in longitude/latitude "
"coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY "
"than there are on GEOMETRY; those functions that are defined take more CPU "
"time to execute."
msgstr "Der neue GEOGRAPHY Datentyp ermöglicht es, die Koordinaten in Form von Länge und Breite zu speichern. Allerdings mit dem Nachteil, dass für den GEOGRAPHY Datentyp weniger Funktionen als für den GEOMETRY Datentyp vorhanden sind und diese auch mehr CPU-Zeit beanspruchen."

#. Tag: para
#: using_postgis_dataman.xml:353
#, no-c-format
msgid ""
"The type you choose should be conditioned on the expected working area of "
"the application you are building. Will your data span the globe or a large "
"continental area, or is it local to a state, county or municipality?"
msgstr "Welchen Datentyp Sie wählen sollte aufgrund der zu erwartene Flächenausdehnung ihrer Anwendung festgelegt werden. Erstrecken sich Ihre Daten über den gesamten Globus oder über eine große kontinentale Fläche, oder sind sie auf einen Staat, ein Land oder eine Gemeinde beschränkt."

#. Tag: para
#: using_postgis_dataman.xml:355
#, no-c-format
msgid ""
"If your data is contained in a small area, you might find that choosing an "
"appropriate projection and using GEOMETRY is the best solution, in terms of "
"performance and functionality available."
msgstr "Wenn sich Ihre Daten in einem kleinen Bereich befinden, werden Sie vermutlich eine passende Projektion wählen und den geometrischen Datentyp verwenden, da dies in Bezug auf die Rechenleistung und die verfügbare Funktionalität die bessere Lösung ist."

#. Tag: para
#: using_postgis_dataman.xml:356
#, no-c-format
msgid ""
"If your data is global or covers a continental region, you may find that "
"GEOGRAPHY allows you to build a system without having to worry about "
"projection details. You store your data in longitude/latitude, and use the "
"functions that have been defined on GEOGRAPHY."
msgstr "Wenn Ihre Daten global sind oder einen ganzen Kontinent bedecken, ermöglicht es der geographische Datentyp ein System aufzubauen, bei dem Sie sich nicht um Projektionsdetails kümmern müssen. Sie speichern die Daten als Länge und Breite und verwenden dann jene Funktionen die für den geographischen Datentyp definiert sind."

#. Tag: para
#: using_postgis_dataman.xml:358
#, no-c-format
msgid ""
"If you don't understand projections, and you don't want to learn about them,"
" and you're prepared to accept the limitations in functionality available in"
" GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. "
"Simply load your data up as longitude/latitude and go from there."
msgstr "Wenn Sie keine Ahnung von Projektionen haben, sich nicht näher damit beschäftigen wollen und die Einschränkungen der verfügbaren Funktionalität für den geographischen Datentyp in Kauf nehmen können, ist es vermutlich einfacher für Sie den geographischen anstatt des geometrischen Datentyps zu verwenden."

#. Tag: para
#: using_postgis_dataman.xml:361
#, no-c-format
msgid ""
"Refer to <xref linkend=\"PostGIS_TypeFunctionMatrix\"/> for compare between "
"what is supported for Geography vs. Geometry. For a brief listing and "
"description of Geography functions, refer to <xref "
"linkend=\"PostGIS_GeographyFunctions\"/>"
msgstr "Für einen Vergleich, welche Funktionalität von Geography vs. Geometry unterstützt wird, siehe <xref linkend=\"PostGIS_TypeFunctionMatrix\"/>. Für eine kurze Liste mit der Beschreibung der geographischen Funktionen, siehe <xref linkend=\"PostGIS_GeographyFunctions\"/>"

#. Tag: title
#: using_postgis_dataman.xml:367
#, no-c-format
msgid "Geography Advanced FAQ"
msgstr "Fortgeschrittene FAQ's zum GEOGRAPHY Datentyp"

#. Tag: para
#: using_postgis_dataman.xml:371
#, no-c-format
msgid "Do you calculate on the sphere or the spheroid?"
msgstr "Werden die Berechnungen auf einer Kugel oder auf einem Rotationsellipsoid durchgeführt?"

#. Tag: para
#: using_postgis_dataman.xml:375
#, no-c-format
msgid ""
"By default, all distance and area calculations are done on the spheroid. You"
" should find that the results of calculations in local areas match up will "
"with local planar results in good local projections. Over larger areas, the "
"spheroidal calculations will be more accurate than any calculation done on a"
" projected plane."
msgstr "Standardmäßig werden alle Entfernungs- und Flächenberechnungen auf dem Referenzellipsoid ausgeführt. Das Ergebnis der Berechnung sollte in lokalen Gebieten gut mit dem planaren Ergebnis zusammenpasst - eine gut gewählte lokale Projektion vorausgesetzt. Bei größeren Gebieten ist die Berechnung über das Referenzellipsoid genauer als irgendeine Berechnung die auf der projizierten Ebene ausgeführt wird."

#. Tag: para
#: using_postgis_dataman.xml:378
#, no-c-format
msgid ""
"All the geography functions have the option of using a sphere calculation, "
"by setting a final boolean parameter to 'FALSE'. This will somewhat speed up"
" calculations, particularly for cases where the geometries are very simple."
msgstr "Alle geographischen Funktionen verfügen über eine Option um die Berechnung auf einer Kugel durchzuführen. Dies erreicht man, indem der letzte boolesche Eingabewert auf 'FALSE' gesetzt wird. Dies beschleunigt die Berechnung einigermaßen, insbesondere wenn die Geometrie sehr einfach gestaltet ist."

#. Tag: para
#: using_postgis_dataman.xml:384
#, no-c-format
msgid "What about the date-line and the poles?"
msgstr "Wie schaut das mit der Datumsgrenze und den Polen aus?"

#. Tag: para
#: using_postgis_dataman.xml:388
#, no-c-format
msgid ""
"All the calculations have no conception of date-line or poles, the "
"coordinates are spherical (longitude/latitude) so a shape that crosses the "
"dateline is, from a calculation point of view, no different from any other "
"shape."
msgstr "Alle diese Berechnungen wissen weder über Datumsgrenzen noch über Pole Bescheid. Da es sich um sphärische Koordinaten handelt (Länge und Breite), unterscheidet sich ist eine Geometrie die eine Datumsgrenze überschreitet vom Gesichtspunkt der Berechnung her durch nichts von irgendeiner anderen Geometrie."

#. Tag: para
#: using_postgis_dataman.xml:396
#, no-c-format
msgid "What is the longest arc you can process?"
msgstr "Wie lang kann ein Bogen sein, damit er noch verarbeitet werden kann?"

#. Tag: para
#: using_postgis_dataman.xml:400
#, no-c-format
msgid ""
"We use great circle arcs as the \"interpolation line\" between two points. "
"That means any two points are actually joined up two ways, depending on "
"which direction you travel along the great circle. All our code assumes that"
" the points are joined by the *shorter* of the two paths along the great "
"circle. As a consequence, shapes that have arcs of more than 180 degrees "
"will not be correctly modelled."
msgstr "Wir verwenden Großkreisbögen als \"Interpolationslinie\" zwischen zwei Punkten. Das bedeutet, dass es für den Join zwischen zwei Punkten zwei Möglichkeiten gibt, je nachdem, aus welcher Richtung man den Großkreises überquert. Unser gesamter Code setzt voraus, dass die Punkte von der \"kürzeren\" der beiden Strecken her durch den Großkreis verbunden werden. Als Konsequenz wird eine Geometrie, welche Bögen von mehr als 180 Grad aufweist nicht korrekt modelliert."

#. Tag: para
#: using_postgis_dataman.xml:407
#, no-c-format
msgid ""
"Why is it so slow to calculate the area of Europe / Russia / insert big "
"geographic region here ?"
msgstr "Warum dauert es so lange, die Fläche von Europa / Russland /irgendeiner anderen großen geographischen Region zu berechnen ?"

#. Tag: para
#: using_postgis_dataman.xml:411
#, no-c-format
msgid ""
"Because the polygon is so darned huge! Big areas are bad for two reasons: "
"their bounds are huge, so the index tends to pull the feature no matter what"
" query you run; the number of vertices is huge, and tests (distance, "
"containment) have to traverse the vertex list at least once and sometimes N "
"times (with N being the number of vertices in the other candidate feature)."
msgstr "Weil das Polygon so verdammt groß ist! Große Flächen sind aus zwei Gründen schlecht: ihre Begrenzung ist riesig, wodurch der Index dazu tendiert das Geoobjekt herauszuholen, egal wie Sie die Anfrage ausführen; die Anzahl der Knoten ist riesig, und Tests (wie ST_Distance, ST_Contains) müssen alle Knoten zumindest einmal, manchmal sogar N-mal durchlaufen (wobei N die Anzahl der Knoten im beteiligten Geoobjekt bezeichnet)."

#. Tag: para
#: using_postgis_dataman.xml:416
#, no-c-format
msgid ""
"As with GEOMETRY, we recommend that when you have very large polygons, but "
"are doing queries in small areas, you \"denormalize\" your geometric data "
"into smaller chunks so that the index can effectively subquery parts of the "
"object and so queries don't have to pull out the whole object every time. "
"Just because you *can* store all of Europe in one polygon doesn't mean you "
"*should*."
msgstr "Wenn es sich um sehr große Polygone handelt, die Abfragen aber nur in kleinen Gebieten stattfinden, empfehlen wir wie beim geometrischen Datentyp, dass Sie die Geometrie in kleinere Stücke \"denormalisieren\". Dadurch kann der Index effiziente Unterabfragen auf Teile des Geoobjekts ausführen, da eine Abfrage nicht jedesmal das gesamte Geoobjekt herausholen muss. Nur weil Sie ganz Europa in einem Polygon speichern *können* heißt das nicht, dass Sie dies auch tun *sollten*."

#. Tag: title
#: using_postgis_dataman.xml:425
#, no-c-format
msgid "Using OpenGIS Standards"
msgstr "Verwendung von OGC-Standards"

#. Tag: para
#: using_postgis_dataman.xml:427
#, no-c-format
msgid ""
"The OpenGIS \"Simple Features Specification for SQL\" defines standard GIS "
"object types, the functions required to manipulate them, and a set of meta-"
"data tables. In order to ensure that meta-data remain consistent, operations"
" such as creating and removing a spatial column are carried out through "
"special procedures defined by OpenGIS."
msgstr "Die OpenGIS \"Simple Features Specification for SQL\" standardisert die Datentypen von Geoobjekten, die Funktionen die benötigt werden um diese zu verarbeiten, sowie die Metadatentabellen. Um sicherzustellen, dass die Metadaten konsistent bleiben, werden Vorgänge wie das Erstellen oder das Löschen einer Geometriespalte, durch dafür eigens von OpenGIS festgelegten Prozeduren ausgeführt."

#. Tag: para
#: using_postgis_dataman.xml:433
#, no-c-format
msgid ""
"There are two OpenGIS meta-data tables: <varname>SPATIAL_REF_SYS</varname> "
"and <varname>GEOMETRY_COLUMNS</varname>. The "
"<varname>SPATIAL_REF_SYS</varname> table holds the numeric IDs and textual "
"descriptions of coordinate systems used in the spatial database."
msgstr "Es gibt zwei OpenGIS Metadatentabellen: <varname>SPATIAL_REF_SYS</varname> und <varname>GEOMETRY_COLUMNS</varname>. Die <varname>SPATIAL_REF_SYS</varname> Tabelle enthält die numerischen Identifikatoren und textlichen Beschreibungen der in der Datenbank verwendeten Koordinatensysteme."

#. Tag: title
#: using_postgis_dataman.xml:440
#, no-c-format
msgid "The SPATIAL_REF_SYS Table and Spatial Reference Systems"
msgstr "Die SPATIAL_REF_SYS Tabelle und Koordinatenreferenzsysteme"

#. Tag: para
#: using_postgis_dataman.xml:442
#, no-c-format
msgid ""
"The spatial_ref_sys table is a PostGIS included and OGC compliant database "
"table that lists over 3000 known <ulink "
"url=\"http://www.sharpgis.net/post/2007/05/Spatial-references2c-coordinate-"
"systems2c-projections2c-datums2c-ellipsoids-e28093-confusing.aspx\">spatial "
"reference systems</ulink> and details needed to transform/reproject between "
"them."
msgstr "Die Tabelle \"spatial_ref_sys\" ist eine mit PostGIS kommende und OGC-konforme Datenbanktabelle, die über 3000 bekannte <ulink url=\"http://www.sharpgis.net/post/2007/05/Spatial-references2c-coordinate-systems2c-projections2c-datums2c-ellipsoids-e28093-confusing.aspx\">Koordinatenreferenzsysteme</ulink> enthält, sowie Details zur Koordinatentransformation zwischen diesen."

#. Tag: para
#: using_postgis_dataman.xml:446
#, no-c-format
msgid ""
"Although the PostGIS spatial_ref_sys table contains over 3000 of the more "
"commonly used spatial reference system definitions that can be handled by "
"the proj library, it does not contain all known to man and you can even "
"define your own custom projection if you are familiar with proj4 constructs."
" Keep in mind that most spatial reference systems are regional and have no "
"meaning when used outside of the bounds they were intended for."
msgstr "Obwohl in der PostGIS Tabelle \"spatial_ref_sys\" über 3000 der gebräuchlichsten Koordinatenreferenzsysteme definiert sind, die mit der Bibliothek \"Proj4\" gehandhabt werden können, enthält sie nicht alle bekannten Projektionen. Sie können auch ihre eigenen Projektionen in der Tabelle definieren, falls Sie mit den Konstrukten von \"Proj4\" vertraut sind. Sie sollten nicht außer Acht lassen, dass die meisten Koordinatenreferenzsysteme regional sind und außerhalb des vorgesehenen Bereichs keinen Sinn haben."

#. Tag: para
#: using_postgis_dataman.xml:449
#, no-c-format
msgid ""
"An excellent resource for finding spatial reference systems not defined in "
"the core set is <ulink "
"url=\"http://spatialreference.org/\">http://spatialreference.org/</ulink>"
msgstr "Eine hervorragende Quelle zum Auffinden von Koordinatenreferenzsystemen, welche nicht in der Grundmenge enthalten sind, ist <ulink url=\"http://spatialreference.org/\">http://spatialreference.org/</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:451
#, no-c-format
msgid ""
"Some of the more commonly used spatial reference systems are: <ulink "
"url=\"http://spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long "
"Lat</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/4269/\">4269 "
"- NAD 83 Long Lat</ulink>, <ulink "
"url=\"http://spatialreference.org/ref/epsg/3395/\">3395 - WGS 84 World "
"Mercator</ulink>, <ulink "
"url=\"http://spatialreference.org/ref/epsg/2163/\">2163 - US National Atlas "
"Equal Area</ulink>, Spatial reference systems for each NAD 83, WGS 84 UTM "
"zone - UTM zones are one of the most ideal for measurement, but only cover "
"6-degree regions."
msgstr "Einige der häufiger eingesetzten Koordinatenreferenzsysteme sind: <ulink url=\"http://spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD 83 Long Lat</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/\">3395 - WGS 84 World Mercator</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/2163/\">2163 - US National Atlas Equal Area</ulink>, Koordinatenreferenzsysteme für jede NAD 83, WGS 84 und UTM Zone - UTM Zonen sind ideal für Messungen, decken aber nur 6 Grad breite, vertikale Zonen ab."

#. Tag: para
#: using_postgis_dataman.xml:457
#, no-c-format
msgid ""
"Various US state plane spatial reference systems (meter or feet based) - "
"usually one or 2 exists per US state. Most of the meter ones are in the core"
" set, but many of the feet based ones or ESRI created ones you will need to "
"pull from <ulink "
"url=\"http://spatialreference.org\">spatialreference.org</ulink>."
msgstr "Verschiedenste Koordinatenreferenzsysteme \"US State Plane\"  (auf Meter und Fuß basierend) - üblicherweise 2 pro US Staat. Die meisten auf Meter basierten befinden sich in der Grundmenge, aber viele der auf Fuß basierten, oder von ESRI erzeugten müssen von <ulink url=\"http://spatialreference.org\">spatialreference.org</ulink> heruntergeladen werden."

#. Tag: para
#: using_postgis_dataman.xml:461
#, no-c-format
msgid ""
"For details on determining which UTM zone to use for your area of interest, "
"check out the <ulink "
"url=\"http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctionsDistance\">utmzone"
" PostGIS plpgsql helper function</ulink>."
msgstr "Genauere Angaben zur Ermittlung der UTM Zone für ein bestimmtes Gebiet finden Sie unter<ulink url=\"http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctionsDistance\"> utmzone PostGIS plpgsql helper function</ulink>."

#. Tag: para
#: using_postgis_dataman.xml:465
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> table definition is as follows:"
msgstr "Die <varname>SPATIAL_REF_SYS</varname> Tabelle ist folgendermaßen definiert:"

#. Tag: programlisting
#: using_postgis_dataman.xml:468
#, no-c-format
msgid ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"
msgstr "CREATE TABLE spatial_ref_sys (\n  srid       INTEGER NOT NULL PRIMARY KEY,\n  auth_name  VARCHAR(256),\n  auth_srid  INTEGER,\n  srtext     VARCHAR(2048),\n  proj4text  VARCHAR(2048)\n)"

#. Tag: para
#: using_postgis_dataman.xml:470
#, no-c-format
msgid "The <varname>SPATIAL_REF_SYS</varname> columns are as follows:"
msgstr "Die <varname>SPATIAL_REF_SYS</varname> Spalten folgendermaßen:"

#. Tag: ulink
#: using_postgis_dataman.xml:475
#, no-c-format
msgid "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"
msgstr "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:478
#, no-c-format
msgid ""
"An integer value that uniquely identifies the Spatial Referencing System "
"(SRS) within the database."
msgstr "Ein ganzzahliger Wert, der das Koordinatenreferenzsystem (SRS) innerhalb der Datenbank eindeutig ausweist."

#. Tag: term
#: using_postgis_dataman.xml:484
#, no-c-format
msgid "AUTH_NAME"
msgstr "AUTH_NAME"

#. Tag: para
#: using_postgis_dataman.xml:487
#, no-c-format
msgid ""
"The name of the standard or standards body that is being cited for this "
"reference system. For example, \"EPSG\" would be a valid "
"<varname>AUTH_NAME</varname>."
msgstr "Der Name des Standards oder der Normungsorganisation unte dem dieses Koordinatenreferenzsystem zitiert wird. Zum Beispiel ist \"EPSG\" ein gültiger <varname>AUTH_NAME</varname>."

#. Tag: term
#: using_postgis_dataman.xml:494
#, no-c-format
msgid "AUTH_SRID"
msgstr "AUTH_SRID"

#. Tag: para
#: using_postgis_dataman.xml:497
#, no-c-format
msgid ""
"The ID of the Spatial Reference System as defined by the Authority cited in "
"the <varname>AUTH_NAME</varname>. In the case of EPSG, this is where the "
"EPSG projection code would go."
msgstr "Die von der in <varname>AUTH_NAME</varname> zitierten Quelle festgelegte ID des Koordinatenreferenzsystems. Im Falle von EPSG ist dies der EPSG Projektionscode."

#. Tag: term
#: using_postgis_dataman.xml:504
#, no-c-format
msgid "SRTEXT"
msgstr "SRTEXT"

#. Tag: para
#: using_postgis_dataman.xml:507
#, no-c-format
msgid ""
"The Well-Known Text representation of the Spatial Reference System. An "
"example of a WKT SRS representation is:"
msgstr "Die Well-Known-Text Darstellung des Koordinatenreferenzsystems. Ein Beispiel dazu:"

#. Tag: programlisting
#: using_postgis_dataman.xml:510
#, no-c-format
msgid ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"
msgstr "PROJCS[\"NAD83 / UTM Zone 10N\",\n  GEOGCS[\"NAD83\",\n        DATUM[\"North_American_Datum_1983\",\n          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n        ],\n        PRIMEM[\"Greenwich\",0],\n        UNIT[\"degree\",0.0174532925199433]\n  ],\n  PROJECTION[\"Transverse_Mercator\"],\n  PARAMETER[\"latitude_of_origin\",0],\n  PARAMETER[\"central_meridian\",-123],\n  PARAMETER[\"scale_factor\",0.9996],\n  PARAMETER[\"false_easting\",500000],\n  PARAMETER[\"false_northing\",0],\n  UNIT[\"metre\",1]\n]"

#. Tag: para
#: using_postgis_dataman.xml:512
#, no-c-format
msgid ""
"For a listing of EPSG projection codes and their corresponding WKT "
"representations, see <ulink "
"url=\"http://www.opengeospatial.org/\">http://www.opengeospatial.org/</ulink>."
" For a discussion of WKT in general, see the OpenGIS \"Coordinate "
"Transformation Services Implementation Specification\" at <ulink "
"url=\"http://www.opengeospatial.org/standards\">http://www.opengeospatial.org/standards</ulink>."
" For information on the European Petroleum Survey Group (EPSG) and their "
"database of spatial reference systems, see <ulink "
"url=\"http://www.epsg.org/\">http://www.epsg.org</ulink>."
msgstr "Für eine Auflistung der EPSG Projektionscodes und deren entsprechende WKT Darstellung siehe <ulink url=\"http://www.opengeospatial.org/\">http://www.opengeospatial.org/</ulink>. Eine allgemeine Erläuterung zu WKT finden Sie in der OpenGIS \"Coordinate Transformation Services Implementation Specification\" unter <ulink url=\"http://www.opengeospatial.org/standards\">http://www.opengeospatial.org/standards</ulink>. Information zur European Petroleum Survey Group (EPSG) und deren Datenbank über Koordinatenreferenzsysteme finden Sie unter <ulink url=\"http://www.epsg.org/\">http://www.epsg.org</ulink>."

#. Tag: term
#: using_postgis_dataman.xml:525
#, no-c-format
msgid "PROJ4TEXT"
msgstr "PROJ4TEXT"

#. Tag: para
#: using_postgis_dataman.xml:528
#, no-c-format
msgid ""
"PostGIS uses the Proj4 library to provide coordinate transformation "
"capabilities. The <varname>PROJ4TEXT</varname> column contains the Proj4 "
"coordinate definition string for a particular SRID. For example:"
msgstr "PostGIS verwendet die Bibliothek \"Proj4\" zur Koordinatentransformation. Die Spalte <varname>PROJ4TEXT</varname> enthält eine Proj4 Zeichenfolge mit der Definition des Koordinatensystems für eine bestimmte SRID. Zum Beispiel:"

#. Tag: programlisting
#: using_postgis_dataman.xml:533
#, no-c-format
msgid "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"
msgstr "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"

#. Tag: para
#: using_postgis_dataman.xml:535
#, no-c-format
msgid ""
"For more information about, see the Proj4 web site at <ulink "
"url=\"http://trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. The"
" <filename>spatial_ref_sys.sql</filename> file contains both "
"<varname>SRTEXT</varname> and <varname>PROJ4TEXT</varname> definitions for "
"all EPSG projections."
msgstr "Weiterführende Information finden Sie auf der Proj4 Webseite unter <ulink url=\"http://trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. Die Datei <filename>spatial_ref_sys.sql</filename> enthält sowohl <varname>SRTEXT</varname> als auch <varname>PROJ4TEXT</varname> Definitionen aller EPSG Projektionen."

#. Tag: title
#: using_postgis_dataman.xml:546
#, no-c-format
msgid "The GEOMETRY_COLUMNS VIEW"
msgstr "Die gespeicherte Abfrage GEOMETRY_COLUMNS"

#. Tag: para
#: using_postgis_dataman.xml:548
#, no-c-format
msgid ""
"In versions of PostGIS prior to 2.0.0, geometry_columns was a table that "
"could be directly edited, and sometimes got out of synch with the actual "
"definition of the geometry columns. In PostGIS 2.0.0, "
"<varname>GEOMETRY_COLUMNS</varname> became a view with the same front-facing"
" structure as prior versions, but reading from database system catalogs Its "
"structure is as follows:"
msgstr "In Vorgängerversionen von PostGIS 2.0.0 war \"geometry_columns\" als Tabelle angelegt, die direkt editiert werden konnte und manchmal asynchron zur aktuellen Definition der Geometriespalte wurde. In PostGIS 2.0.0 wurde <varname>GEOMETRY_COLUMNS</varname> zu einem View, der nach aussen hin dieselbe Struktur wie die Tabelle der Vorgängerversionen aufweist, die Information jedoch aus dem Systemkatalog der Datenbank holt. Der View ist folgendermaßen aufgebaut:"

#. Tag: programlisting
#: using_postgis_dataman.xml:552
#, no-c-format
msgid "\\d geometry_columns"
msgstr "\\d geometry_columns"

#. Tag: screen
#: using_postgis_dataman.xml:553
#, no-c-format
msgid ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"
msgstr "View \"public.geometry_columns\"\n      Column       |          Type          | Modifiers\n-------------------+------------------------+-----------\n f_table_catalog   | character varying(256) |\n f_table_schema    | character varying(256) |\n f_table_name      | character varying(256) |\n f_geometry_column | character varying(256) |\n coord_dimension   | integer                |\n srid              | integer                |\n type              | character varying(30)  |"

#. Tag: para
#: using_postgis_dataman.xml:555
#, no-c-format
msgid "The column meanings have not changed from prior versions and are:"
msgstr "Die Bedeutung der Attribute hat sich seit den Vorgängerversionen nicht geändert:"

#. Tag: term
#: using_postgis_dataman.xml:559
#, no-c-format
msgid "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"
msgstr "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"

#. Tag: para
#: using_postgis_dataman.xml:562
#, no-c-format
msgid ""
"The fully qualified name of the feature table containing the geometry "
"column. Note that the terms \"catalog\" and \"schema\" are Oracle-ish. There"
" is not PostgreSQL analogue of \"catalog\" so that column is left blank -- "
"for \"schema\" the PostgreSQL schema name is used (<varname>public</varname>"
" is the default)."
msgstr "Der vollständige Name der Tabelle welche die Geometriespalte enthält. Die Bezeichnungen \"catalog\" und \"schema\" sind Oracle-isch. Es gibt keine Entsprechung in PostgreSQL für \"catalog\", weshalb diese Spalte leer bleibt - für \"schema\" wird der Name des Schemas in PostgreSQL verwendet (standardmäßig <varname>public</varname>)."

#. Tag: term
#: using_postgis_dataman.xml:571
#, no-c-format
msgid "F_GEOMETRY_COLUMN"
msgstr "F_GEOMETRY_COLUMN"

#. Tag: para
#: using_postgis_dataman.xml:574
#, no-c-format
msgid "The name of the geometry column in the feature table."
msgstr "Der Name der Geometriespalte in der Feature-Tabelle."

#. Tag: term
#: using_postgis_dataman.xml:579
#, no-c-format
msgid "COORD_DIMENSION"
msgstr "COORD_DIMENSION"

#. Tag: para
#: using_postgis_dataman.xml:582
#, no-c-format
msgid "The spatial dimension (2, 3 or 4 dimensional) of the column."
msgstr "Die räumliche Dimension (2-, 3- oder 4-dimensional) der Geometriespalte."

#. Tag: term
#: using_postgis_dataman.xml:588
#, no-c-format
msgid "<term>SRID</term>"
msgstr "<term>SRID</term>"

#. Tag: para
#: using_postgis_dataman.xml:591
#, no-c-format
msgid ""
"The ID of the spatial reference system used for the coordinate geometry in "
"this table. It is a foreign key reference to the "
"<varname>SPATIAL_REF_SYS</varname>."
msgstr "Der Identifikator des Koordinatenreferenzsystems, welches für die Geometrie in dieser Tabelle verwendet wird. Dieser ist ein Fremdschlüssel der sich auf die Tabelle <varname>SPATIAL_REF_SYS</varname> bezieht."

#. Tag: term
#: using_postgis_dataman.xml:598
#, no-c-format
msgid "TYPE"
msgstr "TYPE"

#. Tag: para
#: using_postgis_dataman.xml:601
#, no-c-format
msgid ""
"The type of the spatial object. To restrict the spatial column to a single "
"type, use one of: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, "
"MULTIPOLYGON, GEOMETRYCOLLECTION or corresponding XYM versions POINTM, "
"LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, "
"GEOMETRYCOLLECTIONM. For heterogeneous (mixed-type) collections, you can use"
" \"GEOMETRY\" as the type."
msgstr "Der Datentyp des Geoobjekts. Um die räumliche Spalte auf einen einzelnen Datentyp zu beschränken, benutzen Sie bitte: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION oder die entsprechenden XYM Versionen POINTM, LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM und GEOMETRYCOLLECTIONM. Für uneinheitliche Kollektionen (gemischete Datentypen) können Sie den Datentyp \"GEOMETRY\" verwenden."

#. Tag: para
#: using_postgis_dataman.xml:610
#, no-c-format
msgid ""
"This attribute is (probably) not part of the OpenGIS specification, but is "
"required for ensuring type homogeneity."
msgstr "Dieses Attribut gehört (wahrscheinlich) nicht zur OpenGIS Spezifikation, wird aber benötigt um homogene Datentypen zu gewährleisten."

#. Tag: title
#: using_postgis_dataman.xml:620
#, no-c-format
msgid "Creating a Spatial Table"
msgstr "Erstellung einer räumlichen Tabelle"

#. Tag: para
#: using_postgis_dataman.xml:622
#, no-c-format
msgid ""
"Creating a table with spatial data, can be done in one step. As shown in the"
" following example which creates a roads table with a 2D linestring geometry"
" column in WGS84 long lat"
msgstr "Die Erzeugung einer Tabelle mit spatialen Daten kann in einem Schritt ausgeführt werden. Dies wird im folgende Beispiel demonstriert, welches eine Straßentabelle mit einer geometrischen Spalte für 2D Linienzüge in WGS84 Länge/Breite erzeugt"

#. Tag: programlisting
#: using_postgis_dataman.xml:624
#, no-c-format
msgid ""
"CREATE TABLE ROADS ( ID int4\n"
"                , ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) );"
msgstr "CREATE TABLE ROADS ( ID int4\n                , ROAD_NAME varchar(25), geom geometry(LINESTRING,4326) );"

#. Tag: para
#: using_postgis_dataman.xml:626
#, no-c-format
msgid ""
"We can add additional columns using standard ALTER TABLE command as we do in"
" this next example where we add a 3-D linestring."
msgstr "Wir können zusätzliche Spalten hinzufügen, indem wir den normalen ALTER TABLE Befehl verwenden. Wir zeigen dies im nächsten Beispiel, wo wir einen 3D-Linienzug hinzufügen."

#. Tag: programlisting
#: using_postgis_dataman.xml:627
#, no-c-format
msgid "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"
msgstr "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"

#. Tag: para
#: using_postgis_dataman.xml:629
#, no-c-format
msgid ""
"For backwards compability, you can still create a spatial table in two "
"stages using the management functions."
msgstr "Aus Gründen der Abwärtskompatibilität können Sie eine räumliche Tabelle immer noch in zwei Schritten mit den Management Funktionen erstellen."

#. Tag: para
#: using_postgis_dataman.xml:633
#, no-c-format
msgid "Create a normal non-spatial table."
msgstr "Erstellen Sie zuerst eine normale, nicht-räumliche Tabelle."

#. Tag: para
#: using_postgis_dataman.xml:635
#, no-c-format
msgid ""
"For example: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME varchar(25) "
")</command>"
msgstr "Zum Beispiel: <command>CREATE TABLE ROADS ( ID int4, ROAD_NAME varchar(25) )</command>"

#. Tag: para
#: using_postgis_dataman.xml:640
#, no-c-format
msgid ""
"Add a spatial column to the table using the OpenGIS \"AddGeometryColumn\" "
"function. Refer to <xref linkend=\"AddGeometryColumn\"/> for more details."
msgstr "Eine räumliche Spalte zu einer Tabelle mit der OpenGIS Funktion \"AddGeometryColumn\" hinzufügen. Siehe <xref linkend=\"AddGeometryColumn\"/> für weitere Details."

#. Tag: para
#: using_postgis_dataman.xml:643
#, no-c-format
msgid ""
"The syntax is: <programlisting>AddGeometryColumn(\n"
"  &lt;schema_name&gt;,\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")</programlisting> Or, using current schema:"
msgstr "Die Syntax lautet: <programlisting>AddGeometryColumn(\n  &lt;schema_name&gt;,\n  &lt;table_name&gt;,\n  &lt;column_name&gt;,\n  &lt;srid&gt;,\n  &lt;type&gt;,\n  &lt;dimension&gt;\n)</programlisting> Oder, im aktuellen Schema:"

#. Tag: programlisting
#: using_postgis_dataman.xml:643
#, no-c-format
msgid ""
"AddGeometryColumn(\n"
"  &lt;table_name&gt;,\n"
"  &lt;column_name&gt;,\n"
"  &lt;srid&gt;,\n"
"  &lt;type&gt;,\n"
"  &lt;dimension&gt;\n"
")"
msgstr "AddGeometryColumn(\n  &lt;table_name&gt;,\n  &lt;column_name&gt;,\n  &lt;srid&gt;,\n  &lt;type&gt;,\n  &lt;dimension&gt;\n)"

#. Tag: para
#: using_postgis_dataman.xml:645
#, no-c-format
msgid ""
"Example1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"
msgstr "Beispiel1: <command>SELECT AddGeometryColumn('public', 'roads', 'geom', 423, 'LINESTRING', 2)</command>"

#. Tag: para
#: using_postgis_dataman.xml:648
#, no-c-format
msgid ""
"Example2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, "
"'LINESTRING', 2)</command>"
msgstr "Beispiel2: <command>SELECT AddGeometryColumn( 'roads', 'geom', 423, 'LINESTRING', 2)</command>"

#. Tag: para
#: using_postgis_dataman.xml:653
#, no-c-format
msgid ""
"Here is an example of SQL used to create a table and add a spatial column "
"(assuming that an SRID of 128 exists already):"
msgstr "Ein SQL-Beispiel das eine Tabelle erzeugt und eine räumliche Spalte hinzufügt (die Existenz einer SRID von 128 vorausgesetzt):"

#. Tag: programlisting
#: using_postgis_dataman.xml:656
#, no-c-format
msgid ""
"CREATE TABLE parks (\n"
"  park_id    INTEGER,\n"
"  park_name  VARCHAR,\n"
"  park_date  DATE,\n"
"  park_type  VARCHAR\n"
");\n"
"SELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"
msgstr "CREATE TABLE parks (\n  park_id    INTEGER,\n  park_name  VARCHAR,\n  park_date  DATE,\n  park_type  VARCHAR\n);\nSELECT AddGeometryColumn('parks', 'park_geom', 128, 'MULTIPOLYGON', 2 );"

#. Tag: para
#: using_postgis_dataman.xml:658
#, no-c-format
msgid ""
"Here is another example, using the generic \"geometry\" type and the "
"undefined SRID value of 0:"
msgstr "Ein anderes Beispiel, welches den allgemeinen \"geometry\" Datentyp und die unbestimmte SRID, mit dem Wert 0, verwendet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:661
#, no-c-format
msgid ""
"CREATE TABLE roads (\n"
"  road_id INTEGER,\n"
"  road_name VARCHAR\n"
");\n"
"SELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"
msgstr "CREATE TABLE roads (\n  road_id INTEGER,\n  road_name VARCHAR\n);\nSELECT AddGeometryColumn( 'roads', 'roads_geom', 0, 'GEOMETRY', 3 );"

#. Tag: title
#: using_postgis_dataman.xml:665
#, no-c-format
msgid "Manually Registering Geometry Columns in geometry_columns"
msgstr "Geometrische Spalten in \"geometry_columns\" händisch registrieren"

#. Tag: para
#: using_postgis_dataman.xml:666
#, no-c-format
msgid ""
"The AddGeometryColumn() approach creates a geometry column of specified "
"type. This type and dimension are queryable from the "
"<varname>geometry_columns</varname> view. Starting with PostGIS 2.0, "
"geometry_columns is no longer editable and all geometry columns are "
"autoregistered."
msgstr "Der Ansatz mit AddGeometryColumn() erzeugt eine Geometriespalte mit einem bestimmten Datentyp. Dieser Datentyp und die geometrische Dimension können über den View <varname>geometry_columns</varname> abgefragt werden. Ab PostGIS 2.0.0 werden sämtliche Geometriespalten automatisch registriert und \"geometry_columns\" kann nicht mehr editiert werden."

#. Tag: para
#: using_postgis_dataman.xml:669
#, no-c-format
msgid ""
"If your geometry columns were created as generic in a table or view and no "
"constraints applied, they will not have a dimension, type or srid in "
"geometry_columns views, but will still be listed."
msgstr "Wenn Ihre Geometriespalten in einer Tabelle oder einem View generisch erstellt wurden und keine Constraints zugewiesen haben, so werden diese in dem View \"geometry_columns\" zwar aufgelistet, haben aber keine Dimension, keinen Datentyp und keine SRID."

#. Tag: para
#: using_postgis_dataman.xml:671
#, no-c-format
msgid ""
"Two of the cases where this may happen, but you can't use AddGeometryColumn,"
" is in the case of SQL Views and bulk inserts. For bulk insert case, you can"
" correct the registration in the geometry_columns table by constraining the "
"column or doing an alter table. For views, you could expose using a CAST "
"operation. Note in PostGIS 2.0+ if your column is typmod based, the creation"
" process would register it correctly, so no need to do anything. Also views "
"that have no spatial function applied to the geometry will register the same"
" as the underlying table geometry column."
msgstr "Zwei Fälle bei denen dies passieren kann und wo Sie die Funktion \"AddGeometryColumn\" nicht verwenden können sind SQL-Views und Masseninserts. Beim Fall von Masseninserts können Sie die Registrierung in der Tabelle \"geometry_columns\" korrigieren, indem Sie auf die Spalte einen CONSTRAINT setzen oder ein \"ALTER TABLE\" durchführen. Ab PostGIS 2.0, falls Ihre Spalte Typmod basiert ist, geschieht die Registrierung beim Erstellungsprozess auf korrekte Weise, so dass Sie hier nichts tun müssen. Auch Views, bei denen keine räumliche Funktion auf die Geometrie angewendet wird, werden auf gleiche Weise wie die Geometrie der zugrunde liegenden Tabelle registriert."

#. Tag: programlisting
#: using_postgis_dataman.xml:678
#, no-c-format
msgid ""
"--Lets say you have a view created like this\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- For it to register correctly in PostGIS 2.0+\n"
"-- You need to cast the geometry\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- If you know the geometry type for sure is a 2D POLYGON then you could do\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As geom, f_name\n"
"        FROM public.mytable;"
msgstr "--Angenommen Sie erzeugen folgende gespeicherte Abfrage\nCREATE VIEW  public.vwmytablemercator AS\n        SELECT gid, ST_Transform(geom,3395) As geom, f_name\n        FROM public.mytable;\n\n-- Um diese in PostGIS 2.0+ richtig zu registrieren\n-- benötigt es eine Typumwandlung der Geometrie\n--\nDROP VIEW public.vwmytablemercator;\nCREATE VIEW  public.vwmytablemercator AS\n        SELECT gid, ST_Transform(geom,3395)::geometry(Geometry, 3395) As geom, f_name\n        FROM public.mytable;\n\n-- Wenn Sie sicher sind, das es sich bei der Geometrie um ein 2D-Polygon handelt, können Sie folgendes tun\nDROP VIEW public.vwmytablemercator;\nCREATE VIEW  public.vwmytablemercator AS\n        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As geom, f_name\n        FROM public.mytable;"

#. Tag: programlisting
#: using_postgis_dataman.xml:679
#, no-c-format
msgid ""
"--Lets say you created a derivative table by doing a bulk insert\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"--Create 2d index on new table\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"\n"
"-- If your points are 3D points or 3M points,\n"
"-- then you might want to create an nd index instead of a 2d index\n"
"-- like so\n"
"CREATE INDEX my_special_pois_geom_gist_nd\n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"--To manually register this new table's geometry column in geometry_columns\n"
"-- Note that this approach will work for both PostGIS 2.0+ and PostGIS 1.4+\n"
"-- For PostGIS 2.0 it will also change the underlying structure of the table to\n"
"-- to make the column typmod based.\n"
"-- For PostGIS prior to 2.0, this technique can also be used to register views\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n"
"\n"
"--If you are using PostGIS 2.0 and for whatever reason, you\n"
"-- you need the old constraint based definition behavior\n"
"-- (such as case of inherited tables where all children do not have the same type and srid)\n"
"-- set new optional  use_typmod argument to false\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, false);"
msgstr "--Angenommen Sie haben eine abgeleitete Tabelle über ein Masseninsert erzeugt\nSELECT poi.gid, poi.geom, citybounds.city_name\nINTO myschema.my_special_pois\nFROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n\n--Einen 2D Index auf die neue Tabelle legen\nCREATE INDEX idx_myschema_myspecialpois_geom_gist\n  ON myschema.my_special_pois USING gist(geom);\n\n-- Falls Ihre Punkte 3D-Punkte oder 3M-Punkte sind,\n-- können Sie einen ND-Index anstatt eines 2D-Indexes erstellen\n-- das geht so:\nCREATE INDEX my_special_pois_geom_gist_nd\n        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n\n-- Um die Geometriespalte der neuen Tabelle in geometry_columns händisch zu registrieren\n-- Beachten Sie bitte, dass dieser Ansatz sowohl für PostGIS2.0+ als auch für PostGIS 1.4+ funktioniert\n-- Bei PostGIS 2.0+ wird dabei auch die zugrundeliegende Struktur der Tabelle geändert\n-- um die Spalte Typmod basiert zu machen.\n-- Bei Vorgängerversionen von PostGIS 2.0, kann diese Methode auch verwendet werden, um Views zu registrieren\nSELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n\n-- Wenn Sie PostGIS 2.0 verwenden und aus welchem Grund auch immer\n-- das alte Verhalten mit auf CONSTRAINTs basierender Definition benötigen\n-- (wie im Fall von vererbten Tabellen bei denen nicht alle Kindtabellen denselben Datentyp und dieselbe SRID aufweisen)\n-- das neue optionale Argument \"use_typmod\" auf FALSE setzen\nSELECT populate_geometry_columns('myschema.my_special_pois'::regclass, false);"

#. Tag: para
#: using_postgis_dataman.xml:681
#, no-c-format
msgid ""
"Although the old-constraint based method is still supported, a constraint-"
"based geometry column used directly in a view, will not register correctly "
"in geometry_columns, as will a typmod one. In this example we define a "
"column using typmod and another using constraints."
msgstr "Obwohl die alte auf CONSTRAINTs basierte Methode immer noch unterstützt wird, wird eine auf Constraints basierende Geometriespalte, die direkt in einem View verwendet wird, nicht korrekt in geometry_columns registriert. Eine Typmod basierte wird korrekt registriert. Im folgenden Beispiel definieren wir eine Spalte mit Typmod und eine andere mit Constraints."

#. Tag: programlisting
#: using_postgis_dataman.xml:684
#, no-c-format
msgid ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY\n"
"   , poi_name text, cat varchar(20)\n"
"   , geom geometry(POINT,4326) );\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"
msgstr "CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY\n   , poi_name text, cat varchar(20)\n   , geom geometry(POINT,4326) );\nSELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"

#. Tag: para
#: using_postgis_dataman.xml:685
#, no-c-format
msgid "If we run in psql"
msgstr "In psql:"

#. Tag: programlisting
#: using_postgis_dataman.xml:686
#, no-c-format
msgid "\\d pois_ny;"
msgstr "\\d pois_ny;"

#. Tag: para
#: using_postgis_dataman.xml:687
#, no-c-format
msgid ""
"We observe they are defined differently -- one is typmod, one is constraint"
msgstr "Wir sehen, das diese Spalten unterschiedlich definiert sind -- eine mittels Typmodifizierer, eine nutzt einen Constraint"

#. Tag: screen
#: using_postgis_dataman.xml:688
#, no-c-format
msgid ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------+------------------------------------------------------\n"
" gid       | integer               | not null default nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"
msgstr "Table \"public.pois_ny\"\n  Column   |         Type          |                       Modifiers\n\n-----------+-----------------------+------------------------------------------------------\n gid       | integer               | not null default nextval('pois_ny_gid_seq'::regclass)\n poi_name  | text                  |\n cat       | character varying(20) |\n geom      | geometry(Point,4326)  |\n geom_2160 | geometry              |\nIndexes:\n    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\nCheck constraints:\n    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::text\n        OR geom_2160 IS NULL)\n    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"

#. Tag: para
#: using_postgis_dataman.xml:689
#, no-c-format
msgid "In geometry_columns, they both register correctly"
msgstr "Beide registrieren sich korrekt in \"geometry_columns\""

#. Tag: programlisting
#: using_postgis_dataman.xml:690
#, no-c-format
msgid ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"
msgstr "SELECT f_table_name, f_geometry_column, srid, type\n        FROM geometry_columns\n        WHERE f_table_name = 'pois_ny';"

#. Tag: screen
#: using_postgis_dataman.xml:691
#, no-c-format
msgid ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"
msgstr "f_table_name | f_geometry_column | srid | type\n-------------+-------------------+------+-------\npois_ny      | geom              | 4326 | POINT\npois_ny      | geom_2160         | 2160 | POINT"

#. Tag: para
#: using_postgis_dataman.xml:692
#, no-c-format
msgid "However -- if we were to create a view like this"
msgstr "Jedoch -- wenn wir einen View auf die folgende Weise erstellen"

#. Tag: programlisting
#: using_postgis_dataman.xml:693
#, no-c-format
msgid ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr "CREATE VIEW vw_pois_ny_parks AS\nSELECT *\n  FROM pois_ny\n  WHERE cat='park';\n\nSELECT f_table_name, f_geometry_column, srid, type\n        FROM geometry_columns\n        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: para
#: using_postgis_dataman.xml:694
#, no-c-format
msgid ""
"The typmod based geom view column registers correctly, but the constraint "
"based one does not."
msgstr "Die Typmod basierte geometrische Spalte eines View registriert sich korrekt, die auf Constraint basierende nicht."

#. Tag: screen
#: using_postgis_dataman.xml:696
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"
msgstr "f_table_name   | f_geometry_column | srid |   type\n------------------+-------------------+------+----------\n vw_pois_ny_parks | geom              | 4326 | POINT\n vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"

#. Tag: para
#: using_postgis_dataman.xml:698
#, no-c-format
msgid ""
"This may change in future versions of PostGIS, but for now To force the "
"constraint based view column to register correctly, we need to do this:"
msgstr "Dies kann sich bei zukünftigen Versionen von PostGIS ändern, vorerst müssen Sie aber folgendes ausführen, um die auf Constraint basierende Spalte eines View korrekt zu registrieren:"

#. Tag: programlisting
#: using_postgis_dataman.xml:700
#, no-c-format
msgid ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT gid, poi_name, cat\n"
"  , geom\n"
"  , geom_2160::geometry(POINT,2160) As geom_2160\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr "DROP VIEW vw_pois_ny_parks;\nCREATE VIEW vw_pois_ny_parks AS\nSELECT gid, poi_name, cat\n  , geom\n  , geom_2160::geometry(POINT,2160) As geom_2160\n  FROM pois_ny\n  WHERE cat='park';\nSELECT f_table_name, f_geometry_column, srid, type\n        FROM geometry_columns\n        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: screen
#: using_postgis_dataman.xml:701
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"
msgstr "f_table_name   | f_geometry_column | srid | type\n------------------+-------------------+------+-------\n vw_pois_ny_parks | geom              | 4326 | POINT\n vw_pois_ny_parks | geom_2160         | 2160 | POINT"

#. Tag: title
#: using_postgis_dataman.xml:705
#, no-c-format
msgid "Ensuring OpenGIS compliancy of geometries"
msgstr "Wahrung der OGC-Konformität von Geometrien"

#. Tag: para
#: using_postgis_dataman.xml:707
#, no-c-format
msgid ""
"PostGIS is compliant with the Open Geospatial Consortium’s (OGC) OpenGIS "
"Specifications. As such, many PostGIS methods require, or more accurately, "
"assume that geometries that are operated on are both simple and valid. For "
"example, it does not make sense to calculate the area of a polygon that has "
"a hole defined outside of the polygon, or to construct a polygon from a non-"
"simple boundary line."
msgstr "PostGIS ist mit den Open Geospatial Consortium (OGC) OpenGIS Spezifikationen konform. Daher setzen viele PostGIS Methoden voraus, dass die Geometrien mit denen sie rechnen sowohl \"Simple\" als auch \"Valid\" sind . Zum Beispiel hat es keinen Sinn, die Fläche eines Polygons zu berechnen, das eine Insel aufweist die ausserhalb des Polygons festgelegt ist, oder ein Polygon aus einer Begrenzungslinie zu konstruieren, welche nicht \"simple\" ist."

#. Tag: para
#: using_postgis_dataman.xml:714
#, no-c-format
msgid ""
"According to the OGC Specifications, a <emphasis>simple</emphasis> geometry "
"is one that has no anomalous geometric points, such as self intersection or "
"self tangency and primarily refers to 0 or 1-dimensional geometries (i.e. "
"<varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). Geometry validity, on "
"the other hand, primarily refers to 2-dimensional geometries (i.e. "
"<varname>[MULTI]POLYGON)</varname> and defines the set of assertions that "
"characterizes a valid polygon. The description of each geometric class "
"includes specific conditions that further detail geometric simplicity and "
"validity."
msgstr "Entsprechend der OGC Spezifikationen ist eine <emphasis>simple/einfache</emphasis> Geometrie eine solche, die sich nicht selbst überschneidet oder berührt und bezieht sich in erster Linie auf 0- und 1-dimensionale Geometrien (insbesondere <varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). Andererseits bezieht sich die Validität/Gültigkeit einer Geometrie hauptsächlich auf 2-dimensionale Geometrien (insbesondere <varname>[MULTI]POLYGON)</varname> und definiert die Menge an Aussagen, welche ein valides/gültiges Polygon auszeichnen. Die Beschreibung einer jeden geometrischen Klasse schließt bestimmte Bedingungen mit ein, welche die Simplizität und Validität von Geometrien näher beschreiben."

#. Tag: para
#: using_postgis_dataman.xml:724
#, no-c-format
msgid ""
"A <varname>POINT</varname> is inheritably <emphasis>simple</emphasis> as a "
"0-dimensional geometry object."
msgstr "Da ein <varname>POINT</varname> ein 0-dimensionales geometrisches Objekt ist, ist er von vornherein <emphasis>simple</emphasis>."

#. Tag: para
#: using_postgis_dataman.xml:727
#, no-c-format
msgid ""
"<varname>MULTIPOINT</varname>s are <emphasis>simple</emphasis> if no two "
"coordinates (<varname>POINT</varname>s) are equal (have identical coordinate"
" values)."
msgstr "<varname>MULTIPOINT</varname>s sind <emphasis>simple</emphasis>, if no two coordinates wenn sich nicht zwei Koordinate (<varname>POINT</varname>s) decken (identische Koordinatenpaare)."

#. Tag: para
#: using_postgis_dataman.xml:731
#, no-c-format
msgid ""
"A <varname>LINESTRING</varname> is <emphasis>simple</emphasis> if it does "
"not pass through the same <varname>POINT</varname> twice (except for the "
"endpoints, in which case it is referred to as a linear ring and additionally"
" considered closed)."
msgstr "Ein <varname>LINESTRING</varname> ist <emphasis>simple</emphasis>, wenn er nicht zweimal durch denselben <varname>POINT</varname> geht (ausgenommen bei Endpunkten, wo dieser als linearer Ring benannt wird und zusätzlich als geschlossen angesehen wird)."

#. Tag: emphasis
#: using_postgis_dataman.xml:746
#, no-c-format
msgid "<emphasis>(a)</emphasis>"
msgstr "<emphasis>(a)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:756
#, no-c-format
msgid "<emphasis>(b)</emphasis>"
msgstr "<emphasis>(b)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:768
#, no-c-format
msgid "<emphasis>(c)</emphasis>"
msgstr "<emphasis>(c)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:778
#, no-c-format
msgid "<emphasis>(d)</emphasis>"
msgstr "<emphasis>(d)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:788
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(a)</emphasis> and <emphasis "
"role=\"bold\">(c)</emphasis> are simple <varname>LINESTRING</varname>s, "
"<emphasis role=\"bold\">(b)</emphasis> and <emphasis "
"role=\"bold\">(d)</emphasis> are not."
msgstr "<emphasis role=\"bold\">(a)</emphasis> und <emphasis role=\"bold\">(c)</emphasis> sind simple <varname>LINESTRING</varname>s, <emphasis role=\"bold\">(b)</emphasis> und <emphasis role=\"bold\">(d)</emphasis> nicht."

#. Tag: para
#: using_postgis_dataman.xml:797
#, no-c-format
msgid ""
"A <varname>MULTILINESTRING</varname> is <emphasis>simple</emphasis> only if "
"all of its elements are simple and the only intersection between any two "
"elements occurs at <varname>POINT</varname>s that are on the boundaries of "
"both elements."
msgstr "Ein <varname>MULTILINESTRING</varname> ist nur dann <emphasis>simple</emphasis>, wenn alle seine Elemente \"simple\" sind und die einzigen Überschneidungen zwischen zwei Elementen nur an jenen <varname>POINT</varname>s auftreten, die an den Begrenzungen der beiden Elemente liegen."

#. Tag: emphasis
#: using_postgis_dataman.xml:812
#, no-c-format
msgid "<emphasis>(e)</emphasis>"
msgstr "<emphasis>(e)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:822
#, no-c-format
msgid "<emphasis>(f)</emphasis>"
msgstr "<emphasis>(f)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:832
#, no-c-format
msgid "<emphasis>(g)</emphasis>"
msgstr "<emphasis>(g)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:842
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(e)</emphasis> and <emphasis "
"role=\"bold\">(f)</emphasis> are simple <varname>MULTILINESTRING</varname>s,"
" <emphasis role=\"bold\">(g)</emphasis> is not."
msgstr "<emphasis role=\"bold\">(e)</emphasis> und <emphasis role=\"bold\">(f)</emphasis> sind simple <varname>MULTILINESTRING</varname>s, <emphasis role=\"bold\">(g)</emphasis> nicht."

#. Tag: para
#: using_postgis_dataman.xml:851
#, no-c-format
msgid ""
"By definition, a <varname>POLYGON</varname> is always "
"<emphasis>simple</emphasis>. It is <emphasis>valid</emphasis> if no two "
"rings in the boundary (made up of an exterior ring and interior rings) "
"cross. The boundary of a <varname>POLYGON</varname> may intersect at a "
"<varname>POINT</varname> but only as a tangent (i.e. not on a line). A "
"<varname>POLYGON</varname> may not have cut lines or spikes and the interior"
" rings must be contained entirely within the exterior ring."
msgstr "Definitionsgemäß ist ein <varname>POLYGON</varname> immer <emphasis>simple</emphasis>. Es ist <emphasis>valid</emphasis>, wenn sich keine zwei Ringe an der Begrenzung (bestehend aus einem äußeren Ring und inneren Ringen) kreuzen. Die Begrenzung eines <varname>POLYGON</varname>s darf an einem <varname>POINT</varname> schneiden, allerdings nur als Tangente (insbesondere nicht an einer Linie). Ein <varname>POLYGON</varname> darf keine Schnittlinien oder \"Spikes\" aufweisen und die inneren Ringe müssen zur Gänze im äußeren Ring enthalten sein."

#. Tag: emphasis
#: using_postgis_dataman.xml:869
#, no-c-format
msgid "<emphasis>(h)</emphasis>"
msgstr "<emphasis>(h)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:879
#, no-c-format
msgid "<emphasis>(i)</emphasis>"
msgstr "<emphasis>(i)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:889
#, no-c-format
msgid "<emphasis>(j)</emphasis>"
msgstr "<emphasis>(j)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:901
#, no-c-format
msgid "<emphasis>(k)</emphasis>"
msgstr "<emphasis>(k)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:911
#, no-c-format
msgid "<emphasis>(l)</emphasis>"
msgstr "<emphasis>(l)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:921
#, no-c-format
msgid "<emphasis>(m)</emphasis>"
msgstr "<emphasis>(m)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:930
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(h)</emphasis> and <emphasis "
"role=\"bold\">(i)</emphasis> are valid <varname>POLYGON</varname>s, "
"<emphasis role=\"bold\">(j-m)</emphasis> cannot be represented as single "
"<varname>POLYGON</varname>s, but <emphasis role=\"bold\">(j)</emphasis> and "
"<emphasis role=\"bold\">(m)</emphasis> could be represented as a valid "
"<varname>MULTIPOLYGON</varname>."
msgstr "<emphasis role=\"bold\">(h)</emphasis> und <emphasis role=\"bold\">(i)</emphasis> sind valide <varname>POLYGON</varname>e, <emphasis role=\"bold\">(j-m)</emphasis> können nicht als einzelne <varname>POLYGON</varname>e dargestellt werden, aber <emphasis role=\"bold\">(j)</emphasis> und <emphasis role=\"bold\">(m)</emphasis> können als ein valides <varname>MULTIPOLYGON</varname> dargestellt werden."

#. Tag: para
#: using_postgis_dataman.xml:942
#, no-c-format
msgid ""
"A <varname>MULTIPOLYGON</varname> is <emphasis>valid</emphasis> if and only "
"if all of its elements are valid and the interiors of no two elements "
"intersect. The boundaries of any two elements may touch, but only at a "
"finite number of <varname>POINT</varname>s."
msgstr "Ein <varname>MULTIPOLYGON</varname> ist dann und nur dann <emphasis>valid</emphasis>e, wenn alle seine Elemente valide sind und sich das Innere zweier Elemente nicht überschneidet. Die Begrenzungen zweier Elemente können sich berühren, allerdings nur an einer endlichen Anzahl von <varname>POINT</varname>s."

#. Tag: emphasis
#: using_postgis_dataman.xml:957
#, no-c-format
msgid "<emphasis>(n)</emphasis>"
msgstr "<emphasis>(n)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:967
#, no-c-format
msgid "<emphasis>(o)</emphasis>"
msgstr "<emphasis>(o)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:977
#, no-c-format
msgid "<emphasis>(p)</emphasis>"
msgstr "<emphasis>(p)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:986
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(n)</emphasis> and <emphasis "
"role=\"bold\">(o)</emphasis> are not valid <varname>MULTIPOLYGON</varname>s."
" <emphasis role=\"bold\">(p)</emphasis>, however, is valid."
msgstr "<emphasis role=\"bold\">(n)</emphasis> und <emphasis role=\"bold\">(o)</emphasis> sind keine validen <varname>MULTIPOLYGON</varname>e. Hingegen ist <emphasis role=\"bold\">(p)</emphasis> valid."

#. Tag: para
#: using_postgis_dataman.xml:995
#, no-c-format
msgid ""
"Most of the functions implemented by the GEOS library rely on the assumption"
" that your geometries are valid as specified by the OpenGIS Simple Feature "
"Specification. To check simplicity or validity of geometries you can use the"
" <link linkend=\"ST_IsSimple\">ST_IsSimple()</link> and <link "
"linkend=\"ST_IsValid\">ST_IsValid()</link>"
msgstr "Die meisten der von der GEOS Bibliothek implementierten Funktionen beruhen auf der Annahme, dass Ihre Geometrien entsprechend der OpenGIS Simple Feature Spezifikation, valide sind. Um die Simplizität und Validität von Geometrien festzustellen, können Sie <link linkend=\"ST_IsSimple\">ST_IsSimple()</link> und <link linkend=\"ST_IsValid\">ST_IsValid()</link> verwenden."

#. Tag: programlisting
#: using_postgis_dataman.xml:1001
#, no-c-format
msgid ""
"-- Typically, it doesn't make sense to check\n"
"-- for validity on linear features since it will always return TRUE.\n"
"-- But in this example, PostGIS extends the definition of the OGC IsValid\n"
"-- by returning false if a LineString has less than 2 *distinct* vertices.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"
msgstr "-- Üblicherweise hat es keinen Sinn lineare Geometrien\n-- auf Validität zu überprüfen, da immer TRUE zurückgegeben wird.\n-- Aber in diesem Beispiel erweitert PostGIS die OGC Definition von IsValid\n-- indem es FALSE zurückgibt, wenn ein LineString weniger als 2 *eindeutige* Stützpunkte aufweist.\ngisdb=# SELECT\n   ST_IsValid('LINESTRING(0 0, 1 1)'),\n   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n\n st_isvalid | st_isvalid\n------------+-----------\n      t     |     f"

#. Tag: para
#: using_postgis_dataman.xml:1003
#, no-c-format
msgid ""
"By default, PostGIS does not apply this validity check on geometry input, "
"because testing for validity needs lots of CPU time for complex geometries, "
"especially polygons. If you do not trust your data sources, you can manually"
" enforce such a check to your tables by adding a check constraint:"
msgstr "Standardmäßig überprüft PostGIS eine Geometrieeingabe nicht auf Validität, da Validitätstests von komplexen Geometrien, insbesondere Polygonen, viel CPU Zeit beanspruchen. Fall Sie Ihren Datenquellen nicht    trauen, können Sie eine Überprüfung Ihrer Tabellen durch eine \"Check Constraint\"/Prüfbeschränkung erzwingen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1009
#, no-c-format
msgid ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"
msgstr "ALTER TABLE mytable\n  ADD CONSTRAINT geometry_valid_check\n        CHECK (ST_IsValid(the_geom));"

#. Tag: para
#: using_postgis_dataman.xml:1011
#, no-c-format
msgid ""
"If you encounter any strange error messages such as \"GEOS Intersection() "
"threw an error!\" or \"JTS Intersection() threw an error!\" when calling "
"PostGIS functions with valid input geometries, you likely found an error in "
"either PostGIS or one of the libraries it uses, and you should contact the "
"PostGIS developers. The same is true if a PostGIS function returns an "
"invalid geometry for valid input."
msgstr "Falls Sie irgendwelche seltsamen Fehlermeldungen, wie \"GEOS Intersection() threw an error!\" oder \"JTS Intersection() threw an error!\", erhalten, obwohl sie eine PostGIS Funktion mit validen Eingabegemetrien aufgerufen haben, ist es wahrscheinlich dass Sie einen Fehler in PostGIS oder einer von PostGIS verwendeten Bibliothek gefunden haben. In diesem Fall sollten Sie das PostGIS Entwicklerteam kontaktieren. Dasselbe gilt, wenn eine PostGIS Funktion auf eine valide Eingabegeometrie eine invalide Geometrie zurückgibt."

#. Tag: para
#: using_postgis_dataman.xml:1019
#, no-c-format
msgid ""
"Strictly compliant OGC geometries cannot have Z or M values. The <link "
"linkend=\"ST_IsValid\">ST_IsValid()</link> function won't consider higher "
"dimensioned geometries invalid! Invocations of <link "
"linkend=\"AddGeometryColumn\">AddGeometryColumn()</link> will add a "
"constraint checking geometry dimensions, so it is enough to specify 2 there."
msgstr "Eine streng konforme OGC-Geometrie hat keine Z- oder M-Werte. Die Funktion <link linkend=\"ST_IsValid\">ST_IsValid()</link> betrachtet höhere geometrische Dimensionen nicht als invalide! Aufrufe von <link linkend=\"AddGeometryColumn\">AddGeometryColumn()</link> fügen eine Check-Constraint für die geometrische Dimension hinzu, weshalb es hier ausreicht 2 anzugeben."

#. Tag: title
#: using_postgis_dataman.xml:1029
#, no-c-format
msgid "Dimensionally Extended 9 Intersection Model (DE-9IM)"
msgstr "DE-9IM-Matrix (DE-9IM)"

#. Tag: para
#: using_postgis_dataman.xml:1031
#, no-c-format
msgid ""
"It is sometimes the case that the typical spatial predicates (<xref "
"linkend=\"ST_Contains\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>, ...) are "
"insufficient in and of themselves to adequately provide that desired spatial"
" filter."
msgstr "Manchmal kommt es vor, dass die typischen räumlichen Aussagen (<xref linkend=\"ST_Contains\"/>, <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>, ...) an sich nicht ausreichen, um den verlangten räumlichen Filter auf geeignete Weise zu liefern.  "

#. Tag: para
#: using_postgis_dataman.xml:1043
#, no-c-format
msgid ""
"For example, consider a linear dataset representing a road network. It may "
"be the task of a GIS analyst to identify all road segments that cross each "
"other, not at a point, but on a line, perhaps invalidating some business "
"rule. In this case, <xref linkend=\"ST_Crosses\"/> does not adequately "
"provide the necessary spatial filter since, for linear features, it returns "
"<varname>true</varname> only where they cross at a point."
msgstr "Betrachten Sie zum Beispiel einen linearen Datensatz, der ein Straßennetz darstellt. Es kann sein, dass ein GIS-Analyst die Aufgabe hat, alle Straßenabschnitte herauszufinden, die sich gegenseitig nicht an einem Punkt sondern entlang einer Linie kreuzen, da dies möglicherweise irgendeiner Unternehmensvorschrift wiederspricht. In diesem Fall liefert <xref linkend=\"ST_Crosses\"/> nicht den passenden räumlichen Filter, da bei linearen Geoobjekten nur dann <varname>TRUE</varname> zurückgeben wird wenn sie sich an einem Punkt kreuzen."

#. Tag: para
#: using_postgis_dataman.xml:1050
#, no-c-format
msgid ""
"One two-step solution might be to first perform the actual intersection "
"(<xref linkend=\"ST_Intersection\"/>) of pairs of road segments that "
"spatially intersect (<xref linkend=\"ST_Intersects\"/>), and then compare "
"the intersection's <xref linkend=\"ST_GeometryType\"/> with "
"'<varname>LINESTRING</varname>' (properly dealing with cases that return "
"<varname>GEOMETRYCOLLECTION</varname>s of <varname>[MULTI]POINT</varname>s, "
"<varname>[MULTI]LINESTRING</varname>s, etc.)."
msgstr "Eine zweistufige Lösung kann sein, dass man zuerst die eigentliche Verschneidung (<xref linkend=\"ST_Intersection\"/>) von  Straßenabschnittspaaren die sich räumlich überschneiden (<xref linkend=\"ST_Intersects\"/>) ausführt, und anschließend den <xref linkend=\"ST_GeometryType\"/> der Verschneidung mit '<varname>LINESTRING</varname>' vergleicht (vermutlich muss man sich mit Fällen auseinandersetzen die <varname>GEOMETRYCOLLECTION</varname>s von <varname>[MULTI]POINT</varname>s, <varname>[MULTI]LINESTRING</varname>s, etc. zurückgeben)."

#. Tag: para
#: using_postgis_dataman.xml:1058
#, no-c-format
msgid "A more elegant / faster solution may indeed be desirable."
msgstr "Eine elegantere/schnellere Lösung wäre sicherlich wünschenswert."

#. Tag: para
#: using_postgis_dataman.xml:1072
#, no-c-format
msgid ""
"A second [theoretical] example may be that of a GIS analyst trying to locate"
" all wharfs or docks that intersect a lake's boundary on a line and where "
"only one end of the wharf is up on shore. In other words, where a wharf is "
"within, but not completely within a lake, intersecting the boundary of a "
"lake on a line, and where the wharf's endpoints are both completely within "
"and on the boundary of the lake. The analyst may need to use a combination "
"of spatial predicates to isolate the sought after features:"
msgstr "Ein zweites [theoretisches] Beispiel wäre, dass ein GIS-Analyst versucht alle Anlegestellen oder Kais welche die Begrenzung eines Sees entlang einer Linie überschneiden und bei denen nur ein Ende der Anlegestelle an der Küste liegt. Anders ausgedrückt, wo ein Kai im, aber nicht zur Gänze im See liegt, da er den See entlang einer Linie schneidet und seine Endpunkte sowohl zur Gänze in und auf der Begrenzung des Sees liegen. Dazu kann es nötig sein, dass der Analyst eine Kombination von Aussagen ausführen muss, um die gesuchten Geoobjekte herauszufiltern:"

#. Tag: para
#: using_postgis_dataman.xml:1083
#, no-c-format
msgid "(lake, wharf) = TRUE"
msgstr "(lake, wharf) = TRUE"

#. Tag: para
#: using_postgis_dataman.xml:1087
#, no-c-format
msgid "(lake, wharf) = FALSE"
msgstr "(lake, wharf) = FALSE"

#. Tag: para
#: using_postgis_dataman.xml:1091
#, no-c-format
msgid "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"
msgstr "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"

#. Tag: para
#: using_postgis_dataman.xml:1096
#, no-c-format
msgid ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) ="
" 1"
msgstr "(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = 1"

#. Tag: para
#: using_postgis_dataman.xml:1099
#, no-c-format
msgid "... (needless to say, this could get quite complicated)"
msgstr "... (überflüssig zu erwähnen, das dies ziemlich kompliziert werden kann)"

#. Tag: para
#: using_postgis_dataman.xml:1108
#, no-c-format
msgid ""
"So enters the Dimensionally Extended 9 Intersection Model, or DE-9IM for "
"short."
msgstr "Somit stürzen wir uns auf die DE-9IM-Matrix, oder kurz DE-9IM"

#. Tag: title
#: using_postgis_dataman.xml:1112
#, no-c-format
msgid "Theory"
msgstr "Theorie"

#. Tag: para
#: using_postgis_dataman.xml:1114
#, no-c-format
msgid ""
"According to the <ulink "
"url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple Features "
"Implementation Specification for SQL</ulink>, \"the basic approach to "
"comparing two geometries is to make pair-wise tests of the intersections "
"between the Interiors, Boundaries and Exteriors of the two geometries and to"
" classify the relationship between the two geometries based on the entries "
"in the resulting 'intersection' matrix.\""
msgstr "Entsprechend der <ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, \"Der grundlegende Ansatz um zwei Geometrien zu vergleichen, besteht in einer paarweisen Überprüfung des Inneren, der Begrenzung und des Äusseren zweier Geometrien und der Einstufung der Beziehung zwischen den zwei Geometrien an Hand den Einträgen in die resultierende 'Verschneidungs'-Matrix.\" [frei übersetzt]"

#. Tag: glossterm
#: using_postgis_dataman.xml:1125
#, no-c-format
msgid "<glossterm>Boundary</glossterm>"
msgstr "<glossterm>Boundary</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1128
#, no-c-format
msgid ""
"The boundary of a geometry is the set of geometries of the next lower "
"dimension. For <varname>POINT</varname>s, which have a dimension of 0, the "
"boundary is the empty set. The boundary of a <varname>LINESTRING</varname> "
"are the two endpoints. For <varname>POLYGON</varname>s, the boundary is the "
"linework that make up the exterior and interior rings."
msgstr "Die Begrenzung einer Geometrie ist die geometrische Grundmenge der nächst kleineren Dimension. Bei <varname>POINT</varname>s, die die Dimension 0 haben ist die Begrenzung die leere Menge. Die Begrenzung eines <varname>LINESTRING</varname>s sind die zwei Endpunkte. Bei <varname>POLYGON</varname>en entspricht die Begrenzung jenen Linien, die die äußeren und inneren Ringe zusammensetzen."

#. Tag: glossterm
#: using_postgis_dataman.xml:1139
#, no-c-format
msgid "<glossterm>Interior</glossterm>"
msgstr "<glossterm>Interior</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1142
#, no-c-format
msgid ""
"The interior of a geometry are those points of a geometry that are left when"
" the boundary is removed. For <varname>POINT</varname>s, the interior is the"
" <varname>POINT</varname> itself. The interior of a "
"<varname>LINESTRING</varname> are the set of real points between the "
"endpoints. For <varname>POLYGON</varname>s, the interior is the areal "
"surface inside the polygon."
msgstr "Die Innenseite/interior einer Geometrie besteht aus jenen Punkten einer Geometrie, die zurückbleiben, wenn die Außenbegrenzung/boundary entfernt wird. Bei <varname>POINT</varname>s ist die Innenseite der <varname>POINT</varname> selbst. Die Innenseite eines <varname>LINESTRING</varname>s ist die Menge der echten Punkte zwischen den Endpunkten. Bei <varname>POLYGON</varname>en entspricht die Innenseite der Fläche innerhalb des Polygons."

#. Tag: glossterm
#: using_postgis_dataman.xml:1153
#, no-c-format
msgid "<glossterm>Exterior</glossterm>"
msgstr "<glossterm>Exterior</glossterm>"

#. Tag: para
#: using_postgis_dataman.xml:1156
#, no-c-format
msgid ""
"The exterior of a geometry is the universe, an areal surface, not on the "
"interior or boundary of the geometry."
msgstr "Die Außenseite/exterior einer Geometrie ist durch die Grundgesamtheit gegeben. Das ist jene Fläche, die nicht auf der Innenseite/interior oder auf der Begrenzung der Geometrie liegt."

#. Tag: para
#: using_postgis_dataman.xml:1163
#, no-c-format
msgid ""
"Given geometry <emphasis>a</emphasis>, where the <emphasis>I(a)</emphasis>, "
"<emphasis>B(a)</emphasis>, and <emphasis>E(a)</emphasis> are the "
"<emphasis>Interior</emphasis>, <emphasis>Boundary</emphasis>, and "
"<emphasis>Exterior</emphasis> of a, the mathematical representation of the "
"matrix is:"
msgstr "Gegeben sei die Geometrie <emphasis>a</emphasis>, wobei <emphasis>I(a)</emphasis>, <emphasis>B(a)</emphasis>, und <emphasis>E(a)</emphasis> das <emphasis>Innere/Interior</emphasis>, die <emphasis>Begrenzung/Boundary</emphasis> und das<emphasis>Äussere/Exterior</emphasis> von a sind; die mathematische Formulierung der Matrix lautet:"

#. Tag: emphasis
#: using_postgis_dataman.xml:1175 using_postgis_dataman.xml:1185
#: using_postgis_dataman.xml:1269 using_postgis_dataman.xml:1282
#, no-c-format
msgid "<emphasis role=\"bold\">Interior</emphasis>"
msgstr "<emphasis role=\"bold\">Interior</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1177 using_postgis_dataman.xml:1191
#: using_postgis_dataman.xml:1272 using_postgis_dataman.xml:1305
#, no-c-format
msgid "<emphasis role=\"bold\">Boundary</emphasis>"
msgstr "<emphasis role=\"bold\">Boundary</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1179 using_postgis_dataman.xml:1197
#: using_postgis_dataman.xml:1275 using_postgis_dataman.xml:1328
#, no-c-format
msgid "<emphasis role=\"bold\">Exterior</emphasis>"
msgstr "<emphasis role=\"bold\">Exterior</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1186
#, no-c-format
msgid "dim( I(a) ∩ I(b) )"
msgstr "dim( I(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1187
#, no-c-format
msgid "dim( I(a) ∩ B(b) )"
msgstr "dim( I(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1188
#, no-c-format
msgid "dim( I(a) ∩ E(b) )"
msgstr "dim( I(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1192
#, no-c-format
msgid "dim( B(a) ∩ I(b) )"
msgstr "dim( B(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1193
#, no-c-format
msgid "dim( B(a) ∩ B(b) )"
msgstr "dim( B(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1194
#, no-c-format
msgid "dim( B(a) ∩ E(b) )"
msgstr "dim( B(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1198
#, no-c-format
msgid "dim( E(a) ∩ I(b) )"
msgstr "dim( E(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1199
#, no-c-format
msgid "dim( E(a) ∩ B(b) )"
msgstr "dim( E(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_dataman.xml:1200
#, no-c-format
msgid "dim( E(a) ∩ E(b) )"
msgstr "dim( E(a) ∩ E(b) )"

#. Tag: para
#: using_postgis_dataman.xml:1207
#, no-c-format
msgid ""
"Where <emphasis>dim(a)</emphasis> is the dimension of <emphasis>a</emphasis>"
" as specified by <xref linkend=\"ST_Dimension\"/> but has the domain of "
"<literal>{0,1,2,T,F,*}</literal>"
msgstr "Wobei <emphasis>dim(a)</emphasis>, so wie von <xref linkend=\"ST_Dimension\"/> festgelegt, die Dimension von <emphasis>a</emphasis> ist, aber zu der Domäne von <literal>{0,1,2,T,F,*}</literal> gehört."

#. Tag: para
#: using_postgis_dataman.xml:1214
#, no-c-format
msgid "<literal>0</literal> =&gt; point"
msgstr "<literal>0</literal> =&gt; point"

#. Tag: para
#: using_postgis_dataman.xml:1218
#, no-c-format
msgid "<literal>1</literal> =&gt; line"
msgstr "<literal>1</literal> =&gt; line"

#. Tag: para
#: using_postgis_dataman.xml:1222
#, no-c-format
msgid "<literal>2</literal> =&gt; area"
msgstr "<literal>2</literal> =&gt; area"

#. Tag: para
#: using_postgis_dataman.xml:1226
#, no-c-format
msgid "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"
msgstr "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"

#. Tag: para
#: using_postgis_dataman.xml:1231
#, no-c-format
msgid "<literal>F</literal> =&gt; empty set"
msgstr "<literal>F</literal> =&gt; Leere Menge"

#. Tag: para
#: using_postgis_dataman.xml:1235
#, no-c-format
msgid "<literal>*</literal> =&gt; don't care"
msgstr "<literal>*</literal> =&gt; braucht nicht zu kümmern"

#. Tag: para
#: using_postgis_dataman.xml:1239
#, no-c-format
msgid "Visually, for two overlapping polygonal geometries, this looks like:"
msgstr "Bildlich schaut dies für zwei überlappende Polygongeometrien folgendermaßen aus:"

#. Tag: para
#: using_postgis_dataman.xml:1286 using_postgis_dataman.xml:1298
#: using_postgis_dataman.xml:1332 using_postgis_dataman.xml:1344
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1292 using_postgis_dataman.xml:1309
#: using_postgis_dataman.xml:1321 using_postgis_dataman.xml:1338
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1315
#, no-c-format
msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"
msgstr "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1356
#, no-c-format
msgid ""
"Read from left to right and from top to bottom, the dimensional matrix is "
"represented, '<emphasis role=\"bold\">212101212</emphasis>'."
msgstr "Von links nach rechts und von oben nach unten gelesen wird die Dimensionsmatrix durch '<emphasis role=\"bold\">212101212</emphasis>' dargestellt."

#. Tag: para
#: using_postgis_dataman.xml:1359
#, no-c-format
msgid ""
"A relate matrix that would therefore represent our first example of two "
"lines that intersect on a line would be: '<emphasis "
"role=\"bold\">1*1***1**</emphasis>'"
msgstr "Eine Beziehungsmatrix, welche das erste Beispiel von zwei Linien, die sich auf einer Linie schneiden, abbildet, würde '<emphasis role=\"bold\">102101FF2</emphasis>' entsprechen."

#. Tag: programlisting
#: using_postgis_dataman.xml:1363
#, no-c-format
msgid ""
"-- Identify road segments that cross on a line\n"
"SELECT a.id\n"
"FROM roads a, roads b\n"
"WHERE a.id != b.id\n"
"AND a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '1*1***1**');"
msgstr "-- Identifizierung der Strassenabschnitte, die eine Linie kreuzen\nSELECT a.id\nFROM roads a, roads b\nWHERE a.id != b.id\nAND a.geom &amp;&amp; b.geom\nAND ST_Relate(a.geom, b.geom, '1*1***1**');"

#. Tag: para
#: using_postgis_dataman.xml:1365
#, no-c-format
msgid ""
"A relate matrix that represents the second example of wharfs partly on the "
"lake's shoreline would be '<emphasis role=\"bold\">102101FF2</emphasis>'"
msgstr "Eine Beziehungsmatrix, welche das zweite Beispiel mit den Kais, die teilweise an der Uferlinie des Sees liegen, abbildet, würde '<emphasis role=\"bold\">102101FF2</emphasis>' entsprechen."

#. Tag: programlisting
#: using_postgis_dataman.xml:1369
#, no-c-format
msgid ""
"-- Identify wharfs partly on a lake's shoreline\n"
"SELECT a.lake_id, b.wharf_id\n"
"FROM lakes a, wharfs b\n"
"WHERE a.geom &amp;&amp; b.geom\n"
"AND ST_Relate(a.geom, b.geom, '102101FF2');"
msgstr "-- Ermittlung von Dämmen, die teilweise an der Uferlinie eines Sees liegen\nSELECT a.lake_id, b.wharf_id\nFROM lakes a, wharfs b\nWHERE a.geom &amp;&amp; b.geom\nAND ST_Relate(a.geom, b.geom, '102101FF2');"

#. Tag: para
#: using_postgis_dataman.xml:1371
#, no-c-format
msgid "For more information or reading, see:"
msgstr "Für weiterführende Information siehe:"

#. Tag: para
#: using_postgis_dataman.xml:1375
#, no-c-format
msgid ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink> (version 1.1, section "
"2.1.13.2)"
msgstr "<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple Features Implementation Specification for SQL</ulink> (Version 1.1, Abschnitt 2.1.13.2)"

#. Tag: ulink
#: using_postgis_dataman.xml:1380
#, no-c-format
msgid "Dimensionally Extended Nine-Intersection Model (DE-9IM)"
msgstr "DE-9IM-Matrix (DE-9IM)"

#. Tag: ulink
#: using_postgis_dataman.xml:1384
#, no-c-format
msgid "GeoTools: Point Set Theory and the DE-9IM Matrix"
msgstr "Geotools: Mengentheoretische Topologie und die DE-9IM-Matrix"

#. Tag: para
#: using_postgis_dataman.xml:1387
#, no-c-format
msgid "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"
msgstr "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"

#. Tag: title
#: using_postgis_dataman.xml:1397
#, no-c-format
msgid "Loading GIS (Vector) Data"
msgstr "GIS (Vector) Daten laden"

#. Tag: para
#: using_postgis_dataman.xml:1399
#, no-c-format
msgid ""
"Once you have created a spatial table, you are ready to upload GIS data to "
"the database. Currently, there are two ways to get data into a "
"PostGIS/PostgreSQL database: using formatted SQL statements or using the "
"Shape file loader/dumper."
msgstr "Sobald Sie eine räumliche Tabelle erstellt haben, sind Sie bereit um GIS Daten in Ihre Datenbank zu laden. Aktuell existieren zwei Wege um Daten in die PostGIS/PostgreSQL Datenbank zu importieren: die Verwendung von formatierten SQL-Anweisungen oder des Shapefile Loader/Dumper."

#. Tag: title
#: using_postgis_dataman.xml:1405
#, no-c-format
msgid "Loading Data Using SQL"
msgstr "Daten via SQL laden"

#. Tag: para
#: using_postgis_dataman.xml:1407
#, no-c-format
msgid ""
"If you can convert your data to a text representation, then using formatted "
"SQL might be the easiest way to get your data into PostGIS. As with Oracle "
"and other SQL databases, data can be bulk loaded by piping a large text file"
" full of SQL \"INSERT\" statements into the SQL terminal monitor."
msgstr "Falls Sie Ihre Daten in eine Textdarstellung konvertieren können, dann ist möglicherweise die Verwendung von formatiertem SQL der leichteste Weg um Ihre Daten in PostGIS zu importieren. Wie bei Oracle und anderen Datenbanken, können die Daten über Masseninserts geladen werden, indem eine große Textdatei, in der sich lauter SQL \"INSERT\" Anweisungen befinden, an die SQL-Konsole weitergeleitet wird."

#. Tag: para
#: using_postgis_dataman.xml:1413
#, no-c-format
msgid ""
"A data upload file (<filename>roads.sql</filename> for example) might look "
"like this:"
msgstr "Eine Importdatei (z.B. <filename>roads.sql</filename>) könnte folgendermaßen aussehen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1416
#, no-c-format
msgid ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 243242)',-1),'Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 244817)',-1),'Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 229814)',-1),'Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 259122)',-1),'Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 228134)',-1),'Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 268322)',-1),'Dave Cres');\n"
"COMMIT;"
msgstr "BEGIN;\nINSERT INTO roads (road_id, roads_geom, road_name)\n  VALUES (1,ST_GeomFromText('LINESTRING(191232 243118,191108 243242)',-1),'Jeff Rd');\nINSERT INTO roads (road_id, roads_geom, road_name)\n  VALUES (2,ST_GeomFromText('LINESTRING(189141 244158,189265 244817)',-1),'Geordie Rd');\nINSERT INTO roads (road_id, roads_geom, road_name)\n  VALUES (3,ST_GeomFromText('LINESTRING(192783 228138,192612 229814)',-1),'Paul St');\nINSERT INTO roads (road_id, roads_geom, road_name)\n  VALUES (4,ST_GeomFromText('LINESTRING(189412 252431,189631 259122)',-1),'Graeme Ave');\nINSERT INTO roads (road_id, roads_geom, road_name)\n  VALUES (5,ST_GeomFromText('LINESTRING(190131 224148,190871 228134)',-1),'Phil Tce');\nINSERT INTO roads (road_id, roads_geom, road_name)\n  VALUES (6,ST_GeomFromText('LINESTRING(198231 263418,198213 268322)',-1),'Dave Cres');\nCOMMIT;"

#. Tag: para
#: using_postgis_dataman.xml:1418
#, no-c-format
msgid ""
"The data file can be piped into PostgreSQL very easily using the \"psql\" "
"SQL terminal monitor:"
msgstr "Diese Datei kann dann über die \"psql\" SQL-Konsole sehr leicht nach PostgreSQL weitergeleitet werden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1421
#, no-c-format
msgid "psql -d [database] -f roads.sql"
msgstr "psql -d [database] -f roads.sql"

#. Tag: title
#: using_postgis_dataman.xml:1425
#, no-c-format
msgid "shp2pgsql: Using the ESRI Shapefile Loader"
msgstr "shp2pgsql: Using the ESRI Shapefile Loader"

#. Tag: para
#: using_postgis_dataman.xml:1427
#, no-c-format
msgid ""
"The <filename>shp2pgsql</filename> data loader converts ESRI Shape files "
"into SQL suitable for insertion into a PostGIS/PostgreSQL database either in"
" geometry or geography format. The loader has several operating modes "
"distinguished by command line flags:"
msgstr "Der <filename>shp2pgsql</filename> Datenlader wandelt ESRI Shapefiles in eine SQL-Datei um, die für das Einfügen in eine PostGIS/PostgreSQL Datenbank mit der \"psql\"-Konsole, sowohl im Geometrie- als auch im Geographie-Format, geeignet ist. Der Loader besitzt eine Reihe von Betriebsmodi, die durch Flags auf der Befehlszeile ausgewählt werden:"

#. Tag: para
#: using_postgis_dataman.xml:1432
#, no-c-format
msgid ""
"In addition to the shp2pgsql command-line loader, there is an <filename"
">shp2pgsql-gui</filename> graphical interface with most of the options as "
"the command-line loader, but may be easier to use for one-off non-scripted "
"loading or if you are new to PostGIS. It can also be configured as a plugin "
"to PgAdminIII."
msgstr "Zusätzlich zu dem befehlszeilenorientierten Lader \"shp2pgsql\" gibt es auch die graphische Schnittstelle <filename>shp2pgssql-gui</filename>, welche fast ebensoviele Optionen wie der befehlszeilenorientierte Lader zur Verfügung stellt und für viele nicht so Befehlszeilenversierte bzw. PostGIS-Neuankömmlinge vielleicht einfacher zu bedienen ist. Es gibt auch ein Plugin davon für PgAdminIII."

#. Tag: term
#: using_postgis_dataman.xml:1439
#, no-c-format
msgid "(c|a|d|p) These are mutually exclusive options:"
msgstr "(c|a|d|p) Dies sind sich gegenseitig ausschließende Optionen:"

#. Tag: term
#: using_postgis_dataman.xml:1444
#, no-c-format
msgid "<term>-c</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1446
#, no-c-format
msgid ""
"Creates a new table and populates it from the shapefile. <emphasis>This is "
"the default mode.</emphasis>"
msgstr "Erstellt eine neue Tabelle und füllt sie von einem Shapefile her. <emphasis>Dies ist der Standardmodus</emphasis>."

#. Tag: term
#: using_postgis_dataman.xml:1454
#, no-c-format
msgid "<term>-a</term>"
msgstr "<term>-a</term>"

#. Tag: para
#: using_postgis_dataman.xml:1456
#, no-c-format
msgid ""
"Appends data from the Shape file into the database table. Note that to use "
"this option to load multiple files, the files must have the same attributes "
"and same data types."
msgstr "Fügt Daten aus dem Shapefile zu der Datenbanktabelle hinzu. Beachten Sie bitte, falls Sie diese Option verwenden um mehrere Dateien zu laden, dass die Attribute und Datentypen in den Dateien übereinstimmen müssen."

#. Tag: term
#: using_postgis_dataman.xml:1465 using_postgis_dataman.xml:1854
#, no-c-format
msgid "<term>-d</term>"
msgstr "<term>-d</term>"

#. Tag: para
#: using_postgis_dataman.xml:1467
#, no-c-format
msgid ""
"Drops the database table before creating a new table with the data in the "
"Shape file."
msgstr "Löscht die Datenbanktabelle, bevor eine neue Tabelle mit den Daten vom Shapefile befüllt wird."

#. Tag: term
#: using_postgis_dataman.xml:1475
#, no-c-format
msgid "<term>-p</term>"
msgstr "<term>-p</term>"

#. Tag: para
#: using_postgis_dataman.xml:1477
#, no-c-format
msgid ""
"Only produces the table creation SQL code, without adding any actual data. "
"This can be used if you need to completely separate the table creation and "
"data loading steps."
msgstr "Erzeugt nur den SQL-Code zur Erstellung der Tabelle, ohne irgendwelche Daten hinzuzufügen. Kann verwendet werden, um die Erstellung und das Laden einer Tabelle vollständig zu trennen."

#. Tag: term
#: using_postgis_dataman.xml:1490
#, no-c-format
msgid "<term>-?</term>"
msgstr "<term>-?</term>"

#. Tag: para
#: using_postgis_dataman.xml:1492
#, no-c-format
msgid "Display help screen."
msgstr "Zeigt die Hilfe an."

#. Tag: term
#: using_postgis_dataman.xml:1499
#, no-c-format
msgid "<term>-D</term>"
msgstr "<term>-D</term>"

#. Tag: para
#: using_postgis_dataman.xml:1501
#, no-c-format
msgid ""
"Use the PostgreSQL \"dump\" format for the output data. This can be combined"
" with -a, -c and -d. It is much faster to load than the default \"insert\" "
"SQL format. Use this for very large data sets."
msgstr "Verwendung des PostgreSQL \"dump\" Formats für die Datenausgabe. Kann mit -a, -c und -d kombiniert werden. Ist wesentlich schneller als das standardmäßige SQL \"insert\" Format. Verwenden Sie diese Option wenn Sie sehr große Datensätze haben."

#. Tag: term
#: using_postgis_dataman.xml:1510
#, no-c-format
msgid "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"
msgstr "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1512
#, no-c-format
msgid ""
"Creates and populates the geometry tables with the specified SRID. "
"Optionally specifies that the input shapefile uses the given FROM_SRID, in "
"which case the geometries will be reprojected to the target SRID. FROM_SRID "
"cannot be specified with -D."
msgstr "Erzeugt und befüllt die Geometrietabelle in einer bestimmten SRID. Optional kann FROM_SRID für die Shapedatei angegeben werden, wodurch die Geometrie von FROM_SRID in die Ziel-SRID projiziert wird. FROM_SRID und -D können nicht gleichzeitig angegeben werden."

#. Tag: term
#: using_postgis_dataman.xml:1523
#, no-c-format
msgid "<term>-k</term>"
msgstr "<term>-k</term>"

#. Tag: para
#: using_postgis_dataman.xml:1525
#, no-c-format
msgid ""
"Keep identifiers' case (column, schema and attributes). Note that attributes"
" in Shapefile are all UPPERCASE."
msgstr "Erhält die Groß- und Kleinschreibung (Spalte, Schema und Attribute). Beachten Sie bitte, dass die Attributnamen in Shapedateien immer Großbuchstaben haben."

#. Tag: term
#: using_postgis_dataman.xml:1533
#, no-c-format
msgid "<term>-i</term>"
msgstr "<term>-i</term>"

#. Tag: para
#: using_postgis_dataman.xml:1535
#, no-c-format
msgid ""
"Coerce all integers to standard 32-bit integers, do not create 64-bit "
"bigints, even if the DBF header signature appears to warrant it."
msgstr "Wandeln Sie alle Ganzzahlen in standard 32-bit Integer um, erzeugen Sie keine 64-bit BigInteger, auch nicht dann wenn der DBF-Header dies unterstellt."

#. Tag: term
#: using_postgis_dataman.xml:1543
#, no-c-format
msgid "<term>-I</term>"
msgstr "<term>-I</term>"

#. Tag: para
#: using_postgis_dataman.xml:1545
#, no-c-format
msgid "Create a GiST index on the geometry column."
msgstr "Einen GIST Index auf die Geometriespalte anlegen."

#. Tag: term
#: using_postgis_dataman.xml:1552
#, no-c-format
msgid "<term>-m</term>"
msgstr "<term>-m</term>"

#. Tag: para
#: using_postgis_dataman.xml:1554
#, no-c-format
msgid ""
"-m <filename>a_file_name</filename> Specify a file containing a set of "
"mappings of (long) column names to 10 character DBF column names. The "
"content of the file is one or more lines of two names separated by white "
"space and no trailing or leading space. For example:"
msgstr "-m <filename>a_file_name</filename> bestimmt eine Datei, in welcher die Abbildungen der (langen) Spaltennamen in die 10 Zeichen langen DBF Spaltennamen festgelegt sind. Der Inhalt der Datei besteht aus einer oder mehreren Zeilen die jeweils zwei, durch Leerzeichen getrennte Namen enthalten, aber weder vorne noch hinten mit Leerzeichen versehen werden dürfen. Zum Beispiel:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1559
#, no-c-format
msgid ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"
msgstr "COLUMNNAME DBFFIELD1\nAVERYLONGCOLUMNNAME DBFFIELD2"

#. Tag: term
#: using_postgis_dataman.xml:1565
#, no-c-format
msgid "<term>-S</term>"
msgstr "<term>-S</term>"

#. Tag: para
#: using_postgis_dataman.xml:1567
#, no-c-format
msgid ""
"Generate simple geometries instead of MULTI geometries. Will only succeed if"
" all the geometries are actually single (I.E. a MULTIPOLYGON with a single "
"shell, or or a MULTIPOINT with a single vertex)."
msgstr "Erzeugt eine Einzel- anstatt einer Mehrfachgeometrie. Ist nur erfolgversprechend, wenn die Geometrie auch tatsächlich eine Einzelgeometrie ist (insbesondere gilt das für ein Mehrfachpolygon/MULTIPOLYGON, dass nur aus einer einzelnen Begrenzung besteht, oder für einen Mehrfachpunkt/MULTIPOINT, der nur einen einzigen Knoten aufweist)."

#. Tag: term
#: using_postgis_dataman.xml:1576
#, no-c-format
msgid "-t &lt;dimensionality&gt;"
msgstr "-t &lt;dimensionality&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1578
#, no-c-format
msgid ""
"Force the output geometry to have the specified dimensionality. Use the "
"following strings to indicate the dimensionality: 2D, 3DZ, 3DM, 4D."
msgstr "Zwingt die Ausgabegeometrie eine bestimmte Dimension anzunehmen. Sie können die folgenden Zeichenfolgen verwenden, um die Dimensionalität anzugeben: 2D, 3DZ, 3DM, 4D."

#. Tag: para
#: using_postgis_dataman.xml:1582
#, no-c-format
msgid ""
"If the input has fewer dimensions that specified, the output will have those"
" dimensions filled in with zeroes. If the input has more dimensions that "
"specified, the unwanted dimensions will be stripped."
msgstr "Wenn die Eingabe weniger Dimensionen aufweist als angegeben, dann werden diese Dimensionen bei der Ausgabe mit Nullen gefüllt. Wenn die Eingabe mehr Dimensionen als angegeben aufweist werden diese abgestreift."

#. Tag: term
#: using_postgis_dataman.xml:1591
#, no-c-format
msgid "<term>-w</term>"
msgstr "<term>-w</term>"

#. Tag: para
#: using_postgis_dataman.xml:1593
#, no-c-format
msgid ""
"Output WKT format, instead of WKB. Note that this can introduce coordinate "
"drifts due to loss of precision."
msgstr "Ausgabe im Format WKT anstatt WKB. Beachten Sie bitte, dass es hierbei zu Koordinatenverschiebungen infolge von Genauigkeitsverlusten kommen kann."

#. Tag: term
#: using_postgis_dataman.xml:1601
#, no-c-format
msgid "<term>-e</term>"
msgstr "<term>-e</term>"

#. Tag: para
#: using_postgis_dataman.xml:1603
#, no-c-format
msgid ""
"Execute each statement on its own, without using a transaction. This allows "
"loading of the majority of good data when there are some bad geometries that"
" generate errors. Note that this cannot be used with the -D flag as the "
"\"dump\" format always uses a transaction."
msgstr "Jede Anweisung einzeln und nicht in einer Transaktion ausführen. Dies erlaubt den Großteil auch dann zu laden, also die guten Daten, wenn eine Geometrie dabei ist die Fehler verursacht. Beachten Sie bitte das dies nicht gemeinsam mit der -D Flag angegeben werden kann, da das \"dump\" Format immer eine Transaktion verwendet."

#. Tag: term
#: using_postgis_dataman.xml:1613
#, no-c-format
msgid "-W &lt;encoding&gt;"
msgstr "-W &lt;encoding&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1615
#, no-c-format
msgid ""
"Specify encoding of the input data (dbf file). When used, all attributes of "
"the dbf are converted from the specified encoding to UTF8. The resulting SQL"
" output will contain a <code>SET CLIENT_ENCODING to UTF8</code> command, so "
"that the backend will be able to reconvert from UTF8 to whatever encoding "
"the database is configured to use internally."
msgstr "Gibt die Codierung der Eingabedaten (dbf-Datei) an. Wird die Option verwendet, so werden alle Attribute der dbf-Datei von der angegebenen Codierung nach UTF8 konvertiert. Die resultierende SQL-Ausgabe enthält dann den Befehl <code>SET CLIENT_ENCODING to UTF8</code>, damit das Back-end wiederum die Möglichkeit hat, von UTF8 in die, für die interne Nutzung konfigurierte Datenbankcodierung zu decodieren."

#. Tag: term
#: using_postgis_dataman.xml:1625
#, no-c-format
msgid "-N &lt;policy&gt;"
msgstr "-N &lt;policy&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1627
#, no-c-format
msgid "NULL geometries handling policy (insert*,skip,abort)"
msgstr "Umgang mit NULL-Geometrien (insert*, skip, abort)"

#. Tag: term
#: using_postgis_dataman.xml:1633
#, no-c-format
msgid "<term>-n</term>"
msgstr "<term>-n</term>"

#. Tag: para
#: using_postgis_dataman.xml:1635
#, no-c-format
msgid ""
"-n Only import DBF file. If your data has no corresponding shapefile, it "
"will automatically switch to this mode and load just the dbf. So setting "
"this flag is only needed if you have a full shapefile set, and you only want"
" the attribute data and no geometry."
msgstr "-n Es wird nur die *.dbf-Datei importiert. Wenn das Shapefile nicht Ihren Daten entspricht, wird automatisch auf diesen Modus geschaltet und nur die *.dbf-Datei geladen. Daher müssen Sie diese Flag nur dann setzen, wenn sie einen vollständigen Shapefile-Satz haben und lediglich die Attributdaten, und nicht die Geometrie, laden wollen."

#. Tag: term
#: using_postgis_dataman.xml:1643
#, no-c-format
msgid "<term>-G</term>"
msgstr "<term>-G</term>"

#. Tag: para
#: using_postgis_dataman.xml:1645
#, no-c-format
msgid ""
"Use geography type instead of geometry (requires lon/lat data) in WGS84 long"
" lat (SRID=4326)"
msgstr "Verwendung des geographischen Datentyps in WGS84 (SRID=4326), anstelle des geometrischen Datentyps (benötigt Längen- und Breitenangaben)."

#. Tag: term
#: using_postgis_dataman.xml:1651
#, no-c-format
msgid "-T &lt;tablespace&gt;"
msgstr "-T &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1653
#, no-c-format
msgid ""
"Specify the tablespace for the new table. Indexes will still use the default"
" tablespace unless the -X parameter is also used. The PostgreSQL "
"documentation has a good description on when to use custom tablespaces."
msgstr "Den Tablespace für die neue Tabelle festlegen. Solange der -X Parameter nicht angegeben wird, benutzen die Indizes weiterhin den standardmäßig festgelegten Tablespace. Die PostgreSQL Dokumentation beinhaltet eine gute Beschreibung, wann es sinnvoll ist, eigene Tablespaces zu verwenden."

#. Tag: term
#: using_postgis_dataman.xml:1661
#, no-c-format
msgid "-X &lt;tablespace&gt;"
msgstr "-X &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1663
#, no-c-format
msgid ""
"Specify the tablespace for the new table's indexes. This applies to the "
"primary key index, and the GIST spatial index if -I is also used."
msgstr "Den Tablespace bestimmen, in dem die neuen Tabellenindizes angelegt werden sollen. Gilt für den Primärschlüsselindex und wenn \"-l\" verwendet wird, auch für den räumlichen GIST-Index."

#. Tag: para
#: using_postgis_dataman.xml:1671
#, no-c-format
msgid ""
"An example session using the loader to create an input file and uploading it"
" might look like this:"
msgstr "Eine beispielhafte Sitzung, in welcher der Loader verwendet wird, um eine Eingabedatei zu erzeugen und anschließend hochzuladen, könnte folgendermaßen aussehen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1676
#, no-c-format
msgid ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; roads.sql\n"
"# psql -d roadsdb -f roads.sql"
msgstr "# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; roads.sql\n# psql -d roadsdb -f roads.sql"

#. Tag: para
#: using_postgis_dataman.xml:1678
#, no-c-format
msgid "A conversion and upload can be done all in one step using UNIX pipes:"
msgstr "Konvertierung und Import können über UNIX-Pipes in einem Schritt erfolgen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1682
#, no-c-format
msgid "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"
msgstr "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"

#. Tag: title
#: using_postgis_dataman.xml:1687
#, no-c-format
msgid "Retrieving GIS Data"
msgstr "Abfrage von GIS-Daten"

#. Tag: para
#: using_postgis_dataman.xml:1689
#, no-c-format
msgid ""
"Data can be extracted from the database using either SQL or the Shape file "
"loader/dumper. In the section on SQL we will discuss some of the operators "
"available to do comparisons and queries on spatial tables."
msgstr "Daten können entweder über SQL oder mit dem Shapefile Loader/Dumper aus der Datenbank geholt werden. Im Abschnitt über SQL werden wir einige Operatoren besprechen, die für Gegenüberstellungen und Abfragen von Geometrietabellen zur Verfügung stehen."

#. Tag: title
#: using_postgis_dataman.xml:1695
#, no-c-format
msgid "Using SQL to Retrieve Data"
msgstr "Daten via SQL abfragen"

#. Tag: para
#: using_postgis_dataman.xml:1697
#, no-c-format
msgid ""
"The most straightforward means of pulling data out of the database is to use"
" a SQL select query to reduce the number of RECORDS and COLUMNS returned and"
" dump the resulting columns into a parsable text file:"
msgstr "Das geradlinigste Mittel um Daten aus der Datenbank zu holen, besteht in der Anwendung einer SQL Select-Anfrage. Dadurch kann man die Anzahl der zurückgegebenen Datensätze und Spalten reduzieren und die resultierenden Datenbankspalten in eine lesbare Textdatei überspielen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1702
#, no-c-format
msgid ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"
msgstr "db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n\nroad_id | geom                                    | road_name\n--------+-----------------------------------------+-----------\n          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n(6 rows)"

#. Tag: para
#: using_postgis_dataman.xml:1704
#, no-c-format
msgid ""
"However, there will be times when some kind of restriction is necessary to "
"cut down the number of fields returned. In the case of attribute-based "
"restrictions, just use the same SQL syntax as normal with a non-spatial "
"table. In the case of spatial restrictions, the following operators are "
"available/useful:"
msgstr "Wie auch immer, manchmal wird eine Einschränkung notwendig sein, um die Anzahl der zurückgegebenen Werte zu reduzieren. Falls es sich um eine Beschränkung auf ein Attribut handelt, können Sie die selbe SQL-Syntax verwenden wie bei jeder anderen Nicht-Geometrietabelle. Für räumliche Beschränkungen sind folgende Operatoren verfügbar/nützlich:"

#. Tag: term
#: using_postgis_dataman.xml:1712
#, no-c-format
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#. Tag: para
#: using_postgis_dataman.xml:1715
#, no-c-format
msgid ""
"This operator tells whether the bounding box of one geometry intersects the "
"bounding box of another."
msgstr "Dieser Operator stellt fest, ob sich die Umgebungsrechtecke zweier Geometrien schneiden."

#. Tag: term
#: using_postgis_dataman.xml:1721
#, no-c-format
msgid "ST_OrderingEquals"
msgstr "ST_OrderingEquals"

#. Tag: para
#: using_postgis_dataman.xml:1724
#, no-c-format
msgid ""
"This tests whether two geometries are geometrically identical. For example, "
"if 'POLYGON((0 0,1 1,1 0,0 0))' is the same as 'POLYGON((0 0,1 1,1 0,0 0))' "
"(it is)."
msgstr "Überprüft, ob zwei Geometrien geometrisch identisch sind. Zum Beispiel, ob 'POLYGON((0 0,1 1,1 0,0 0))' identisch mit 'POLYGON((0 0,1 1,1 0,0 0))'  ist (ist es)."

#. Tag: term
#: using_postgis_dataman.xml:1731
#, no-c-format
msgid "<term>=</term>"
msgstr "<term>=</term>"

#. Tag: para
#: using_postgis_dataman.xml:1734
#, no-c-format
msgid ""
"This operator is a little more naive, it only tests whether the bounding "
"boxes of two geometries are the same."
msgstr "Dieser Operator stellt fest, ob die Umgebungsrechtecke zweier Geometrien ident sind."

#. Tag: para
#: using_postgis_dataman.xml:1740
#, no-c-format
msgid ""
"Next, you can use these operators in queries. Note that when specifying "
"geometries and boxes on the SQL command line, you must explicitly turn the "
"string representations into geometries by using the \"ST_GeomFromText()\" "
"function. The 312 is a fictitious spatial reference system that matches our "
"data. So, for example:"
msgstr "Außerdem können Sie diese Operatoren in Anfragen verwenden. Beachten Sie bitte, wenn Sie eine Geometrie oder eine Box auf der SQL-Befehlszeile eingeben, dass Sie die Zeichensatzdarstellung explizit mit der Funktion \"ST_GeomFromText()\" in eine Geometrie umwandeln müssen. 312 ist ein fiktives Koordinatenreferenzsystem dass zu Unseren Daten passt. Also, zum Beispiel:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1746
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE ST_OrderingEquals(roads_geom , ST_GeomFromText('LINESTRING(191232 243118,191108 243242)',312) ) ;"
msgstr "SELECT road_id, road_name\n  FROM roads\n  WHERE ST_OrderingEquals(roads_geom , ST_GeomFromText('LINESTRING(191232 243118,191108 243242)',312) ) ;"

#. Tag: para
#: using_postgis_dataman.xml:1748
#, no-c-format
msgid ""
"The above query would return the single record from the \"ROADS_GEOM\" table"
" in which the geometry was equal to that value."
msgstr "Die obere Abfrage würde einen einzelnen Datensatz aus der Tabelle \"ROADS_GEOM\" zurückgeben, in dem die Geometrie gleich dem angegebenen Wert ist."

#. Tag: para
#: using_postgis_dataman.xml:1751
#, no-c-format
msgid ""
"When using the \"&amp;&amp;\" operator, you can specify either a BOX3D as "
"the comparison feature or a GEOMETRY. When you specify a GEOMETRY, however, "
"its bounding box will be used for the comparison."
msgstr "Der Operator \"&amp;&amp;\" kann entweder mit einer BOX3D oder mit einer Geometrie verwendet werden. Allerdings wird auch bei einer Geometrie nur das Umgebungsrechteck für den Vergleich herangezogen."

#. Tag: programlisting
#: using_postgis_dataman.xml:1756
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))',312);"
msgstr "SELECT road_id, road_name\nFROM roads\nWHERE roads_geom &amp;&amp; ST_GeomFromText('POLYGON((...))',312);"

#. Tag: para
#: using_postgis_dataman.xml:1758
#, no-c-format
msgid ""
"The above query will use the bounding box of the polygon for comparison "
"purposes."
msgstr "Die obere Abfrage verwendet das Umgebungsrechteck des Polygons zu Vergleichszwecken."

#. Tag: para
#: using_postgis_dataman.xml:1761
#, no-c-format
msgid ""
"The most common spatial query will probably be a \"frame-based\" query, used"
" by client software, like data browsers and web mappers, to grab a \"map "
"frame\" worth of data for display. Using a \"BOX3D\" object for the frame, "
"such a query looks like this:"
msgstr "Die häufigsten räumlichen Abfragen werden vermutlich in einem bestimmten Ausschnitt ausgeführt. Insbesondere von Client-Software, wie Datenbrowsern und Kartendiensten, die auf diese Weise die Daten für die Darstellung eines \"Kartenausschnitts\" erfassen. Die Abfrage zur Verwendung des \"BOX3D\" Objekts für einen solchen Ausschnitt sieht folgendermaßen aus:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1766
#, no-c-format
msgid ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"
msgstr "SELECT ST_AsText(roads_geom) AS geom\nFROM roads\nWHERE\n  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"

#. Tag: para
#: using_postgis_dataman.xml:1768
#, no-c-format
msgid ""
"Note the use of the SRID 312, to specify the projection of the envelope."
msgstr "Achten Sie auf die Verwendung von SRID=312, welche die Projektion Einhüllenden/Enveloppe bestimmt."

#. Tag: title
#: using_postgis_dataman.xml:1772
#, no-c-format
msgid "Using the Dumper"
msgstr "Verwendung des Dumper"

#. Tag: para
#: using_postgis_dataman.xml:1774
#, no-c-format
msgid ""
"The <filename>pgsql2shp</filename> table dumper connects directly to the "
"database and converts a table (possibly defined by a query) into a shape "
"file. The basic syntax is:"
msgstr "Der Tabellendumper <filename>pgsql2shp</filename> verbindet sich direkt mit der Datenbank und konvertiert eine Tabelle (evtl. durch eine Abfrage festgelegt) in eine Shapedatei. Die grundlegende Syntax lautet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1778
#, no-c-format
msgid ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"
msgstr "pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"

#. Tag: programlisting
#: using_postgis_dataman.xml:1780
#, no-c-format
msgid "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"
msgstr "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1782
#, no-c-format
msgid "The commandline options are:"
msgstr "Optionen auf der Befehlszeile:"

#. Tag: term
#: using_postgis_dataman.xml:1786
#, no-c-format
msgid "-f &lt;filename&gt;"
msgstr "-f &lt;filename&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1789
#, no-c-format
msgid "Write the output to a particular filename."
msgstr "Ausgabe in eine bestimmte Datei."

#. Tag: term
#: using_postgis_dataman.xml:1794
#, no-c-format
msgid "-h &lt;host&gt;"
msgstr "-h &lt;host&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1797
#, no-c-format
msgid "The database host to connect to."
msgstr "Der Datenbankserver, mit dem eine Verbindung aufgebaut werden soll."

#. Tag: term
#: using_postgis_dataman.xml:1802
#, no-c-format
msgid "-p &lt;port&gt;"
msgstr "-p &lt;port&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1805
#, no-c-format
msgid "The port to connect to on the database host."
msgstr "Der Port über den der Verbindungsaufbau mit dem Datenbank Server hergestellt werden soll."

#. Tag: term
#: using_postgis_dataman.xml:1810
#, no-c-format
msgid "-P &lt;password&gt;"
msgstr "-P &lt;password&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1813
#, no-c-format
msgid "The password to use when connecting to the database."
msgstr "Das Passwort, das zum Verbindungsaufbau mit der Datenbank verwendet werden soll."

#. Tag: term
#: using_postgis_dataman.xml:1818
#, no-c-format
msgid "-u &lt;user&gt;"
msgstr "-u &lt;user&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1821
#, no-c-format
msgid "The username to use when connecting to the database."
msgstr "Das Benutzername, der zum Verbindungsaufbau mit der Datenbank verwendet werden soll."

#. Tag: term
#: using_postgis_dataman.xml:1826
#, no-c-format
msgid "-g &lt;geometry column&gt;"
msgstr "-g &lt;geometry column&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1829
#, no-c-format
msgid ""
"In the case of tables with multiple geometry columns, the geometry column to"
" use when writing the shape file."
msgstr "Bei Tabellen mit mehreren Geometriespalten, jene Geometriespalte die ins Shapefile geschrieben werden soll."

#. Tag: term
#: using_postgis_dataman.xml:1835
#, no-c-format
msgid "<term>-b</term>"
msgstr "<term>-b</term>"

#. Tag: para
#: using_postgis_dataman.xml:1838
#, no-c-format
msgid ""
"Use a binary cursor. This will make the operation faster, but will not work "
"if any NON-geometry attribute in the table lacks a cast to text."
msgstr "Verwendung eines \"binären Cursors\"/Iterators. Macht die Berechnung schneller, funktioniert aber nicht wenn irgendein geometrieloses Attribut nicht in den Typ \"text\" umgewandelt werden kann."

#. Tag: term
#: using_postgis_dataman.xml:1845
#, no-c-format
msgid "<term>-r</term>"
msgstr "<term>-r</term>"

#. Tag: para
#: using_postgis_dataman.xml:1848
#, no-c-format
msgid ""
"Raw mode. Do not drop the <varname>gid</varname> field, or escape column "
"names."
msgstr "RAW-Modus. Das Attribut <varname>gid</varname> wird nicht verworfen und Spaltennamen werden nicht maskiert."

#. Tag: para
#: using_postgis_dataman.xml:1857
#, no-c-format
msgid ""
"For backward compatibility: write a 3-dimensional shape file when dumping "
"from old (pre-1.0.0) postgis databases (the default is to write a "
"2-dimensional shape file in that case). Starting from postgis-1.0.0+, "
"dimensions are fully encoded."
msgstr "Für Abwärtskompatibilität: schreiben Sie eine 3-dimensionale Shapedatei, wenn Sie aus alten (pre-1.0.0) PostGIS Datenbanken exportieren (standardmäßig würde in diesem Fall eine 2-dimensionale Shapedatei herausgeschrieben). Ab PostGIS-1.0.0+ wird die Dimension vollständig codiert."

#. Tag: term
#: using_postgis_dataman.xml:1865
#, no-c-format
msgid "-m <varname>filename</varname>"
msgstr "-m <varname>filename</varname>"

#. Tag: para
#: using_postgis_dataman.xml:1867
#, no-c-format
msgid ""
"Remap identifiers to ten character names. The content of the file is lines "
"of two symbols separated by a single white space and no trailing or leading "
"space: VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."
msgstr "Bildet die Identifikatoren in Namen mit 10 Zeichen ab. Der Inhalt der Datei besteht aus Zeilen von jeweils zwei leerzeichengetrennten Symbolen, jedoch ohne vor- oder nachgestellte Leerzeichen: VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."

#. Tag: title
#: using_postgis_dataman.xml:1880
#, no-c-format
msgid "Building Indexes"
msgstr "Indizes aufbauen"

#. Tag: para
#: using_postgis_dataman.xml:1882
#, no-c-format
msgid ""
"Indexes are what make using a spatial database for large data sets possible."
" Without indexing, any search for a feature would require a \"sequential "
"scan\" of every record in the database. Indexing speeds up searching by "
"organizing the data into a search tree which can be quickly traversed to "
"find a particular record. PostgreSQL supports three kinds of indexes by "
"default: B-Tree indexes, R-Tree indexes, and GiST indexes."
msgstr "Indizes ermöglichen erst das Arbeiten mit großen Datensätzen in einer Geodatenbank. Ohne Indizierung würde jede Featureanfrage einen \"Full Table Scan\" in der Datenbank benötigen. Die Indizierung beschleunigt die Suche, indem die Daten in einem Suchbaum strukturiert werden, der dann schnell durchlaufen werden kann, um einen bestimmten Datensatz zu finden. PostgreSQL unterstützt standardmäßig drei Arten von Indizes: B-Baum, R-Baum und GIST Indizes."

#. Tag: para
#: using_postgis_dataman.xml:1892
#, no-c-format
msgid ""
"B-Trees are used for data which can be sorted along one axis; for example, "
"numbers, letters, dates. GIS data cannot be rationally sorted along one axis"
" (which is greater, (0,0) or (0,1) or (1,0)?) so B-Tree indexing is of no "
"use for us."
msgstr "Ein B-Baum wird verwendet, wenn die Daten entlang einer Achse sortiert werden können; zum Beispiel Zahlen, Buchstaben und Datum. Geodaten können nicht vernünftig entlang einer Achse sortiert werden (was ist größer - (0,0), (0,1) oder (1,0)?), weshalb die Indizierung mittels  B-Baum für Uns hier keine Verwendung findet."

#. Tag: para
#: using_postgis_dataman.xml:1899
#, no-c-format
msgid ""
"R-Trees break up data into rectangles, and sub-rectangles, and sub-sub "
"rectangles, etc. R-Trees are used by some spatial databases to index GIS "
"data, but the PostgreSQL R-Tree implementation is not as robust as the GiST "
"implementation."
msgstr "R-Bäume unterteilen die Daten in Rechtecke, die wiederum in Rechtecke unterteilt werden, usw.. R-Bäume werden von einigen Geodatenbanken zur Indizierung von Geodaten verwendet. Bei PostgreSQL ist die der R-Baum allerdings nicht so robust umgesetzt wie die GIST Implementierung."

#. Tag: para
#: using_postgis_dataman.xml:1906
#, no-c-format
msgid ""
"GiST (Generalized Search Trees) indexes break up data into \"things to one "
"side\", \"things which overlap\", \"things which are inside\" and can be "
"used on a wide range of data-types, including GIS data. PostGIS uses an "
"R-Tree index implemented on top of GiST to index GIS data."
msgstr "GiST (Generalized Search Tree) Indizes unterteilen die Daten in \"Dinge auf einer Seite\", \"Dinge die sich überlagern\", \"Dinge die innerhalb liegen\". Sie können auf eine Vielzahl von Datentypen, inklusive Geodaten, angewendet werden. PostGIS verwendet einen R-Baum der auf dem GIST Index aufgesetzt wurde, um Geodaten zu indizieren."

#. Tag: title
#: using_postgis_dataman.xml:1915
#, no-c-format
msgid "GiST Indexes"
msgstr "GiST-Indizes"

#. Tag: para
#: using_postgis_dataman.xml:1917
#, no-c-format
msgid ""
"GiST stands for \"Generalized Search Tree\" and is a generic form of "
"indexing. In addition to GIS indexing, GiST is used to speed up searches on "
"all kinds of irregular data structures (integer arrays, spectral data, etc) "
"which are not amenable to normal B-Tree indexing."
msgstr "GIST, \"Generalized Search Tree\", steht für eine generische Datenstruktur. Zusätzlich zu der indizierung von GIS-Daten, wird GIST zur schnelleren Abfrage aller möglichen unregelmäßigen Datenstrukturen (Ganzzahl-Felder, Spektraldaten, etc.), welche über gewöhnlicher B-Baum Indizierung nicht zugänglich sind."

#. Tag: para
#: using_postgis_dataman.xml:1922
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an"
" index to speed up spatial searches of the data (unless all your searches "
"are based on attributes, in which case you'll want to build a normal index "
"on the attribute fields)."
msgstr "Sobald eine Geodatentabelle ein paar tausend Zeilen überschreitet, werden Sie einen Index erzeugen wollen, um die räumlichen Abfragen auf die Daten zu beschleunigen (außer Ihre Suche basiert lediglich auf Attributen, in diesem Fall werden Sie einen gewöhnlichen Index auf die Attribute setzen)."

#. Tag: para
#: using_postgis_dataman.xml:1927
#, no-c-format
msgid ""
"The syntax for building a GiST index on a \"geometry\" column is as follows:"
msgstr "Die Syntax, mit der ein GIST-Index auf eine Geometriespalte angelegt wird, lautet wie folgt:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1930
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"
msgstr "CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1931
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get the an n-dimensional "
"index supported in PostGIS 2.0+ for the geometry type, you can create one "
"using this syntax"
msgstr "Die obere Syntax erzeugt immer einen 2D-Index. Um einen n-dimensionalen Index zu erhalten, welcher ab PostGIS 2.0+ für den geometrischen Datentyp unterstützt wird, können Sie die folgende Syntax verwenden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1932
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"
msgstr "CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1934
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive exercise: on tables "
"of around 1 million rows, on a 300MHz Solaris machine, we have found "
"building a GiST index takes about 1 hour. After building an index, it is "
"important to force PostgreSQL to collect table statistics, which are used to"
" optimize query plans:"
msgstr "Die Erstellung eines räumlichen Indexes ist eine rechenintensive Aufgabe: Bei Tabellen mit um die 1 Millionen Zeilen und auf einer 300MHz Solaris, haben wir festgestellt, dass der Aufbau des GIST-Index  ca. 1 Stunde dauerte. Nachdem der Index aufgebaut ist, sollte man unbedingt die Tabellenstatistik von PostgreSQL erneuern; diese wird  benüzt um den Auswertungsplan/\"Query Plan\" zu optimieren:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1940 using_postgis_dataman.xml:2023
#, no-c-format
msgid ""
"VACUUM ANALYZE [table_name] [(column_name)];\n"
"-- This is only needed for PostgreSQL 7.4 installations and below\n"
"SELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);"
msgstr "VACUUM ANALYZE [table_name] [(column_name)];\n-- Dies wird nur für Installationen von PostgreSQL 7.4, oder niedriger, benötigt\nSELECT UPDATE_GEOMETRY_STATS([table_name], [column_name]);"

#. Tag: para
#: using_postgis_dataman.xml:1942
#, no-c-format
msgid ""
"GiST indexes have two advantages over R-Tree indexes in PostgreSQL. Firstly,"
" GiST indexes are \"null safe\", meaning they can index columns which "
"include null values. Secondly, GiST indexes support the concept of "
"\"lossiness\" which is important when dealing with GIS objects larger than "
"the PostgreSQL 8K page size. Lossiness allows PostgreSQL to store only the "
"\"important\" part of an object in an index -- in the case of GIS objects, "
"just the bounding box. GIS objects larger than 8K will cause R-Tree indexes "
"to fail in the process of being built."
msgstr "Gegenüber R-Baum Indizes haben GIST-Indizes in PostgreSQL zwei Vorteile. Erstens: GIST-Indizes sind \"NULL safe\", d.h. Spalten die NULL- Werte enthalten können indiziert werden. GIST-Indizes sind verlustfrei/\"Concept of lossiness\", was bei GIS-Objekten wichtig ist, die größer als die 8k Speicherseitengröße/\"Page Size\" von PostgreSQL sind. Diese Verlustfreiheit ermöglicht es PostgreSQL nur den \"wichtigen\" Teil eines Objektes in einem Index zu speichern -- bei GIS Objekten das Umgebungsrechteck. GIS-Objekte, die größer als 8K sind, können mit R-Baum-Indizes nicht erstellt werden."

#. Tag: title
#: using_postgis_dataman.xml:1954
#, no-c-format
msgid "BRIN Indexes"
msgstr "BRIN Indizes"

#. Tag: para
#: using_postgis_dataman.xml:1956
#, no-c-format
msgid ""
"BRIN stands for \"Block Range Index\" and is a generic form of indexing that"
" has been introduced in PostgreSQL 9.5. BRIN is a lossy kind of index, and "
"its main usage is to provide a compromise for both read and write "
"performance. Its primary goal is to handle very large tables for which some "
"of the columns have some natural correlation with their physical location "
"within the table. In addition to GIS indexing, BRIN is used to speed up "
"searches on various kinds of regular or irregular data structures (integer, "
"arrays etc)."
msgstr "Die Bezeichnung BRIN steht für \"Block Range Index\", eine generische Form des Indizierens und wurde mit PostgreSQL 9.5 eingeführt. BRIN ist ein verlustbehafteter Index, dessen Hauptzweck ist, einen Kompromiss sowohl bei der Lese- als auch bei der Schreibgeschwindigkeit anzubieten. Der Hauptverwendungszweck liegt bei sehr großen Tabellen, in denen einige Spalten einen natürlichen Bezug zu dem physischen Speicherplatz innerhalb der Tabelle haben. Zusätzlich zur Indizierung von GIS-Daten, werden BRIN-Indizes zur Beschleunigung von Suchabfragen auf unterschiedliche regelmäßige und unregelmäßige Datenstrukturen (Ganzzahlen, Felder etc.) verwendet."

#. Tag: para
#: using_postgis_dataman.xml:1965
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an"
" index to speed up spatial searches of the data (unless all your searches "
"are based on attributes, in which case you'll want to build a normal index "
"on the attribute fields). GiST indexes are really performant as long as "
"their size doesn't exceed the amount of RAM available for the database, and "
"as long as you can afford the storage size, and the penalty in write "
"workload. Otherwise, BRIN index can be considered as an alternative."
msgstr "Sobald eine Geodatentabelle ein paar tausend Zeilen überschreitet, werden Sie einen Index erzeugen wollen, um die räumlichen Abfragen auf die Daten zu beschleunigen (außer Ihre Suche basiert lediglich auf Attributen, in diesem Fall werden Sie einen gewöhnlichen Index auf die Attribute setzen). GIST Indizes sind sehr performant, solange ihre Dateigröße den verfügbaren Arbeitsspeicher der Datenbank nicht überschreitet, genügend Festplattenspeicher vorhanden ist und die Systembelastung durch Schreibvorgänge akzeptiert werden kann. Andernfalls bietet der BRIN Index eine Alternative."

#. Tag: para
#: using_postgis_dataman.xml:1974
#, no-c-format
msgid ""
"The idea of a BRIN index is to store only the bouding box englobing all the "
"geometries contained in all the rows in a set of table blocks, called a "
"range. Obviously, this indexing method will only be efficient if the data is"
" physically ordered in a way where the resulting bouding boxes for block "
"ranges will be mutually exclusive. The resulting index will be really small,"
" but will be less efficient than a GiST index in many cases."
msgstr "Die Idee hinter einem BRIN-Index ist, dass nur das Umgebungsrechteck abgespeichert wird, dass die gesamte Geometrie eines oder mehrerer Tabellenblöcke umschließt; dies wird als \"Range\" bezeichnet. Es ist klar, dass diese Indizierungsmethode nur dann effizient sein kann, wenn die Daten physikalisch so angeordnet sind, dass sich die resultierenden Umgebungsrechtecke der \"Block Ranges\" gegenseitig ausschließen. Der resultierende Index ist zwar sehr klein, in vielen Fällen allerdings weniger effizient als ein GIST Index."

#. Tag: para
#: using_postgis_dataman.xml:1982
#, no-c-format
msgid ""
"Building a BRIN index is way less intensive than building a GiST index. It's"
" quite common to build a BRIN index in more than ten time less than a GiST "
"index would have required. As a BRIN index only store one bouding box for "
"one to many table blocks, it's pretty common to consume up to a thousand "
"time less disk space for this kind of indexes."
msgstr "Die Erstellung eines BRIN-Index benötigt wesentlich weniger Zeit, als die Erstellung eines GIST-Index. Es ist durchaus üblich, dass die Erstellung des BRIN Index mehr als zehnmal so schnell ist, als die eines GIST Index. Da ein BRIN Index nur ein Umgebungsrechteck für einen oder mehrere Tabellenblöcke speichert, benötigt dieser oft bis zu tausendmal weniger Festplattenspeicher."

#. Tag: para
#: using_postgis_dataman.xml:1988
#, no-c-format
msgid ""
"You can choose the number of blocks to summarize in a range. If you decrease"
" this number, the index will be bigger but will probably help to get better "
"performance."
msgstr "Sie können die Anzahl der Blöcke festlegen, die zu einen \"Range\" aufsummiert werden sollen. Wenn Sie die Anzahl verringern, wird der Index zwar größer, höchstwahrscheinlich aber zu einer besseren Performanz verhelfen."

#. Tag: para
#: using_postgis_dataman.xml:1992
#, no-c-format
msgid ""
"The syntax for building a BRIN index on a \"geometry\" column is as follows:"
msgstr "Der Syntax zur Erstellung eines BRIN-Indizes auf eine geometrische Spalte lautet wie folgt:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1995
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] );"
msgstr "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1996
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get a 3d-dimensional "
"index, you can create one using this syntax"
msgstr "Die obere Syntax erzeugt immer einen 2D-Index. Um einen 3-dimensionalen Index zu erhalten, können Sie die folgende Syntax verwenden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1997
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_3d);"
msgstr "CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] brin_geometry_inclusion_ops_3d);"

#. Tag: para
#: using_postgis_dataman.xml:1998
#, no-c-format
msgid "You can also get a 4d-dimensional index using the 4d operator class"
msgstr "Sie können auch einen 4-dimensionalen Index über die 4D-Operatorklasse erstellen"

#. Tag: programlisting
#: using_postgis_dataman.xml:1999
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] "
"brin_geometry_inclusion_ops_4d);"
msgstr "CREATE INDEX [indexname] ON [tablename] USING BRIN ([geometryfield] brin_geometry_inclusion_ops_4d);"

#. Tag: para
#: using_postgis_dataman.xml:2000
#, no-c-format
msgid ""
"These above syntaxes will use the default number or block in a range, which "
"is 128. To specify the number of blocks you want to summarise in a range, "
"you can create one using this syntax"
msgstr "Die oberen Syntaxen verwenden die Standardeinstellung für die Anzahl der Blöcke in einem \"Range\", nämlich 128. Wenn Sie die Anzahl der Blöcke, die in einem Range zusammengefasst werden sollen, selbst festlegen wollen, verwenden Sie bitte die folgende Syntax"

#. Tag: programlisting
#: using_postgis_dataman.xml:2001
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] ) WITH "
"(pages_per_range = [number]);"
msgstr "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geometryfield] ) WITH (pages_per_range = [number]);"

#. Tag: para
#: using_postgis_dataman.xml:2002
#, no-c-format
msgid ""
"Also, keep in mind that a BRIN index will only store one index value for a "
"large number of rows. If your table stores geometries with a mixed number of"
" dimensions, it's likely that the resulting index will have poor "
"performance. You can avoid this drop of performance by choosing the operator"
" class whith the least number of dimensions of the stored geometries"
msgstr "Beachten Sie bitte auch, dass ein BRIN Index nur einen Indexwert für eine große Anzahl von Zeilen speichert. Wenn Ihre Tabelle eine Geometrie mit unterschiedlichen Dimensionen speichert, dann ist es wahrscheinlich dass der Index eine schlechte Performanz aufweist. Sie können diesen Performanzrückgang vermeiden, indem Sie die Operatorklasse mit der niedrigsten Dimension der gespeicherten Geometrie wählen."

#. Tag: para
#: using_postgis_dataman.xml:2010
#, no-c-format
msgid ""
"Also the \"geography\" datatype is supported for BRIN indexing. The syntax "
"for building a BRIN index on a \"geography\" column is as follows:"
msgstr "Der BRIN-Index wird auch vom geographischen Datentyp unterstützt. Die Syntax zur Erstellung eines BRIN-Index auf eine \"geographische\" Spalte lautet wie folgt:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2013
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geographyfield] );"
msgstr "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geographyfield] );"

#. Tag: para
#: using_postgis_dataman.xml:2014
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index for geospatial objects on the "
"spheroid."
msgstr "Der obere Syntax erzeugt den 2D-Index für Geoobjekte immer auf dem Referenzellipsoid."

#. Tag: para
#: using_postgis_dataman.xml:2016
#, no-c-format
msgid ""
"Currently, just the \"inclusion support\" is considered here, meaning that "
"just <varname>&amp;&amp;</varname>, <varname>~</varname> and "
"<varname>@</varname> operators can be used for the 2D cases (both for "
"\"geometry\" and for \"geography\"), and just the "
"<varname>&amp;&amp;&amp;</varname> operator can be used for the 3D "
"geometries. There is no support for kNN searches at the moment."
msgstr "Aktuell wird hierbei nur die \"Inklusionsunterstützung\" betrachtet; d.h. dass nur die Operatoren <varname>&amp;&amp;</varname>, <varname>~</varname> und <varname>@</varname> für 2D (sowohl für den \"geometrischen\", als auch für den \"geographischen\" Datentyp), und nur der Operator <varname>&amp;&amp;&amp;</varname> für 3D-Geometrie verwendet werden kann. Die kNN-Suche wird zur Zeit nicht unterstützt."

#. Tag: title
#: using_postgis_dataman.xml:2027
#, no-c-format
msgid "Using Indexes"
msgstr "Verwendung von Indizes"

#. Tag: para
#: using_postgis_dataman.xml:2029
#, no-c-format
msgid ""
"Ordinarily, indexes invisibly speed up data access: once the index is built,"
" the query planner transparently decides when to use index information to "
"speed up a query plan. Unfortunately, the PostgreSQL query planner does not "
"optimize the use of GiST indexes well, so sometimes searches which should "
"use a spatial index instead default to a sequence scan of the whole table."
msgstr "Üblicherweise beschleunigen Indizes den Datenzugriff: Sobald der Index aufgebaut ist, entscheidet der Anfrageoptimierer ob der Index den Auswertungsplan bescheunigt. Unglücklicherweise optimiert der Anfrageoptimierer von PostgreSQL die Verwendung von GIST Indizes nicht sehr gut, so dass manchmal eine Suche, welche die Verwendung eines räumlichen Index bedingen sollte, über einen Full Table Scan ausgeführt wird."

#. Tag: para
#: using_postgis_dataman.xml:2036
#, no-c-format
msgid ""
"If you find your spatial indexes are not being used (or your attribute "
"indexes, for that matter) there are a couple things you can do:"
msgstr "Wenn Sie bemerken, dass Ihre räumlichen Indizes (oder Ihre Attributindizes) nicht verwendet werden, können Sie eine Reihe von Dingen unternehmen:"

#. Tag: para
#: using_postgis_dataman.xml:2042
#, no-c-format
msgid ""
"Firstly, make sure statistics are gathered about the number and "
"distributions of values in a table, to provide the query planner with better"
" information to make decisions around index usage. For PostgreSQL 7.4 "
"installations and below this is done by running "
"<command>update_geometry_stats([table_name, column_name])</command> (compute"
" distribution) and <command>VACUUM ANALYZE [table_name] "
"[column_name]</command> (compute number of values). Starting with PostgreSQL"
" 8.0 running <command>VACUUM ANALYZE</command> will do both operations. You "
"should regularly vacuum your databases anyways -- many PostgreSQL DBAs have "
"<command>VACUUM</command> run as an off-peak cron job on a regular basis."
msgstr "Zuerst stellen Sie bitte sicher, dass eine Statistik über die Anzahl und die Verteilung der Werte in der Tabelle erfasst wurde. Dadurch wird dem Anfrageoptimierer bessere Information zur Verfügung gestellt, um die Entscheidungen bezüglich der Anwendung des Index zu treffen. Bei PostgreSQL 7.4 und niedriger wird dies durch <command>update_geometry_stats([table_name, column_name])</command> (compute distribution) und <command>VACUUM ANALYZE [table_name] [column_name]</command> (compute number of values). "

#. Tag: para
#: using_postgis_dataman.xml:2056
#, no-c-format
msgid ""
"If vacuuming does not work, you can force the planner to use the index "
"information by using the <command>SET ENABLE_SEQSCAN=OFF</command> command. "
"You should only use this command sparingly, and only on spatially indexed "
"queries: generally speaking, the planner knows better than you do about when"
" to use normal B-Tree indexes. Once you have run your query, you should "
"consider setting <varname>ENABLE_SEQSCAN</varname> back on, so that other "
"queries will utilize the planner as normal."
msgstr "Wenn VACUUM nicht funktioniert, können Sie den Anfrageoptimierer dazu zwingen den Index zu verwenden, indem Sie den Befehl <command>SET ENABLE_SEQSCAN=OFF</command> ausführen. Sie sollten diesen Befehl sehr spärlich und nur für räumlich indizierte Anfragen verwenden: d.h. der Anfrageoptimierer weiß besser Bescheid als Sie, ob ein gewöhnlicher B-Baum Index verwendet werden soll oder nicht. Sobald Sie Ihre Abfrage ausgeführt haben sollten Sie daher <varname>ENABLE_SEQSCAN</varname> wieder auf ON stellen, damit weitere Abfragen den Anfrageoptimierer wie üblich nutzen können."

#. Tag: para
#: using_postgis_dataman.xml:2066
#, no-c-format
msgid ""
"As of version 0.6, it should not be necessary to force the planner to use "
"the index with <varname>ENABLE_SEQSCAN</varname>."
msgstr "Ab Version 0.6 sollte es nicht mehr notwendig sein, den Anfrageoptimierer mittels <varname>ENABLE_SEQSCAN</varname> zur Anwendung des Index zu zwingen."

#. Tag: para
#: using_postgis_dataman.xml:2073
#, no-c-format
msgid ""
"If you find the planner wrong about the cost of sequential vs index scans "
"try reducing the value of random_page_cost in postgresql.conf or using SET "
"random_page_cost=#. Default value for the parameter is 4, try setting it to "
"1 or 2. Decrementing the value makes the planner more inclined of using "
"Index scans."
msgstr "Wenn Sie herausfinden, daß sich der Anfrageoptimierer bezüglich der Kosten des Full Table Scan im Verhältnis zum Index Scan irrt, können Sie versuchen den Wert von \"randam_page_cost\" in \"postgresql.conff\" zu reduzieren, oder SET random_page_cost=# ausführen. Der Standardwert des Parameters ist 4, versuchen Sie ihn auf 1 oder 2 zu setzen. Eine Verringerung des Wertes führt dazu, dass der Anfrageoptimierer eher den Index Scan verwendet."

#. Tag: title
#: using_postgis_dataman.xml:2084
#, no-c-format
msgid "Complex Queries"
msgstr "Komplexe Abfragen"

#. Tag: para
#: using_postgis_dataman.xml:2086
#, no-c-format
msgid ""
"The <emphasis>raison d'etre</emphasis> of spatial database functionality is "
"performing queries inside the database which would ordinarily require "
"desktop GIS functionality. Using PostGIS effectively requires knowing what "
"spatial functions are available, and ensuring that appropriate indexes are "
"in place to provide good performance. The SRID of 312 used in these examples"
" is purely for demonstration. You should be using a REAL SRID listed in the "
"the spatial_ref_sys table and one that matches the projection of your data. "
"If your data has no spatial reference system specified, you should be "
"THINKING very thoughtfully why it doesn't and maybe it should."
msgstr "<emphasis>Sinn und Zweck</emphasis> der Geodatenbankfunktionalität ist es, Abfragen innerhalb der Datenbank auszuführen, welche üblicherweise die Funktionalität eines Desktop-GIS benötigen würden. Um PostGIS effizient zu nutzen, müssen Sie die verfügbaren räumlichen Funktionen kennen und sicherstellen, dass die geeigneten Indizes vorhanden sind um eine gute Performanz zu gewährleisten. Die SRID von 312, die in diesen Beispielen verwendet wird, ist für bloße Demonstrationszwecke gedacht. Sie sollten eine ECHTE SRID aus der Tabelle \"spatial_ref_sys\" verwenden, die auch mit der Projektion Ihrer Daten übereinstimmen muss. Falls Ihren Daten kein Koordinatenreferenzsystem zugewiesen ist, sollten Sie genau eruieren warum dies so ist."

#. Tag: para
#: using_postgis_dataman.xml:2094
#, no-c-format
msgid ""
"If your reason is because you are modeling something that doesn't have a "
"geographic spatial reference system defined such as the internals of a "
"molecule or the floorplan of a not yet built amusement park then that's "
"fine. If the location of the amusement park has been planned however, then "
"it would make sense to use a suitable planar coordinate system for that "
"location if nothing more than to ensure the amusement part is not "
"trespassing on already existing structures."
msgstr "Wenn der Grund darin liegt, dass Sie irgendetwas modellieren, für dass kein Koordinatenreferenzsystem festgelegt ist, wie der innere Aufbau eines Moleküls oder der Grundriss eines noch nicht gebauten Vergnügungsparks, so ist dies in Ordnung. Wenn der Standort des Vergnügungsparks bereits geplant wurde, dann ist die Wahl eines geeigneten Koordinatenreferenzsystems sinnvoll, auch wenn es nur darum geht sicherzustellen, dass der Vergnügungspark keine bereits bestehenden Strukturen überdeckt."

#. Tag: para
#: using_postgis_dataman.xml:2098
#, no-c-format
msgid ""
"Even in the case where you are planning a Mars expedition to transport the "
"human race in the event of a nuclear holocaust and you want to map out the "
"Mars planet for rehabitation, you can use a non-earthly coordinate system "
"such as <ulink "
"url=\"http://spatialreference.org/ref/iau2000/mars-2000/\">Mars 2000</ulink>"
" make one up and insert it in the <varname>spatial_ref_sys</varname> table. "
"Though this Mars coordinate system is a non-planar one (it's in degrees "
"spheroidal), you can use it with the geography type to have your length and "
"proximity measurements in meters instead of degrees."
msgstr "Sogar wenn Sie eine Mars Expedition planen, um die menschliche Rasse nach einem nuklearen Holocaust zu transportieren und Sie den Planeten Mars für die Besiedelung kartieren wollen, so können Sie ein Koordinatenreferenzsystem wie <ulink url=\"http://spatialreference.org/ref/iau2000/mars-2000/\">Mars 2000</ulink> erstellen und dieses in die Tabelle <varname>spatial_ref_sys</varname> einfügen. Obwohl diese Koordinatensystem für den Mars nicht planar ist (es ist in Grad des Referenzellipsoids), können Sie es mit dem geographischen Datentyp nutzen, um Längen- und Abstandsmessungen in Meter anstatt in Grad anzuzeigen."

#. Tag: title
#: using_postgis_dataman.xml:2104
#, no-c-format
msgid "Taking Advantage of Indexes"
msgstr "Indizes nutzen"

#. Tag: para
#: using_postgis_dataman.xml:2106
#, no-c-format
msgid ""
"When constructing a query it is important to remember that only the "
"bounding-box-based operators such as &amp;&amp; can take advantage of the "
"GiST spatial index. Functions such as <varname>ST_Distance()</varname> "
"cannot use the index to optimize their operation. For example, the following"
" query would be quite slow on a large table:"
msgstr "Wenn Sie eine Abfrage erstellen müssen Sie beachten, dass nur die auf den Umgebungsrechtecken basierenden Operatoren wie &amp;&amp; die Vorteile eines räumlichen GIST Index ausnutzen können. Funktionen wie <varname>ST_Distance()</varname> können den Index nicht zur Optimierung heranziehen. Zum Beispiel würde die folgende Abfrage auf eine große Tabelle ziemlich langsam ablaufen:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2113
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) &lt; 100"
msgstr "SELECT the_geom\nFROM geom_table\nWHERE ST_Distance(the_geom, ST_GeomFromText('POINT(100000 200000)', 312)) &lt; 100"

#. Tag: para
#: using_postgis_dataman.xml:2115
#, no-c-format
msgid ""
"This query is selecting all the geometries in geom_table which are within "
"100 units of the point (100000, 200000). It will be slow because it is "
"calculating the distance between each point in the table and our specified "
"point, ie. one <varname>ST_Distance()</varname> calculation for each row in "
"the table. We can avoid this by using the &amp;&amp; operator to reduce the "
"number of distance calculations required:"
msgstr "Diese Abfrage wählt all jene Geometrie der Tabelle \"geom_table\" aus, die weniger als 100 Einheiten von dem Punkt (100000, 200000) entfernt liegt. Sie ist sehr langsam, da die Entfernung zwischen jedem Punkt in der Tabelle und Unserem angegebenen Punkt berechnet werden muss, d.h. eine <varname>ST_Distance()</varname> Berechnung pro Tabellenzeile. Wir können dies vermeiden, indem wir den Operator \"&amp;&amp;\" verwenden und so die Anzahl der benötigten Entfernungsberechnungen verringern:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2122
#, no-c-format
msgid ""
"SELECT the_geom\n"
"FROM geom_table\n"
"WHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, 200100,312), 100)"
msgstr "SELECT the_geom\nFROM geom_table\nWHERE ST_DWithin(the_geom,  ST_MakeEnvelope(90900, 190900, 100100, 200100,312), 100)"

#. Tag: para
#: using_postgis_dataman.xml:2124
#, no-c-format
msgid ""
"This query selects the same geometries, but it does it in a more efficient "
"way. Assuming there is a GiST index on the_geom, the query planner will "
"recognize that it can use the index to reduce the number of rows before "
"calculating the result of the <varname>ST_distance()</varname> function. "
"Notice that the <varname>ST_MakeEnvelope</varname> geometry which is used in"
" the &amp;&amp; operation is a 200 unit square box centered on the original "
"point - this is our \"query box\". The &amp;&amp; operator uses the index to"
" quickly reduce the result set down to only those geometries which have "
"bounding boxes that overlap the \"query box\". Assuming that our query box "
"is much smaller than the extents of the entire geometry table, this will "
"drastically reduce the number of distance calculations that need to be done."
msgstr "Diese Anfrage wählt dieselbe Geometrie aus, allerdings auf effizientere Weise. Angenommen es existiert ein GIST Index auf der Spalte \"the_geom\" und der Anfrageoptimierer erkennt, dass der Index angewendet werden kann, um die Zeilenanzahl zu verringern, bevor das Ergebnis durch die Funktion <varname>ST_Distance()</varname> errechnet wird. Anmerkung: die Geometrie <varname>ST_MakeEnvelope</varname>, die vom Operator \"&amp;&amp;\" verwendet wird, ist ein Quadrat mit einer Seitenlänge von 200 Einheiten, dessen Mittelpunkt auf dem ursprünglichen Punkt liegt - dies ist Unsere \"Abfrage Box\". Der Operator \"&amp;&amp;\" verwendet diesen Index, um die Ergebnismenge rasch auf die Geometrie zu reduzieren, deren Umgebungsrechtecke die \"Abfrage Box\" überlagern. Falls Unsere \"Abfrage Box\" wesentlich kleiner als die Gesamtausdehnung der gesamten Geometrietabelle ist, wird dadurch die Anzahl der Entfernungsberechnungen drastisch verringert- dies ist genau das, was wir wollen."

#. Tag: title
#: using_postgis_dataman.xml:2138
#, no-c-format
msgid "Change in Behavior"
msgstr "Änderung der Verhaltensweise"

#. Tag: para
#: using_postgis_dataman.xml:2140
#, no-c-format
msgid ""
"As of PostGIS 1.3.0, most of the Geometry Relationship Functions, with the "
"notable exceptions of ST_Disjoint and ST_Relate, include implicit bounding "
"box overlap operators."
msgstr "Ab PostGIS 1.3.0 implizieren die meisten geometrischen Relationsfunktionen die Verwendung von Überlappungsoperatoren auf die Umgebungsrechtecke. Erwähnenswerte Ausnahmen sind ST_Disjoint und ST_Relate."

#. Tag: title
#: using_postgis_dataman.xml:2147
#, no-c-format
msgid "Examples of Spatial SQL"
msgstr "Beispiele für Spatial SQL"

#. Tag: para
#: using_postgis_dataman.xml:2149
#, no-c-format
msgid ""
"The examples in this section will make use of two tables, a table of linear "
"roads, and a table of polygonal municipality boundaries. The table "
"definitions for the <varname>bc_roads</varname> table is:"
msgstr "Die Beispiele in diesem Abschnitt verwenden zwei Tabellen, eine Tabelle mit linearen Strassen, und eine Tabelle mit polygonalen Verwaltungsgrenzen. Die Tabellendefinition der Tabelle <varname>bc_roads</varname> lautet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2153
#, no-c-format
msgid ""
"Column      | Type              | Description\n"
"------------+-------------------+-------------------\n"
"gid         | integer           | Unique ID\n"
"name        | character varying | Road Name\n"
"the_geom    | geometry          | Location Geometry (Linestring)"
msgstr "Column      | Type              | Description\n------------+-------------------+-------------------\ngid         | integer           | Unique ID\nname        | character varying | Road Name\nthe_geom    | geometry          | Location Geometry (Linestring)"

#. Tag: para
#: using_postgis_dataman.xml:2155
#, no-c-format
msgid ""
"The table definition for the <varname>bc_municipality</varname> table is:"
msgstr "Die Tabellendefinition für die Tabelle <varname>bc_municipality</varname>:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2158
#, no-c-format
msgid ""
"Column     | Type              | Description\n"
"-----------+-------------------+-------------------\n"
"gid        | integer           | Unique ID\n"
"code       | integer           | Unique ID\n"
"name       | character varying | City / Town Name\n"
"the_geom   | geometry          | Location Geometry (Polygon)"
msgstr "Column     | Type              | Description\n-----------+-------------------+-------------------\ngid        | integer           | Unique ID\ncode       | integer           | Unique ID\nname       | character varying | City / Town Name\nthe_geom   | geometry          | Location Geometry (Polygon)"

#. Tag: para
#: using_postgis_dataman.xml:2163
#, no-c-format
msgid "What is the total length of all roads, expressed in kilometers?"
msgstr "Gesamtlänge aller Straßen in Kilometer?"

#. Tag: para
#: using_postgis_dataman.xml:2168
#, no-c-format
msgid "You can answer this question with a very simple piece of SQL:"
msgstr "Sie können diese Frage mit einer sehr einfachen SQL Anweisung beantworten:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2171
#, no-c-format
msgid ""
"SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
"\n"
"km_roads\n"
"------------------\n"
"70842.1243039643\n"
"(1 row)"
msgstr "SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n\nkm_roads\n------------------\n70842.1243039643\n(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2177
#, no-c-format
msgid "How large is the city of Prince George, in hectares?"
msgstr "Wieviele Hektar hat die Stadt Prince George?"

#. Tag: para
#: using_postgis_dataman.xml:2181
#, no-c-format
msgid ""
"This query combines an attribute condition (on the municipality name) with a"
" spatial calculation (of the area):"
msgstr "Diese Abfrage kombiniert eine Attributbedingung (auf den Gemeindenamen) mit einer räumlichen Berechnung (der Fläche):"

#. Tag: programlisting
#: using_postgis_dataman.xml:2185
#, no-c-format
msgid ""
"SELECT\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM bc_municipality\n"
"WHERE name = 'PRINCE GEORGE';\n"
"\n"
"hectares\n"
"------------------\n"
"32657.9103824927\n"
"(1 row)"
msgstr "SELECT\n  ST_Area(the_geom)/10000 AS hectares\nFROM bc_municipality\nWHERE name = 'PRINCE GEORGE';\n\nhectares\n------------------\n32657.9103824927\n(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2191
#, no-c-format
msgid "What is the largest municipality in the province, by area?"
msgstr "Welche ist die flächengrößte Gemeinde der Provinz?"

#. Tag: para
#: using_postgis_dataman.xml:2196
#, no-c-format
msgid ""
"This query brings a spatial measurement into the query condition. There are "
"several ways of approaching this problem, but the most efficient is below:"
msgstr "Diese Abfrage verwendet eine räumliche Messung als Abfragefilter. Es gibt verschiedene Wege, um diese Problem anzugehen, aber die effizienteste Methode ist folgende:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2200
#, no-c-format
msgid ""
"SELECT\n"
"  name,\n"
"  ST_Area(the_geom)/10000 AS hectares\n"
"FROM\n"
"  bc_municipality\n"
"ORDER BY hectares DESC\n"
"LIMIT 1;\n"
"\n"
"name           | hectares\n"
"---------------+-----------------\n"
"TUMBLER RIDGE  | 155020.02556131\n"
"(1 row)"
msgstr "SELECT\n  name,\n  ST_Area(the_geom)/10000 AS hectares\nFROM\n  bc_municipality\nORDER BY hectares DESC\nLIMIT 1;\n\nname           | hectares\n---------------+-----------------\nTUMBLER RIDGE  | 155020.02556131\n(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2202
#, no-c-format
msgid ""
"Note that in order to answer this query we have to calculate the area of "
"every polygon. If we were doing this a lot it would make sense to add an "
"area column to the table that we could separately index for performance. By "
"ordering the results in a descending direction, and them using the "
"PostgreSQL \"LIMIT\" command we can easily pick off the largest value "
"without using an aggregate function like max()."
msgstr "Um diese Anfrage zu beantworten müssen wir die Fläche eines jeden Polygons berechnen. Wenn wir dies oft machen müssen, kann es aufgrund der Rechenleistung sinnvoll sein, eine eigene Flächenspalte an die Tabelle anzuhängen und mit einem Index zu versehen. Indem wir das Ergebnis in absteigender Reihenfolge sortieren und den PostgreSQL Befehl \"LIMIT\" einsetzen, können wir die größten Werte herausfiltern, ohne eine Aggregatfunktion wie max() verwenden zu müssen."

#. Tag: para
#: using_postgis_dataman.xml:2214
#, no-c-format
msgid "What is the length of roads fully contained within each municipality?"
msgstr "Welche Länge haben die Straßen, die zur Gänze innerhalb einer Gemeinde liegen?"

#. Tag: para
#: using_postgis_dataman.xml:2219
#, no-c-format
msgid ""
"This is an example of a \"spatial join\", because we are bringing together "
"data from two tables (doing a join) but using a spatial interaction "
"condition (\"contained\") as the join condition rather than the usual "
"relational approach of joining on a common key:"
msgstr "Dies ist ein Beispiel für einen \"Spatial Join\", da wir die Daten aus zwei Tabellen zusammenführen (einen Join ausführen) und als Join-Bedingung eine räumliche Interaktion (\"contained\") verwenden - anstelle  des üblichen relationalen Ansatzes bei dem die Tabellen über einen gemeinsamen Schlüssel verknüpft werden:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2225
#, no-c-format
msgid ""
"SELECT\n"
"  m.name,\n"
"  sum(ST_Length(r.the_geom))/1000 as roads_km\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE\n"
"  ST_Contains(m.the_geom,r.the_geom)\n"
"GROUP BY m.name\n"
"ORDER BY roads_km;\n"
"\n"
"name                        | roads_km\n"
"----------------------------+------------------\n"
"SURREY                      | 1539.47553551242\n"
"VANCOUVER                   | 1450.33093486576\n"
"LANGLEY DISTRICT            | 833.793392535662\n"
"BURNABY                     | 773.769091404338\n"
"PRINCE GEORGE               | 694.37554369147\n"
"..."
msgstr "SELECT\n  m.name,\n  sum(ST_Length(r.the_geom))/1000 as roads_km\nFROM\n  bc_roads AS r,\n  bc_municipality AS m\nWHERE\n  ST_Contains(m.the_geom,r.the_geom)\nGROUP BY m.name\nORDER BY roads_km;\n\nname                        | roads_km\n----------------------------+------------------\nSURREY                      | 1539.47553551242\nVANCOUVER                   | 1450.33093486576\nLANGLEY DISTRICT            | 833.793392535662\nBURNABY                     | 773.769091404338\nPRINCE GEORGE               | 694.37554369147\n..."

#. Tag: para
#: using_postgis_dataman.xml:2227
#, no-c-format
msgid ""
"This query takes a while, because every road in the table is summarized into"
" the final result (about 250K roads for our particular example table). For "
"smaller overlays (several thousand records on several hundred) the response "
"can be very fast."
msgstr "Diese Abfrage dauert ein Weilchen, da sämtliche Straßen in der Tabelle in das endgültige Ergebnis aufsummiert werden müssen (über 250k Straßen in Unserem speziellen Beispiel). Bei kleineren Überlagerungen (ein paar tausend Datensätze auf ein paar Hundert) kann die Antwort sehr schnell zurückkommen."

#. Tag: para
#: using_postgis_dataman.xml:2236
#, no-c-format
msgid ""
"Create a new table with all the roads within the city of Prince George."
msgstr "Eine neue Tabelle erzeugen, die alle Straßen der Stadt Prince George beinhaltet."

#. Tag: para
#: using_postgis_dataman.xml:2241
#, no-c-format
msgid ""
"This is an example of an \"overlay\", which takes in two tables and outputs "
"a new table that consists of spatially clipped or cut resultants. Unlike the"
" \"spatial join\" demonstrated above, this query actually creates new "
"geometries. An overlay is like a turbo-charged spatial join, and is useful "
"for more exact analysis work:"
msgstr "Dies ist ein Beispiel für ein \"Overlay\", das zwei Tabellen entgegennimmt und eine neue Tabelle ausgibt, welche die aus- und abgeschnittene Ergebnisgeometrie enthält. Anders als bei dem oben gezeigten \"Spatial Join\" erzeugt diese Abfrage eine neue Geometrie. Ein \"Overlay\" ist wie ein \"Spatial Join\" mit Turbolader und wird für genauere Analysen verwendet:"

#. Tag: programlisting
#: using_postgis_dataman.xml:2248
#, no-c-format
msgid ""
"CREATE TABLE pg_roads as\n"
"SELECT\n"
"  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n"
"  ST_Length(r.the_geom) AS rd_orig_length,\n"
"  r.*\n"
"FROM\n"
"  bc_roads AS r,\n"
"  bc_municipality AS m\n"
"WHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);"
msgstr "CREATE TABLE pg_roads as\nSELECT\n  ST_Intersection(r.the_geom, m.the_geom) AS intersection_geom,\n  ST_Length(r.the_geom) AS rd_orig_length,\n  r.*\nFROM\n  bc_roads AS r,\n  bc_municipality AS m\nWHERE  m.name = 'PRINCE GEORGE' AND ST_Intersects(r.the_geom, m.the_geom);"

#. Tag: para
#: using_postgis_dataman.xml:2254
#, no-c-format
msgid "What is the length in kilometers of \"Douglas St\" in Victoria?"
msgstr "Wie lange ist die \"Douglas St\" in Victoria in Kilometern?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2259
#, no-c-format
msgid ""
"SELECT\n"
"  sum(ST_Length(r.the_geom))/1000 AS kilometers\n"
"FROM\n"
"  bc_roads r,\n"
"  bc_municipality m\n"
"WHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA'\n"
"        AND ST_Contains(m.the_geom, r.the_geom) ;\n"
"\n"
"kilometers\n"
"------------------\n"
"4.89151904172838\n"
"(1 row)"
msgstr "SELECT\n  sum(ST_Length(r.the_geom))/1000 AS kilometers\nFROM\n  bc_roads r,\n  bc_municipality m\nWHERE  r.name = 'Douglas St' AND m.name = 'VICTORIA'\n        AND ST_Contains(m.the_geom, r.the_geom) ;\n\nkilometers\n------------------\n4.89151904172838\n(1 row)"

#. Tag: para
#: using_postgis_dataman.xml:2265
#, no-c-format
msgid "What is the largest municipality polygon that has a hole?"
msgstr "Welches ist das größte Gemeindepolygon mit einer Lücke?"

#. Tag: programlisting
#: using_postgis_dataman.xml:2270
#, no-c-format
msgid ""
"SELECT gid, name, ST_Area(the_geom) AS area\n"
"FROM bc_municipality\n"
"WHERE ST_NRings(the_geom) &gt; 1\n"
"ORDER BY area DESC LIMIT 1;\n"
"\n"
"gid  | name         | area\n"
"-----+--------------+------------------\n"
"12   | SPALLUMCHEEN | 257374619.430216\n"
"(1 row)"
msgstr "SELECT gid, name, ST_Area(the_geom) AS area\nFROM bc_municipality\nWHERE ST_NRings(the_geom) &gt; 1\nORDER BY area DESC LIMIT 1;\n\ngid  | name         | area\n-----+--------------+------------------\n12   | SPALLUMCHEEN | 257374619.430216\n(1 row)"
