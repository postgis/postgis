# SOME DESCRIPTIVE TITLE.
#
# Translators:
# Andreas Schild <andreas.schild@bfw.gv.at>, 2017-2019
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2020-12-15 04:51+0000\n"
"PO-Revision-Date: 2019-03-11 14:57+0000\n"
"Last-Translator: Andreas Schild <andreas.schild@bfw.gv.at>\n"
"Language-Team: German (http://www.transifex.com/postgis/postgis/language/"
"de/)\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. Tag: para
#: reference_measure.xml:5
#, no-c-format
msgid ""
"These functions compute measurements of distance, area and angles. There are "
"also functions to compute geometry values determined by measurements."
msgstr ""

#. Tag: title
#: reference_measure.xml:10
#, no-c-format
msgid "Measurement Functions"
msgstr ""

#. Tag: refname
#: reference_measure.xml:14
#, no-c-format
msgid "ST_Area"
msgstr "ST_Area"

#. Tag: refpurpose
#: reference_measure.xml:16
#, fuzzy, no-c-format
msgid "Returns the area of a polygonal geometry."
msgstr "Gibt den geometrischen Schwerpunkt einer Geometrie zurück."

#. Tag: funcsynopsis
#: reference_measure.xml:20
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Area</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Area</function></"
"funcdef> <paramdef><type>geography </type><parameter>geog</parameter></"
"paramdef> <paramdef choice=\"opt\"><type>boolean </"
"type><parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_Area</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Area</function></"
"funcdef> <paramdef><type>geography </type><parameter>geog</parameter></"
"paramdef> <paramdef choice=\"opt\"><type>boolean </"
"type><parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"

#. Tag: title
#: reference_measure.xml:34 reference_measure.xml:97 reference_measure.xml:173
#: reference_measure.xml:217 reference_measure.xml:291
#: reference_measure.xml:372 reference_measure.xml:448
#: reference_measure.xml:497 reference_measure.xml:544
#: reference_measure.xml:600 reference_measure.xml:672
#: reference_measure.xml:737 reference_measure.xml:794
#: reference_measure.xml:826 reference_measure.xml:869
#: reference_measure.xml:923 reference_measure.xml:1018
#: reference_measure.xml:1085 reference_measure.xml:1137
#: reference_measure.xml:1179 reference_measure.xml:1253
#: reference_measure.xml:1300 reference_measure.xml:1351
#: reference_measure.xml:1386 reference_measure.xml:1432
#: reference_measure.xml:1488 reference_measure.xml:1565
#, no-c-format
msgid "Description"
msgstr "Beschreibung"

#. Tag: para
#: reference_measure.xml:36
#, fuzzy, no-c-format
msgid ""
"Returns the area of a polygonal geometry. For geometry types a 2D Cartesian "
"(planar) area is computed, with units specified by the SRID. For geography "
"types by default area is determined on a spheroid with units in square "
"meters. To compute the area using the faster but less accurate spherical "
"model use <varname>ST_Area(geog,false)</varname>."
msgstr ""
"Gibt den Flächeninhalt von Polygonen und Mehrfachpolygonen zurück. Gibt den "
"Flächeninhalt der Datentypen \"ST_Surface\" und \"ST_MultiSurface\" zurück. "
"Beim geometrischen Datentyp wird die kartesische 2D-Fläche ermittelt und in "
"den Einheiten des SRID ausgegeben. Beim geographischen Datentyp wird die "
"Fläche standardmäßig auf einem Referenzellipsoid ermittelt und in "
"Quadratmeter ausgegeben. Mit ST_Area(geog,false) kann der Flächeninhalt auf "
"einer Kugel ermittelt werden; dies ist zwar schneller aber auch weniger "
"genau."

#. Tag: para
#: reference_measure.xml:41
#, no-c-format
msgid "Enhanced: 2.0.0 - support for 2D polyhedral surfaces was introduced."
msgstr ""
"Erweiterung: Mit 2.0.0 wurde 2D-Unterstützung für polyedrische Oberflächen "
"eingeführt."

#. Tag: para
#: reference_measure.xml:42 reference_measure.xml:389
#, no-c-format
msgid ""
"Enhanced: 2.2.0 - measurement on spheroid performed with GeographicLib for "
"improved accuracy and robustness. Requires Proj &gt;= 4.9.0 to take "
"advantage of the new feature."
msgstr ""
"Erweiterung: 2.2.0 - die Messung auf dem Referenzellipsoid wird mit der "
"Bibliothek \"GeographicLib\" durchgeführt. Dadurch wurde die Genauigkeit und "
"die Robustheit erhöht. Um die Vorteile dieser neuen Funktionalität zu "
"nutzen, benötigen Sie Proj &gt;= 4.9.0."

#. Tag: para
#: reference_measure.xml:43 reference_measure.xml:390
#, no-c-format
msgid "Changed: 3.0.0 - does not depend on SFCGAL anymore."
msgstr ""

#. Tag: para
#: reference_measure.xml:44 reference_measure.xml:382
#, no-c-format
msgid "&sfs_compliant;"
msgstr "&sfs_compliant;"

#. Tag: para
#: reference_measure.xml:45
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 8.1.2, 9.5.3"
msgstr "&sqlmm_compliant; SQL-MM 3: 8.1.2, 9.5.3"

#. Tag: para
#: reference_measure.xml:46 reference_measure.xml:298 reference_measure.xml:455
#: reference_measure.xml:1030 reference_measure.xml:1144
#: reference_measure.xml:1581
#, no-c-format
msgid "&P_support;"
msgstr "&P_support;"

#. Tag: para
#: reference_measure.xml:47
#, no-c-format
msgid ""
"For polyhedral surfaces, only supports 2D polyhedral surfaces (not 2.5D). "
"For 2.5D, may give a non-zero answer, but only for the faces that sit "
"completely in XY plane."
msgstr ""
"Bei polyedrischen Oberflächen wird nur 2D (nicht 2.5D) unterstützt. Bei 2.5D "
"kann ein Ergebnis ungleich null geliefert werden, wenn die Oberflächen "
"vollständig in der XY-Ebene liegen."

#. Tag: title
#: reference_measure.xml:52 reference_measure.xml:113 reference_measure.xml:188
#: reference_measure.xml:227 reference_measure.xml:304
#: reference_measure.xml:464 reference_measure.xml:511
#: reference_measure.xml:561 reference_measure.xml:626
#: reference_measure.xml:701 reference_measure.xml:836
#: reference_measure.xml:886 reference_measure.xml:936
#: reference_measure.xml:1034 reference_measure.xml:1099
#: reference_measure.xml:1151 reference_measure.xml:1220
#: reference_measure.xml:1265 reference_measure.xml:1396
#: reference_measure.xml:1504 reference_measure.xml:1585
#, no-c-format
msgid "Examples"
msgstr "Beispiele"

#. Tag: para
#: reference_measure.xml:53
#, no-c-format
msgid ""
"Return area in square feet for a plot of Massachusetts land and multiply by "
"conversion to get square meters. Note this is in square feet because "
"EPSG:2249 is Massachusetts State Plane Feet"
msgstr ""
"Gibt den Flächeninhalt eines Grundstücks in Massachusetts - in Quadratfuß  "
"und konvertiert in Quadratmeter - zurück. Anmerkung: Wegen \"Massachusetts "
"State Plane Feet\" (EPSG:2249) wird der Flächeninhalt in Quadratfuß "
"ausgegeben"

#. Tag: programlisting
#: reference_measure.xml:56
#, no-c-format
msgid ""
"select ST_Area(geom) sqft,\n"
"    ST_Area(geom) * 0.3048 ^ 2 sqm\n"
"from (\n"
"         select 'SRID=2249;POLYGON((743238 2967416,743238 2967450,\n"
"                                 743265 2967450,743265.625 2967416,743238 "
"2967416))' :: geometry geom\n"
"     ) subquery;\n"
"┌─────────┬─────────────┐\n"
"│  sqft   │     sqm     │\n"
"├─────────┼─────────────┤\n"
"│ 928.625 │ 86.27208552 │\n"
"└─────────┴─────────────┘"
msgstr ""

#. Tag: para
#: reference_measure.xml:57
#, no-c-format
msgid ""
"Return area square feet and transform to Massachusetts state plane meters "
"(EPSG:26986) to get square meters. Note this is in square feet because 2249 "
"is Massachusetts State Plane Feet and transformed area is in square meters "
"since EPSG:26986 is state plane Massachusetts meters"
msgstr ""
"Gibt den Flächeninhalt in Quadratfuß aus und transformiert nach "
"\"Massachusetts state plane meters\" (EPSG:26986) um Quadratmeter zu "
"erhalten. Da die Fläche in \"Massachusetts State Plane Feet\" (EPSG:2249) "
"vorliegt, wird der Flächeninhalt in Quadratfuß ausgegeben. Die "
"transformierte Fläche ist in Quadratmeter, da sie in EPSG:26986 "
"\"Massachusetts state plane meters\" (EPSG:26986) vorliegt."

#. Tag: programlisting
#: reference_measure.xml:60
#, no-c-format
msgid ""
"select ST_Area(geom) sqft,\n"
"    ST_Area(ST_Transform(geom, 26986)) As sqm\n"
"from (\n"
"         select\n"
"             'SRID=2249;POLYGON((743238 2967416,743238 2967450,\n"
"             743265 2967450,743265.625 2967416,743238 2967416))' :: geometry "
"geom\n"
"     ) subquery;\n"
"┌─────────┬─────────────────┐\n"
"│  sqft   │       sqm       │\n"
"├─────────┼─────────────────┤\n"
"│ 928.625 │ 86.272430607008 │\n"
"└─────────┴─────────────────┘"
msgstr ""

#. Tag: para
#: reference_measure.xml:62
#, no-c-format
msgid ""
"Return area square feet and square meters using geography data type. Note "
"that we transform to our geometry to geography (before you can do that make "
"sure your geometry is in WGS 84 long lat 4326). Geography always measures in "
"meters. This is just for demonstration to compare. Normally your table will "
"be stored in geography data type already."
msgstr ""
"Gibt den Flächeninhalt in Quadratfuß und in Quadratmeter für den "
"geographischen Datentyp zurück. Beachten Sie bitte, dass wir den "
"geometrischen in den geographischen Datentyp umwandeln (dafür muss die "
"Geometrie in WGS84 lon lat 4326 vorliegen). Beim geographischen Datentyp "
"wird immer in Meter gemessen. Dies ist nur für Vergleichszwecke gedacht, da "
"Ihre Tabelle üblicherweise bereits den geographischen Datentyp aufweisen "
"wird."

#. Tag: programlisting
#: reference_measure.xml:65
#, no-c-format
msgid ""
"select ST_Area(geog) / 0.3048 ^ 2 sqft_spheroid,\n"
"    ST_Area(geog, false) / 0.3048 ^ 2 sqft_sphere,\n"
"    ST_Area(geog) sqm_spheroid\n"
"from (\n"
"         select ST_Transform(\n"
"                    'SRID=2249;POLYGON((743238 2967416,743238 2967450,743265 "
"2967450,743265.625 2967416,743238 2967416))'::geometry,\n"
"                    4326\n"
"             ) :: geography geog\n"
"     ) as subquery;\n"
"┌──────────────────┬──────────────────┬──────────────────┐\n"
"│  sqft_spheroid   │   sqft_sphere    │   sqm_spheroid   │\n"
"├──────────────────┼──────────────────┼──────────────────┤\n"
"│ 928.684405784452 │ 927.049336105925 │ 86.2776044979692 │\n"
"└──────────────────┴──────────────────┴──────────────────┘"
msgstr ""

#. Tag: para
#: reference_measure.xml:67
#, no-c-format
msgid "If your data is in geography already:"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:68
#, no-c-format
msgid ""
"select ST_Area(geog) / 0.3048 ^ 2 sqft,\n"
"    ST_Area(the_geog) sqm\n"
"from somegeogtable;"
msgstr ""

#. Tag: title
#: reference_measure.xml:71 reference_measure.xml:144 reference_measure.xml:262
#: reference_measure.xml:330 reference_measure.xml:419
#: reference_measure.xml:471 reference_measure.xml:518
#: reference_measure.xml:568 reference_measure.xml:632
#: reference_measure.xml:711 reference_measure.xml:772
#: reference_measure.xml:803 reference_measure.xml:845
#: reference_measure.xml:893 reference_measure.xml:990
#: reference_measure.xml:1060 reference_measure.xml:1110
#: reference_measure.xml:1157 reference_measure.xml:1226
#: reference_measure.xml:1270 reference_measure.xml:1328
#: reference_measure.xml:1363 reference_measure.xml:1403
#: reference_measure.xml:1459 reference_measure.xml:1538
#: reference_measure.xml:1611
#, no-c-format
msgid "See Also"
msgstr "Siehe auch"

#. Tag: para
#: reference_measure.xml:72
#, fuzzy, no-c-format
msgid ""
", <xref linkend=\"ST_GeomFromText\"/>, <xref linkend=\"ST_GeographyFromText"
"\"/>, <xref linkend=\"ST_SetSRID\"/>, <xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_GeomFromEWKT\"/>, <xref linkend=\"ST_Length_Spheroid\"/"
">, <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_measure.xml:78
#, no-c-format
msgid "ST_Azimuth"
msgstr "ST_Azimuth"

#. Tag: refpurpose
#: reference_measure.xml:80
#, no-c-format
msgid ""
"Returns the north-based azimuth as the angle in radians measured clockwise "
"from the vertical on pointA to pointB."
msgstr ""
"Gibt den auf die Nordrichtung bezogenen Azimut in Radiant zurück. Der Winkel "
"wird von einer Senkrechten auf \"pointA\" nach pointB im Uhrzeigersinn "
"gemessen."

#. Tag: funcsynopsis
#: reference_measure.xml:83
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Azimuth</function></funcdef> "
"<paramdef><type>geometry </type><parameter>pointA</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>pointB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Azimuth</"
"function></funcdef> <paramdef><type>geography </type><parameter>pointA</"
"parameter></paramdef> <paramdef><type>geography </type><parameter>pointB</"
"parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_Azimuth</function></funcdef> "
"<paramdef><type>geometry </type><parameter>pointA</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>pointB</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Azimuth</"
"function></funcdef> <paramdef><type>geography </type><parameter>pointA</"
"parameter></paramdef> <paramdef><type>geography </type><parameter>pointB</"
"parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_measure.xml:99
#, no-c-format
msgid ""
"Returns the azimuth in radians of the segment defined by the given point "
"geometries, or NULL if the two points are coincident. The azimuth is angle "
"is referenced from north, and is positive clockwise: North = 0; East = "
"&#x03C0;/2; South = &#x03C0;; West = 3&#x03C0;/2."
msgstr ""
"Gibt den Azimut des Kreisbogens in Radiant zurück, der durch die gegebenen "
"Punkte bestimmt ist. Wenn sich die beiden Punkte decken, wird NULL "
"zurückgegeben. Der Azimut ist der auf die Nordrichtung bezogene Winkel; er "
"ist im Uhrzeigersinn positiv: Norden = 0; Osten = &#x03C0;/2; Süden = "
"&#x03C0;; Westen = 3&#x03C0;/2."

#. Tag: para
#: reference_measure.xml:101
#, no-c-format
msgid ""
"For the geography type, the forward azimuth is solved as part of the inverse "
"geodesic problem."
msgstr ""
"Beim geographischen Datentyp wird der vorwärtsgerichtete Azimuth als Teil "
"der zweiten geodätischen Hauptaufgabe gelöst."

#. Tag: para
#: reference_measure.xml:102
#, no-c-format
msgid ""
"The azimuth is mathematical concept defined as the angle between a reference "
"plane and a point, with angular units in radians. Units can be converted to "
"degrees using a built-in PostgreSQL function degrees(), as shown in the "
"example."
msgstr ""
"Der mathematische Begriff Azimut ist als Winkel zwischen einer Referenzebene "
"und einem Punkt definiert, wobei das Winkelmaß in Radiant angegeben wird. "
"Wie im folgenden Beispiel gezeigt, kann mit der in PostgreSQL integrierten "
"Funktion \"degrees()\" von der Einheit Radiant auf die Einheit Grad "
"umgerechnet werden."

#. Tag: para
#: reference_measure.xml:105
#, no-c-format
msgid "Availability: 1.1.0"
msgstr "Verfügbarkeit: 1.1.0"

#. Tag: para
#: reference_measure.xml:106
#, no-c-format
msgid "Enhanced: 2.0.0 support for geography was introduced."
msgstr ""
"Erweiterung: mit 2.0.0 wurde die Unterstützung des geographischen Datentyps "
"eingeführt."

#. Tag: para
#: reference_measure.xml:107
#, no-c-format
msgid ""
"Enhanced: 2.2.0 measurement on spheroid performed with GeographicLib for "
"improved accuracy and robustness. Requires Proj &gt;= 4.9.0 to take "
"advantage of the new feature."
msgstr ""
"Erweiterung: 2.2.0 die Messungen auf dem Referenzellipsoid werden mit der "
"Bibliothek \"GeographicLib\" durchgeführt. Dadurch wurde die Genauigkeit und "
"die Robustheit erhöht. Um die Vorteile dieser neuen Funktionalität zu "
"nutzen, benötigen Sie Proj &gt;= 4.9.0."

#. Tag: para
#: reference_measure.xml:108
#, no-c-format
msgid ""
"Azimuth is especially useful in conjunction with ST_Translate for shifting "
"an object along its perpendicular axis. See upgis_lineshift <ulink url="
"\"http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctions"
"\">Plpgsqlfunctions PostGIS wiki section</ulink> for example of this."
msgstr ""
"Der Azimut ist in Verbindung mit ST_Translate besonders nützlich, weil damit "
"ein Objekt entlang seiner rechtwinkeligen Achse verschoben werden kann. "
"Siehe dazu die Funktion \"upgis_lineshift\", in dem Abschnitt <ulink url="
"\"http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctions"
"\">Plpgsqlfunctions des PostGIS Wiki</ulink>, für ein Beispiel."

#. Tag: para
#: reference_measure.xml:114 reference_measure.xml:189
#, no-c-format
msgid "Geometry Azimuth in degrees"
msgstr "Geometrischer Datentyp - Azimut in Grad"

#. Tag: programlisting
#: reference_measure.xml:115
#, no-c-format
msgid ""
"SELECT degrees(ST_Azimuth(ST_Point(25, 45), ST_Point(75, 100))) AS degA_B,\n"
"            degrees(ST_Azimuth(ST_Point(75, 100), ST_Point(25, 45))) AS "
"degB_A;\n"
"\n"
"      dega_b       |     degb_a\n"
"------------------+------------------\n"
" 42.2736890060937 | 222.273689006094"
msgstr ""
"SELECT degrees(ST_Azimuth(ST_Point(25, 45), ST_Point(75, 100))) AS degA_B,\n"
"            degrees(ST_Azimuth(ST_Point(75, 100), ST_Point(25, 45))) AS "
"degB_A;\n"
"\n"
"      dega_b       |     degb_a\n"
"------------------+------------------\n"
" 42.2736890060937 | 222.273689006094"

#. Tag: para
#: reference_measure.xml:125
#, no-c-format
msgid ""
"Green: the start Point(25,45) with its vertical. Yellow: degA_B as the path "
"to travel (azimuth)."
msgstr ""
"Grün: der Anfangspunkt Point(25,45) mit der Senkrechten darauf. Gelb: der zu "
"durchlaufende Pfad \"degA_B\" (Azimut)."

#. Tag: para
#: reference_measure.xml:134
#, no-c-format
msgid ""
"Green: the start Point(75,100) with its vertical. Yellow: degB_A as the path "
"to travel (azimuth)."
msgstr ""
"Grün: der Anfangspunkt Point(75,100) mit der Senkrechten darauf. Gelb: der "
"zu durchlaufende Pfad \"degB_A\" (Azimut)."

#. Tag: para
#: reference_measure.xml:145
#, no-c-format
msgid ""
", <xref linkend=\"ST_Translate\"/>, <xref linkend=\"ST_Project\"/>, <ulink "
"url=\"http://www.postgresql.org/docs/current/interactive/functions-math.html"
"\">PostgreSQL Math Functions</ulink>"
msgstr ""
", <xref linkend=\"ST_Translate\"/>, <xref linkend=\"ST_Project\"/>, <ulink "
"url=\"http://www.postgresql.org/docs/current/interactive/functions-math.html"
"\">PostgreSQL Math Functions</ulink>"

#. Tag: refname
#: reference_measure.xml:152
#, no-c-format
msgid "ST_Angle"
msgstr "ST_Angle"

#. Tag: refpurpose
#: reference_measure.xml:154
#, no-c-format
msgid ""
"Returns the angle between 3 points, or between 2 vectors (4 points or 2 "
"lines)."
msgstr ""
"Gibt den Winkel zwischen 3 Punkten oder zwischen 2 Vektoren (4 Punkte oder 2 "
"Linien) zurück."

#. Tag: funcsynopsis
#: reference_measure.xml:157
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Angle</function></funcdef> "
"<paramdef><type>geometry </type><parameter>point1</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>point2</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>point3</parameter></paramdef> "
"<paramdef choice=\"opt\"><type>geometry </type><parameter>point4</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_Angle</function></funcdef> <paramdef><type>geometry </"
"type><parameter>line1</parameter></paramdef> <paramdef><type>geometry </"
"type><parameter>line2</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_Angle</function></funcdef> "
"<paramdef><type>geometry </type><parameter>point1</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>point2</parameter></paramdef> "
"<paramdef><type>geometry </type><parameter>point3</parameter></paramdef> "
"<paramdef choice=\"opt\"><type>geometry </type><parameter>point4</"
"parameter></paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_Angle</function></funcdef> <paramdef><type>geometry </"
"type><parameter>line1</parameter></paramdef> <paramdef><type>geometry </"
"type><parameter>line2</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_measure.xml:175
#, no-c-format
msgid ""
"For 3 points, computes the angle measured clockwise of P1P2P3. If input are "
"2 lines, get first and last point of the lines as 4 points. For 4 points,"
"compute the angle measured clockwise of P1P2,P3P4. Results are always "
"positive, between 0 and 2*Pi radians. Uses azimuth of pairs or points."
msgstr ""
"Fpr 3 Punkte wird der Winkel im Uhrzeigersinn von P1P2P3 errechnet. Bei der "
"Eingabe von 2 Linien werden 4 Punkte aus den Anfangs- und Endpunkten der "
"Linien ermittelt. Für die 4 Punkte wird der Winkel im Uhrzeigersinn von P1P2,"
"P3P4 berechnet. Das ergebnis ist immer positiv, zwischen 0 und 2*Pi Radiant. "
"Verwendet den Azimut von Linienpaaren oder Punkten."

#. Tag: para
#: reference_measure.xml:182
#, no-c-format
msgid "ST_Angle(P1,P2,P3) = ST_Angle(P2,P1,P2,P3)"
msgstr "ST_Angle(P1,P2,P3) = ST_Angle(P2,P1,P2,P3)"

#. Tag: para
#: reference_measure.xml:183
#, no-c-format
msgid ""
"Result is in radian and can be converted to degrees using a built-in "
"PostgreSQL function degrees(), as shown in the example."
msgstr ""
"Das Ergebnis wird in Radiant ausgegeben. Wie im folgenden Beispiel gezeigt, "
"kann mit der in PostgreSQL integrierten Funktion \"degrees()\" von der "
"Einheit Radiant auf die Einheit Grad umgerechnet werden."

#. Tag: para
#: reference_measure.xml:184
#, no-c-format
msgid "Availability: 2.5.0"
msgstr "Verfügbarkeit: 2.5.0"

#. Tag: programlisting
#: reference_measure.xml:190
#, fuzzy, no-c-format
msgid ""
"WITH rand AS (\n"
"                SELECT s, random() * 2 * PI() AS rad1\n"
"                        , random() * 2 * PI() AS rad2\n"
"                FROM  generate_series(1,2,2) AS s\n"
"        )\n"
"         , points AS (\n"
"                SELECT s, rad1,rad2, ST_MakePoint(cos1+s,sin1+s) as p1, "
"ST_MakePoint(s,s) AS p2, ST_MakePoint(cos2+s,sin2+s) as p3\n"
"                FROM rand\n"
"                        ,cos(rad1) cos1, sin(rad1) sin1\n"
"                        ,cos(rad2) cos2, sin(rad2) sin2\n"
"        )\n"
"        SELECT s, ST_AsText(ST_SnapToGrid(ST_MakeLine(ARRAY[p1,p2,"
"p3]),0.001)) AS line\n"
"                , degrees(ST_Angle(p1,p2,p3)) as computed_angle\n"
"                , round(degrees(2*PI()-rad2 -2*PI()+rad1+2*PI()))::int%360 "
"AS reference\n"
"                , round(degrees(2*PI()-rad2 -2*PI()+rad1+2*PI()))::int%360 "
"AS reference\n"
"        FROM points ;\n"
"\n"
"1 | line | computed_angle | reference\n"
"------------------+------------------\n"
"1 | LINESTRING(1.511 1.86,1 1,0.896 0.005) | 155.27033848688 | 155"
msgstr ""
"WITH rand AS (\n"
"                SELECT s, random() * 2 * PI() AS rad1\n"
"                        , random() * 2 * PI() AS rad2\n"
"                FROM  generate_series(1,2,2) AS s\n"
"        )\n"
"         , points AS (\n"
"                SELECT s, rad1,rad2, ST_MakePoint(cos1+s,sin1+s) as p1, "
"ST_MakePoint(s,s) AS p2, ST_MakePoint(cos2+s,sin2+s) as p3\n"
"                FROM rand\n"
"                        ,cos(rad1) cos1, sin(rad1) sin1\n"
"                        ,cos(rad2) cos2, sin(rad2) sin2\n"
"        )\n"
"        SELECT s, ST_AsText(ST_SnapToGrid(ST_MakeLine(ARRAY[p1,p2,"
"p3]),0.001)) AS line\n"
"                , degrees(ST_Angle(p1,p2,p3)) as computed_angle\n"
"                , round(degrees(2*PI()-rad2 -2*PI()+rad1+2*PI()))::int%360 "
"AS reference\n"
"                , round(degrees(2*PI()-rad2 -2*PI()+rad1+2*PI()))::int%360 "
"AS reference\n"
"        FROM points ;\n"
"\n"
"1 | line | computed_angle | reference\n"
"------------------+------------------\n"
"1 | LINESTRING(1.511 1.86,1 1,0.896 0.005) | 155.27033848688 | 155"

#. Tag: refname
#: reference_measure.xml:196
#, no-c-format
msgid "ST_ClosestPoint"
msgstr "ST_ClosestPoint"

#. Tag: refpurpose
#: reference_measure.xml:198
#, fuzzy, no-c-format
msgid ""
"Returns the 2D point on g1 that is closest to g2. This is the first point of "
"the shortest line."
msgstr ""
"Gibt den 3-dimensionalen Punkt auf g1 zurück, der den kürzesten Abstand zu "
"g2 hat. Dies ist der Anfangspunkt des kürzesten Abstands in 3D."

#. Tag: funcprototype
#: reference_measure.xml:204
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_ClosestPoint</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_ClosestPoint</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:219
#, fuzzy, no-c-format
msgid ""
"Returns the 2-dimensional point on g1 that is closest to g2. This is the "
"first point of the shortest line."
msgstr ""
"Gibt den 3-dimensionalen Punkt auf g1 zurück, der den kürzesten Abstand zu "
"g2 hat. Dies ist der Anfangspunkt des kürzesten Abstands in 3D."

#. Tag: para
#: reference_measure.xml:222
#, no-c-format
msgid ""
"If you have a 3D Geometry, you may prefer to use <xref linkend="
"\"ST_3DClosestPoint\"/>."
msgstr ""
"Falls es sich um eine 3D-Geometrie handelt, sollten Sie <xref linkend="
"\"ST_3DClosestPoint\"/> vorziehen."

#. Tag: para
#: reference_measure.xml:223 reference_measure.xml:696
#: reference_measure.xml:931 reference_measure.xml:1096
#: reference_measure.xml:1500
#, no-c-format
msgid "Availability: 1.5.0"
msgstr "Verfügbarkeit: 1.5.0"

#. Tag: para
#: reference_measure.xml:237
#, no-c-format
msgid ""
"Closest between point and linestring is the point itself, but closest point "
"between a linestring and point is the point on line string that is closest."
msgstr ""
"Der nächstliegende Punkt zwischen einem Punkt und einem Linienzug ist der "
"Punkt selbst. Aber der nächstliegende Punkt zwischen einem Linienzug und "
"einem Punkt ist der Punkt auf dem Linienzug mit dem geringsten Abstand."

#. Tag: programlisting
#: reference_measure.xml:241
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_ClosestPoint(pt,line)) AS cp_pt_line,\n"
"        ST_AsText(ST_ClosestPoint(line,pt)) As cp_line_pt\n"
"FROM (SELECT 'POINT(100 100)'::geometry As pt,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry As "
"line\n"
"        ) As foo;\n"
"\n"
"\n"
"   cp_pt_line   |                cp_line_pt\n"
"----------------+------------------------------------------\n"
" POINT(100 100) | POINT(73.0769230769231 115.384615384615)"
msgstr ""
"SELECT ST_AsText(ST_ClosestPoint(pt,line)) AS cp_pt_line,\n"
"        ST_AsText(ST_ClosestPoint(line,pt)) As cp_line_pt\n"
"FROM (SELECT 'POINT(100 100)'::geometry As pt,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry As "
"line\n"
"        ) As foo;\n"
"\n"
"\n"
"   cp_pt_line   |                cp_line_pt\n"
"----------------+------------------------------------------\n"
" POINT(100 100) | POINT(73.0769230769231 115.384615384615)"

#. Tag: para
#: reference_measure.xml:249
#, no-c-format
msgid "closest point on polygon A to polygon B"
msgstr "Der Punkt des Polygons A der am nähesten beim Polygon B liegt"

#. Tag: programlisting
#: reference_measure.xml:252
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"                ST_ClosestPoint(\n"
"                        ST_GeomFromText('POLYGON((175 150, 20 40, 50 60, 125 "
"100, 175 150))'),\n"
"                        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                        )\n"
"                ) As ptwkt;\n"
"\n"
"                  ptwkt\n"
"------------------------------------------\n"
" POINT(140.752120669087 125.695053378061)"
msgstr ""
"SELECT ST_AsText(\n"
"                ST_ClosestPoint(\n"
"                        ST_GeomFromText('POLYGON((175 150, 20 40, 50 60, 125 "
"100, 175 150))'),\n"
"                        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                        )\n"
"                ) As ptwkt;\n"
"\n"
"                  ptwkt\n"
"------------------------------------------\n"
" POINT(140.752120669087 125.695053378061)"

#. Tag: para
#: reference_measure.xml:264
#, no-c-format
msgid ""
",<xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_MaxDistance\"/>"
msgstr ""
",<xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_MaxDistance\"/>"

#. Tag: refname
#: reference_measure.xml:270
#, no-c-format
msgid "ST_3DClosestPoint"
msgstr "ST_3DClosestPoint"

#. Tag: refpurpose
#: reference_measure.xml:272
#, fuzzy, no-c-format
msgid ""
"Returns the 3D point on g1 that is closest to g2. This is the first point of "
"the 3D shortest line."
msgstr ""
"Gibt den 3-dimensionalen Punkt auf g1 zurück, der den kürzesten Abstand zu "
"g2 hat. Dies ist der Anfangspunkt des kürzesten Abstands in 3D."

#. Tag: funcprototype
#: reference_measure.xml:278
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_3DClosestPoint</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_3DClosestPoint</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:293
#, no-c-format
msgid ""
"Returns the 3-dimensional point on g1 that is closest to g2. This is the "
"first point of the 3D shortest line. The 3D length of the 3D shortest line "
"is the 3D distance."
msgstr ""
"Gibt den 3-dimensionalen Punkt auf g1 zurück, der den kürzesten Abstand zu "
"g2 hat. Dies ist der Anfangspunkt des kürzesten Abstands in 3D. Die Länge "
"des kürzesten Abstands in 3D ergibt sich aus der 3D-Distanz."

#. Tag: para
#: reference_measure.xml:296 reference_measure.xml:453
#: reference_measure.xml:830 reference_measure.xml:882
#: reference_measure.xml:1028 reference_measure.xml:1142
#: reference_measure.xml:1390 reference_measure.xml:1579
#, no-c-format
msgid "&Z_support;"
msgstr "&Z_support;"

#. Tag: para
#: reference_measure.xml:299 reference_measure.xml:458
#: reference_measure.xml:1026 reference_measure.xml:1146
#: reference_measure.xml:1447 reference_measure.xml:1577
#, no-c-format
msgid "Availability: 2.0.0"
msgstr "Verfügbarkeit: 2.0.0"

#. Tag: para
#: reference_measure.xml:300 reference_measure.xml:1027
#: reference_measure.xml:1578
#, no-c-format
msgid ""
"Changed: 2.2.0 - if 2 2D geometries are input, a 2D point is returned "
"(instead of old behavior assuming 0 for missing Z). In case of 2D and 3D, Z "
"is no longer assumed to be 0 for missing Z."
msgstr ""
"Änderung: 2.2.0 - Wenn 2 geometrische Objekte in 2D übergegeben werden, wird "
"ein 2D-Punkt zurückgegeben (anstelle wie früher 0 für ein fehlendes Z). Im "
"Falle von 2D und 3D, wird für fehlende Z nicht länger 0 angenommen."

#. Tag: para
#: reference_measure.xml:309
#, no-c-format
msgid "linestring and point -- both 3d and 2d closest point"
msgstr "Linienstück und Punkt -- Punkt mit kürzestem Abstand; in 3D und in 2D"

#. Tag: programlisting
#: reference_measure.xml:310
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(line,pt)) AS cp3d_line_pt,\n"
"                ST_AsEWKT(ST_ClosestPoint(line,pt)) As cp2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
" cp3d_line_pt                                                |               "
"cp2d_line_pt\n"
"-----------------------------------------------------------"
"+------------------------------------------\n"
" POINT(54.6993798867619 128.935022917228 11.5475869506606) | "
"POINT(73.0769230769231 115.384615384615)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(line,pt)) AS cp3d_line_pt,\n"
"                ST_AsEWKT(ST_ClosestPoint(line,pt)) As cp2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
" cp3d_line_pt                                                |               "
"cp2d_line_pt\n"
"-----------------------------------------------------------"
"+------------------------------------------\n"
" POINT(54.6993798867619 128.935022917228 11.5475869506606) | "
"POINT(73.0769230769231 115.384615384615)"

#. Tag: para
#: reference_measure.xml:314
#, no-c-format
msgid "linestring and multipoint -- both 3d and 2d closest point"
msgstr ""
"Linienstück und Mehrfachpunkt - Punkt mit kürzestem Abstand; in 3D und in 2D "

#. Tag: programlisting
#: reference_measure.xml:315
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(line,pt)) AS cp3d_line_pt,\n"
"                ST_AsEWKT(ST_ClosestPoint(line,pt)) As cp2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"                       cp3d_line_pt                        | cp2d_line_pt\n"
"-----------------------------------------------------------+--------------\n"
" POINT(54.6993798867619 128.935022917228 11.5475869506606) | POINT(50 75)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(line,pt)) AS cp3d_line_pt,\n"
"                ST_AsEWKT(ST_ClosestPoint(line,pt)) As cp2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"                       cp3d_line_pt                        | cp2d_line_pt\n"
"-----------------------------------------------------------+--------------\n"
" POINT(54.6993798867619 128.935022917228 11.5475869506606) | POINT(50 75)"

#. Tag: para
#: reference_measure.xml:319
#, no-c-format
msgid "Multilinestring and polygon both 3d and 2d closest point"
msgstr ""
"Mehrfachlinie und Polygon - Punkt mit kürzestem Abstand; in 3D und in 2D"

#. Tag: programlisting
#: reference_measure.xml:320
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(poly, mline)) As cp3d,\n"
"    ST_AsEWKT(ST_ClosestPoint(poly, mline)) As cp2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"                   cp3d                    |     cp2d\n"
"-------------------------------------------+--------------\n"
" POINT(39.993580415989 54.1889925532825 5) | POINT(20 40)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DClosestPoint(poly, mline)) As cp3d,\n"
"    ST_AsEWKT(ST_ClosestPoint(poly, mline)) As cp2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"                   cp3d                    |     cp2d\n"
"-------------------------------------------+--------------\n"
" POINT(39.993580415989 54.1889925532825 5) | POINT(20 40)"

#. Tag: para
#: reference_measure.xml:332
#, no-c-format
msgid ""
", <xref linkend=\"ST_ClosestPoint\"/>, <xref linkend=\"ST_3DDistance\"/>, "
"<xref linkend=\"ST_3DShortestLine\"/>"
msgstr ""
", <xref linkend=\"ST_ClosestPoint\"/>, <xref linkend=\"ST_3DDistance\"/>, "
"<xref linkend=\"ST_3DShortestLine\"/>"

#. Tag: refname
#: reference_measure.xml:338
#, no-c-format
msgid "ST_Distance"
msgstr "ST_Distance"

#. Tag: refpurpose
#: reference_measure.xml:340
#, fuzzy, no-c-format
msgid "Returns the distance between two geometry or geography values."
msgstr ""
"Gibt die größte 3-dimensionale Distanz zwischen zwei geometrischen Objekten "
"als Linie zurück"

#. Tag: funcsynopsis
#: reference_measure.xml:343
#, fuzzy, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Distance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Distance</"
"function></funcdef> <paramdef><type>geography </type> <parameter>geog1</"
"parameter></paramdef> <paramdef><type>geography </type> <parameter>geog2</"
"parameter></paramdef> <paramdef choice=\"opt\"><type>boolean </type> "
"<parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_HausdorffDistance</function></"
"funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_HausdorffDistance</function></funcdef> <paramdef><type>geometry "
"</type> <parameter>g1</parameter></paramdef> <paramdef><type>geometry </"
"type> <parameter>g2</parameter></paramdef> <paramdef><type>float</type> "
"<parameter>densifyFrac</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_measure.xml:374
#, fuzzy, no-c-format
msgid ""
"For <xref linkend=\"geometry\"/> types returns the minimum 2D Cartesian "
"(planar) distance between two geometries, in projected units (spatial ref "
"units)."
msgstr ""
"Für den geometrischen Datentyp. Es wird der geringste 3-dimensionale "
"kartesische Abstand zwischen zwei geometrischen Objekten in projizierten "
"Einheiten (Einheiten des Koordinatenreferenzsystem) zurückgegeben."

#. Tag: para
#: reference_measure.xml:377
#, fuzzy, no-c-format
msgid ""
"For <xref linkend=\"geography\"/> types defaults to return the minimum "
"geodesic distance between two geographies in meters, compute on the spheroid "
"determined by the SRID. If <varname>use_spheroid</varname> is false, a "
"faster spherical calculation is used."
msgstr ""
"Beim geometrischen Datentyp <xref linkend=\"geometry\"/> wird die geringste "
"kartesische Distanz in 2D zwischen zwei geometrischen Objekten - in "
"projizierten Einheiten (Einheiten des Koordinatenreferenzsystem) - "
"zurückgegeben. Beim geographischen Datentyp <xref linkend=\"geography\"/> "
"wird standardmäßig die geringste geodätische Distanz zwischen zwei "
"geographischen Objekten in Meter zurückgegeben. Wenn use_speroid FALSE ist, "
"erfolgt eine schnellere Berechnung auf einer Kugel anstatt auf dem "
"Referenzellipsoid."

#. Tag: para
#: reference_measure.xml:383
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 5.1.23"
msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.23"

#. Tag: para
#: reference_measure.xml:384
#, no-c-format
msgid "&curve_support;"
msgstr "&curve_support;"

#. Tag: para
#: reference_measure.xml:386
#, no-c-format
msgid ""
"Availability: 1.5.0 geography support was introduced in 1.5. Speed "
"improvements for planar to better handle large or many vertex geometries"
msgstr ""
"Verfügbarkeit: 1.5.0 die Unterstützung des geograpischen Datentyps wurde "
"eingeführt. Geschwindigkeitsverbesserungen bei einer umfangreichen Geometrie "
"und bei einer Geometrie mit vielen Knoten"

#. Tag: para
#: reference_measure.xml:387
#, no-c-format
msgid ""
"Enhanced: 2.1.0 improved speed for geography. See <ulink url=\"http://"
"boundlessgeo.com/2012/07/making-geography-faster/\">Making Geography faster</"
"ulink> for details."
msgstr ""
"Enhanced: 2.1.0 Geschwindigkeitsverbesserung beim geographischen Datentyp. "
"Siehe <ulink url=\"http://boundlessgeo.com/2012/07/making-geography-faster/"
"\">Making Geography faster</ulink> für Details."

#. Tag: para
#: reference_measure.xml:388
#, no-c-format
msgid "Enhanced: 2.1.0 - support for curved geometries was introduced."
msgstr ""
"Erweiterung: 2.1.0 - Unterstützung für Kurven beim geometrischen Datentyp "
"eingeführt."

#. Tag: title
#: reference_measure.xml:394
#, no-c-format
msgid "Basic Geometry Examples"
msgstr "Standardbeispiele Geometrie"

#. Tag: para
#: reference_measure.xml:396
#, no-c-format
msgid ""
"Geometry example - units in planar degrees 4326 is WGS 84 long lat, units "
"are degrees."
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:397
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                'SRID=4326;POINT(-72.1235 42.3521)'::geometry,\n"
"                'SRID=4326;LINESTRING(-72.1260 42.45, -72.123 42.1546)'::"
"geometry\n"
"        );\n"
"st_distance\n"
"-----------------\n"
"0.00150567726382282"
msgstr ""
"SELECT ST_AsText(\n"
"        ST_LongestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As lline;\n"
"\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(100 100,98 190)"

#. Tag: para
#: reference_measure.xml:399
#, no-c-format
msgid ""
"Geometry example - units in meters (SRID: 3857, proportional to pixels on "
"popular web maps). Although the value is off, nearby ones can be compared "
"correctly, which makes it a good choice for algorithms like KNN or KMeans."
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:402
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry, 3857),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry, 3857)\n"
"                );\n"
"st_distance\n"
"-----------------\n"
"167.441410065196"
msgstr ""
"SELECT ST_Intersects(\n"
"                ST_GeographyFromText('SRID=4326;LINESTRING(-43.23456 "
"72.4567,-43.23456 72.4568)'),\n"
"                ST_GeographyFromText('SRID=4326;POINT(-43.23456 "
"72.4567772)')\n"
"                );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: para
#: reference_measure.xml:404
#, no-c-format
msgid ""
"Geometry example - units in meters (SRID: 3857 as above, but corrected by "
"cos(lat) to account for distortion)"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:405
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry, 3857),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry, 3857)\n"
"                ) * cosd(42.3521);\n"
"st_distance\n"
"-----------------\n"
"123.742351254151"
msgstr ""
"SELECT ST_Intersects(\n"
"                ST_GeographyFromText('SRID=4326;LINESTRING(-43.23456 "
"72.4567,-43.23456 72.4568)'),\n"
"                ST_GeographyFromText('SRID=4326;POINT(-43.23456 "
"72.4567772)')\n"
"                );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: para
#: reference_measure.xml:407
#, no-c-format
msgid ""
"Geometry example - units in meters (SRID: 26986 Massachusetts state plane "
"meters) (most accurate for Massachusetts)"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:408
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry, 26986),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry, 26986)\n"
"                );\n"
"st_distance\n"
"-----------------\n"
"123.797937878454"
msgstr ""
"SELECT ST_Intersects(\n"
"                ST_GeographyFromText('SRID=4326;LINESTRING(-43.23456 "
"72.4567,-43.23456 72.4568)'),\n"
"                ST_GeographyFromText('SRID=4326;POINT(-43.23456 "
"72.4567772)')\n"
"                );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: para
#: reference_measure.xml:410
#, no-c-format
msgid ""
"Geometry example - units in meters (SRID: 2163 US National Atlas Equal area) "
"(least accurate)"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:411
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry, 2163),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry, 2163)\n"
"                );\n"
"\n"
"st_distance\n"
"------------------\n"
"126.664256056812"
msgstr ""
"SELECT ST_Intersects(\n"
"                ST_GeographyFromText('SRID=4326;LINESTRING(-43.23456 "
"72.4567,-43.23456 72.4568)'),\n"
"                ST_GeographyFromText('SRID=4326;POINT(-43.23456 "
"72.4567772)')\n"
"                );\n"
"\n"
" st_intersects\n"
"---------------\n"
"t"

#. Tag: title
#: reference_measure.xml:414 reference_measure.xml:767
#, no-c-format
msgid "Geography Examples"
msgstr "Beispiele für den geographischen Datentyp "

#. Tag: para
#: reference_measure.xml:415
#, no-c-format
msgid ""
"Same as geometry example but note units in meters - use sphere for slightly "
"faster and less accurate computation."
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:416
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Distance(gg1, gg2) As spheroid_dist, ST_Distance(gg1, gg2, false) "
"As sphere_dist\n"
"FROM (SELECT\n"
"        'SRID=4326;POINT(-72.1235 42.3521)'::geography as gg1,\n"
"        'SRID=4326;LINESTRING(-72.1260 42.45, -72.123 42.1546)'::geography "
"as gg2\n"
"        ) As foo  ;\n"
"\n"
"  spheroid_dist   |   sphere_dist\n"
"------------------+------------------\n"
" 123.802076746848 | 123.475736916397"
msgstr ""
"-- gleich wie das Beispiel mit dem geometrischen Datentyp, aber Einheiten in "
"Meter - verwendet Kugel für eine geringfügige Geschwindigkeitsverbesserung, "
"allerdings ungenauer\n"
"SELECT ST_Distance(gg1, gg2) As spheroid_dist, ST_Distance(gg1, gg2, false) "
"As sphere_dist\n"
"FROM (SELECT\n"
"        'SRID=4326;POINT(-72.1235 42.3521)'::geography as gg1,\n"
"        'SRID=4326;LINESTRING(-72.1260 42.45, -72.123 42.1546)'::geography "
"as gg2\n"
"        ) As foo  ;\n"
"\n"
"  spheroid_dist   |   sphere_dist\n"
"------------------+------------------\n"
" 123.802076746848 | 123.475736916397"

#. Tag: para
#: reference_measure.xml:421
#, no-c-format
msgid ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DistanceSphere\"/>, "
"<xref linkend=\"ST_Distance_Spheroid\"/>, <xref linkend=\"ST_MaxDistance\"/"
">, <xref linkend=\"ST_HausdorffDistance\"/>, <xref linkend="
"\"ST_FrechetDistance\"/>, <xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DistanceSphere\"/>, "
"<xref linkend=\"ST_Distance_Spheroid\"/>, <xref linkend=\"ST_MaxDistance\"/"
">, <xref linkend=\"ST_HausdorffDistance\"/>, <xref linkend="
"\"ST_FrechetDistance\"/>, <xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_measure.xml:428
#, no-c-format
msgid "ST_3DDistance"
msgstr "ST_3DDistance"

#. Tag: refpurpose
#: reference_measure.xml:430
#, fuzzy, no-c-format
msgid ""
"Returns the 3D cartesian minimum distance (based on spatial ref) between two "
"geometries in projected units."
msgstr ""
"Für den geometrischen Datentyp. Es wird der geringste 3-dimensionale "
"kartesische Abstand (basierend auf dem Koordinatenreferenzsystem) zwischen "
"zwei geometrischen Objekten in projizierten Einheiten zurückgegeben."

#. Tag: funcprototype
#: reference_measure.xml:435
#, no-c-format
msgid ""
"<funcdef>float <function>ST_3DDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_3DDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:450
#, fuzzy, no-c-format
msgid ""
"Returns the 3-dimensional minimum cartesian distance between two geometries "
"in projected units (spatial ref units)."
msgstr ""
"Für den geometrischen Datentyp. Es wird der geringste 3-dimensionale "
"kartesische Abstand zwischen zwei geometrischen Objekten in projizierten "
"Einheiten (Einheiten des Koordinatenreferenzsystem) zurückgegeben."

#. Tag: para
#: reference_measure.xml:456
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM ?"
msgstr "&sqlmm_compliant; SQL-MM ?"

#. Tag: para
#: reference_measure.xml:459 reference_measure.xml:1147
#, no-c-format
msgid ""
"Changed: 2.2.0 - In case of 2D and 3D, Z is no longer assumed to be 0 for "
"missing Z."
msgstr ""
"Änderung: 2.2.0 - Im Falle von 2D und 3D wird für ein fehlendes Z nicht mehr "
"0 angenommen."

#. Tag: para
#: reference_measure.xml:460
#, no-c-format
msgid "Changed: 3.0.0 - SFCGAL version removed"
msgstr ""

#. Tag: programlisting
#: reference_measure.xml:466
#, fuzzy, no-c-format
msgid ""
"-- Geometry example - units in meters (SRID: 2163 US National Atlas Equal "
"area) (3D point and line compared 2D point and line)\n"
"-- Note: currently no vertical datum support so Z is not transformed and "
"assumed to be same units as final.\n"
"SELECT ST_3DDistance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521 4)'::"
"geometry,2163),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45 "
"15, -72.123 42.1546 20)'::geometry,2163)\n"
"                ) As dist_3d,\n"
"                ST_Distance(\n"
"                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
"geometry,2163),\n"
"                        ST_Transform('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.123 42.1546)'::geometry,2163)\n"
"                ) As dist_2d;\n"
"\n"
"     dist_3d      |     dist_2d\n"
"------------------+-----------------\n"
" 127.295059324629 | 126.66425605671"
msgstr ""
"-- Beispiel Geometrie - Einheiten in Meter (SRID: 2163 US National Atlas "
"Equal area) (Abstand zwischen Punkt und Linie; Vergleich zwischen 3D und "
"2D)\n"
"-- Anmerkung: zur Zeit gibt es keine Unterstützung für ein Höhendatum, daher "
"wird Z unverändert übernommen und nicht transformiert.\n"
"SELECT ST_3DDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 4)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_3d,\n"
"                ST_Distance(\n"
"                        ST_Transform(ST_GeomFromText('POINT(-72.1235 "
"42.3521)',4326),2163),\n"
"                        ST_Transform(ST_GeomFromText('LINESTRING(-72.1260 "
"42.45, -72.123 42.1546)', 4326),2163)\n"
"                ) As dist_2d;\n"
"\n"
"     dist_3d      |     dist_2d\n"
"------------------+-----------------\n"
" 127.295059324629 | 126.66425605671"

#. Tag: programlisting
#: reference_measure.xml:467
#, fuzzy, no-c-format
msgid ""
"-- Multilinestring and polygon both 3d and 2d distance\n"
"-- Same example as 3D closest point example\n"
"SELECT ST_3DDistance(poly, mline) As dist3d,\n"
"    ST_Distance(poly, mline) As dist2d\n"
"        FROM (SELECT  'POLYGON((175 150 5, 20 40 5, 35 45 5, 50 60 5, 100 "
"100 5, 175 150 5))'::geometry as poly,\n"
"               'MULTILINESTRING((175 155 2, 20 40 20, 50 60 -2, 125 100 1, "
"175 155 1), (1 10 2, 5 20 1))'::geometry as mline) as foo;\n"
"      dist3d       | dist2d\n"
"-------------------+--------\n"
" 0.716635696066337 |      0"
msgstr ""
"-- MultiLinestring und Polygon, Distanz in 3D und in 2D\n"
"-- Gleiches Beispiel wie das mit dem nächstliegenden Punkt in 3D\n"
"SELECT ST_3DDistance(poly, mline) As dist3d,\n"
"    ST_Distance(poly, mline) As dist2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"      dist3d       | dist2d\n"
"-------------------+--------\n"
" 0.716635696066337 |      0"

#. Tag: para
#: reference_measure.xml:473
#, no-c-format
msgid ""
", <xref linkend=\"ST_3DClosestPoint\"/>, <xref linkend=\"ST_3DDWithin\"/>, "
"<xref linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_3DShortestLine\"/>, "
"<xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_3DClosestPoint\"/>, <xref linkend=\"ST_3DDWithin\"/>, "
"<xref linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_3DShortestLine\"/>, "
"<xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_measure.xml:479
#, no-c-format
msgid "ST_DistanceSphere"
msgstr "ST_DistanceSphere"

#. Tag: refpurpose
#: reference_measure.xml:481
#, fuzzy, no-c-format
msgid ""
"Returns minimum distance in meters between two lon/lat geometries using a "
"spherical earth model."
msgstr ""
"Gibt die kürzeste Distanz zwischen zwei geometrischen Objekten zurück, die "
"über Länge, Breite und ein bestimmtes Referenzellipsoid gegeben sind. "
"Vorgängerversionen von PostGIS 1.5 unterstützten nur Punkte."

#. Tag: funcprototype
#: reference_measure.xml:488
#, no-c-format
msgid ""
"<funcdef>float <function>ST_DistanceSphere</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomlonlatA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>geomlonlatB</"
"parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_DistanceSphere</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomlonlatA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>geomlonlatB</"
"parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:499
#, no-c-format
msgid ""
"Returns minimum distance in meters between two lon/lat points. Uses a "
"spherical earth and radius derived from the spheroid defined by the SRID. "
"Faster than <xref linkend=\"ST_Distance_Spheroid\"/>, but less accurate. "
"PostGIS Versions prior to 1.5 only implemented for points."
msgstr ""
"Gibt die kürzeste Distanz zwischen zwei Punkten zurück, die über Länge und "
"Breite gegeben sind. Verwendet die Kugelform für die Erde und den Radius des "
"Referenzellipsoids, der durch die SRID festgelegt ist. Ist schneller als "
"<xref linkend=\"ST_Distance_Spheroid\"/>, aber weniger genau. "
"Vorgängerversionen von PostGIS 1.5 unterstützten nur Punkte."

#. Tag: para
#: reference_measure.xml:505 reference_measure.xml:555
#, no-c-format
msgid ""
"Availability: 1.5 - support for other geometry types besides points was "
"introduced. Prior versions only work with points."
msgstr ""
"Verfügbarkeit: 1.5 die Unterstützung für weitere geometrische Datentypen "
"neben Punkten eingeführt. Bei Vorgängerversionen wurden nur Punkte "
"unterstützt."

#. Tag: para
#: reference_measure.xml:506
#, no-c-format
msgid ""
"Changed: 2.2.0 In prior versions this used to be called ST_Distance_Sphere"
msgstr ""
"Änderung: 2.2.0 In Vorgängerversionen als ST_Distance_Sphere bezeichet."

#. Tag: programlisting
#: reference_measure.xml:513
#, no-c-format
msgid ""
"SELECT round(CAST(ST_DistanceSphere(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As dist_meters,\n"
"round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As dist_utm11_meters,\n"
"round(CAST(ST_Distance(ST_Centroid(the_geom), ST_GeomFromText('POINT(-118 "
"38)', 4326)) As numeric),5) As dist_degrees,\n"
"round(CAST(ST_Distance(ST_Transform(the_geom,32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As min_dist_line_point_meters\n"
"FROM\n"
"        (SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', "
"4326) As the_geom) as foo;\n"
"         dist_meters | dist_utm11_meters | dist_degrees | "
"min_dist_line_point_meters\n"
"        -------------+-------------------+--------------"
"+----------------------------\n"
"                70424.47 |          70438.00 |      0.72900 "
"|                   65871.18"
msgstr ""
"SELECT round(CAST(ST_DistanceSphere(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As dist_meters,\n"
"round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As dist_utm11_meters,\n"
"round(CAST(ST_Distance(ST_Centroid(the_geom), ST_GeomFromText('POINT(-118 "
"38)', 4326)) As numeric),5) As dist_degrees,\n"
"round(CAST(ST_Distance(ST_Transform(the_geom,32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As min_dist_line_point_meters\n"
"FROM\n"
"        (SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', "
"4326) As the_geom) as foo;\n"
"         dist_meters | dist_utm11_meters | dist_degrees | "
"min_dist_line_point_meters\n"
"        -------------+-------------------+--------------"
"+----------------------------\n"
"                70424.47 |          70438.00 |      0.72900 "
"|                   65871.18"

#. Tag: para
#: reference_measure.xml:520
#, no-c-format
msgid ", <xref linkend=\"ST_Distance_Spheroid\"/>"
msgstr ", <xref linkend=\"ST_Distance_Spheroid\"/>"

#. Tag: refname
#: reference_measure.xml:526
#, no-c-format
msgid "ST_DistanceSpheroid"
msgstr "ST_DistanceSpheroid"

#. Tag: refpurpose
#: reference_measure.xml:528
#, fuzzy, no-c-format
msgid ""
"Returns the minimum distance between two lon/lat geometries using a "
"spheroidal earth model."
msgstr ""
"Gibt die kürzeste Distanz zwischen zwei geometrischen Objekten zurück, die "
"über Länge, Breite und ein bestimmtes Referenzellipsoid gegeben sind. "
"Vorgängerversionen von PostGIS 1.5 unterstützten nur Punkte."

#. Tag: funcprototype
#: reference_measure.xml:534
#, no-c-format
msgid ""
"<funcdef>float <function>ST_DistanceSpheroid</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomlonlatA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>geomlonlatB</"
"parameter></paramdef> <paramdef><type>spheroid </type> "
"<parameter>measurement_spheroid</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_DistanceSpheroid</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomlonlatA</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>geomlonlatB</"
"parameter></paramdef> <paramdef><type>spheroid </type> "
"<parameter>measurement_spheroid</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:546
#, fuzzy, no-c-format
msgid ""
"Returns minimum distance in meters between two lon/lat geometries given a "
"particular spheroid. See the explanation of spheroids given for <xref "
"linkend=\"ST_Length_Spheroid\"/>."
msgstr ""
"Gibt die kürzeste Distanz zwischen zwei geometrischen Objekten in Meter "
"zurück, die über Länge, Breite und ein bestimmtes Referenzellipsoid gegeben "
"sind. Siehe die Erklärung zu Referenzellipsoiden unter <xref linkend="
"\"ST_Length_Spheroid\"/>. Vorgängerversionen von PostGIS 1.5 unterstützten "
"nur Punkte."

#. Tag: para
#: reference_measure.xml:550
#, fuzzy, no-c-format
msgid ""
"This function does not look at the SRID of the geometry. It assumes the "
"geometry coordinates are based on the provided spheroid."
msgstr ""
"Aktuell schaut diese Funktion nicht auf die SRID der Geometrie, sondern "
"nimmt an, dass die Geometrie in den Koordinaten des gegebenen "
"Referenzellipsoids vorliegt. Vorgängerversionen von PostGIS 1.5 "
"unterstützten nur Punkte."

#. Tag: para
#: reference_measure.xml:556
#, fuzzy, no-c-format
msgid "Changed: 2.2.0 In prior versions this was called ST_Distance_Spheroid"
msgstr ""
"Änderung: 2.2.0 In Vorgängerversionen als ST_Distance_Spheroid bezeichet."

#. Tag: programlisting
#: reference_measure.xml:563
#, no-c-format
msgid ""
"SELECT round(CAST(\n"
"                ST_DistanceSpheroid(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326), 'SPHEROID[\"WGS "
"84\",6378137,298.257223563]')\n"
"                        As numeric),2) As dist_meters_spheroid,\n"
"                round(CAST(ST_DistanceSphere(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As "
"dist_meters_sphere,\n"
"round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As dist_utm11_meters\n"
"FROM\n"
"        (SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', "
"4326) As the_geom) as foo;\n"
" dist_meters_spheroid | dist_meters_sphere | dist_utm11_meters\n"
"----------------------+--------------------+-------------------\n"
"                         70454.92 |           70424.47 |          70438.00"
msgstr ""
"SELECT round(CAST(\n"
"                ST_DistanceSpheroid(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326), 'SPHEROID[\"WGS "
"84\",6378137,298.257223563]')\n"
"                        As numeric),2) As dist_meters_spheroid,\n"
"                round(CAST(ST_DistanceSphere(ST_Centroid(the_geom), "
"ST_GeomFromText('POINT(-118 38)',4326)) As numeric),2) As "
"dist_meters_sphere,\n"
"round(CAST(ST_Distance(ST_Transform(ST_Centroid(the_geom),32611),\n"
"                ST_Transform(ST_GeomFromText('POINT(-118 38)', 4326),32611)) "
"As numeric),2) As dist_utm11_meters\n"
"FROM\n"
"        (SELECT ST_GeomFromText('LINESTRING(-118.584 38.374,-118.583 38.5)', "
"4326) As the_geom) as foo;\n"
" dist_meters_spheroid | dist_meters_sphere | dist_utm11_meters\n"
"----------------------+--------------------+-------------------\n"
"                         70454.92 |           70424.47 |          70438.00"

#. Tag: para
#: reference_measure.xml:570
#, no-c-format
msgid ", <xref linkend=\"ST_DistanceSphere\"/>"
msgstr ", <xref linkend=\"ST_DistanceSphere\"/>"

#. Tag: refname
#: reference_measure.xml:577
#, no-c-format
msgid "ST_FrechetDistance"
msgstr "ST_FrechetDistance"

#. Tag: refpurpose
#: reference_measure.xml:579
#, fuzzy, no-c-format
msgid "Returns the Fréchet distance between two geometries."
msgstr ""
"Gibt den kürzesten 3-dimensionalen Abstand zwischen zwei geometrischen "
"Objekten als Linie zurück"

#. Tag: funcprototype
#: reference_measure.xml:584
#, no-c-format
msgid ""
"<funcdef>float <function>ST_FrechetDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>densifyFrac = -1</parameter></"
"paramdef>"
msgstr ""
"<funcdef>float <function>ST_FrechetDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
"<paramdef><type>float</type> <parameter>densifyFrac = -1</parameter></"
"paramdef>"

#. Tag: para
#: reference_measure.xml:602
#, no-c-format
msgid ""
"Implements algorithm for computing the Fréchet distance restricted to "
"discrete points for both geometries, based on <ulink url=\"http://www.kr."
"tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf\">Computing Discrete "
"Fréchet Distance</ulink>. The Fréchet distance is a measure of similarity "
"between curves that takes into account the location and ordering of the "
"points along the curves. Therefore it is often better than the Hausdorff "
"distance."
msgstr ""
"Implementiert einen Algorithmus zur Berechnung der Fréchet-Metrik, der für "
"beide geometrischen Objekte auf diskrete Punkte beschränkt ist und auf "
"<ulink url=\"http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf"
"\">Computing Discrete Fréchet Distance</ulink> beruht. Die Fréchet-Metrik "
"ist ein Maß für die Ähnlichkeit von Kurven, welches die Position und die "
"Reihenfolge der Kurvenstützpunkte mit einbezieht. Daher ist sie oft besser "
"geeignet als die Hausdorff-Metrik."

#. Tag: para
#: reference_measure.xml:604
#, no-c-format
msgid ""
"When the optional densifyFrac is specified, this function performs a segment "
"densification before computing the discrete Fréchet distance. The "
"densifyFrac parameter sets the fraction by which to densify each segment. "
"Each segment will be split into a number of equal-length subsegments, whose "
"fraction of the total length is closest to the given fraction."
msgstr ""
"Wenn der optionale Parameter \"densifyFrac\" vorgegeben wird, dann führt "
"diese Funktion eine Verdichtung der Linienstücke durch, bevor die diskrete "
"Fréchet-Metrik berechnet wird. Der Parameter \"densifyFrac\" bestimmt um "
"welchen Anteil die Linienstücke verdichtet werden. Jedes Linienstück wird in "
"gleichlange Teilsegmente zerlegt, deren Anteil an der Gesamtlänge am "
"nächsten an den vorgegebenen Anteil herankommt."

#. Tag: para
#: reference_measure.xml:607 reference_measure.xml:682
#, no-c-format
msgid ""
"Units are in the units of the spatial reference system of the geometries."
msgstr ""

#. Tag: para
#: reference_measure.xml:611 reference_measure.xml:686
#, no-c-format
msgid ""
"The current implementation supports only vertices as the discrete locations. "
"This could be extended to allow an arbitrary density of points to be used."
msgstr ""
"Bei der aktuellen Implementierung können die diskreten Punkte nur Knoten "
"sein. Dies könnte erweitert werden, um eine beliebige Punktdichte zu "
"ermöglichen."

#. Tag: para
#: reference_measure.xml:616
#, no-c-format
msgid ""
"The smaller densifyFrac we specify, the more acurate Fréchet distance we "
"get. But, the computation time and the memory usage increase with the square "
"of the number of subsegments."
msgstr ""
"Umso kleiner wir densifyFrac wählen, umso genauer wird die Fréchet-Metrik. "
"Aber die Rechenzeit und der Speicherplatzbedarf steigen quadratisch mit der "
"Anzahl der Teilabschnitte."

#. Tag: para
#: reference_measure.xml:620 reference_measure.xml:1259
#, fuzzy, no-c-format
msgid "Performed by the GEOS module."
msgstr "Wird durch das GEOS Modul ausgeführt"

#. Tag: para
#: reference_measure.xml:621
#, no-c-format
msgid "Availability: 2.4.0 - requires GEOS &gt;= 3.7.0"
msgstr "Verfügbarkeit: 2.4.0 - benötigt GEOS &gt;= 3.7.0"

#. Tag: programlisting
#: reference_measure.xml:627
#, no-c-format
msgid ""
"postgres=# SELECT st_frechetdistance('LINESTRING (0 0, 100 0)'::geometry, "
"'LINESTRING (0 0, 50 50, 100 0)'::geometry);\n"
" st_frechetdistance\n"
"--------------------\n"
"   70.7106781186548\n"
"(1 row)"
msgstr ""
"postgres=# SELECT st_frechetdistance('LINESTRING (0 0, 100 0)'::geometry, "
"'LINESTRING (0 0, 50 50, 100 0)'::geometry);\n"
" st_frechetdistance\n"
"--------------------\n"
"   70.7106781186548\n"
"(1 row)"

#. Tag: programlisting
#: reference_measure.xml:628
#, no-c-format
msgid ""
"SELECT st_frechetdistance('LINESTRING (0 0, 100 0)'::geometry, 'LINESTRING "
"(0 0, 50 50, 100 0)'::geometry, 0.5);\n"
" st_frechetdistance\n"
"--------------------\n"
"                 50\n"
"(1 row)"
msgstr ""
"SELECT st_frechetdistance('LINESTRING (0 0, 100 0)'::geometry, 'LINESTRING "
"(0 0, 50 50, 100 0)'::geometry, 0.5);\n"
" st_frechetdistance\n"
"--------------------\n"
"                 50\n"
"(1 row)"

#. Tag: refname
#: reference_measure.xml:640
#, no-c-format
msgid "ST_HausdorffDistance"
msgstr "ST_HausdorffDistance"

#. Tag: refpurpose
#: reference_measure.xml:642
#, fuzzy, no-c-format
msgid "Returns the Hausdorff distance between two geometries."
msgstr ""
"Gibt den kürzesten 3-dimensionalen Abstand zwischen zwei geometrischen "
"Objekten als Linie zurück"

#. Tag: funcsynopsis
#: reference_measure.xml:646
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_HausdorffDistance</function></"
"funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_HausdorffDistance</function></funcdef> <paramdef><type>geometry "
"</type> <parameter>g1</parameter></paramdef> <paramdef><type>geometry </"
"type> <parameter>g2</parameter></paramdef> <paramdef><type>float</type> "
"<parameter>densifyFrac</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_HausdorffDistance</function></"
"funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
"paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_HausdorffDistance</function></funcdef> <paramdef><type>geometry "
"</type> <parameter>g1</parameter></paramdef> <paramdef><type>geometry </"
"type> <parameter>g2</parameter></paramdef> <paramdef><type>float</type> "
"<parameter>densifyFrac</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_measure.xml:674
#, fuzzy, no-c-format
msgid ""
"Returns the Hausdorff distance between two geometries, a measure of how "
"similar or dissimilar 2 geometries are."
msgstr ""
"Gibt die Hausdorff-Metrik von zwei geometrischen Objekten zurück. Dies ist "
"ein grundsätzliches Maß für die Ähnlichkeit oder Unähnlichkeit von 2 "
"geometrischen Objekten. Die Einheiten sind in den Einheiten des "
"Koordinatenreferenzsystems der Geometrie."

#. Tag: para
#: reference_measure.xml:676
#, no-c-format
msgid ""
"Implements algorithm for computing a distance metric which can be thought of "
"as the \"Discrete Hausdorff Distance\". This is the Hausdorff distance "
"restricted to discrete points for one of the geometries. <ulink url=\"http://"
"en.wikipedia.org/wiki/Hausdorff_distance\">Wikipedia article on Hausdorff "
"distance</ulink> <ulink url=\"http://lin-ear-th-inking.blogspot.com/2009/01/"
"computing-geometric-similarity.html\">Martin Davis note on how Hausdorff "
"Distance calculation was used to prove correctness of the "
"CascadePolygonUnion approach.</ulink>"
msgstr ""
"Implementiert einen Algorithmus zur Berechnung einer Abstandsmetrik, welche "
"als \"Diskrete Hausdorff-Metrik\" gedacht werden kann. Dabei handelt es sich "
"um eine Hausdorff-Metrik, die auf diskrete Punkte einer Geometrie beschränkt "
"ist.<ulink url=\"http://en.wikipedia.org/wiki/Hausdorff_distance\">Wikipedia "
"article on Hausdorff distance</ulink> <ulink url=\"http://lin-ear-th-inking."
"blogspot.com/2009/01/computing-geometric-similarity.html\">Martin Davis "
"Notizen wie die Hausdorff-Metrik zur Überprüfung der Korrektheit des "
"CascadePolygonUnion Ansatzes verwendet wurde.</ulink>"

#. Tag: para
#: reference_measure.xml:679
#, no-c-format
msgid ""
"When densifyFrac is specified, this function performs a segment "
"densification before computing the discrete hausdorff distance. The "
"densifyFrac parameter sets the fraction by which to densify each segment. "
"Each segment will be split into a number of equal-length subsegments, whose "
"fraction of the total length is closest to the given fraction."
msgstr ""
"Wenn densifyFrac vorgegeben wird, dann führt diese Funktion eine Verdichtung "
"der Linienstücke durch, bevor die diskrete Hausdorff-Metrik berechnet wird. "
"Der Parameter \"densifyFrac\" bestimmt um welchen Anteil die Linienstücke "
"verdichtet werden. Jedes Linienstück wird in gleichlange Teilsegmente "
"zerlegt, deren Anteil an der Gesamtlänge am nächsten an den vorgegebenen "
"Anteil herankommt."

#. Tag: para
#: reference_measure.xml:691
#, no-c-format
msgid ""
"This algorithm is NOT equivalent to the standard Hausdorff distance. "
"However, it computes an approximation that is correct for a large subset of "
"useful cases. One important part of this subset is Linestrings that are "
"roughly parallel to each other, and roughly equal in length. This is a "
"useful metric for line matching."
msgstr ""
"Dieser Algorithmus ist NICHT gleichwertig mit der normalen Hausdorff-Metrik. "
"Er führt aber eine Näherungsberechnung durch, die für eine große Zahl von "
"Anwendungsfällen korrekt ist. Ein wichtiger Anwendungsfall sind "
"Linienstücke, die ungefähr parallel sind und etwa die gleiche Länge haben. "
"Diese Funktion bietet eine wertvolle Metrik zum Anpassen von Linien."

#. Tag: para
#: reference_measure.xml:702
#, no-c-format
msgid ""
"For each building, find the parcel that best represents it. First we require "
"the parcel intersect with the geometry. DISTINCT ON guarantees we get each "
"building listed only once, the ORDER BY .. ST_HausdorffDistance gives us a "
"preference of parcel that is most similar to the building."
msgstr ""
"Finde zu jedem Bauwerk das Grundstück, das am besten dazu passt. Zuerst "
"verlangen wir, dass sich das Grundstück mit dem Bauwerk schneidet. DISTINCT "
"ON stellt sicher, dass wir jedes Bauwerk nur einmal aufgelistet bekommen, "
"ORDER BY .. ST_HausdorffDistance bevorzugt die Grundstücke, die dem Bauwerk "
"am ähnlichsten sind."

#. Tag: programlisting
#: reference_measure.xml:704
#, no-c-format
msgid ""
"SELECT DISTINCT ON(buildings.gid) buildings.gid, parcels.parcel_id\n"
"   FROM buildings INNER JOIN parcels ON ST_Intersects(buildings.geom,parcels."
"geom)\n"
"     ORDER BY buildings.gid, ST_HausdorffDistance(buildings.geom, parcels."
"geom);"
msgstr ""
"SELECT DISTINCT ON(buildings.gid) buildings.gid, parcels.parcel_id\n"
"   FROM buildings INNER JOIN parcels ON ST_Intersects(buildings.geom,parcels."
"geom)\n"
"     ORDER BY buildings.gid, ST_HausdorffDistance(buildings.geom, parcels."
"geom);"

#. Tag: programlisting
#: reference_measure.xml:706
#, no-c-format
msgid ""
"postgis=# SELECT ST_HausdorffDistance(\n"
"                                'LINESTRING (0 0, 2 0)'::geometry,\n"
"                                'MULTIPOINT (0 1, 1 0, 2 1)'::geometry);\n"
" st_hausdorffdistance\n"
" ----------------------\n"
"                                         1\n"
"(1 row)"
msgstr ""
"postgis=# SELECT ST_HausdorffDistance(\n"
"                                'LINESTRING (0 0, 2 0)'::geometry,\n"
"                                'MULTIPOINT (0 1, 1 0, 2 1)'::geometry);\n"
" st_hausdorffdistance\n"
" ----------------------\n"
"                                         1\n"
"(1 row)"

#. Tag: programlisting
#: reference_measure.xml:707
#, no-c-format
msgid ""
"postgis=# SELECT st_hausdorffdistance('LINESTRING (130 0, 0 0, 0 150)'::"
"geometry, 'LINESTRING (10 10, 10 150, 130 10)'::geometry, 0.5);\n"
" st_hausdorffdistance\n"
" ----------------------\n"
"                                        70\n"
"(1 row)"
msgstr ""
"postgis=# SELECT st_hausdorffdistance('LINESTRING (130 0, 0 0, 0 150)'::"
"geometry, 'LINESTRING (10 10, 10 150, 130 10)'::geometry, 0.5);\n"
" st_hausdorffdistance\n"
" ----------------------\n"
"                                        70\n"
"(1 row)"

#. Tag: refname
#: reference_measure.xml:719
#, no-c-format
msgid "ST_Length"
msgstr "ST_Length"

#. Tag: refpurpose
#: reference_measure.xml:721
#, fuzzy, no-c-format
msgid "Returns the 2D length of a linear geometry."
msgstr "Gibt den geometrischen Schwerpunkt einer Geometrie zurück."

#. Tag: funcsynopsis
#: reference_measure.xml:724
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Length</function></funcdef> "
"<paramdef><type>geometry </type><parameter>a_2dlinestring</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_Length</function></funcdef> <paramdef><type>geography </"
"type><parameter>geog</parameter></paramdef> <paramdef choice=\"opt"
"\"><type>boolean </type><parameter>use_spheroid=true</parameter></paramdef> "
"</funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_Length</function></funcdef> "
"<paramdef><type>geometry </type><parameter>a_2dlinestring</parameter></"
"paramdef> </funcprototype> <funcprototype> <funcdef>float "
"<function>ST_Length</function></funcdef> <paramdef><type>geography </"
"type><parameter>geog</parameter></paramdef> <paramdef choice=\"opt"
"\"><type>boolean </type><parameter>use_spheroid=true</parameter></paramdef> "
"</funcprototype>"

#. Tag: para
#: reference_measure.xml:739
#, fuzzy, no-c-format
msgid ""
"For geometry types: returns the 2D Cartesian length of the geometry if it is "
"a LineString, MultiLineString, ST_Curve, ST_MultiCurve. For areal geometries "
"0 is returned; use <xref linkend=\"ST_Perimeter\"/> instead. The units of "
"length is determined by the spatial reference system of the geometry."
msgstr ""
"Beim geometrischen Datentyp wird die kartesische 2D Länge der Geometrie "
"zurückgegeben. Dabei muss es sich um einen LineString, einen "
"MultiLineString, eine ST_Curve oder eine ST_MultiCurve handeln. Bei einer "
"flächigen Geometrie wird 0 zurückgegeben. Für eine flächige Geometrie können "
"Sie <xref linkend=\"ST_Perimeter\"/> verwenden. Bei den geometrischen "
"Datentypen sind die Einheiten für die Längenmessungen durch das "
"Koordinatenreferenzsystem festgelegt."

#. Tag: para
#: reference_measure.xml:743
#, fuzzy, no-c-format
msgid ""
"For geography types: computation is performed using the inverse geodesic "
"calculation. Units of length are in meters. If PostGIS is compiled with PROJ "
"version 4.8.0 or later, the spheroid is specified by the SRID, otherwise it "
"is exclusive to WGS84. If <varname>use_spheroid=false</varname>, then the "
"calculation is based on a sphere instead of a spheroid."
msgstr ""
"Beim geographischen Datentyp werden die Berechnungen über die zweite "
"geodätische Hauptaufgabe mit der Längeneinheit Meter durchgeführt. Wenn "
"PostGIS mit PROJ Version 4.8.0 oder höher kompiliert wurde, dann ist das "
"Referenzellipsoid durch die SRID bestimmt; sonst ist es ausschließlich "
"WGS84. Wenn <varname>use_spheroid=false</varname> ist, dann werden die "
"Berechnungen auf einer Kugel anstatt auf einem Referenzellipsoid ausgeführt."

#. Tag: para
#: reference_measure.xml:748
#, no-c-format
msgid ""
"Currently for geometry this is an alias for ST_Length2D, but this may change "
"to support higher dimensions."
msgstr ""
"Zur Zeit ein Synonym für ST_Length2D; dies kann sich allerdings ändern, wenn "
"höhere Dimensionen unterstützt werden."

#. Tag: para
#: reference_measure.xml:750
#, no-c-format
msgid ""
"Changed: 2.0.0 Breaking change -- in prior versions applying this to a MULTI/"
"POLYGON of type geography would give you the perimeter of the POLYGON/"
"MULTIPOLYGON. In 2.0.0 this was changed to return 0 to be in line with "
"geometry behavior. Please use ST_Perimeter if you want the perimeter of a "
"polygon"
msgstr ""
"Änderung: 2.0.0 Wesentliche Änderung -- In früheren Versionen ergab die "
"Anwendung auf ein  MULTI/POLYGON vom geographischen Datentyp den Umfang des "
"POLYGON/MULTIPOLYGON. In 2.0.0 wurde dies geändert und es wird jetzt 0 "
"zurückgegeben, damit es mit der Verhaltensweise beim geometrischen Datentyp "
"übereinstimmt. Verwenden Sie bitte ST_Perimeter, wenn Sie den Umfang eines "
"Polygons wissen wollen"

#. Tag: para
#: reference_measure.xml:753
#, fuzzy, no-c-format
msgid ""
"For geography the calculation defaults to using a spheroidal model. To use "
"the faster but less accurate spherical calculation use ST_Length(gg,false);"
msgstr ""
"Beim geographischer Datentyp werden die Messungen standardmäßig am "
"Referenzellipsoid durchgeführt. Für die schnellere, aber ungenauere "
"Berechnung auf einer Kugel können Sie ST_Length(gg,false) verwenden;"

#. Tag: para
#: reference_measure.xml:754 reference_measure.xml:1311
#, no-c-format
msgid "&sfs_compliant; s2.1.5.1"
msgstr "&sfs_compliant; s2.1.5.1"

#. Tag: para
#: reference_measure.xml:755
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 7.1.2, 9.3.4"
msgstr "&sqlmm_compliant; SQL-MM 3: 7.1.2, 9.3.4"

#. Tag: para
#: reference_measure.xml:756
#, no-c-format
msgid "Availability: 1.5.0 geography support was introduced in 1.5."
msgstr "Verfügbarkeit: 1.5.0 Unterstützung von geograpischen Koordinaten."

#. Tag: para
#: reference_measure.xml:757
#, no-c-format
msgid "&sfcgal_enhanced;"
msgstr "&sfcgal_enhanced;"

#. Tag: title
#: reference_measure.xml:761
#, no-c-format
msgid "Geometry Examples"
msgstr "Beispiele mit geometrischem Datentyp"

#. Tag: para
#: reference_measure.xml:762
#, no-c-format
msgid ""
"Return length in feet for line string. Note this is in feet because "
"EPSG:2249 is Massachusetts State Plane Feet"
msgstr ""
"Gibt die Länge eines Linienstücks zurück. Beachten Sie, dass die Einheit Fuß "
"ist, da EPSG:2249 \"Massachusetts State Plane Feet\" ist"

#. Tag: programlisting
#: reference_measure.xml:764
#, fuzzy, no-c-format
msgid ""
"SELECT ST_Length(ST_GeomFromText('LINESTRING(743238 2967416,743238 "
"2967450,743265 2967450,\n"
"743265.625 2967416,743238 2967416)',2249));\n"
"\n"
"st_length\n"
"---------\n"
" 122.630744000095\n"
"\n"
"\n"
"--Transforming WGS 84 LineString to Massachusetts state plane meters\n"
"SELECT ST_Length(\n"
"        ST_Transform(\n"
"                ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.1240 42.45666, -72.123 42.1546)'),\n"
"                26986\n"
"        )\n"
");\n"
"\n"
"st_length\n"
"---------\n"
"34309.4563576191"
msgstr ""
"SELECT ST_Length(ST_GeomFromText('LINESTRING(743238 2967416,743238 "
"2967450,743265 2967450,\n"
"743265.625 2967416,743238 2967416)',2249));\n"
"st_length\n"
"---------\n"
" 122.630744000095\n"
"\n"
"\n"
"--Koordinatentransformation eines Linienzuges von \"WGS 84\" nach "
"\"Massachusetts state plane meters\"\n"
"SELECT ST_Length(\n"
"        ST_Transform(\n"
"                ST_GeomFromEWKT('SRID=4326;LINESTRING(-72.1260 42.45, "
"-72.1240 42.45666, -72.123 42.1546)'),\n"
"                26986\n"
"        )\n"
");\n"
"st_length\n"
"---------\n"
"34309.4563576191"

#. Tag: para
#: reference_measure.xml:768
#, no-c-format
msgid "Return length of WGS 84 geography line"
msgstr ""
"Gibt die Länge einer Linie zurück, die in geographischen WGS 84 Koordinaten "
"vorliegt."

#. Tag: programlisting
#: reference_measure.xml:769
#, fuzzy, no-c-format
msgid ""
"-- the default calculation uses a spheroid\n"
"SELECT ST_Length(the_geog) As length_spheroid,  ST_Length(the_geog,false) As "
"length_sphere\n"
"FROM (SELECT ST_GeographyFromText(\n"
"'SRID=4326;LINESTRING(-72.1260 42.45, -72.1240 42.45666, -72.123 42.1546)') "
"As the_geog)\n"
" As foo;\n"
"\n"
" length_spheroid  |  length_sphere\n"
"------------------+------------------\n"
" 34310.5703627288 | 34346.2060960742"
msgstr ""
"-- standardmäßig wird die Berechnung auf einer Kugel anstatt auf dem "
"Referenzellipsoid ausgeführt\n"
"SELECT ST_Length(the_geog) As length_spheroid,  ST_Length(the_geog,false) As "
"length_sphere\n"
"FROM (SELECT ST_GeographyFromText(\n"
"'SRID=4326;LINESTRING(-72.1260 42.45, -72.1240 42.45666, -72.123 42.1546)') "
"As the_geog)\n"
" As foo;\n"
" length_spheroid  |  length_sphere\n"
"------------------+------------------\n"
" 34310.5703627288 | 34346.2060960742"

#. Tag: para
#: reference_measure.xml:773
#, no-c-format
msgid ""
", <xref linkend=\"ST_GeomFromEWKT\"/>, <xref linkend=\"ST_Length_Spheroid\"/"
">, <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_GeomFromEWKT\"/>, <xref linkend=\"ST_Length_Spheroid\"/"
">, <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_measure.xml:779
#, no-c-format
msgid "ST_Length2D"
msgstr "ST_Length2D"

#. Tag: refpurpose
#: reference_measure.xml:781
#, fuzzy, no-c-format
msgid ""
"Returns the 2D length of a linear geometry. Alias for <varname>ST_Length</"
"varname>"
msgstr ""
"<para>Gibt die 2-dimensionale Länge einer Linie oder einer Mehrfachlinie "
"zurück. Dies ist ein Alias für <varname>ST_Length</varname></para>"

#. Tag: funcprototype
#: reference_measure.xml:786
#, no-c-format
msgid ""
"<funcdef>float <function>ST_Length2D</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_2dlinestring</parameter></"
"paramdef>"
msgstr ""
"<funcdef>float <function>ST_Length2D</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_2dlinestring</parameter></"
"paramdef>"

#. Tag: para
#: reference_measure.xml:796
#, fuzzy, no-c-format
msgid ""
"Returns the 2D length of the geometry if it is a linestring or multi-"
"linestring. This is an alias for <varname>ST_Length</varname>"
msgstr ""
"<para>Gibt die 2-dimensionale Länge einer Linie oder einer Mehrfachlinie "
"zurück. Dies ist ein Alias für <varname>ST_Length</varname></para>"

#. Tag: para
#: reference_measure.xml:805
#, no-c-format
msgid ", <xref linkend=\"ST_3DLength\"/>"
msgstr ", <xref linkend=\"ST_3DLength\"/>"

#. Tag: refname
#: reference_measure.xml:811
#, no-c-format
msgid "ST_3DLength"
msgstr "ST_3DLength"

#. Tag: refpurpose
#: reference_measure.xml:813
#, fuzzy, no-c-format
msgid "Returns the 3D length of a linear geometry."
msgstr "Gibt den geometrischen Schwerpunkt einer Geometrie zurück."

#. Tag: funcprototype
#: reference_measure.xml:818
#, no-c-format
msgid ""
"<funcdef>float <function>ST_3DLength</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_3dlinestring</parameter></"
"paramdef>"
msgstr ""
"<funcdef>float <function>ST_3DLength</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_3dlinestring</parameter></"
"paramdef>"

#. Tag: para
#: reference_measure.xml:828
#, no-c-format
msgid ""
"Returns the 3-dimensional or 2-dimensional length of the geometry if it is a "
"linestring or multi-linestring. For 2-d lines it will just return the 2-d "
"length (same as ST_Length and ST_Length2D)"
msgstr ""
"Gibt die 2- oder 3-dimensionale Länge einer Linie oder einer Mehrfachlinie "
"zurück. Bei einer 2-D Linie wird die Länge nur in 2D zurückgegeben (gleich "
"wie ST_Length und ST_Length2D)"

#. Tag: para
#: reference_measure.xml:831
#, no-c-format
msgid "Changed: 2.0.0 In prior versions this used to be called ST_Length3D"
msgstr "Änderung: 2.0.0 In Vorgängerversionen als ST_Length3D bezeichet."

#. Tag: para
#: reference_measure.xml:838
#, no-c-format
msgid ""
"Return length in feet for a 3D cable. Note this is in feet because EPSG:2249 "
"is Massachusetts State Plane Feet"
msgstr ""
"Gibt die Länge eines 3D-Kabels zurück. Beachten Sie, dass die Einheit Fuß "
"ist, da EPSG:2249 \"Massachusetts State Plane Feet\" ist"

#. Tag: programlisting
#: reference_measure.xml:840
#, no-c-format
msgid ""
"SELECT ST_3DLength(ST_GeomFromText('LINESTRING(743238 2967416 1,743238 "
"2967450 1,743265 2967450 3,\n"
"743265.625 2967416 3,743238 2967416 3)',2249));\n"
"ST_3DLength\n"
"-----------\n"
"122.704716741457"
msgstr ""
"SELECT ST_3DLength(ST_GeomFromText('LINESTRING(743238 2967416 1,743238 "
"2967450 1,743265 2967450 3,\n"
"743265.625 2967416 3,743238 2967416 3)',2249));\n"
"ST_3DLength\n"
"-----------\n"
"122.704716741457"

#. Tag: para
#: reference_measure.xml:847
#, no-c-format
msgid ", <xref linkend=\"ST_Length2D\"/>"
msgstr ", <xref linkend=\"ST_Length2D\"/>"

#. Tag: refname
#: reference_measure.xml:853
#, no-c-format
msgid "ST_LengthSpheroid"
msgstr "ST_LengthSpheroid"

#. Tag: refpurpose
#: reference_measure.xml:855
#, fuzzy, no-c-format
msgid ""
"Returns the 2D or 3D length/perimeter of a lon/lat geometry on a spheroid."
msgstr "Gibt den geometrischen Schwerpunkt einer Geometrie zurück."

#. Tag: funcprototype
#: reference_measure.xml:860
#, no-c-format
msgid ""
"<funcdef>float <function>ST_LengthSpheroid</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_geometry</parameter></"
"paramdef> <paramdef><type>spheroid </type> <parameter>a_spheroid</"
"parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_LengthSpheroid</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>a_geometry</parameter></"
"paramdef> <paramdef><type>spheroid </type> <parameter>a_spheroid</"
"parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:871
#, fuzzy, no-c-format
msgid ""
"Calculates the length or perimeter of a geometry on an ellipsoid. This is "
"useful if the coordinates of the geometry are in longitude/latitude and a "
"length is desired without reprojection. The spheroid is specified by a text "
"value as follows:"
msgstr ""
"Berechnet die/den Länge/Umfang einer Geometrie auf einem Ellipsoid. Dies ist "
"nützlich wenn die Koordinaten der Geometrie in Länge und Breite vorliegen, "
"und die Länge der Geometrie ohne benötigt wird, ohne dass umprojiziert "
"werden muss. Das Ellipsoid ist ein eigener Datentyp und kann wie folgt "
"erstellt werden:"

#. Tag: literallayout
#: reference_measure.xml:876
#, no-c-format
msgid ""
"SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR AXIS&gt;,&lt;INVERSE FLATTENING&gt;]"
msgstr ""
"SPHEROID[&lt;NAME&gt;,&lt;SEMI-MAJOR AXIS&gt;,&lt;INVERSE FLATTENING&gt;]"

#. Tag: para
#: reference_measure.xml:877
#, fuzzy, no-c-format
msgid "For example:"
msgstr "Geometrie Beispiel"

#. Tag: literallayout
#: reference_measure.xml:878
#, no-c-format
msgid "SPHEROID[\"GRS_1980\",6378137,298.257222101]"
msgstr "SPHEROID[\"GRS_1980\",6378137,298.257222101]"

#. Tag: para
#: reference_measure.xml:880
#, no-c-format
msgid "Availability: 1.2.2"
msgstr "Verfügbarkeit: 1.2.2"

#. Tag: para
#: reference_measure.xml:881
#, fuzzy, no-c-format
msgid ""
"Changed: 2.2.0 In prior versions this was called ST_Length_Spheroid and had "
"the alias ST_3DLength_Spheroid"
msgstr ""
"Änderung: 2.2.0 In Vorgängerversionen als ST_Length_Spheroid bezeichet.und "
"mit dem Alias \"ST_3DLength_Spheroid\" versehen"

#. Tag: programlisting
#: reference_measure.xml:888
#, no-c-format
msgid ""
"SELECT ST_LengthSpheroid( geometry_column,\n"
"                          'SPHEROID[\"GRS_1980\",6378137,298.257222101]' )\n"
"                          FROM geometry_table;\n"
"\n"
"SELECT ST_LengthSpheroid( the_geom, sph_m ) As tot_len,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
"                          FROM (SELECT "
"ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),\n"
"        (-71.05957 42.3589 , -71.061 43))') As the_geom,\n"
"CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As sph_m)  "
"as foo;\n"
"        tot_len      |    len_line1     |    len_line2\n"
"------------------+------------------+------------------\n"
" 85204.5207562955 | 13986.8725229309 | 71217.6482333646\n"
"\n"
" --3D\n"
"SELECT ST_LengthSpheroid( the_geom, sph_m ) As tot_len,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
"                          FROM (SELECT "
"ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),\n"
"        (-71.05957 42.3589 75, -71.061 43 90))') As the_geom,\n"
"CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As sph_m)  "
"as foo;\n"
"\n"
"         tot_len      |    len_line1    |    len_line2\n"
"------------------+-----------------+------------------\n"
" 85204.5259107402 | 13986.876097711 | 71217.6498130292"
msgstr ""
"SELECT ST_LengthSpheroid( geometry_column,\n"
"                          'SPHEROID[\"GRS_1980\",6378137,298.257222101]' )\n"
"                          FROM geometry_table;\n"
"\n"
"SELECT ST_LengthSpheroid( the_geom, sph_m ) As tot_len,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
"                          FROM (SELECT "
"ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),\n"
"        (-71.05957 42.3589 , -71.061 43))') As the_geom,\n"
"CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As sph_m)  "
"as foo;\n"
"        tot_len      |    len_line1     |    len_line2\n"
"------------------+------------------+------------------\n"
" 85204.5207562955 | 13986.8725229309 | 71217.6482333646\n"
"\n"
" --3D\n"
"SELECT ST_LengthSpheroid( the_geom, sph_m ) As tot_len,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
"ST_LengthSpheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
"                          FROM (SELECT "
"ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),\n"
"        (-71.05957 42.3589 75, -71.061 43 90))') As the_geom,\n"
"CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As sph_m)  "
"as foo;\n"
"\n"
"         tot_len      |    len_line1    |    len_line2\n"
"------------------+-----------------+------------------\n"
" 85204.5259107402 | 13986.876097711 | 71217.6498130292"

#. Tag: para
#: reference_measure.xml:895
#, no-c-format
msgid ", <xref linkend=\"ST_Length\"/>"
msgstr ", <xref linkend=\"ST_Length\"/>"

#. Tag: refname
#: reference_measure.xml:902
#, no-c-format
msgid "ST_LongestLine"
msgstr "ST_LongestLine"

#. Tag: refpurpose
#: reference_measure.xml:904
#, fuzzy, no-c-format
msgid "Returns the 2D longest line between two geometries."
msgstr ""
"Gibt die größte 3-dimensionale Distanz zwischen zwei geometrischen Objekten "
"als Linie zurück"

#. Tag: funcprototype
#: reference_measure.xml:910
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_LongestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_LongestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:925
#, fuzzy, no-c-format
msgid ""
"Returns the 2-dimensional longest line between the points of two geometries."
msgstr ""
"Gibt die längste 2-dimensionale Linie zwischen den Punkten zweier Geometrien "
"zurück."

#. Tag: para
#: reference_measure.xml:927
#, fuzzy, no-c-format
msgid ""
"The function returns the first longest line if more than one is found. The "
"line returned starts on g1 and ends on g2. The length of the line is equal "
"to the distance returned by <xref linkend=\"ST_MaxDistance\"/>."
msgstr ""
"Gibt den größten 3-dimensionalen Abstand zwischen zwei geometrischen "
"Objekten als Linie zurück. Wenn es mehr als einen größten Abstand gibt, dann "
"wird nur die erste zurückgegeben. Die zurückgegebene Linie fängt immer mit "
"\"g1\" an und endet mit \"g2\". Die Länge der 3D-Linie die von dieser "
"Funktion zurückgegeben wird ist immer ident mit der von <xref linkend="
"\"ST_3DMaxDistance\"/> für \"g1\" und \n"
"\"g2\" zurückgegebenen Distanz."

#. Tag: para
#: reference_measure.xml:946
#, fuzzy, no-c-format
msgid "Longest line between a point and a line"
msgstr "Längste Strecke zwischen Punkt und Linie"

#. Tag: programlisting
#: reference_measure.xml:949
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"        ST_LongestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As lline;\n"
"\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(100 100,98 190)"
msgstr ""
"SELECT ST_AsText(\n"
"        ST_LongestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As lline;\n"
"\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(100 100,98 190)"

#. Tag: para
#: reference_measure.xml:958
#, fuzzy, no-c-format
msgid "Longest line between two polygons"
msgstr "Längste Strecke zwischen Polygon und Polygon"

#. Tag: programlisting
#: reference_measure.xml:961
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"        ST_LongestLine(\n"
"                ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"                        50 60, 125 100, 175 150))'),\n"
"                ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                )\n"
"        ) As llinewkt;\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(20 40,121.111404660392 186.629392246051)"
msgstr ""
"SELECT ST_AsText(\n"
"        ST_LongestLine(\n"
"                ST_GeomFromText('POLYGON((175 150, 20 40,\n"
"                        50 60, 125 100, 175 150))'),\n"
"                ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                )\n"
"        ) As llinewkt;\n"
"\n"
"   lline\n"
"-----------------\n"
"LINESTRING(20 40,121.111404660392 186.629392246051)"

#. Tag: para
#: reference_measure.xml:977
#, fuzzy, no-c-format
msgid ""
"Longest straight distance to travel from one part of a city to another. Note "
"that the maximum distance is equal to the length of the line."
msgstr ""
"Die längste Luftlinie um von einer Seite einer eleganten Stadt auf die "
"andere zu wechseln. Beachten Sie, dass das Ergebnis von ST_MaxDistance ident "
"mit der Länge von ST_LongestLine ist. "

#. Tag: programlisting
#: reference_measure.xml:981
#, fuzzy, no-c-format
msgid ""
"SELECT ST_AsText( ST_LongestLine(c.geom, c.geom)) AS llinewkt,\n"
"       ST_MaxDistance( c.geom,c.geom) AS max_dist,\n"
"       ST_Length( ST_LongestLine(c.geom, c.geom)) AS lenll\n"
"FROM (SELECT ST_MakeValid( ST_Collect(geom)) AS geom\n"
"      FROM (SELECT ST_Translate( ST_SnapToGrid(\n"
"                ST_Buffer(\n"
"                    ST_Point(50 ,generate_series(50,190, 50)),\n"
"                    40, 'quad_segs=2'),1), x, 0) AS geom\n"
"            FROM generate_series(1,100,50) As x) AS foo\n"
"      ) AS c;\n"
"\n"
"          llinewkt          |     max_dist     |      lenll\n"
"---------------------------+------------------+------------------\n"
" LINESTRING(23 22,129 178) | 188.605408193933 | 188.605408193933"
msgstr ""
"SELECT ST_AsText(ST_LongestLine(c.the_geom, c.the_geom)) As llinewkt,\n"
"        ST_MaxDistance(c.the_geom,c.the_geom) As max_dist,\n"
"        ST_Length(ST_LongestLine(c.the_geom, c.the_geom)) As lenll\n"
"FROM (SELECT ST_BuildArea(ST_Collect(the_geom)) As the_geom\n"
"        FROM (SELECT ST_Translate(ST_SnapToGrid(ST_Buffer(ST_Point(50 ,"
"generate_series(50,190, 50)\n"
"                        ),40, 'quad_segs=2'),1), x, 0)  As the_geom\n"
"                        FROM generate_series(1,100,50) As x)  AS foo\n"
") As c;\n"
"\n"
"          llinewkt          |     max_dist     |      lenll\n"
"---------------------------+------------------+------------------\n"
" LINESTRING(23 22,129 178) | 188.605408193933 | 188.605408193933"

#. Tag: para
#: reference_measure.xml:992
#, fuzzy, no-c-format
msgid ""
", <xref linkend=\"ST_MakeValid\"/>, <xref linkend=\"ST_ShortestLine\"/>, "
"<xref linkend=\"ST_3DLongestLine\"/>"
msgstr ""
", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_MaxDistance\"/>"

#. Tag: refname
#: reference_measure.xml:998
#, no-c-format
msgid "ST_3DLongestLine"
msgstr "ST_3DLongestLine"

#. Tag: refpurpose
#: reference_measure.xml:1000
#, fuzzy, no-c-format
msgid "Returns the 3D longest line between two geometries"
msgstr ""
"Gibt die größte 3-dimensionale Distanz zwischen zwei geometrischen Objekten "
"als Linie zurück"

#. Tag: funcprototype
#: reference_measure.xml:1005
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_3DLongestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_3DLongestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1020
#, fuzzy, no-c-format
msgid ""
"Returns the 3-dimensional longest line between two geometries. The function "
"returns the first longest line if more than one. The line returned starts in "
"g1 and ends in g2. The 3D length of the line is equal to the distance "
"returned by <xref linkend=\"ST_3DMaxDistance\"/>."
msgstr ""
"Gibt den größten 3-dimensionalen Abstand zwischen zwei geometrischen "
"Objekten als Linie zurück. Wenn es mehr als einen größten Abstand gibt, dann "
"wird nur die erste zurückgegeben. Die zurückgegebene Linie fängt immer mit "
"\"g1\" an und endet mit \"g2\". Die Länge der 3D-Linie die von dieser "
"Funktion zurückgegeben wird ist immer ident mit der von <xref linkend="
"\"ST_3DMaxDistance\"/> für \"g1\" und \n"
"\"g2\" zurückgegebenen Distanz."

#. Tag: para
#: reference_measure.xml:1039
#, no-c-format
msgid "linestring and point -- both 3d and 2d longest line"
msgstr "Linienstück und Punkt -- größter Abstand in 3D und in 2D"

#. Tag: programlisting
#: reference_measure.xml:1040
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DLongestLine(line,pt)) AS lol3d_line_pt,\n"
"                ST_AsEWKT(ST_LongestLine(line,pt)) As lol2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"           lol3d_line_pt           |       lol2d_line_pt\n"
"-----------------------------------+----------------------------\n"
" LINESTRING(50 75 1000,100 100 30) | LINESTRING(98 190,100 100)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DLongestLine(line,pt)) AS lol3d_line_pt,\n"
"                ST_AsEWKT(ST_LongestLine(line,pt)) As lol2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"           lol3d_line_pt           |       lol2d_line_pt\n"
"-----------------------------------+----------------------------\n"
" LINESTRING(50 75 1000,100 100 30) | LINESTRING(98 190,100 100)"

#. Tag: para
#: reference_measure.xml:1044
#, no-c-format
msgid "linestring and multipoint -- both 3d and 2d longest line"
msgstr "Linienstück und Mehrfachpunkt -- größter Abstand in 3D und in 2D"

#. Tag: programlisting
#: reference_measure.xml:1045
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DLongestLine(line,pt)) AS lol3d_line_pt,\n"
"                ST_AsEWKT(ST_LongestLine(line,pt)) As lol2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"          lol3d_line_pt          |      lol2d_line_pt\n"
"---------------------------------+--------------------------\n"
" LINESTRING(98 190 1,50 74 1000) | LINESTRING(98 190,50 74)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DLongestLine(line,pt)) AS lol3d_line_pt,\n"
"                ST_AsEWKT(ST_LongestLine(line,pt)) As lol2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"          lol3d_line_pt          |      lol2d_line_pt\n"
"---------------------------------+--------------------------\n"
" LINESTRING(98 190 1,50 74 1000) | LINESTRING(98 190,50 74)"

#. Tag: para
#: reference_measure.xml:1049
#, no-c-format
msgid "Multilinestring and polygon both 3d and 2d longest line"
msgstr "Mehrfachlinie und Polygon - größter Abstand in 3D und in 2D"

#. Tag: programlisting
#: reference_measure.xml:1050
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DLongestLine(poly, mline)) As lol3d,\n"
"    ST_AsEWKT(ST_LongestLine(poly, mline)) As lol2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"            lol3d             |          lol2d\n"
"------------------------------+--------------------------\n"
" LINESTRING(175 150 5,1 10 2) | LINESTRING(175 150,1 10)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DLongestLine(poly, mline)) As lol3d,\n"
"    ST_AsEWKT(ST_LongestLine(poly, mline)) As lol2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"            lol3d             |          lol2d\n"
"------------------------------+--------------------------\n"
" LINESTRING(175 150 5,1 10 2) | LINESTRING(175 150,1 10)"

#. Tag: para
#: reference_measure.xml:1062
#, no-c-format
msgid ""
", <xref linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_LongestLine\"/>, "
"<xref linkend=\"ST_3DShortestLine\"/>, <xref linkend=\"ST_3DMaxDistance\"/>"
msgstr ""
", <xref linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_LongestLine\"/>, "
"<xref linkend=\"ST_3DShortestLine\"/>, <xref linkend=\"ST_3DMaxDistance\"/>"

#. Tag: refname
#: reference_measure.xml:1068
#, no-c-format
msgid "ST_MaxDistance"
msgstr "ST_MaxDistance"

#. Tag: refpurpose
#: reference_measure.xml:1070
#, fuzzy, no-c-format
msgid ""
"Returns the 2D largest distance between two geometries in projected units."
msgstr ""
"Gibt die größte 2-dimensionale Distanz zwischen zwei geometrischen Objekten "
"in projizierten Einheiten zurück."

#. Tag: funcprototype
#: reference_measure.xml:1076
#, no-c-format
msgid ""
"<funcdef>float <function>ST_MaxDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_MaxDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1088
#, fuzzy, no-c-format
msgid ""
"Returns the 2-dimensional maximum distance between two geometries, in "
"projected units. The maximum distance always occurs between two vertices. "
"This is the length of the line returned by <xref linkend=\"ST_LongestLine\"/"
">."
msgstr ""
"Gibt die größte 2-dimensionale Distanz zwischen zwei geometrischen Objekten "
"in projizierten Einheiten zurück. Wenn g1 und g2 dieselbe Geometrie sind, "
"dann gibt die Funktion die Distanz zwischen den beiden am weitesten "
"entfernten Knoten in dieser Geometrie zurück."

#. Tag: para
#: reference_measure.xml:1092
#, fuzzy, no-c-format
msgid ""
"If g1 and g2 are the same geometry, returns the distance between the two "
"vertices farthest apart in that geometry."
msgstr ""
"Gibt die größte 2-dimensionale Distanz zwischen zwei geometrischen Objekten "
"in projizierten Einheiten zurück. Wenn g1 und g2 dieselbe Geometrie sind, "
"dann gibt die Funktion die Distanz zwischen den beiden am weitesten "
"entfernten Knoten in dieser Geometrie zurück."

#. Tag: para
#: reference_measure.xml:1101
#, fuzzy, no-c-format
msgid "Maximum distance between a point and lines."
msgstr "Längste Strecke zwischen Punkt und Linie"

#. Tag: programlisting
#: reference_measure.xml:1102
#, fuzzy, no-c-format
msgid ""
"postgis=# SELECT ST_MaxDistance('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 "
"2 )'::geometry);\n"
"   st_maxdistance\n"
"-----------------\n"
" 2\n"
"\n"
"postgis=# SELECT ST_MaxDistance('POINT(0 0)'::geometry, 'LINESTRING ( 2 2, 2 "
"2 )'::geometry);\n"
"  st_maxdistance\n"
"------------------\n"
" 2.82842712474619"
msgstr ""
"postgis=# SELECT ST_MaxDistance('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 "
"2 )'::geometry);\n"
"   st_maxdistance\n"
"-----------------\n"
" 2\n"
"(1 row)\n"
"\n"
"postgis=# SELECT ST_MaxDistance('POINT(0 0)'::geometry, 'LINESTRING ( 2 2, 2 "
"2 )'::geometry);\n"
"  st_maxdistance\n"
"------------------\n"
" 2.82842712474619\n"
"(1 row)"

#. Tag: para
#: reference_measure.xml:1104
#, fuzzy, no-c-format
msgid "Maximum distance between vertices of a geometry."
msgstr ""
"Gibt den kürzesten 3-dimensionalen Abstand zwischen zwei geometrischen "
"Objekten als Linie zurück"

#. Tag: programlisting
#: reference_measure.xml:1105
#, fuzzy, no-c-format
msgid ""
"SELECT ST_MaxDistance('POLYGON ((10 10, 10 0, 0 0, 10 10))'::geometry,\n"
"                      'POLYGON ((10 10, 10 0, 0 0, 10 10))'::geometry);\n"
"  st_maxdistance\n"
"------------------\n"
" 14.142135623730951"
msgstr ""
"postgres=# SELECT st_frechetdistance('LINESTRING (0 0, 100 0)'::geometry, "
"'LINESTRING (0 0, 50 50, 100 0)'::geometry);\n"
" st_frechetdistance\n"
"--------------------\n"
"   70.7106781186548\n"
"(1 row)"

#. Tag: para
#: reference_measure.xml:1111
#, no-c-format
msgid ""
", <xref linkend=\"ST_LongestLine\"/>, <xref linkend=\"ST_DFullyWithin\"/>"
msgstr ""
", <xref linkend=\"ST_LongestLine\"/>, <xref linkend=\"ST_DFullyWithin\"/>"

#. Tag: refname
#: reference_measure.xml:1117
#, no-c-format
msgid "ST_3DMaxDistance"
msgstr "ST_3DMaxDistance"

#. Tag: refpurpose
#: reference_measure.xml:1119
#, fuzzy, no-c-format
msgid ""
"Returns the 3D cartesian maximum distance (based on spatial ref) between two "
"geometries in projected units."
msgstr ""
"Für den geometrischen Datentyp. Gibt die maximale 3-dimensionale kartesische "
"Distanz (basierend auf dem Koordinatenreferenzsystem) zwischen zwei "
"geometrischen Objekten in projizierten Einheiten zurück."

#. Tag: funcprototype
#: reference_measure.xml:1124
#, no-c-format
msgid ""
"<funcdef>float <function>ST_3DMaxDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_3DMaxDistance</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1139
#, fuzzy, no-c-format
msgid ""
"Returns the 3-dimensional maximum cartesian distance between two geometries "
"in projected units (spatial ref units)."
msgstr ""
"Für den geometrischen Datentyp. Gibt die maximale 3-dimensionale kartesische "
"Distanz zwischen zwei geometrischen Objekten in projizierten Einheiten "
"(Einheiten des Koordinatenreferenzsystem) zurück."

#. Tag: programlisting
#: reference_measure.xml:1153
#, no-c-format
msgid ""
"-- Geometry example - units in meters (SRID: 2163 US National Atlas Equal "
"area) (3D point and line compared 2D point and line)\n"
"-- Note: currently no vertical datum support so Z is not transformed and "
"assumed to be same units as final.\n"
"SELECT ST_3DMaxDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 10000)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_3d,\n"
"                ST_MaxDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 10000)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_2d;\n"
"\n"
"     dist_3d      |     dist_2d\n"
"------------------+------------------\n"
" 24383.7467488441 | 22247.8472107251"
msgstr ""
"-- Beispiel Geometrie - Einheiten in Meter (SRID: 2163 US National Atlas "
"Equal area) (Vergleich von 3D-Punkt und Linie mit 2D-Punkt und Linie)\n"
"-- Anmerkung: zur Zeit gibt es keine Unterstützung für ein Höhendatum, daher "
"wird Z unverändert übernommen und nicht transformiert.\n"
"SELECT ST_3DMaxDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 10000)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_3d,\n"
"                ST_MaxDistance(\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"POINT(-72.1235 42.3521 10000)'),2163),\n"
"                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
"LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163)\n"
"                ) As dist_2d;\n"
"\n"
"     dist_3d      |     dist_2d\n"
"------------------+------------------\n"
" 24383.7467488441 | 22247.8472107251"

#. Tag: para
#: reference_measure.xml:1159
#, no-c-format
msgid ""
", <xref linkend=\"ST_3DDWithin\"/>, <xref linkend=\"ST_3DMaxDistance\"/>, "
"<xref linkend=\"ST_Transform\"/>"
msgstr ""
", <xref linkend=\"ST_3DDWithin\"/>, <xref linkend=\"ST_3DMaxDistance\"/>, "
"<xref linkend=\"ST_Transform\"/>"

#. Tag: refname
#: reference_measure.xml:1165
#, no-c-format
msgid "ST_MinimumClearance"
msgstr "ST_MinimumClearance"

#. Tag: refpurpose
#: reference_measure.xml:1166
#, no-c-format
msgid ""
"Returns the minimum clearance of a geometry, a measure of a geometry's "
"robustness."
msgstr ""
"Gibt das Mindestabstandsmaß für eine Geometrie zurück; ein Maß für die "
"Robustheit einer Geometrie."

#. Tag: funcprototype
#: reference_measure.xml:1171
#, no-c-format
msgid ""
"<funcdef>float <function>ST_MinimumClearance</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_MinimumClearance</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1181
#, no-c-format
msgid ""
"It is not uncommon to have a geometry that, while meeting the criteria for "
"validity according to ST_IsValid (polygons) or ST_IsSimple (lines), would "
"become invalid if one of the vertices moved by a slight distance, as can "
"happen during conversion to text-based formats (such as WKT, KML, GML "
"GeoJSON), or binary formats that do not use double-precision floating point "
"coordinates (MapInfo TAB)."
msgstr ""
"Es ist nicht ungewöhnlich dass eine Geometrie, welche die Kriterien für "
"Validität gemäß ST_IsValid (Polygone) oder ST_IsSimple (Linien) erfüllt, "
"durch eine geringe Verschiebung von einem Knoten invalid wird. Dies kann "
"während einer Konvertierung in Textformate (wie WKT, KML, GML und GeoJSON) "
"vorkommen, oder bei binären Formaten, welche die Koordinaten nicht als "
"Gleitpunkt-Zahl mit doppelter Genauigkeit (double-precision floating point) "
"abspeichern (MapInfo TAB)."

#. Tag: para
#: reference_measure.xml:1188
#, no-c-format
msgid ""
"A geometry's \"minimum clearance\" is the smallest distance by which a "
"vertex of the geometry could be moved to produce an invalid geometry. It can "
"be thought of as a quantitative measure of a geometry's robustness, where "
"increasing values of minimum clearance indicate increasing robustness."
msgstr ""
"Das \"Mindestabstandsmaß\" einer Geometrie entspricht der kürzesten Strecke, "
"um die ein Knoten der Geometrie bewegt werden kann, ohne dass die Geometrie "
"invalid wird. Es kann als quantitative Maßzahl für die Robustheit einer "
"Geometrie gesehen werden, wobei steigende Werte zunehmende Robustheit "
"anzeigen."

#. Tag: para
#: reference_measure.xml:1194
#, no-c-format
msgid ""
"If a geometry has a minimum clearance of <varname>e</varname>, it can be "
"said that:"
msgstr ""
"Wenn eine Geometrie ein Mindestabstandsmaß von <varname>e</varname> hat, "
"dann gilt:"

#. Tag: para
#: reference_measure.xml:1198
#, no-c-format
msgid ""
"No two distinct vertices in the geometry are separated by less than "
"<varname>e</varname>."
msgstr ""
"Zwei sich unterscheidende Knoten der Geometrie sind nicht weniger als "
"<varname>e</varname> voneinander entfernt."

#. Tag: para
#: reference_measure.xml:1203
#, no-c-format
msgid ""
"No vertex is closer than <varname>e</varname> to a line segement of which it "
"is not an endpoint."
msgstr ""
"Kein Knoten liegt näher als <varname>e</varname> bei einem Liniensegment, "
"außer es ist ein Endpunkt."

#. Tag: para
#: reference_measure.xml:1210
#, no-c-format
msgid ""
"If no minimum clearance exists for a geometry (for example, a single point, "
"or a multipoint whose points are identical), then ST_MinimumClearance will "
"return Infinity."
msgstr ""
"Wenn für eine Geometrie kein Mindestabstandsmaß existiert (zum Beispiel ein "
"einzelner Punkt, oder ein Mehrfachpunkt, dessen Punkte identisch sind), dann "
"gibt ST_MinimumClearance unendlich zurück."

#. Tag: para
#: reference_measure.xml:1215
#, no-c-format
msgid "Availability: 2.3.0"
msgstr "Verfügbarkeit: 2.3.0"

#. Tag: programlisting
#: reference_measure.xml:1221
#, no-c-format
msgid ""
"SELECT ST_MinimumClearance('POLYGON ((0 0, 1 0, 1 1, 0.5 3.2e-4, 0 0))');\n"
" st_minimumclearance\n"
"---------------------\n"
"             0.00032"
msgstr ""
"SELECT ST_MinimumClearance('POLYGON ((0 0, 1 0, 1 1, 0.5 3.2e-4, 0 0))');\n"
" st_minimumclearance\n"
"---------------------\n"
"             0.00032"

#. Tag: refname
#: reference_measure.xml:1236
#, no-c-format
msgid "ST_MinimumClearanceLine"
msgstr "ST_MinimumClearanceLine"

#. Tag: refpurpose
#: reference_measure.xml:1237
#, no-c-format
msgid ""
"Returns the two-point LineString spanning a geometry's minimum clearance."
msgstr ""
"Gibt ein Linienstück mit zwei Punkten zurück, welche sich über das "
"Mindestabstandsmaß erstreckt."

#. Tag: funcprototype
#: reference_measure.xml:1242
#, no-c-format
msgid ""
"<funcdef>Geometry <function>ST_MinimumClearanceLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g</parameter></paramdef>"
msgstr ""
"<funcdef>Geometry <function>ST_MinimumClearanceLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1255
#, no-c-format
msgid ""
"Returns the two-point LineString spanning a geometry's minimum clearance. If "
"the geometry does not have a minimum clearance, <varname>LINESTRING EMPTY</"
"varname> will be returned."
msgstr ""
"Gibt ein Zwei-Punkt-Linienstück zurück, welches sich über das "
"Mindestabstandsmaß erstreckt. Wenn die Geometrie kein Mindestabstandsmaß "
"aufweist, dann wird <varname>LINESTRING EMPTY</varname> zurückgegeben."

#. Tag: para
#: reference_measure.xml:1260
#, no-c-format
msgid "Availability: 2.3.0 - requires GEOS &gt;= 3.6.0"
msgstr "Verfügbarkeit: 2.3.0 - benötigt GEOS &gt;= 3.6.0"

#. Tag: programlisting
#: reference_measure.xml:1266
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_MinimumClearanceLine('POLYGON ((0 0, 1 0, 1 1, 0.5 "
"3.2e-4, 0 0))'));\n"
"st_astext\n"
"-------------------------------\n"
"LINESTRING(0.5 0.00032,0.5 0)"
msgstr ""
"SELECT ST_AsText(ST_MinimumClearanceLine('POLYGON ((0 0, 1 0, 1 1, 0.5 "
"3.2e-4, 0 0))'));\n"
"st_astext\n"
"-------------------------------\n"
"LINESTRING(0.5 0.00032,0.5 0)"

#. Tag: refname
#: reference_measure.xml:1281
#, no-c-format
msgid "ST_Perimeter"
msgstr "ST_Perimeter"

#. Tag: refpurpose
#: reference_measure.xml:1283
#, no-c-format
msgid ""
"Returns the length of the boundary of a polygonal geometry or geography."
msgstr ""

#. Tag: funcsynopsis
#: reference_measure.xml:1286
#, no-c-format
msgid ""
"<funcprototype> <funcdef>float <function>ST_Perimeter</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Perimeter</"
"function></funcdef> <paramdef><type>geography </type><parameter>geog</"
"parameter></paramdef> <paramdef choice=\"opt\"><type>boolean </"
"type><parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"
msgstr ""
"<funcprototype> <funcdef>float <function>ST_Perimeter</function></funcdef> "
"<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> </"
"funcprototype> <funcprototype> <funcdef>float <function>ST_Perimeter</"
"function></funcdef> <paramdef><type>geography </type><parameter>geog</"
"parameter></paramdef> <paramdef choice=\"opt\"><type>boolean </"
"type><parameter>use_spheroid=true</parameter></paramdef> </funcprototype>"

#. Tag: para
#: reference_measure.xml:1302
#, no-c-format
msgid ""
"Returns the 2D perimeter of the geometry/geography if it is a ST_Surface, "
"ST_MultiSurface (Polygon, MultiPolygon). 0 is returned for non-areal "
"geometries. For linear geometries use <xref linkend=\"ST_Length\"/>. For "
"geometry types, units for perimeter measures are specified by the spatial "
"reference system of the geometry."
msgstr ""
"Gibt für die geometrischen/geographischen Datentypen ST_Surface, "
"ST_MultiSurface (Polygon, MultiPolygon) den Umfang in 2D zurück. Bei einer "
"nicht flächigen Geometrie wird 0 zurückgegeben. Für eine lineare Geometrie "
"können Sie <xref linkend=\"ST_Length\"/> verwenden. Beim geometrischen "
"Datentyp sind die Einheiten der Umfangsmessung durch das "
"Koordinatenreferenzsystem der Geometrie festgelegt."

#. Tag: para
#: reference_measure.xml:1305
#, no-c-format
msgid ""
"For geography types, the calculations are performed using the inverse "
"geodesic problem, where perimeter units are in meters. If PostGIS is "
"compiled with PROJ version 4.8.0 or later, the spheroid is specified by the "
"SRID, otherwise it is exclusive to WGS84. If <varname>use_spheroid=false</"
"varname>, then calculations will approximate a sphere instead of a spheroid."
msgstr ""
"Beim geographischen Datentyp werden die Berechnungen über die zweite "
"geodätische Hauptaufgabe durchgeführt, wobei die Einheit für den Umfang "
"Meter ist. Wenn PostGIS mit PROJ Version 4.8.0 oder höher kompiliert wurde, "
"dann ist das Referenzellipsoid durch die SRID bestimmt; sonst ist es "
"ausschließlich WGS84. Wenn <varname>use_spheroid=false</varname> ist, dann "
"werden die Berechnungen auf einer Kugel anstatt auf einem Referenzellipsoid "
"ausgeführt."

#. Tag: para
#: reference_measure.xml:1309
#, no-c-format
msgid ""
"Currently this is an alias for ST_Perimeter2D, but this may change to "
"support higher dimensions."
msgstr ""
"Zur Zeit ein Synonym für ST_Perimeter2D; dies kann sich allerdings ändern, "
"wenn höhere Dimensionen unterstützt werden."

#. Tag: para
#: reference_measure.xml:1312
#, no-c-format
msgid "&sqlmm_compliant; SQL-MM 3: 8.1.3, 9.5.4"
msgstr "&sqlmm_compliant; SQL-MM 3: 8.1.3, 9.5.4"

#. Tag: para
#: reference_measure.xml:1313
#, no-c-format
msgid "Availability 2.0.0: Support for geography was introduced"
msgstr ""
"Verfügbarkeit: Mit 2.0.0 wurde die Unterstützung für geograpischen "
"Koordinaten eingeführt"

#. Tag: title
#: reference_measure.xml:1317
#, no-c-format
msgid "Examples: Geometry"
msgstr "Beispiele: geometrischer Datentyp"

#. Tag: para
#: reference_measure.xml:1318
#, no-c-format
msgid ""
"Return perimeter in feet for Polygon and MultiPolygon. Note this is in feet "
"because EPSG:2249 is Massachusetts State Plane Feet"
msgstr ""
"Den Umfang eines Polygons und eines Mehrfachpolygons in Fuß ausgeben. "
"Beachten Sie bitte, dass die Einheit Fuß ist, da EPSG:2249 \"Massachusetts "
"State Plane Feet\" ist "

#. Tag: programlisting
#: reference_measure.xml:1320
#, no-c-format
msgid ""
"SELECT ST_Perimeter(ST_GeomFromText('POLYGON((743238 2967416,743238 "
"2967450,743265 2967450,\n"
"743265.625 2967416,743238 2967416))', 2249));\n"
"st_perimeter\n"
"---------\n"
" 122.630744000095\n"
"(1 row)\n"
"\n"
"SELECT ST_Perimeter(ST_GeomFromText('MULTIPOLYGON(((763104.471273676 "
"2949418.44119003,\n"
"763104.477769673 2949418.42538203,\n"
"763104.189609677 2949418.22343004,763104.471273676 2949418.44119003)),\n"
"((763104.471273676 2949418.44119003,763095.804579742 2949436.33850239,\n"
"763086.132105649 2949451.46730207,763078.452329651 2949462.11549407,\n"
"763075.354136904 2949466.17407812,763064.362142565 2949477.64291974,\n"
"763059.953961626 2949481.28983009,762994.637609571 2949532.04103014,\n"
"762990.568508415 2949535.06640477,762986.710889563 2949539.61421415,\n"
"763117.237897679 2949709.50493431,763235.236617789 2949617.95619822,\n"
"763287.718121842 2949562.20592617,763111.553321674 2949423.91664605,\n"
"763104.471273676 2949418.44119003)))', 2249));\n"
"st_perimeter\n"
"---------\n"
" 845.227713366825\n"
"(1 row)"
msgstr ""
"SELECT ST_Perimeter(ST_GeomFromText('POLYGON((743238 2967416,743238 "
"2967450,743265 2967450,\n"
"743265.625 2967416,743238 2967416))', 2249));\n"
"st_perimeter\n"
"---------\n"
" 122.630744000095\n"
"(1 row)\n"
"\n"
"SELECT ST_Perimeter(ST_GeomFromText('MULTIPOLYGON(((763104.471273676 "
"2949418.44119003,\n"
"763104.477769673 2949418.42538203,\n"
"763104.189609677 2949418.22343004,763104.471273676 2949418.44119003)),\n"
"((763104.471273676 2949418.44119003,763095.804579742 2949436.33850239,\n"
"763086.132105649 2949451.46730207,763078.452329651 2949462.11549407,\n"
"763075.354136904 2949466.17407812,763064.362142565 2949477.64291974,\n"
"763059.953961626 2949481.28983009,762994.637609571 2949532.04103014,\n"
"762990.568508415 2949535.06640477,762986.710889563 2949539.61421415,\n"
"763117.237897679 2949709.50493431,763235.236617789 2949617.95619822,\n"
"763287.718121842 2949562.20592617,763111.553321674 2949423.91664605,\n"
"763104.471273676 2949418.44119003)))', 2249));\n"
"st_perimeter\n"
"---------\n"
" 845.227713366825\n"
"(1 row)"

#. Tag: title
#: reference_measure.xml:1323
#, no-c-format
msgid "Examples: Geography"
msgstr "Beispiele: geographischer Datentyp"

#. Tag: para
#: reference_measure.xml:1324
#, no-c-format
msgid ""
"Return perimeter in meters and feet for Polygon and MultiPolygon. Note this "
"is geography (WGS 84 long lat)"
msgstr ""
"Gibt den Umfang eines Polygons und eines Mehrfachpolygons in Meter und in "
"Fuß aus. Beachten Sie, dass diese in geographischen Koordinaten (WGS 84 "
"Länge/Breite) vorliegen."

#. Tag: programlisting
#: reference_measure.xml:1325
#, no-c-format
msgid ""
"SELECT  ST_Perimeter(geog) As per_meters, ST_Perimeter(geog)/0.3048 As "
"per_ft\n"
"FROM ST_GeogFromText('POLYGON((-71.1776848522251 "
"42.3902896512902,-71.1776843766326 42.3903829478009,\n"
"-71.1775844305465 42.3903826677917,-71.1775825927231 "
"42.3902893647987,-71.1776848522251 42.3902896512902))') As geog;\n"
"\n"
"   per_meters    |      per_ft\n"
"-----------------+------------------\n"
"37.3790462565251 | 122.634666195949\n"
"\n"
"\n"
"-- MultiPolygon example --\n"
"SELECT  ST_Perimeter(geog) As per_meters, ST_Perimeter(geog,false) As "
"per_sphere_meters,  ST_Perimeter(geog)/0.3048 As per_ft\n"
"FROM ST_GeogFromText('MULTIPOLYGON(((-71.1044543107478 "
"42.340674480411,-71.1044542869917 42.3406744369506,\n"
"-71.1044553562977 42.340673886454,-71.1044543107478 42.340674480411)),\n"
"((-71.1044543107478 42.340674480411,-71.1044860600303 "
"42.3407237015564,-71.1045215770124 42.3407653385914,\n"
"-71.1045498002983 42.3407946553165,-71.1045611902745 "
"42.3408058316308,-71.1046016507427 42.340837442371,\n"
"-71.104617893173 42.3408475056957,-71.1048586153981 "
"42.3409875993595,-71.1048736143677 42.3409959528211,\n"
"-71.1048878050242 42.3410084812078,-71.1044020965803 42.3414730072048,\n"
"-71.1039672113619 42.3412202916693,-71.1037740497748 42.3410666421308,\n"
"-71.1044280218456 42.3406894151355,-71.1044543107478 42.340674480411)))') As "
"geog;\n"
"\n"
"    per_meters    | per_sphere_meters |      per_ft\n"
"------------------+-------------------+------------------\n"
" 257.634283683311 |  257.412311446337 | 845.256836231335"
msgstr ""
"SELECT  ST_Perimeter(geog) As per_meters, ST_Perimeter(geog)/0.3048 As "
"per_ft\n"
"FROM ST_GeogFromText('POLYGON((-71.1776848522251 "
"42.3902896512902,-71.1776843766326 42.3903829478009,\n"
"-71.1775844305465 42.3903826677917,-71.1775825927231 "
"42.3902893647987,-71.1776848522251 42.3902896512902))') As geog;\n"
"\n"
"   per_meters    |      per_ft\n"
"-----------------+------------------\n"
"37.3790462565251 | 122.634666195949\n"
"\n"
"\n"
"-- Beispiel MultiPolygon  --\n"
"SELECT  ST_Perimeter(geog) As per_meters, ST_Perimeter(geog,false) As "
"per_sphere_meters,  ST_Perimeter(geog)/0.3048 As per_ft\n"
"FROM ST_GeogFromText('MULTIPOLYGON(((-71.1044543107478 "
"42.340674480411,-71.1044542869917 42.3406744369506,\n"
"-71.1044553562977 42.340673886454,-71.1044543107478 42.340674480411)),\n"
"((-71.1044543107478 42.340674480411,-71.1044860600303 "
"42.3407237015564,-71.1045215770124 42.3407653385914,\n"
"-71.1045498002983 42.3407946553165,-71.1045611902745 "
"42.3408058316308,-71.1046016507427 42.340837442371,\n"
"-71.104617893173 42.3408475056957,-71.1048586153981 "
"42.3409875993595,-71.1048736143677 42.3409959528211,\n"
"-71.1048878050242 42.3410084812078,-71.1044020965803 42.3414730072048,\n"
"-71.1039672113619 42.3412202916693,-71.1037740497748 42.3410666421308,\n"
"-71.1044280218456 42.3406894151355,-71.1044543107478 42.340674480411)))') As "
"geog;\n"
"\n"
"    per_meters    | per_sphere_meters |      per_ft\n"
"------------------+-------------------+------------------\n"
" 257.634283683311 |  257.412311446337 | 845.256836231335"

#. Tag: para
#: reference_measure.xml:1329
#, no-c-format
msgid ", <xref linkend=\"ST_GeomFromText\"/>, <xref linkend=\"ST_Length\"/>"
msgstr ", <xref linkend=\"ST_GeomFromText\"/>, <xref linkend=\"ST_Length\"/>"

#. Tag: refname
#: reference_measure.xml:1335
#, no-c-format
msgid "ST_Perimeter2D"
msgstr "ST_Perimeter2D"

#. Tag: refpurpose
#: reference_measure.xml:1337
#, no-c-format
msgid ""
"Returns the 2D perimeter of a polygonal geometry. Alias for "
"<varname>ST_Perimeter</varname>."
msgstr ""

#. Tag: funcprototype
#: reference_measure.xml:1343
#, no-c-format
msgid ""
"<funcdef>float <function>ST_Perimeter2D</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_Perimeter2D</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1353
#, fuzzy, no-c-format
msgid "Returns the 2-dimensional perimeter of a polygonal geometry."
msgstr ""
"Gibt den 2-dimensionalen Umfang eines Polygons oder eines Mehrfachpolygons "
"zurück."

#. Tag: para
#: reference_measure.xml:1357
#, no-c-format
msgid ""
"This is currently an alias for ST_Perimeter. In future versions ST_Perimeter "
"may return the highest dimension perimeter for a geometry. This is still "
"under consideration"
msgstr ""
"Zurzeit ein Alias für ST_Perimeter. In zukünftigen Versionen dürfte "
"ST_Perimeter den Umfang in der höchsten Dimension einer Geometrie "
"zurückgeben. Dies befindet sich jedoch noch im Aufbau."

#. Tag: refname
#: reference_measure.xml:1371
#, no-c-format
msgid "ST_3DPerimeter"
msgstr "ST_3DPerimeter"

#. Tag: refpurpose
#: reference_measure.xml:1373
#, fuzzy, no-c-format
msgid "Returns the 3D perimeter of a polygonal geometry."
msgstr "Gibt den geometrischen Schwerpunkt einer Geometrie zurück."

#. Tag: funcprototype
#: reference_measure.xml:1378
#, no-c-format
msgid ""
"<funcdef>float <function>ST_3DPerimeter</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"
msgstr ""
"<funcdef>float <function>ST_3DPerimeter</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1388
#, no-c-format
msgid ""
"Returns the 3-dimensional perimeter of the geometry, if it is a polygon or "
"multi-polygon. If the geometry is 2-dimensional, then the 2-dimensional "
"perimeter is returned."
msgstr ""
"Gibt den 3-dimensionalen Umfang eines Polygons oder eines Mehrfachpolygons "
"zurück. Wenn es sich um eine 2-dimensionale Geometrie handelt wird der 2-"
"dimensionale Umfang zurückgegeben."

#. Tag: para
#: reference_measure.xml:1391
#, no-c-format
msgid "Changed: 2.0.0 In prior versions this used to be called ST_Perimeter3D"
msgstr "Änderung: 2.0.0 In Vorgängerversionen als ST_Perimeter3D bezeichet."

#. Tag: para
#: reference_measure.xml:1397
#, no-c-format
msgid ""
"Perimeter of a slightly elevated polygon in the air in Massachusetts state "
"plane feet"
msgstr ""
"Umfang eines leicht erhöhten Polygons in \"Massachusetts state plane feet\""

#. Tag: programlisting
#: reference_measure.xml:1398
#, no-c-format
msgid ""
"SELECT ST_3DPerimeter(the_geom), ST_Perimeter2d(the_geom), "
"ST_Perimeter(the_geom) FROM\n"
"                        (SELECT ST_GeomFromEWKT('SRID=2249;POLYGON((743238 "
"2967416 2,743238 2967450 1,\n"
"743265.625 2967416 1,743238 2967416 2))') As the_geom) As foo;\n"
"\n"
"  ST_3DPerimeter  |  st_perimeter2d  |   st_perimeter\n"
"------------------+------------------+------------------\n"
" 105.465793597674 | 105.432997272188 | 105.432997272188"
msgstr ""
"SELECT ST_3DPerimeter(the_geom), ST_Perimeter2d(the_geom), "
"ST_Perimeter(the_geom) FROM\n"
"                        (SELECT ST_GeomFromEWKT('SRID=2249;POLYGON((743238 "
"2967416 2,743238 2967450 1,\n"
"743265.625 2967416 1,743238 2967416 2))') As the_geom) As foo;\n"
"\n"
"  ST_3DPerimeter  |  st_perimeter2d  |   st_perimeter\n"
"------------------+------------------+------------------\n"
" 105.465793597674 | 105.432997272188 | 105.432997272188"

#. Tag: para
#: reference_measure.xml:1405
#, no-c-format
msgid ", <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Perimeter2D\"/>"
msgstr ", <xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Perimeter2D\"/>"

#. Tag: refname
#: reference_measure.xml:1411
#, no-c-format
msgid "ST_Project"
msgstr "ST_Project"

#. Tag: refpurpose
#: reference_measure.xml:1413
#, fuzzy, no-c-format
msgid ""
"Returns a point projected from a start point by a distance and bearing "
"(azimuth)."
msgstr ""
"Gibt einen <varname>POINT</varname> zurück, der von einem Anfangspunkt weg, "
"entsprechend einer Distanz in Meter und einer Peilung (Azimut) in Radiant, "
"projiziert wird."

#. Tag: funcprototype
#: reference_measure.xml:1418
#, no-c-format
msgid ""
"<funcdef>geography <function>ST_Project</function></funcdef> "
"<paramdef><type>geography </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>distance</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>azimuth</parameter></paramdef>"
msgstr ""
"<funcdef>geography <function>ST_Project</function></funcdef> "
"<paramdef><type>geography </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>distance</parameter></paramdef> "
"<paramdef><type>float </type> <parameter>azimuth</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1434
#, fuzzy, no-c-format
msgid ""
"Returns a point projected from a start point along a geodesic using a given "
"distance and azimuth (bearing). This is known as the direct geodesic problem."
msgstr ""
"Gibt einen <varname>POINT</varname> zurück, der sich von einem Standpunkt "
"aus durch den Azimut (Pelilung) in Radiant und die Distanz in Meter zum "
"Zielpunkt ergibt. Dies wird auch als erste geodätische Hauptaufgabe "
"bezeichnet."

#. Tag: para
#: reference_measure.xml:1437
#, fuzzy, no-c-format
msgid "The distance is given in meters. Negative values are supported."
msgstr "Die Entfernung wird in Meter angegeben."

#. Tag: para
#: reference_measure.xml:1438
#, fuzzy, no-c-format
msgid ""
"The azimuth (also known as heading or bearing) is given in radians. It is "
"measured clockwise from true north (azimuth zero). East is azimuth "
"&#x03C0;/2 (90 degrees); south is azimuth &#x03C0; (180 degrees); west is "
"azimuth 3&#x03C0;/2 (270 degrees). Negative azimuth values and values "
"greater than 2&#x03C0; (360 degrees) are supported."
msgstr ""
"In der Navigation wird das Azimut auch manchmal als Kurs oder Peilung "
"bezeichnet. Es wird relativ zur Nordrichtung (Azimut null) gemessen. Osten "
"hat ein Azimut von 90 (&#x03C0;/2), Süden 180 (&#x03C0;) und Westen 270 "
"(3&#x03C0;/2)."

#. Tag: para
#: reference_measure.xml:1448
#, no-c-format
msgid "Enhanced: 2.4.0 Allow negative distance and non-normalized azimuth."
msgstr ""
"Erweiterung: 2.4.0 Erlaubt negative Distanzen und nicht normalisierten "
"Azimut."

#. Tag: title
#: reference_measure.xml:1453
#, fuzzy, no-c-format
msgid "Example: Projected point at 100,000 meters and bearing 45 degrees"
msgstr ""
"Beispiel: verwendet Grad - die Distanz zum Zielpunkt ist 100,000 Meter und "
"die Peilung liegt bei 45 Grad"

#. Tag: programlisting
#: reference_measure.xml:1455
#, no-c-format
msgid ""
"SELECT ST_AsText(ST_Project('POINT(0 0)'::geography, 100000, "
"radians(45.0)));\n"
"\n"
"                 st_astext\n"
"--------------------------------------------\n"
" POINT(0.635231029125537 0.639472334729198)\n"
"(1 row)"
msgstr ""
"SELECT ST_AsText(ST_Project('POINT(0 0)'::geography, 100000, "
"radians(45.0)));\n"
"\n"
"                 st_astext\n"
"--------------------------------------------\n"
" POINT(0.635231029125537 0.639472334729198)\n"
"(1 row)"

#. Tag: para
#: reference_measure.xml:1461
#, fuzzy, no-c-format
msgid ""
", <xref linkend=\"ST_Distance\"/>, <ulink url=\"http://www.postgresql.org/"
"docs/current/interactive/functions-math.html\">PostgreSQL function "
"radians()</ulink>"
msgstr ""
", <xref linkend=\"ST_Distance\"/>, <ulink url=\"http://www.postgresql.org/"
"docs/current/interactive/functions-math.html\">PostgreSQL Math Functions</"
"ulink>"

#. Tag: refname
#: reference_measure.xml:1468
#, no-c-format
msgid "ST_ShortestLine"
msgstr "ST_ShortestLine"

#. Tag: refpurpose
#: reference_measure.xml:1470
#, fuzzy, no-c-format
msgid "Returns the 2D shortest line between two geometries"
msgstr ""
"Gibt die 2-dimenionale kürzeste Strecke zwischen zwei Geometrien als Linie "
"zurück"

#. Tag: funcprototype
#: reference_measure.xml:1475
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_ShortestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_ShortestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1490
#, no-c-format
msgid ""
"Returns the 2-dimensional shortest line between two geometries. The function "
"will only return the first shortest line if more than one, that the function "
"finds. If g1 and g2 intersects in just one point the function will return a "
"line with both start and end in that intersection-point. If g1 and g2 are "
"intersecting with more than one point the function will return a line with "
"start and end in the same point but it can be any of the intersecting "
"points. The line returned will always start in g1 and end in g2. The length "
"of the line this function returns will always be the same as ST_Distance "
"returns for g1 and g2."
msgstr ""
"Gibt den kürzesten 2-dimensionalen Abstand zwischen zwei geometrischen "
"Objekten als Linie zurück. Wenn es mehrere kürzeste Abstände gibt, dann wird "
"nur der erste zurückgegeben, der von der Funktion gefunden wurde. Wenn sich "
"g1 und g2 nur in einem Punkt schneiden, dann gibt die Funktion eine Linie "
"zurück, die ihren Anfang und ihr Ende in dem Schnittpunkt hat. Wenn sich g1 "
"und g2 in mehreren Punkten schneiden, dann gibt die Funktion eine Linie "
"zurück, die Anfang und Ende in irgendeinem der Schnittpunkte hat. Die "
"zurückgegebene Linie beginnt immer mit g1 und endet mit g2. Die Länge der 2D-"
"Linie die von dieser Funktion zurückgegeben wird ist immer gleich der von "
"ST_Distance für g1 und \n"
"g2 zurückgegebenen Distanz."

#. Tag: para
#: reference_measure.xml:1514
#, no-c-format
msgid "Shortest line between point and linestring"
msgstr "Kürzeste Strecke zwischen Punkt und Linienzug"

#. Tag: programlisting
#: reference_measure.xml:1517
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"        ST_ShortestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As sline;\n"
"\n"
"\n"
"   sline\n"
"-----------------\n"
"LINESTRING(100 100,73.0769230769231 115.384615384615)"
msgstr ""
"SELECT ST_AsText(\n"
"        ST_ShortestLine('POINT(100 100)'::geometry,\n"
"                'LINESTRING (20 80, 98 190, 110 180, 50 75 )'::geometry)\n"
"        ) As sline;\n"
"\n"
"\n"
"   sline\n"
"-----------------\n"
"LINESTRING(100 100,73.0769230769231 115.384615384615)"

#. Tag: para
#: reference_measure.xml:1525
#, no-c-format
msgid "shortest line between polygon and polygon"
msgstr "kürzeste Strecke zwischen Polygon und Polygon"

#. Tag: programlisting
#: reference_measure.xml:1528
#, no-c-format
msgid ""
"SELECT ST_AsText(\n"
"                ST_ShortestLine(\n"
"                        ST_GeomFromText('POLYGON((175 150, 20 40, 50 60, 125 "
"100, 175 150))'),\n"
"                        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                        )\n"
"                ) As slinewkt;\n"
"\n"
" LINESTRING(140.752120669087 125.695053378061,121.111404660392 "
"153.370607753949)"
msgstr ""
"SELECT ST_AsText(\n"
"                ST_ShortestLine(\n"
"                        ST_GeomFromText('POLYGON((175 150, 20 40, 50 60, 125 "
"100, 175 150))'),\n"
"                        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)\n"
"                        )\n"
"                ) As slinewkt;\n"
"\n"
" LINESTRING(140.752120669087 125.695053378061,121.111404660392 "
"153.370607753949)"

#. Tag: para
#: reference_measure.xml:1540
#, no-c-format
msgid ""
", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_MaxDistance\"/>"
msgstr ""
", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_LongestLine\"/>, <xref "
"linkend=\"ST_MaxDistance\"/>"

#. Tag: refname
#: reference_measure.xml:1545
#, no-c-format
msgid "ST_3DShortestLine"
msgstr "ST_3DShortestLine"

#. Tag: refpurpose
#: reference_measure.xml:1547
#, fuzzy, no-c-format
msgid "Returns the 3D shortest line between two geometries"
msgstr ""
"Gibt den kürzesten 3-dimensionalen Abstand zwischen zwei geometrischen "
"Objekten als Linie zurück"

#. Tag: funcprototype
#: reference_measure.xml:1552
#, no-c-format
msgid ""
"<funcdef>geometry <function>ST_3DShortestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
msgstr ""
"<funcdef>geometry <function>ST_3DShortestLine</function></funcdef> "
"<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
"<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#. Tag: para
#: reference_measure.xml:1567
#, no-c-format
msgid ""
"Returns the 3-dimensional shortest line between two geometries. The function "
"will only return the first shortest line if more than one, that the function "
"finds. If g1 and g2 intersects in just one point the function will return a "
"line with both start and end in that intersection-point. If g1 and g2 are "
"intersecting with more than one point the function will return a line with "
"start and end in the same point but it can be any of the intersecting "
"points. The line returned will always start in g1 and end in g2. The 3D "
"length of the line this function returns will always be the same as <xref "
"linkend=\"ST_3DDistance\"/> returns for g1 and g2."
msgstr ""
"Gibt den kürzesten 3-dimensionalen Abstand zwischen zwei geometrischen "
"Objekten als Linie zurück. Wenn es mehrere kürzeste Abstände gibt, dann wird "
"nur der erste zurückgegeben, der von der Funktion gefunden wurde. Wenn sich "
"g1 und g2 nur in einem Punkt schneiden, dann gibt die Funktion eine Linie "
"zurück, die ihren Anfang und ihr Ende in dem Schnittpunkt hat. Wenn sich g1 "
"und g2 in mehreren Punkten schneiden, dann gibt die Funktion eine Linie "
"zurück, die Anfang und Ende in irgendeinem der Schnittpunkte hat. Die "
"zurückgegebene Linie beginnt immer mit g1 und endet mit g2. Die Länge der 3D-"
"Linie die von dieser Funktion zurückgegeben wird ist immer ident mit der von "
"<xref linkend=\"ST_3DDistance\"/> für g1 und \n"
"g2 zurückgegebenen Distanz."

#. Tag: para
#: reference_measure.xml:1590
#, no-c-format
msgid "linestring and point -- both 3d and 2d shortest line"
msgstr "Linienzug und Punkt -- kürzester Abstand in 3D und in 2D"

#. Tag: programlisting
#: reference_measure.xml:1591
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DShortestLine(line,pt)) AS shl3d_line_pt,\n"
"                ST_AsEWKT(ST_ShortestLine(line,pt)) As shl2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
" shl3d_line_pt                                                                 "
"|               shl2d_line_pt\n"
"----------------------------------------------------------------------------"
"+------------------------------------------------------\n"
" LINESTRING(54.6993798867619 128.935022917228 11.5475869506606,100 100 30)  "
"| LINESTRING(73.0769230769231 115.384615384615,100 100)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DShortestLine(line,pt)) AS shl3d_line_pt,\n"
"                ST_AsEWKT(ST_ShortestLine(line,pt)) As shl2d_line_pt\n"
"        FROM (SELECT 'POINT(100 100 30)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"1000)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
" shl3d_line_pt                                                                 "
"|               shl2d_line_pt\n"
"----------------------------------------------------------------------------"
"+------------------------------------------------------\n"
" LINESTRING(54.6993798867619 128.935022917228 11.5475869506606,100 100 30)  "
"| LINESTRING(73.0769230769231 115.384615384615,100 100)"

#. Tag: para
#: reference_measure.xml:1595
#, no-c-format
msgid "linestring and multipoint -- both 3d and 2d shortest line"
msgstr "Linienstück und Mehrfachpunkt -- kürzester Abstand in 3D und in 2D"

#. Tag: programlisting
#: reference_measure.xml:1596
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DShortestLine(line,pt)) AS shl3d_line_pt,\n"
"                ST_AsEWKT(ST_ShortestLine(line,pt)) As shl2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"                       shl3d_line_pt                                       | "
"shl2d_line_pt\n"
"---------------------------------------------------------------------------"
"+------------------------\n"
" LINESTRING(54.6993798867619 128.935022917228 11.5475869506606,100 100 30) | "
"LINESTRING(50 75,50 74)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DShortestLine(line,pt)) AS shl3d_line_pt,\n"
"                ST_AsEWKT(ST_ShortestLine(line,pt)) As shl2d_line_pt\n"
"        FROM (SELECT 'MULTIPOINT(100 100 30, 50 74 1000)'::geometry As pt,\n"
"                        'LINESTRING (20 80 20, 98 190 1, 110 180 3, 50 75 "
"900)'::geometry As line\n"
"                ) As foo;\n"
"\n"
"\n"
"                       shl3d_line_pt                                       | "
"shl2d_line_pt\n"
"---------------------------------------------------------------------------"
"+------------------------\n"
" LINESTRING(54.6993798867619 128.935022917228 11.5475869506606,100 100 30) | "
"LINESTRING(50 75,50 74)"

#. Tag: para
#: reference_measure.xml:1600
#, no-c-format
msgid "Multilinestring and polygon both 3d and 2d shortest line"
msgstr "Mehrfachlinienzug und Polygon - kürzester Abstand in 3D und in 2D"

#. Tag: programlisting
#: reference_measure.xml:1601
#, no-c-format
msgid ""
"SELECT ST_AsEWKT(ST_3DShortestLine(poly, mline)) As shl3d,\n"
"    ST_AsEWKT(ST_ShortestLine(poly, mline)) As shl2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"                   shl3d                                                                           "
"|     shl2d\n"
"---------------------------------------------------------------------------------------------------"
"+------------------------\n"
" LINESTRING(39.993580415989 54.1889925532825 5,40.4078575708294 "
"53.6052383805529 5.03423778139177) | LINESTRING(20 40,20 40)"
msgstr ""
"SELECT ST_AsEWKT(ST_3DShortestLine(poly, mline)) As shl3d,\n"
"    ST_AsEWKT(ST_ShortestLine(poly, mline)) As shl2d\n"
"        FROM (SELECT  ST_GeomFromEWKT('POLYGON((175 150 5, 20 40 5, 35 45 5, "
"50 60 5, 100 100 5, 175 150 5))') As poly,\n"
"                ST_GeomFromEWKT('MULTILINESTRING((175 155 2, 20 40 20, 50 60 "
"-2, 125 100 1, 175 155 1),\n"
"                (1 10 2, 5 20 1))') As mline ) As foo;\n"
"                   shl3d                                                                           "
"|     shl2d\n"
"---------------------------------------------------------------------------------------------------"
"+------------------------\n"
" LINESTRING(39.993580415989 54.1889925532825 5,40.4078575708294 "
"53.6052383805529 5.03423778139177) | LINESTRING(20 40,20 40)"

#. Tag: para
#: reference_measure.xml:1613
#, no-c-format
msgid ""
", <xref linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_LongestLine\"/>, "
"<xref linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_3DMaxDistance\"/>"
msgstr ""
", <xref linkend=\"ST_3DDistance\"/>, <xref linkend=\"ST_LongestLine\"/>, "
"<xref linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_3DMaxDistance\"/>"

#, fuzzy
#~ msgid ""
#~ ", <xref linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_3DLongestLine\"/"
#~ ">"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ShortestLine\"/>, <xref linkend=\"ST_LongestLine\"/>"

#~ msgid "Basic furthest distance the point is to any part of the line"
#~ msgstr "Größte Distanz zwischen dem Punkt und irgendeinem Teil der Linie"

#~ msgid "Spatial Relationships and Measurements"
#~ msgstr "Lagevergleiche und Metrik"

#~ msgid "ST_3DDWithin"
#~ msgstr "ST_3DDWithin"

#~ msgid ""
#~ "For 3d (z) geometry type Returns true if two geometries 3d distance is "
#~ "within number of units."
#~ msgstr ""
#~ "Für den geometrischen Datentyp in 3D (z). Gibt TRUE zurück, wenn die 3D-"
#~ "Distanz zwischen zwei geometrischen Objekten innerhalb der gegebenen "
#~ "Einheiten liegt."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_3DDWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance_of_srid</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_3DDWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance_of_srid</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "For geometry type returns true if the 3d distance between two objects is "
#~ "within distance_of_srid specified projected units (spatial ref units)."
#~ msgstr ""
#~ "Für den geometrischen Datentyp. Gibt TRUE zurück, wenn die kürzeste 3-"
#~ "dimensionale Distanz zwischen zwei Objekten innerhalb der in "
#~ "\"distance_of_srid\" gegebenen projizierten Einheiten (Einheiten des "
#~ "Koordinatenreferenzsystem) liegt."

#~ msgid ""
#~ "-- Geometry example - units in meters (SRID: 2163 US National Atlas Equal "
#~ "area) (3D point and line compared 2D point and line)\n"
#~ "-- Note: currently no vertical datum support so Z is not transformed and "
#~ "assumed to be same units as final.\n"
#~ "SELECT ST_3DDWithin(\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-72.1235 42.3521 4)'),2163),\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163),\n"
#~ "                        126.8\n"
#~ "                ) As within_dist_3d,\n"
#~ "ST_DWithin(\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-72.1235 42.3521 4)'),2163),\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163),\n"
#~ "                        126.8\n"
#~ "                ) As within_dist_2d;\n"
#~ "\n"
#~ " within_dist_3d | within_dist_2d\n"
#~ "----------------+----------------\n"
#~ " f              | t"
#~ msgstr ""
#~ "-- Beispiel geometrischer Datentyp - Einheiten in Meter (SRID: 2163 US "
#~ "National Atlas Equal area) (Abstand zwischen Punkt und Linie; Vergleich "
#~ "zwischen 3D und 2D)\n"
#~ "-- Anmerkung: zur Zeit gibt es keine Unterstützung für ein Höhendatum, "
#~ "daher wird Z unverändert übernommen und nicht transformiert.\n"
#~ "SELECT ST_3DDWithin(\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-72.1235 42.3521 4)'),2163),\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163),\n"
#~ "                        126.8\n"
#~ "                ) As within_dist_3d,\n"
#~ "ST_DWithin(\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "POINT(-72.1235 42.3521 4)'),2163),\n"
#~ "                        ST_Transform(ST_GeomFromEWKT('SRID=4326;"
#~ "LINESTRING(-72.1260 42.45 15, -72.123 42.1546 20)'),2163),\n"
#~ "                        126.8\n"
#~ "                ) As within_dist_2d;\n"
#~ "\n"
#~ " within_dist_3d | within_dist_2d\n"
#~ "----------------+----------------\n"
#~ " f              | t"

#~ msgid ""
#~ ", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_DWithin\"/>, <xref "
#~ "linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_Transform\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_DWithin\"/>, <xref "
#~ "linkend=\"ST_3DMaxDistance\"/>, <xref linkend=\"ST_Transform\"/>"

#~ msgid "ST_3DDFullyWithin"
#~ msgstr "ST_3DDFullyWithin"

#~ msgid ""
#~ "Returns true if all of the 3D geometries are within the specified "
#~ "distance of one another."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn sich die gesamte 3D-Geometrie innerhalb einer "
#~ "bestimmten Entfernung zueinander befindet."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_3DDFullyWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance</parameter></"
#~ "paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_3DDFullyWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance</parameter></"
#~ "paramdef>"

#~ msgid ""
#~ "Returns true if the 3D geometries are fully within the specified distance "
#~ "of one another. The distance is specified in units defined by the spatial "
#~ "reference system of the geometries. For this function to make sense, the "
#~ "source geometries must both be of the same coordinate projection, having "
#~ "the same SRID."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn die 3D-Geometrie zur Gänze innerhalb der "
#~ "festgelegten Entfernung zueinander liegt. Die Entfernung wird in den "
#~ "Einheiten des Koordinatenreferenzsystems der Geometrie angegeben. Damit "
#~ "diese Funktion sinnvoll angewendet werden kann, muss die "
#~ "Ausgangsgeometrie die gleiche Projektion und die gleiche SRID haben."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries."
#~ msgstr ""
#~ "Dieser Funktionsaufruf bezieht einen automatischen Lagevergleich der "
#~ "umschreibenden Rechtecke mit ein. Dadurch werden sämtliche Indizes "
#~ "genutzt, die für die geometrischen Objekte vorhanden sind, "

#~ msgid ""
#~ "-- This compares the difference between fully within and distance within "
#~ "as well\n"
#~ "                -- as the distance fully within for the 2D footprint of "
#~ "the line/point vs. the 3d fully within\n"
#~ "                SELECT ST_3DDFullyWithin(geom_a, geom_b, 10) as "
#~ "D3DFullyWithin10, ST_3DDWithin(geom_a, geom_b, 10) as D3DWithin10,\n"
#~ "        ST_DFullyWithin(geom_a, geom_b, 20) as D2DFullyWithin20,\n"
#~ "        ST_3DDFullyWithin(geom_a, geom_b, 20) as D3DFullyWithin20 from\n"
#~ "                (select ST_GeomFromEWKT('POINT(1 1 2)') as geom_a,\n"
#~ "                ST_GeomFromEWKT('LINESTRING(1 5 2, 2 7 20, 1 9 100, 14 12 "
#~ "3)') as geom_b) t1;\n"
#~ " d3dfullywithin10 | d3dwithin10 | d2dfullywithin20 | d3dfullywithin20\n"
#~ "------------------+-------------+------------------+------------------\n"
#~ " f                | t           | t                | f"
#~ msgstr ""
#~ "-- Vergleicht den Unterschied zwischen \"zur Gänze im Inneren\" und "
#~ "\"innerhalb einer Distanz\".\n"
#~ " -- Weiters wird \"zur Gänze innerhalb einer Distanz\" für die 2D "
#~ "Abbildung der Linie/des Punktes gegebenüber \"zur Gänze innerhalb\" in 3D "
#~ "verglichen\n"
#~ "                SELECT ST_3DDFullyWithin(geom_a, geom_b, 10) as "
#~ "D3DFullyWithin10, ST_3DDWithin(geom_a, geom_b, 10) as D3DWithin10,\n"
#~ "        ST_DFullyWithin(geom_a, geom_b, 20) as D2DFullyWithin20,\n"
#~ "        ST_3DDFullyWithin(geom_a, geom_b, 20) as D3DFullyWithin20 from\n"
#~ "                (select ST_GeomFromEWKT('POINT(1 1 2)') as geom_a,\n"
#~ "                ST_GeomFromEWKT('LINESTRING(1 5 2, 2 7 20, 1 9 100, 14 12 "
#~ "3)') as geom_b) t1;\n"
#~ " d3dfullywithin10 | d3dwithin10 | d2dfullywithin20 | d3dfullywithin20\n"
#~ "------------------+-------------+------------------+------------------\n"
#~ " f                | t           | t                | f"

#~ msgid ""
#~ ", <xref linkend=\"ST_3DDWithin\"/>, <xref linkend=\"ST_DWithin\"/>, <xref "
#~ "linkend=\"ST_DFullyWithin\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_3DDWithin\"/>, <xref linkend=\"ST_DWithin\"/>, <xref "
#~ "linkend=\"ST_DFullyWithin\"/>"

#~ msgid "ST_3DIntersects"
#~ msgstr "ST_3DIntersects"

#~ msgid ""
#~ "Returns TRUE if the Geometries \"spatially intersect\" in 3d - only for "
#~ "points, linestrings, polygons, polyhedral surface (area). With SFCGAL "
#~ "backend enabled also supports TINS"
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn sich die geometrischen Objekte in 3D \"räumlich "
#~ "schneiden\" - nur für Punkte, Linienzüge, Polygone und polyedrische "
#~ "Oberflächen (Flächen). Wenn das Back-end \"SFCGAL\" aktiviert ist, werden "
#~ "auch TINs unterstützt"

#~ msgid ""
#~ "<funcdef>boolean <function>ST_3DIntersects</function></funcdef> "
#~ "<paramdef> <type>geometry</type> <parameter>geomA</parameter> </paramdef> "
#~ "<paramdef> <type>geometry</type> <parameter>geomB</parameter> </paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_3DIntersects</function></funcdef> "
#~ "<paramdef> <type>geometry</type> <parameter>geomA</parameter> </paramdef> "
#~ "<paramdef> <type>geometry</type> <parameter>geomB</parameter> </paramdef>"

#~ msgid ""
#~ "Overlaps, Touches, Within all imply spatial intersection. If any of the "
#~ "aforementioned returns true, then the geometries also spatially "
#~ "intersect. Disjoint implies false for spatial intersection."
#~ msgstr ""
#~ "ST_Overlaps, ST_Touches und ST_Within implizieren alle \"räumliches "
#~ "Schneiden\". Wenn irgendeine der genannten Funtionen TRUE zurückgibt, "
#~ "dann schneiden sich die geometrischen Objekte. ST_Disjoint impliziert "
#~ "FALSE für \"räumliches Schneiden\"."

#~ msgid ""
#~ "In order to take advantage of support for TINS, you need to enable the "
#~ "SFCGAL backend. This can be done at session time with: <code>set postgis."
#~ "backend = sfcgal;</code> or at the database or system level. Database "
#~ "level can be done with <code>ALTER DATABASE gisdb SET postgis.backend = "
#~ "sfcgal;</code>."
#~ msgstr ""
#~ "Um die Vorteile der Unterstützung von TINs zu nutzen, müssen Sie das Back-"
#~ "end \"SFCGAL\" aktivieren. Dies kann während einer Sitzung mit <code>set "
#~ "postgis.backend = sfcgal;</code>, sowie auf Datenbank- und auf "
#~ "Systemebene erreicht werden. Auf Datenbankebene mit <code>ALTER DATABASE "
#~ "gisdb SET postgis.backend = sfcgal;</code>."

#~ msgid "&T_support;"
#~ msgstr "&T_support;"

#~ msgid "&sqlmm_compliant; SQL-MM 3: ?"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: ?"

#~ msgid ""
#~ "SELECT ST_3DIntersects(pt, line), ST_Intersects(pt,line)\n"
#~ "        FROM (SELECT 'POINT(0 0 2)'::geometry As pt,\n"
#~ "                'LINESTRING (0 0 1, 0 2 3 )'::geometry As line) As foo;\n"
#~ " st_3dintersects | st_intersects\n"
#~ "-----------------+---------------\n"
#~ " f               | t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_3DIntersects(pt, line), ST_Intersects(pt,line)\n"
#~ "        FROM (SELECT 'POINT(0 0 2)'::geometry As pt,\n"
#~ "                'LINESTRING (0 0 1, 0 2 3 )'::geometry As line) As foo;\n"
#~ " st_3dintersects | st_intersects\n"
#~ "-----------------+---------------\n"
#~ " f               | t\n"
#~ "(1 row)"

#~ msgid "TIN Examples"
#~ msgstr "Beispiele mit TIN"

#~ msgid ""
#~ "set postgis.backend = sfcgal;\n"
#~ "SELECT ST_3DIntersects('TIN(((0 0,1 0,0 1,0 0)))'::geometry, "
#~ "'POINT(.1 .1)'::geometry);\n"
#~ " st_3dintersects\n"
#~ "-----------------\n"
#~ " t"
#~ msgstr ""
#~ "set postgis.backend = sfcgal;\n"
#~ "SELECT ST_3DIntersects('TIN(((0 0,1 0,0 1,0 0)))'::geometry, "
#~ "'POINT(.1 .1)'::geometry);\n"
#~ " st_3dintersects\n"
#~ "-----------------\n"
#~ " t"

#~ msgid ""
#~ "Returns the area of the surface if it is a Polygon or MultiPolygon. For "
#~ "geometry, a 2D Cartesian area is determined with units specified by the "
#~ "SRID. For geography, area is determined on a curved surface with units in "
#~ "square meters."
#~ msgstr ""
#~ "Gibt den Flächeninhalt der Oberfläche von Polygonen oder "
#~ "Mehrfachpolygonen zurück. Beim geometrischen Datentyp wird der "
#~ "kartesische Flächeninhalt in 2D ermittelt und in den Einheiten der SRID "
#~ "ausgegeben. Beim geographischen Datentyp wird der Flächeninhalt auf einer "
#~ "gekrümmten Oberfläche ermittelt und in Quadratmeter ausgegeben."

#~ msgid ""
#~ "SELECT ST_Area(the_geom) As sqft, ST_Area(the_geom)*POWER(0.3048,2) As "
#~ "sqm\n"
#~ "                FROM (SELECT\n"
#~ "                ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,\n"
#~ "                        743265 2967450,743265.625 2967416,743238 "
#~ "2967416))',2249) ) As foo(the_geom);\n"
#~ "  sqft   |     sqm\n"
#~ "---------+-------------\n"
#~ " 928.625 | 86.27208552"
#~ msgstr ""
#~ "SELECT ST_Area(the_geom) As sqft, ST_Area(the_geom)*POWER(0.3048,2) As "
#~ "sqm\n"
#~ "                FROM (SELECT\n"
#~ "                ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,\n"
#~ "                        743265 2967450,743265.625 2967416,743238 "
#~ "2967416))',2249) ) As foo(the_geom);\n"
#~ "  sqft   |     sqm\n"
#~ "---------+-------------\n"
#~ " 928.625 | 86.27208552"

#~ msgid ""
#~ "SELECT ST_Area(the_geom) As sqft, ST_Area(ST_Transform(the_geom,26986)) "
#~ "As sqm\n"
#~ "                FROM (SELECT\n"
#~ "                ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,\n"
#~ "                        743265 2967450,743265.625 2967416,743238 "
#~ "2967416))',2249) ) As foo(the_geom);\n"
#~ "  sqft   |       sqm\n"
#~ "---------+------------------\n"
#~ " 928.625 | 86.2724304199219"
#~ msgstr ""
#~ "SELECT ST_Area(the_geom) As sqft, ST_Area(ST_Transform(the_geom,26986)) "
#~ "As sqm\n"
#~ "                FROM (SELECT\n"
#~ "                ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,\n"
#~ "                        743265 2967450,743265.625 2967416,743238 "
#~ "2967416))',2249) ) As foo(the_geom);\n"
#~ "  sqft   |       sqm\n"
#~ "---------+------------------\n"
#~ " 928.625 | 86.2724304199219"

#~ msgid ""
#~ "SELECT ST_Area(the_geog)/POWER(0.3048,2) As sqft_spheroid,  "
#~ "ST_Area(the_geog,false)/POWER(0.3048,2) As sqft_sphere, ST_Area(the_geog) "
#~ "As sqm_spheroid\n"
#~ "                FROM (SELECT\n"
#~ "                geography(\n"
#~ "                ST_Transform(\n"
#~ "                        ST_GeomFromText('POLYGON((743238 2967416,743238 "
#~ "2967450,743265 2967450,743265.625 2967416,743238 2967416))',\n"
#~ "                                2249\n"
#~ "                                ) ,4326\n"
#~ "                        )\n"
#~ "                )\n"
#~ "        ) As foo(the_geog);\n"
#~ "  sqft_spheroid   |   sqft_sphere    |   sqm_spheroid\n"
#~ "------------------+------------------+------------------\n"
#~ " 928.684403538925 | 927.049336105925 | 86.2776042893529\n"
#~ "\n"
#~ " --if your data is in geography already\n"
#~ " SELECT ST_Area(the_geog)/POWER(0.3048,2) As  sqft, ST_Area(the_geog) As "
#~ "sqm\n"
#~ "        FROM somegeogtable;"
#~ msgstr ""
#~ "SELECT ST_Area(the_geog)/POWER(0.3048,2) As sqft_spheroid,  "
#~ "ST_Area(the_geog,false)/POWER(0.3048,2) As sqft_sphere, ST_Area(the_geog) "
#~ "As sqm_spheroid\n"
#~ "                FROM (SELECT\n"
#~ "                geography(\n"
#~ "                ST_Transform(\n"
#~ "                        ST_GeomFromText('POLYGON((743238 2967416,743238 "
#~ "2967450,743265 2967450,743265.625 2967416,743238 2967416))',\n"
#~ "                                2249\n"
#~ "                                ) ,4326\n"
#~ "                        )\n"
#~ "                )\n"
#~ "        ) As foo(the_geog);\n"
#~ "  sqft_spheroid   |   sqft_sphere    |   sqm_spheroid\n"
#~ "------------------+------------------+------------------\n"
#~ " 928.684403538925 | 927.049336105925 | 86.2776042893529\n"
#~ "\n"
#~ " --if your data is in geography already\n"
#~ " SELECT ST_Area(the_geog)/POWER(0.3048,2) As  sqft, ST_Area(the_geog) As "
#~ "sqm\n"
#~ "        FROM somegeogtable;"

#~ msgid ""
#~ ", <xref linkend=\"ST_GeographyFromText\"/>, <xref linkend=\"ST_SetSRID\"/"
#~ ">, <xref linkend=\"ST_Transform\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_GeographyFromText\"/>, <xref linkend=\"ST_SetSRID\"/"
#~ ">, <xref linkend=\"ST_Transform\"/>"

#~ msgid "ST_Centroid"
#~ msgstr "ST_Centroid"

#~ msgid ""
#~ "<funcprototype> <funcdef>geometry <function>ST_Centroid</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>geography "
#~ "<function>ST_Centroid</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>g1</parameter></paramdef> <paramdef choice=\"opt"
#~ "\"><type>boolean </type> <parameter>use_spheroid=true</parameter></"
#~ "paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>geometry <function>ST_Centroid</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>geography "
#~ "<function>ST_Centroid</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>g1</parameter></paramdef> <paramdef choice=\"opt"
#~ "\"><type>boolean </type> <parameter>use_spheroid=true</parameter></"
#~ "paramdef> </funcprototype>"

#~ msgid ""
#~ "Computes the geometric center of a geometry, or equivalently, the center "
#~ "of mass of the geometry as a <varname>POINT</varname>. For "
#~ "[<varname>MULTI</varname>]<varname>POINT</varname>s, this is computed as "
#~ "the arithmetic mean of the input coordinates. For [<varname>MULTI</"
#~ "varname>]<varname>LINESTRING</varname>s, this is computed as the weighted "
#~ "length of each line segment. For [<varname>MULTI</"
#~ "varname>]<varname>POLYGON</varname>s, \"weight\" is thought in terms of "
#~ "area. If an empty geometry is supplied, an empty "
#~ "<varname>GEOMETRYCOLLECTION</varname> is returned. If <varname>NULL</"
#~ "varname> is supplied, <varname>NULL</varname> is returned. If "
#~ "<varname>CIRCULARSTRING</varname> or <varname>COMPOUNDCURVE</varname> are "
#~ "supplied, they are converted to linestring wtih CurveToLine first, then "
#~ "same than for <varname>LINESTRING</varname>"
#~ msgstr ""
#~ "Berechnet den geometrischen Schwerpunkt einer Geometrie, oder "
#~ "gleichbedeutend den Massenmittelpunkt als <varname>POINT</varname>. Für "
#~ "[<varname>MULTI</varname>]<varname>POINT</varname>s wird er aus dem "
#~ "arithmetischem Mittel der gegebenen Koordinaten berechnet. Für "
#~ "[<varname>MULTI</varname>]<varname>LINESTRING</varname>s wird er aus der "
#~ "gewichteten Länge der Liniensegmente errechnet. Für [<varname>MULTI</"
#~ "varname>]<varname>POLYGON</varname>s wird über den Flächeninhalt "
#~ "gewichtet. Wenn eine leere Geometrie gegeben ist, dann wird eine leere "
#~ "<varname>GEOMETRYCOLLECTION</varname> zurückgegeben. Wenn <varname>NULL</"
#~ "varname> gegeben ist, dann wird <varname>NULL</varname> zurückgegeben. "
#~ "Wenn<varname>CIRCULARSTRING</varname> oder <varname>COMPOUNDCURVE</"
#~ "varname> gegeben sind, dann werden diese zuerst in einen Linienzug "
#~ "umgewandelt und anschließend gleich wie <varname>LINESTRING</varname> "
#~ "behandelt."

#~ msgid ""
#~ "New in 2.3.0 : support <varname>CIRCULARSTRING</varname> and "
#~ "<varname>COMPOUNDCURVE</varname> (using CurveToLine)"
#~ msgstr ""
#~ "Neu in 2.3.0: Unterstützung von <varname>CIRCULARSTRING</varname> und "
#~ "<varname>COMPOUNDCURVE</varname> (verwendet ST_CurveToLine)"

#~ msgid "Availability: 2.4.0 support for geography was introduced."
#~ msgstr ""
#~ "Verfügbarkeit: Mit 2.4.0 wurde die Unterstützung für den geograpischen "
#~ "Datentyp eingeführt."

#~ msgid ""
#~ "The centroid is equal to the centroid of the set of component Geometries "
#~ "of highest dimension (since the lower-dimension geometries contribute "
#~ "zero \"weight\" to the centroid)."
#~ msgstr ""
#~ "Der geometrische Schwerpunkt ist gleich dem geometrischen Schwerpunkt der "
#~ "Geometriekomponenten mit der höchsten Dimension (da die niedrigeren "
#~ "Dimensionen der Geometrie nicht zur Gewichtung des Schwerpunktes "
#~ "beitragen)."

#~ msgid "&sqlmm_compliant; SQL-MM 3: 8.1.4, 9.5.5"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 8.1.4, 9.5.5"

#~ msgid ""
#~ "In each of the following illustrations, the green dot represents the "
#~ "centroid of the source geometry."
#~ msgstr ""
#~ "In den folgenden Darstellungen repräsentiert der grüne Punkt den "
#~ "geometrischen Schwerpunkt der Ausgangsgeometrie."

#~ msgid "Centroid of a <varname>MULTIPOINT</varname>"
#~ msgstr "Geometrischer Schwerpunkt eines <varname>MULTIPOINT</varname>"

#~ msgid "Centroid of a <varname>LINESTRING</varname>"
#~ msgstr "Geometrischer Schwerpunkt eines <varname>LINESTRING</varname>"

#~ msgid "Centroid of a <varname>POLYGON</varname>"
#~ msgstr "Geometrischer Schwerpunkt eines <varname>POLYGON</varname>"

#~ msgid "Centroid of a <varname>GEOMETRYCOLLECTION</varname>"
#~ msgstr ""
#~ "Der geometrische Schwerpunkt einer <varname>GEOMETRYCOLLECTION</varname>"

#~ msgid ""
#~ "SELECT ST_AsText(ST_Centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, "
#~ "0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'));\n"
#~ "                                st_astext\n"
#~ "------------------------------------------\n"
#~ " POINT(2.30769230769231 3.30769230769231)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_centroid(g))\n"
#~ "FROM  ST_GeomFromText('CIRCULARSTRING(0 2, -1 1,0 0, 0.5 0, 1 0, 2 1, 1 "
#~ "2, 0.5 2, 0 2)')  AS g ;\n"
#~ "------------------------------------------\n"
#~ "POINT(0.5 1)\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_centroid(g))\n"
#~ "FROM  ST_GeomFromText('COMPOUNDCURVE(CIRCULARSTRING(0 2, -1 1,0 0),(0 0, "
#~ "0.5 0, 1 0),CIRCULARSTRING( 1 0, 2 1, 1 2),(1 2, 0.5 2, 0 2))' ) AS g;\n"
#~ "------------------------------------------\n"
#~ "POINT(0.5 1)"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_Centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, "
#~ "0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'));\n"
#~ "                                st_astext\n"
#~ "------------------------------------------\n"
#~ " POINT(2.30769230769231 3.30769230769231)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_centroid(g))\n"
#~ "FROM  ST_GeomFromText('CIRCULARSTRING(0 2, -1 1,0 0, 0.5 0, 1 0, 2 1, 1 "
#~ "2, 0.5 2, 0 2)')  AS g ;\n"
#~ "------------------------------------------\n"
#~ "POINT(0.5 1)\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_centroid(g))\n"
#~ "FROM  ST_GeomFromText('COMPOUNDCURVE(CIRCULARSTRING(0 2, -1 1,0 0),(0 0, "
#~ "0.5 0, 1 0),CIRCULARSTRING( 1 0, 2 1, 1 2),(1 2, 0.5 2, 0 2))' ) AS g;\n"
#~ "------------------------------------------\n"
#~ "POINT(0.5 1)"

#~ msgid ", <xref linkend=\"ST_GeometricMedian\"/>"
#~ msgstr ", <xref linkend=\"ST_GeometricMedian\"/>"

#~ msgid ""
#~ "<refpurpose>Returns the 2-dimensional point on g1 that is closest to g2. "
#~ "This is the first point of the shortest line.</refpurpose>"
#~ msgstr ""
#~ "<refpurpose>Gibt den 2-dimensionalen Punkt auf g1 zurück, der den "
#~ "geringsten Abstand zu g2 hat. Dies ist der Anfangspunkt der Linie mit dem "
#~ "kürzesten Abstand.</refpurpose>"

#~ msgid ""
#~ "<para>Returns the 2-dimensional point on g1 that is closest to g2. This "
#~ "is the first point of the shortest line.</para>"
#~ msgstr ""
#~ "<para>Gibt den 2-dimensionalen Punkt auf g1 zurück, der den geringsten "
#~ "Abstand zu g2 hat. Dies ist der Anfangspunkt der Linie mit dem kürzesten "
#~ "Abstand.</para>"

#~ msgid "ST_ClusterDBSCAN"
#~ msgstr "ST_ClusterDBSCAN"

#~ msgid ""
#~ "Windowing function that returns integer id for the cluster each input "
#~ "geometry is in based on 2D implementation of Density-based spatial "
#~ "clustering of applications with noise (DBSCAN) algorithm."
#~ msgstr ""
#~ "Eine \"Window Function\" welche die ganzzahlige \"id\" des Clusters "
#~ "zurückgibt in dem sich die gegebenen Geometrie befindet; diese Zuweisung "
#~ "basiert auf einer Implementierung des DBSCAN (Density-Based Spatial "
#~ "Clustering of Applications with Noise) Algorithmus in 2D."

#~ msgid ""
#~ "<funcdef>integer <function>ST_ClusterDBSCAN</function></funcdef> "
#~ "<paramdef><type>geometry winset </type> <parameter>geom</parameter></"
#~ "paramdef> <paramdef><type>float8 </type> <parameter>eps</parameter></"
#~ "paramdef> <paramdef><type>integer </type> <parameter>minpoints</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>integer <function>ST_ClusterDBSCAN</function></funcdef> "
#~ "<paramdef><type>geometry winset </type> <parameter>geom</parameter></"
#~ "paramdef> <paramdef><type>float8 </type> <parameter>eps</parameter></"
#~ "paramdef> <paramdef><type>integer </type> <parameter>minpoints</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "Returns cluster number for each input geometry, based on a 2D "
#~ "implementation of the <ulink url=\"https://en.wikipedia.org/wiki/DBSCAN"
#~ "\">Density-based spatial clustering of applications with noise (DBSCAN)</"
#~ "ulink> algorithm. Unlike <xref linkend=\"ST_ClusterKMeans\"/>, it does "
#~ "not require the number of clusters to be specified, but instead uses the "
#~ "desired <link linkend=\"ST_Distance\">distance</link> (<varname>eps</"
#~ "varname>) and density (<varname>minpoints</varname>) parameters to "
#~ "construct each cluster."
#~ msgstr ""
#~ "Basierend auf einer 2D-Implementierung des <ulink url=\"https://en."
#~ "wikipedia.org/wiki/DBSCAN\">Density-based spatial clustering of "
#~ "applications with noise (DBSCAN)</ulink> Algorithmus wird jeder gegebenen "
#~ "Geometrie eine Clusternummer zugewiesen. Im Unterschied zu <xref linkend="
#~ "\"ST_ClusterKMeans\"/> muss die Anzahl der Cluster nicht festgelegt "
#~ "werden; stattdessen werden die Parameter für die gewünschte <link linkend="
#~ "\"ST_Distance\"> Distanz </link> (<varname>eps</varname>) und die Dichte "
#~ "(<varname>minpoints</varname>) verwendet um die Cluster zu konstruieren."

#~ msgid "An input geometry will be added to a cluster if it is either:"
#~ msgstr ""
#~ "Eine gegebene Geometrie wird zu einem Cluster hinzugefügt wenn sie "
#~ "entweder:"

#~ msgid ""
#~ "A \"core\" geometry, that is within <varname>eps</varname> <link linkend="
#~ "\"ST_Distance\">distance</link> of at least <varname>minpoints</varname> "
#~ "input geometries (including itself) or"
#~ msgstr ""
#~ "Eine \"Kerngeometrie\" ist; d.h. innerhalb einer <link linkend="
#~ "\"ST_Distance\">Entfernung</link> von <varname>eps</varname> zu "
#~ "mindestens <varname>minpoints</varname> geometrischen Objekten (inklusive "
#~ "der Kerngeometrie selbst) liegt,\n"
#~ "oder"

#~ msgid ""
#~ "A \"border\" geometry, that is within <varname>eps</varname> <link "
#~ "linkend=\"ST_Distance\">distance</link> of a core geometry."
#~ msgstr ""
#~ "Eine \"Randgeometrie\" ist;  d.h. die <link linkend=\"ST_Distance"
#~ "\">Entfernung</link> zu einer Kerngeometrie innerhalb von <varname>eps</"
#~ "varname> liegt."

#~ msgid ""
#~ "Note that border geometries may be within <varname>eps</varname> distance "
#~ "of core geometries in more than one cluster; in this case, either "
#~ "assignment would be correct, and the border geometry will be arbitrarily "
#~ "asssigned to one of the available clusters. In these cases, it is "
#~ "possible for a correct cluster to be generated with fewer than "
#~ "<varname>minpoints</varname> geometries. When assignment of a border "
#~ "geometry is ambiguous, repeated calls to ST_ClusterDBSCAN will produce "
#~ "identical results if an ORDER BY clause is included in the window "
#~ "definition, but cluster assignments may differ from other implementations "
#~ "of the same algorithm."
#~ msgstr ""
#~ "Beachten Sie, dass die Grenzen einer Geometrie innerhalb der Entfernung "
#~ "<varname>eps</varname> von der eigentlichen Geometrie liegen und sich so "
#~ "in mehreren Clustern befinden kann; in diesem Fall ist jede Zuweisung "
#~ "richtig und die Grenzen der Geometrie werden willkürlich einem der "
#~ "verfügbaren Cluster zugewiesen. Dabei ist es möglich, dass ein korrekter "
#~ "Cluster aus weniger Geoobjekten erzeugt wird, als durch "
#~ "<varname>minpoints</varname> angegeben ist. Wenn die Zuweisung einer "
#~ "Geometriegrenze nicht eindeutig ist, dann können wiederholte Aufrufe an "
#~ "ST_ClusterDBSCAN dennoch identische Ergebnisse erzeugen falls eine ORDER "
#~ "BY Klausel in die Definition der Window-Funktion eingefügt wurde; die "
#~ "Zuweisung zu den Clustern kann sich allerdings bei anderen "
#~ "Implementierungen des gleichen Algorithmus unterscheiden."

#~ msgid ""
#~ "Input geometries that do not meet the criteria to join any other cluster "
#~ "will be assigned a cluster number of NULL."
#~ msgstr ""
#~ "Wenn eine gegebene Geometrie die Kriterien zur Vereinigung mit einem "
#~ "anderen Cluster nicht erfüllt, dann wird ihr die Clusternummer NULL "
#~ "zugewiesen."

#~ msgid "Availability: 2.3.0 - requires GEOS"
#~ msgstr "Verfügbarkeit: 2.3.0 - benötigt GEOS"

#~ msgid ""
#~ "Assigning a cluster number to each polygon within 50 meters of each "
#~ "other. Require at least 2 polygons per cluster"
#~ msgstr ""
#~ "Polygonen die innerhalb von 50 Meter zueinander liegen eine Clusternummer "
#~ "zuweisen. Pro Cluster werden mindestens 2 Polygone benötigt."

#~ msgid ""
#~ "within 50 meters at least 2 per cluster. singletons have NULL for cid"
#~ msgstr ""
#~ "innerhalb von 50 Meter - mindestens 2  pro Cluster. Bei einelementigen "
#~ "Mengen ist die cid NULL"

#~ msgid ""
#~ "SELECT name, ST_ClusterDBSCAN(geom, eps := 50, minpoints := 2) over () AS "
#~ "cid\n"
#~ "FROM boston_polys\n"
#~ "WHERE name > '' AND building > ''\n"
#~ "        AND ST_DWithin(geom,\n"
#~ "        ST_Transform(\n"
#~ "            ST_GeomFromText('POINT(-71.04054 42.35141)', 4326), 26986),\n"
#~ "           500);"
#~ msgstr ""
#~ "SELECT name, ST_ClusterDBSCAN(geom, eps := 50, minpoints := 2) over () AS "
#~ "cid\n"
#~ "FROM boston_polys\n"
#~ "WHERE name > '' AND building > ''\n"
#~ "        AND ST_DWithin(geom,\n"
#~ "        ST_Transform(\n"
#~ "            ST_GeomFromText('POINT(-71.04054 42.35141)', 4326), 26986),\n"
#~ "           500);"

#~ msgid ""
#~ "<![CDATA[                name                 | bucket\n"
#~ "-------------------------------------+--------\n"
#~ " Manulife Tower                      |      0\n"
#~ " Park Lane Seaport I                 |      0\n"
#~ " Park Lane Seaport II                |      0\n"
#~ " Renaissance Boston Waterfront Hotel |      0\n"
#~ " Seaport Boston Hotel                |      0\n"
#~ " Seaport Hotel & World Trade Center  |      0\n"
#~ " Waterside Place                     |      0\n"
#~ " World Trade Center East             |      0\n"
#~ " 100 Northern Avenue                 |      1\n"
#~ " 100 Pier 4                          |      1\n"
#~ " The Institute of Contemporary Art   |      1\n"
#~ " 101 Seaport                         |      2\n"
#~ " District Hall                       |      2\n"
#~ " One Marina Park Drive               |      2\n"
#~ " Twenty Two Liberty                  |      2\n"
#~ " Vertex                              |      2\n"
#~ " Vertex                              |      2\n"
#~ " Watermark Seaport                   |      2\n"
#~ " Blue Hills Bank Pavilion            |   NULL\n"
#~ " World Trade Center West             |   NULL\n"
#~ "(20 rows)]]>"
#~ msgstr ""
#~ "<![CDATA[                name                 | bucket\n"
#~ "-------------------------------------+--------\n"
#~ " Manulife Tower                      |      0\n"
#~ " Park Lane Seaport I                 |      0\n"
#~ " Park Lane Seaport II                |      0\n"
#~ " Renaissance Boston Waterfront Hotel |      0\n"
#~ " Seaport Boston Hotel                |      0\n"
#~ " Seaport Hotel & World Trade Center  |      0\n"
#~ " Waterside Place                     |      0\n"
#~ " World Trade Center East             |      0\n"
#~ " 100 Northern Avenue                 |      1\n"
#~ " 100 Pier 4                          |      1\n"
#~ " The Institute of Contemporary Art   |      1\n"
#~ " 101 Seaport                         |      2\n"
#~ " District Hall                       |      2\n"
#~ " One Marina Park Drive               |      2\n"
#~ " Twenty Two Liberty                  |      2\n"
#~ " Vertex                              |      2\n"
#~ " Vertex                              |      2\n"
#~ " Watermark Seaport                   |      2\n"
#~ " Blue Hills Bank Pavilion            |   NULL\n"
#~ " World Trade Center West             |   NULL\n"
#~ "(20 rows)]]>"

#~ msgid ""
#~ "Combining parcels with the same cluster number into a single geometry. "
#~ "This uses named argument calling"
#~ msgstr ""
#~ "Grundstücke mit gleicher Clusternummer werden in einer Einzelgeometrie "
#~ "kombiniert. Der Aufruf erfolgt über Schlüsselwortparameter"

#~ msgid ""
#~ "SELECT cid, ST_Collect(geom) AS cluster_geom, array_agg(parcel_id) AS "
#~ "ids_in_cluster FROM (\n"
#~ "    SELECT parcel_id, ST_ClusterDBSCAN(geom, eps := 0.5, minpoints := 5) "
#~ "over () AS cid, geom\n"
#~ "    FROM parcels) sq\n"
#~ "GROUP BY cid;"
#~ msgstr ""
#~ "SELECT cid, ST_Collect(geom) AS cluster_geom, array_agg(parcel_id) AS "
#~ "ids_in_cluster FROM (\n"
#~ "    SELECT parcel_id, ST_ClusterDBSCAN(geom, eps := 0.5, minpoints := 5) "
#~ "over () AS cid, geom\n"
#~ "    FROM parcels) sq\n"
#~ "GROUP BY cid;"

#~ msgid ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend="
#~ "\"ST_ClusterIntersecting\"/>, <xref linkend=\"ST_ClusterWithin\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend="
#~ "\"ST_ClusterIntersecting\"/>, <xref linkend=\"ST_ClusterWithin\"/>"

#~ msgid "ST_ClusterIntersecting"
#~ msgstr "ST_ClusterIntersecting"

#~ msgid ""
#~ "Aggregate. Returns an array with the connected components of a set of "
#~ "geometries"
#~ msgstr ""
#~ "Aggregatfunktion. Gibt ein Feld mit zusammengefassten "
#~ "Geometriekomponenten zurück."

#~ msgid ""
#~ "<funcdef>geometry[] <function>ST_ClusterIntersecting</function></funcdef> "
#~ "<paramdef><type>geometry set</type> <parameter>g</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry[] <function>ST_ClusterIntersecting</function></funcdef> "
#~ "<paramdef><type>geometry set</type> <parameter>g</parameter></paramdef>"

#~ msgid ""
#~ "ST_ClusterIntersecting is an aggregate function that returns an array of "
#~ "GeometryCollections, where each GeometryCollection represents an "
#~ "interconnected set of geometries."
#~ msgstr ""
#~ "ST_ClusterIntersecting ist eine Aggregatfunktion, die ein Feld mit "
#~ "GeometryCollections zurückgibt. Jede GeometryCollection (Sammelgeometrie) "
#~ "besteht aus den Komponenten der Geometrie, die untereinander verbundenen "
#~ "sind."

#~ msgid "Availability: 2.2.0 - requires GEOS"
#~ msgstr "Verfügbarkeit: 2.2.0 - benötigt GEOS"

#~ msgid ""
#~ "WITH testdata AS\n"
#~ "  (SELECT unnest(ARRAY['LINESTRING (0 0, 1 1)'::geometry,\n"
#~ "                       'LINESTRING (5 5, 4 4)'::geometry,\n"
#~ "                       'LINESTRING (6 6, 7 7)'::geometry,\n"
#~ "                       'LINESTRING (0 0, -1 -1)'::geometry,\n"
#~ "                       'POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))'::geometry]) "
#~ "AS geom)\n"
#~ "\n"
#~ "SELECT ST_AsText(unnest(ST_ClusterIntersecting(geom))) FROM testdata;\n"
#~ "\n"
#~ "--result\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(0 0,1 1),LINESTRING(5 5,4 4),LINESTRING(0 "
#~ "0,-1 -1),POLYGON((0 0,4 0,4 4,0 4,0 0)))\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(6 6,7 7))"
#~ msgstr ""
#~ "WITH testdata AS\n"
#~ "  (SELECT unnest(ARRAY['LINESTRING (0 0, 1 1)'::geometry,\n"
#~ "                       'LINESTRING (5 5, 4 4)'::geometry,\n"
#~ "                       'LINESTRING (6 6, 7 7)'::geometry,\n"
#~ "                       'LINESTRING (0 0, -1 -1)'::geometry,\n"
#~ "                       'POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))'::geometry]) "
#~ "AS geom)\n"
#~ "\n"
#~ "SELECT ST_AsText(unnest(ST_ClusterIntersecting(geom))) FROM testdata;\n"
#~ "\n"
#~ "--result\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(0 0,1 1),LINESTRING(5 5,4 4),LINESTRING(0 "
#~ "0,-1 -1),POLYGON((0 0,4 0,4 4,0 4,0 0)))\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(6 6,7 7))"

#~ msgid ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend=\"ST_ClusterWithin"
#~ "\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend=\"ST_ClusterWithin"
#~ "\"/>"

#~ msgid "ST_ClusterKMeans"
#~ msgstr "ST_ClusterKMeans"

#~ msgid ""
#~ "Windowing function that returns integer id for the cluster each input "
#~ "geometry is in."
#~ msgstr ""
#~ "Eine \"Window Function\" welche die ganzzahlige \"id\" des Clusters "
#~ "zurückgibt, in dem sich die gegebenen Geometrie befindet."

#~ msgid ""
#~ "<funcdef>integer <function>ST_ClusterKMeans</function></funcdef> "
#~ "<paramdef><type>geometry winset </type> <parameter>geom</parameter></"
#~ "paramdef> <paramdef><type>integer </type> <parameter>number_of_clusters</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>integer <function>ST_ClusterKMeans</function></funcdef> "
#~ "<paramdef><type>geometry winset </type> <parameter>geom</parameter></"
#~ "paramdef> <paramdef><type>integer </type> <parameter>number_of_clusters</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "Returns 2D distance based <ulink url=\"https://en.wikipedia.org/wiki/K-"
#~ "means_clustering\">k-means</ulink> cluster number for each input "
#~ "geometry. The distance used for clustering is the distance between the "
#~ "centroids of the geometries."
#~ msgstr ""
#~ "Für jedes gegebene geometrische Objekt wird die auf der 2D-Distanz "
#~ "basierende <ulink url=\"https://en.wikipedia.org/wiki/K-means_clustering"
#~ "\">k-means</ulink> Custernummer zurückgegeben. Die bei der Clusteranalyse "
#~ "verwendete Distanz entspricht der Entfernung der Schwerpunkte der "
#~ "geometrischen Objekte."

#~ msgid "Generate dummy set of parcels for examples"
#~ msgstr "Erstellung von Pseudogrundstücken für die Beispiele"

#~ msgid ""
#~ "CREATE TABLE parcels AS\n"
#~ "SELECT lpad((row_number() over())::text,3,'0') As parcel_id, geom,\n"
#~ "('{residential, commercial}'::text[])[1 + mod(row_number()OVER(),2)] As "
#~ "type\n"
#~ "FROM\n"
#~ "    ST_Subdivide(ST_Buffer('LINESTRING(40 100, 98 100, 100 150, 60 90)'::"
#~ "geometry,\n"
#~ "    40, 'endcap=square'),12) As geom;"
#~ msgstr ""
#~ "CREATE TABLE parcels AS\n"
#~ "SELECT lpad((row_number() over())::text,3,'0') As parcel_id, geom,\n"
#~ "('{residential, commercial}'::text[])[1 + mod(row_number()OVER(),2)] As "
#~ "type\n"
#~ "FROM\n"
#~ "    ST_Subdivide(ST_Buffer('LINESTRING(40 100, 98 100, 100 150, 60 90)'::"
#~ "geometry,\n"
#~ "    40, 'endcap=square'),12) As geom;"

#~ msgid "Original Parcels"
#~ msgstr "Ursprüngliche Grundstücke"

#~ msgid "Parcels color-coded by cluster number (cid)"
#~ msgstr "Grundstücke nach der Clusternummer (cid) eingefärbt"

#~ msgid ""
#~ "SELECT ST_ClusterKMeans(geom, 5) OVER() AS cid, parcel_id, geom\n"
#~ "FROM parcels;\n"
#~ "-- result\n"
#~ " cid | parcel_id |   geom\n"
#~ "-----+-----------+---------------\n"
#~ "   0 | 001       | 0103000000...\n"
#~ "   0 | 002       | 0103000000...\n"
#~ "   1 | 003       | 0103000000...\n"
#~ "   0 | 004       | 0103000000...\n"
#~ "   1 | 005       | 0103000000...\n"
#~ "   2 | 006       | 0103000000...\n"
#~ "   2 | 007       | 0103000000...\n"
#~ "(7 rows)"
#~ msgstr ""
#~ "SELECT ST_ClusterKMeans(geom, 5) OVER() AS cid, parcel_id, geom\n"
#~ "FROM parcels;\n"
#~ "-- result\n"
#~ " cid | parcel_id |   geom\n"
#~ "-----+-----------+---------------\n"
#~ "   0 | 001       | 0103000000...\n"
#~ "   0 | 002       | 0103000000...\n"
#~ "   1 | 003       | 0103000000...\n"
#~ "   0 | 004       | 0103000000...\n"
#~ "   1 | 005       | 0103000000...\n"
#~ "   2 | 006       | 0103000000...\n"
#~ "   2 | 007       | 0103000000...\n"
#~ "(7 rows)"

#~ msgid ""
#~ "-- Partitioning parcel clusters by type\n"
#~ "SELECT ST_ClusterKMeans(geom,3) over (PARTITION BY type) AS cid, "
#~ "parcel_id, type\n"
#~ "FROM parcels;\n"
#~ "-- result\n"
#~ " cid | parcel_id |    type\n"
#~ "-----+-----------+-------------\n"
#~ "   1 | 005       | commercial\n"
#~ "   1 | 003       | commercial\n"
#~ "   2 | 007       | commercial\n"
#~ "   0 | 001       | commercial\n"
#~ "   1 | 004       | residential\n"
#~ "   0 | 002       | residential\n"
#~ "   2 | 006       | residential\n"
#~ "(7 rows)"
#~ msgstr ""
#~ "-- Partitionieren des Grundstückclusters nach \"type\"\n"
#~ "SELECT ST_ClusterKMeans(geom,3) over (PARTITION BY type) AS cid, "
#~ "parcel_id, type\n"
#~ "FROM parcels;\n"
#~ "-- result\n"
#~ " cid | parcel_id |    type\n"
#~ "-----+-----------+-------------\n"
#~ "   1 | 005       | commercial\n"
#~ "   1 | 003       | commercial\n"
#~ "   2 | 007       | commercial\n"
#~ "   0 | 001       | commercial\n"
#~ "   1 | 004       | residential\n"
#~ "   0 | 002       | residential\n"
#~ "   2 | 006       | residential\n"
#~ "(7 rows)"

#~ msgid ""
#~ ", <xref linkend=\"ST_ClusterIntersecting\"/>, <xref linkend="
#~ "\"ST_ClusterWithin\"/>, <xref linkend=\"ST_Subdivide\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ClusterIntersecting\"/>, <xref linkend="
#~ "\"ST_ClusterWithin\"/>, <xref linkend=\"ST_Subdivide\"/>"

#~ msgid "ST_ClusterWithin"
#~ msgstr "ST_ClusterWithin"

#~ msgid ""
#~ "Aggregate. Returns an array of GeometryCollections, where each "
#~ "GeometryCollection represents a set of geometries separated by no more "
#~ "than the specified distance."
#~ msgstr ""
#~ "Aggregatfunktion. Gibt ein Feld mit GeometryCollections zurück. Jede "
#~ "GeometryCollection besteht aus den Komponenten der Geometrie, die nicht "
#~ "weiter als die gegebene Distanz voneinander entfernt sind."

#~ msgid ""
#~ "<funcdef>geometry[] <function>ST_ClusterWithin</function></funcdef> "
#~ "<paramdef><type>geometry set </type> <parameter>g</parameter></paramdef> "
#~ "<paramdef><type>float8 </type> <parameter>distance</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry[] <function>ST_ClusterWithin</function></funcdef> "
#~ "<paramdef><type>geometry set </type> <parameter>g</parameter></paramdef> "
#~ "<paramdef><type>float8 </type> <parameter>distance</parameter></paramdef>"

#~ msgid ""
#~ "ST_ClusterWithin is an aggregate function that returns an array of "
#~ "GeometryCollections, where each GeometryCollection represents a set of "
#~ "geometries separated by no more than the specified distance. (Distances "
#~ "are Cartesian distances in the units of the SRID.)"
#~ msgstr ""
#~ "ST_ClusterWithin ist eine Aggregatfunktion, die ein Feld mit "
#~ "GeometryCollections zurückgibt. Jede GeometryCollection (Sammelgeometrie) "
#~ "besteht aus den Komponenten der Geometrie, die nicht weiter als die "
#~ "gegebene Distanz voneinander entfernt sind. (Distanzen sind kartesische "
#~ "Distanzen in den Einheiten der SRID.)"

#~ msgid ""
#~ "WITH testdata AS\n"
#~ "  (SELECT unnest(ARRAY['LINESTRING (0 0, 1 1)'::geometry,\n"
#~ "                       'LINESTRING (5 5, 4 4)'::geometry,\n"
#~ "                       'LINESTRING (6 6, 7 7)'::geometry,\n"
#~ "                       'LINESTRING (0 0, -1 -1)'::geometry,\n"
#~ "                       'POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))'::geometry]) "
#~ "AS geom)\n"
#~ "\n"
#~ "SELECT ST_AsText(unnest(ST_ClusterWithin(geom, 1.4))) FROM testdata;\n"
#~ "\n"
#~ "--result\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(0 0,1 1),LINESTRING(5 5,4 4),LINESTRING(0 "
#~ "0,-1 -1),POLYGON((0 0,4 0,4 4,0 4,0 0)))\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(6 6,7 7))"
#~ msgstr ""
#~ "WITH testdata AS\n"
#~ "  (SELECT unnest(ARRAY['LINESTRING (0 0, 1 1)'::geometry,\n"
#~ "                       'LINESTRING (5 5, 4 4)'::geometry,\n"
#~ "                       'LINESTRING (6 6, 7 7)'::geometry,\n"
#~ "                       'LINESTRING (0 0, -1 -1)'::geometry,\n"
#~ "                       'POLYGON ((0 0, 4 0, 4 4, 0 4, 0 0))'::geometry]) "
#~ "AS geom)\n"
#~ "\n"
#~ "SELECT ST_AsText(unnest(ST_ClusterWithin(geom, 1.4))) FROM testdata;\n"
#~ "\n"
#~ "--result\n"
#~ "\n"
#~ "st_astext\n"
#~ "---------\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(0 0,1 1),LINESTRING(5 5,4 4),LINESTRING(0 "
#~ "0,-1 -1),POLYGON((0 0,4 0,4 4,0 4,0 0)))\n"
#~ "GEOMETRYCOLLECTION(LINESTRING(6 6,7 7))"

#~ msgid ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend="
#~ "\"ST_ClusterIntersecting\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ClusterKMeans\"/>, <xref linkend="
#~ "\"ST_ClusterIntersecting\"/>"

#~ msgid "ST_Contains"
#~ msgstr "ST_Contains"

#~ msgid ""
#~ "Returns true if and only if no points of B lie in the exterior of A, and "
#~ "at least one point of the interior of B lies in the interior of A."
#~ msgstr ""
#~ "Gibt dann und nur dann  TRUE zurück, wenn kein Punkt von B im Äußeren von "
#~ "A liegt und zumindest ein Punkt im Inneren von B auch im Inneren von A "
#~ "liegt."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Contains</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Contains</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#~ msgid ""
#~ "Geometry A contains Geometry B if and only if no points of B lie in the "
#~ "exterior of A, and at least one point of the interior of B lies in the "
#~ "interior of A. An important subtlety of this definition is that A does "
#~ "not contain its boundary, but A does contain itself. Contrast that to "
#~ "<xref linkend=\"ST_ContainsProperly\"/> where geometry A does not Contain "
#~ "Properly itself."
#~ msgstr ""
#~ "Geometrie A enthält Geometrie B dann und nur dann, wenn kein Punkt von B "
#~ "im Äußeren von A liegt und zumindest ein Punkt im Inneren von B auch im "
#~ "Inneren von A liegt. Eine wesentliche Feinheit dieser Definition ist, "
#~ "dass A zwar nicht seine Begrenzung, aber sich selbst enthält. Vergleichen "
#~ "Sie dazu bitte <xref linkend=\"ST_ContainsProperly\"/>, wo sich die "
#~ "Geometrie A nicht zur Gänze selbst enthält."

#~ msgid ""
#~ "Returns TRUE if geometry B is completely inside geometry A. For this "
#~ "function to make sense, the source geometries must both be of the same "
#~ "coordinate projection, having the same SRID. ST_Contains is the inverse "
#~ "of ST_Within. So ST_Contains(A,B) implies ST_Within(B,A) except in the "
#~ "case of invalid geometries where the result is always false regardless or "
#~ "not defined."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn die Geometrie B zur Gänze im Inneren von Geometrie "
#~ "A liegt. Damit diese Funktion sinnvoll angewendet werden kann, muss die "
#~ "Geometrie von A und B sowohl im gleichen Koordinatenreferenzsystem "
#~ "vorliegen als auch die selbe SRID aufweisen. ST_Contains ist die inverse "
#~ "Funktion von ST_Within. ST_Contains(A,B) impliziert somit ST_Within(B,A); "
#~ "außer im Falle einer invaliden Geometrie, wo das Ergebnis immer FALSE "
#~ "oder unbestimmt ist. "

#~ msgid ""
#~ "Enhanced: 2.3.0 Enhancement to PIP short-circuit extended to support "
#~ "MultiPoints with few points. Prior versions only supported point in "
#~ "polygon."
#~ msgstr ""
#~ "Erweiterung: 2.3.0 Die Kurzschlussauswertung für den Punkt-in-Polygon-"
#~ "Test wurde erweitert, um MultiPoints mit wenigen Punkten zu unterstützen. "
#~ "Vorgängerversionen unterstützten nur Punkt in Polygon."

#~ msgid ""
#~ "Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument"
#~ msgstr ""
#~ "Bitte nicht mit einer <varname>GEOMETRYCOLLECTION</varname> als "
#~ "Übergabewert aufrufen"

#~ msgid ""
#~ "Do not use this function with invalid geometries. You will get unexpected "
#~ "results."
#~ msgstr ""
#~ "Verwenden Sie diese Funktion bitte nicht mit invaliden Geometrie. Sie "
#~ "würden unerwartete Ergebnisse bekommen."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_Contains."
#~ msgstr ""
#~ "Dieser Funktionsaufruf schließt einen Lagevergleich der umschreibenden "
#~ "Rechtecke mit ein, wodurch sämtlichen verfügbaren Indizes der Geometrie "
#~ "genutzt werden. Um die Verwendung von Indizes zu verhindern, benutzen Sie "
#~ "bitte _ST_Contains."

#~ msgid ""
#~ "NOTE: this is the \"allowable\" version that returns a boolean, not an "
#~ "integer."
#~ msgstr ""
#~ "Anmerkung: dies ist die \"erlaubende\" Version, welche einen booleschen "
#~ "Wert und keine Ganzzahl zurückgibt."

#~ msgid ""
#~ "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - same as within(geometry B, "
#~ "geometry A)"
#~ msgstr ""
#~ "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - ident mit within(geometry B, "
#~ "geometry A)"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.31"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.31"

#~ msgid ""
#~ "There are certain subtleties to ST_Contains and ST_Within that are not "
#~ "intuitively obvious. For details check out <ulink url=\"http://lin-ear-th-"
#~ "inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html"
#~ "\">Subtleties of OGC Covers, Contains, Within</ulink>"
#~ msgstr ""
#~ "ST_Contains und ST_Within weisen bestimmte Feinheiten auf, die nicht "
#~ "offensichtlich sind. Für Details siehe <ulink url=\"http://lin-ear-th-"
#~ "inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html"
#~ "\">Subtleties of OGC Covers, Contains, Within</ulink>"

#~ msgid ""
#~ "The <function>ST_Contains</function> predicate returns <varname>TRUE</"
#~ "varname> in all the following illustrations."
#~ msgstr ""
#~ "Das Prädikat <function>ST_Contains</function> gibt bei den folgenden "
#~ "Abbildungen <varname>TRUE</varname> zurück."

#~ msgid "<varname>LINESTRING</varname> / <varname>MULTIPOINT</varname>"
#~ msgstr "<varname>LINESTRING</varname> / <varname>MULTIPOINT</varname>"

#~ msgid "<varname>POLYGON</varname> / <varname>POINT</varname>"
#~ msgstr "<varname>POLYGON</varname> / <varname>POINT</varname>"

#~ msgid "<varname>POLYGON</varname> / <varname>LINESTRING</varname>"
#~ msgstr "<varname>POLYGON</varname> / <varname>LINESTRING</varname>"

#~ msgid "<varname>POLYGON</varname> / <varname>POLYGON</varname>"
#~ msgstr "<varname>POLYGON</varname> / <varname>POLYGON</varname>"

#~ msgid ""
#~ "The <function>ST_Contains</function> predicate returns <varname>FALSE</"
#~ "varname> in all the following illustrations."
#~ msgstr ""
#~ "Das Prädikat <function>ST_Contains</function> gibt bei den folgenden "
#~ "Abbildungen <varname>FALSE</varname> zurück."

#~ msgid "<varname>POLYGON</varname> / <varname>MULTIPOINT</varname>"
#~ msgstr "<varname>POLYGON</varname> / <varname>MULTIPOINT</varname>"

#~ msgid ""
#~ "-- A circle within a circle\n"
#~ "SELECT ST_Contains(smallc, bigc) As smallcontainsbig,\n"
#~ "           ST_Contains(bigc,smallc) As bigcontainssmall,\n"
#~ "           ST_Contains(bigc, ST_Union(smallc, bigc)) as "
#~ "bigcontainsunion,\n"
#~ "           ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
#~ "           ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "           ST_Contains(bigc, ST_ExteriorRing(bigc)) As "
#~ "bigcontainsexterior\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "                         ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As "
#~ "bigc) As foo;\n"
#~ "\n"
#~ "-- Result\n"
#~ "  smallcontainsbig | bigcontainssmall | bigcontainsunion | bigisunion | "
#~ "bigcoversexterior | bigcontainsexterior\n"
#~ "------------------+------------------+------------------+------------"
#~ "+-------------------+---------------------\n"
#~ " f                | t                | t                | t          | "
#~ "t        | f\n"
#~ "\n"
#~ "-- Example demonstrating difference between contains and contains "
#~ "properly\n"
#~ "SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
#~ "acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
#~ "   ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
#~ "ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
#~ "FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
#~ "                         ( ST_MakeLine(ST_Point(1,1), "
#~ "ST_Point(-1,-1) ) ),\n"
#~ "                         ( ST_Point(1,1) )\n"
#~ "          ) As foo(geomA);\n"
#~ "\n"
#~ "  geomtype    | acontainsa | acontainspropa | acontainsba | "
#~ "acontainspropba\n"
#~ "--------------+------------+----------------+-------------"
#~ "+-----------------\n"
#~ "ST_Polygon    | t          | f              | f           | f\n"
#~ "ST_LineString | t          | f              | f           | f\n"
#~ "ST_Point      | t          | t              | f           | f"
#~ msgstr ""
#~ "-- Ein Kreis innerhalb eines Kreises\n"
#~ "SELECT ST_Contains(smallc, bigc) As smallcontainsbig,\n"
#~ "           ST_Contains(bigc,smallc) As bigcontainssmall,\n"
#~ "           ST_Contains(bigc, ST_Union(smallc, bigc)) as "
#~ "bigcontainsunion,\n"
#~ "           ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
#~ "           ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "           ST_Contains(bigc, ST_ExteriorRing(bigc)) As "
#~ "bigcontainsexterior\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "                         ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As "
#~ "bigc) As foo;\n"
#~ "\n"
#~ "-- Result\n"
#~ "  smallcontainsbig | bigcontainssmall | bigcontainsunion | bigisunion | "
#~ "bigcoversexterior | bigcontainsexterior\n"
#~ "------------------+------------------+------------------+------------"
#~ "+-------------------+---------------------\n"
#~ " f                | t                | t                | t          | "
#~ "t        | f\n"
#~ "\n"
#~ "-- Beispiel für den Unterschied zwischen \"contains\" und \"contains "
#~ "properly\"\n"
#~ "SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
#~ "acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
#~ "   ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
#~ "ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
#~ "FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
#~ "                         ( ST_MakeLine(ST_Point(1,1), "
#~ "ST_Point(-1,-1) ) ),\n"
#~ "                         ( ST_Point(1,1) )\n"
#~ "          ) As foo(geomA);\n"
#~ "\n"
#~ "  geomtype    | acontainsa | acontainspropa | acontainsba | "
#~ "acontainspropba\n"
#~ "--------------+------------+----------------+-------------"
#~ "+-----------------\n"
#~ "ST_Polygon    | t          | f              | f           | f\n"
#~ "ST_LineString | t          | f              | f           | f\n"
#~ "ST_Point      | t          | t              | f           | f"

#~ msgid ""
#~ ", <xref linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, "
#~ "<xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
#~ "linkend=\"ST_Within\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_Covers\"/>, "
#~ "<xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Equals\"/>, <xref "
#~ "linkend=\"ST_Within\"/>"

#~ msgid "ST_ContainsProperly"
#~ msgstr "ST_ContainsProperly"

#~ msgid ""
#~ "Returns true if B intersects the interior of A but not the boundary (or "
#~ "exterior). A does not contain properly itself, but does contain itself."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn B das Innere von A schneidet, aber nicht die "
#~ "Begrenzung (oder das Äußere) von A. A enthält sich selbst, aber enthält "
#~ "sich nicht zur Gänze selbst."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_ContainsProperly</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_ContainsProperly</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>"

#~ msgid ""
#~ "Returns true if B intersects the interior of A but not the boundary (or "
#~ "exterior)."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn B das Innere von A schneidet, aber nicht die "
#~ "Begrenzung (oder das Äußere) von A."

#~ msgid "A does not contain properly itself, but does contain itself."
#~ msgstr "A enthält sich selbst, aber enthält sich nicht zur Gänze selbst."

#~ msgid ""
#~ "Every point of the other geometry is a point of this geometry's interior. "
#~ "The DE-9IM Intersection Matrix for the two geometries matches [T**FF*FF*] "
#~ "used in <xref linkend=\"ST_Relate\"/>"
#~ msgstr ""
#~ "Jeder Punkt der anderen Geometrie entspricht einem Punkt im Inneren "
#~ "dieser Geometrie. Die DE-9IM-Matrix der beiden geometrischen Objekte, die "
#~ "in <xref linkend=\"ST_Relate\"/> verwendet wird, entspricht [T**FF*FF*] "

#~ msgid ""
#~ "From JTS docs slightly reworded: The advantage to using this predicate "
#~ "over <xref linkend=\"ST_Contains\"/> and <xref linkend=\"ST_Intersects\"/"
#~ "> is that it can be computed efficiently, with no need to compute "
#~ "topology at individual points."
#~ msgstr ""
#~ "Leicht verändert aus der JTS Dokumentation: Der Vorteil dieses Prädikats "
#~ "gegenüber <xref linkend=\"ST_Contains\"/> und <xref linkend="
#~ "\"ST_Intersects\"/> liegt in der Effizienz, da topologische Berechnungen "
#~ "an einzelnen Punkten nicht notwendig sind."

#~ msgid ""
#~ "An example use case for this predicate is computing the intersections of "
#~ "a set of geometries with a large polygonal geometry. Since intersection "
#~ "is a fairly slow operation, it can be more efficient to use "
#~ "containsProperly to filter out test geometries which lie wholly inside "
#~ "the area. In these cases the intersection is known a priori to be exactly "
#~ "the original test geometry."
#~ msgstr ""
#~ "Ein praktischer Anwendungsfall für dieses Prädikat ist die Verschneidung "
#~ "von geometrischen Objekten mit einer umfangreichen Polygongeometrie. Da "
#~ "Verschneidungsoperationen ziemlich langsam ablaufen, kann es effizienter "
#~ "sein die Geometrie. die zur Gänze innerhalb des Gebietes liegt, mit "
#~ "ST_ContainsProperly herauszufiltern. Bei diesen Fällen ist von vornherein "
#~ "bekannt, dass die Verschneidung der Originalgeometrie entspricht."

#~ msgid "Availability: 1.4.0 - requires GEOS &gt;= 3.1.0."
#~ msgstr "Verfügbarkeit: 1.4.0 - benötigt GEOS &gt;= 3.1.0."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_ContainsProperly."
#~ msgstr ""
#~ "Dieser Funktionsaufruf schließt einen Lagevergleich der umschreibenden "
#~ "Rechtecke mit ein, wodurch sämtlichen verfügbaren Indizes der Geometrie "
#~ "genutzt werden. Um die Verwendung von Indizes zu verhindern, benutzen Sie "
#~ "bitte _ST_ContainsProperly."

#~ msgid ""
#~ "--a circle within a circle\n"
#~ "        SELECT ST_ContainsProperly(smallc, bigc) As "
#~ "smallcontainspropbig,\n"
#~ "        ST_ContainsProperly(bigc,smallc) As bigcontainspropsmall,\n"
#~ "        ST_ContainsProperly(bigc, ST_Union(smallc, bigc)) as "
#~ "bigcontainspropunion,\n"
#~ "        ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
#~ "        ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "        ST_ContainsProperly(bigc, ST_ExteriorRing(bigc)) As "
#~ "bigcontainsexterior\n"
#~ "        FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As "
#~ "smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        --Result\n"
#~ "  smallcontainspropbig | bigcontainspropsmall | bigcontainspropunion | "
#~ "bigisunion | bigcoversexterior | bigcontainsexterior\n"
#~ "------------------+------------------+------------------+------------"
#~ "+-------------------+---------------------\n"
#~ " f                     | t                    | f                    | "
#~ "t          | t                 | f\n"
#~ "\n"
#~ " --example demonstrating difference between contains and contains "
#~ "properly\n"
#~ " SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
#~ "acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
#~ " ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
#~ "ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
#~ " FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
#~ "                  ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
#~ "                  ( ST_Point(1,1) )\n"
#~ "        ) As foo(geomA);\n"
#~ "\n"
#~ "  geomtype    | acontainsa | acontainspropa | acontainsba | "
#~ "acontainspropba\n"
#~ "--------------+------------+----------------+-------------"
#~ "+-----------------\n"
#~ "ST_Polygon    | t          | f              | f           | f\n"
#~ "ST_LineString | t          | f              | f           | f\n"
#~ "ST_Point      | t          | t              | f           | f"
#~ msgstr ""
#~ "--Ein Kreis innerhalb eines Kreises\n"
#~ "        SELECT ST_ContainsProperly(smallc, bigc) As "
#~ "smallcontainspropbig,\n"
#~ "        ST_ContainsProperly(bigc,smallc) As bigcontainspropsmall,\n"
#~ "        ST_ContainsProperly(bigc, ST_Union(smallc, bigc)) as "
#~ "bigcontainspropunion,\n"
#~ "        ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion,\n"
#~ "        ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "        ST_ContainsProperly(bigc, ST_ExteriorRing(bigc)) As "
#~ "bigcontainsexterior\n"
#~ "        FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As "
#~ "smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        --Result\n"
#~ "  smallcontainspropbig | bigcontainspropsmall | bigcontainspropunion | "
#~ "bigisunion | bigcoversexterior | bigcontainsexterior\n"
#~ "------------------+------------------+------------------+------------"
#~ "+-------------------+---------------------\n"
#~ " f                     | t                    | f                    | "
#~ "t          | t                 | f\n"
#~ "\n"
#~ " --Beispiel für den Unterschied zwischen \"contains\" und \"contains "
#~ "properly\"\n"
#~ " SELECT ST_GeometryType(geomA) As geomtype, ST_Contains(geomA,geomA) AS "
#~ "acontainsa, ST_ContainsProperly(geomA, geomA) AS acontainspropa,\n"
#~ " ST_Contains(geomA, ST_Boundary(geomA)) As acontainsba, "
#~ "ST_ContainsProperly(geomA, ST_Boundary(geomA)) As acontainspropba\n"
#~ " FROM (VALUES ( ST_Buffer(ST_Point(1,1), 5,1) ),\n"
#~ "                  ( ST_MakeLine(ST_Point(1,1), ST_Point(-1,-1) ) ),\n"
#~ "                  ( ST_Point(1,1) )\n"
#~ "        ) As foo(geomA);\n"
#~ "\n"
#~ "  geomtype    | acontainsa | acontainspropa | acontainsba | "
#~ "acontainspropba\n"
#~ "--------------+------------+----------------+-------------"
#~ "+-----------------\n"
#~ "ST_Polygon    | t          | f              | f           | f\n"
#~ "ST_LineString | t          | f              | f           | f\n"
#~ "ST_Point      | t          | t              | f           | f"

#~ msgid ""
#~ ", <xref linkend=\"ST_Boundary\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
#~ "linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref linkend="
#~ "\"ST_Equals\"/>, <xref linkend=\"ST_Relate\"/>, <xref linkend=\"ST_Within"
#~ "\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_Boundary\"/>, <xref linkend=\"ST_Contains\"/>, <xref "
#~ "linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref linkend="
#~ "\"ST_Equals\"/>, <xref linkend=\"ST_Relate\"/>, <xref linkend=\"ST_Within"
#~ "\"/>"

#~ msgid "ST_Covers"
#~ msgstr "ST_Covers"

#~ msgid "Returns 1 (TRUE) if no point in Geometry B is outside Geometry A"
#~ msgstr ""
#~ "Gibt 1 (TRUE) zurück, falls kein Punkt der Geometrie B außerhalb von "
#~ "Geometry A liegt"

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Covers</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "</funcprototype> <funcprototype> <funcdef>boolean <function>ST_Covers</"
#~ "function></funcdef> <paramdef><type>geography </type> "
#~ "<parameter>geogpolyA</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>geogpointB</parameter></paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Covers</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "</funcprototype> <funcprototype> <funcdef>boolean <function>ST_Covers</"
#~ "function></funcdef> <paramdef><type>geography </type> "
#~ "<parameter>geogpolyA</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>geogpointB</parameter></paramdef> </funcprototype>"

#~ msgid ""
#~ "Returns 1 (TRUE) if no point in Geometry/Geography B is outside Geometry/"
#~ "Geography A"
#~ msgstr ""
#~ "Gibt 1 (TRUE) zurück, falls kein Punkt der Geometrie/Geographie B "
#~ "außerhalb von Geometry/Geographie A liegt"

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_Covers."
#~ msgstr ""
#~ "Dieser Funktionsaufruf bezieht einen automatischen Lagevergleich der "
#~ "umschreibenden Rechtecke mit ein. Dadurch werden sämtliche Indizes "
#~ "genutzt, die für die geometrischen Objekte vorhanden sind. Um die "
#~ "Verwendung von Indizes zu verhindern, benutzen Sie bitte _ST_Covers."

#~ msgid ""
#~ "Enhanced: 2.4.0 Support for polygon in polygon and line in polygon added "
#~ "for geography type"
#~ msgstr ""
#~ "Erweiterung: 2.4.0 Unterstützung für Polygon in Polygon und Linie in "
#~ "Polygon für den geographischen Datentyp hinzugefügt"

#~ msgid ""
#~ "Enhanced: 2.3.0 Enhancement to PIP short-circuit for geometry extended to "
#~ "support MultiPoints with few points. Prior versions only supported point "
#~ "in polygon."
#~ msgstr ""
#~ "Erweiterung: 2.3.0 Die Kurzschlussauswertung für den Punkt-in-Polygon-"
#~ "Test wurde erweitert, so dass jetzt auch MultiPoints unterstützt werden, "
#~ "die nur aus wenigen Punkten bestehen. Bei Vorgängerversionen wurde nur "
#~ "Punkt in Polygon unterstützt."

#~ msgid "Availability: 1.5 - support for geography was introduced."
#~ msgstr "Verfügbarkeit: 1.5 - Unterstützung von geograpischen Koordinaten."

#~ msgid "Availability: 1.2.2 - requires GEOS &gt;= 3.0"
#~ msgstr "Verfügbarkeit: 1.2.2 - benötigt GEOS &gt;= 3.0"

#~ msgid "Not an OGC standard, but Oracle has it too."
#~ msgstr "Kein OGC-Standard, aber Oracle hat das auch."

#~ msgid ""
#~ "--a circle covering a circle\n"
#~ "SELECT ST_Covers(smallc,smallc) As smallinsmall,\n"
#~ "        ST_Covers(smallc, bigc) As smallcoversbig,\n"
#~ "        ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "        ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        --Result\n"
#~ " smallinsmall | smallcoversbig | bigcoversexterior | bigcontainsexterior\n"
#~ "--------------+----------------+-------------------"
#~ "+---------------------\n"
#~ " t            | f              | t                 | f\n"
#~ "(1 row)"
#~ msgstr ""
#~ "--Ein Kreis, der einen anderen Kreis überdeckt\n"
#~ "SELECT ST_Covers(smallc,smallc) As smallinsmall,\n"
#~ "        ST_Covers(smallc, bigc) As smallcoversbig,\n"
#~ "        ST_Covers(bigc, ST_ExteriorRing(bigc)) As bigcoversexterior,\n"
#~ "        ST_Contains(bigc, ST_ExteriorRing(bigc)) As bigcontainsexterior\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        --Result\n"
#~ " smallinsmall | smallcoversbig | bigcoversexterior | bigcontainsexterior\n"
#~ "--------------+----------------+-------------------"
#~ "+---------------------\n"
#~ " t            | f              | t                 | f\n"
#~ "(1 row)"

#~ msgid "Geeography Example"
#~ msgstr "Geographie Beispiel"

#~ msgid ""
#~ "-- a point with a 300 meter buffer compared to a point, a point and its "
#~ "10 meter buffer\n"
#~ "SELECT ST_Covers(geog_poly, geog_pt) As poly_covers_pt,\n"
#~ "        ST_Covers(ST_Buffer(geog_pt,10), geog_pt) As "
#~ "buff_10m_covers_cent\n"
#~ "        FROM (SELECT ST_Buffer(ST_GeogFromText('SRID=4326;POINT(-99.327 "
#~ "31.4821)'), 300) As geog_poly,\n"
#~ "                                ST_GeogFromText('SRID=4326;POINT(-99.33 "
#~ "31.483)') As geog_pt ) As foo;\n"
#~ "\n"
#~ " poly_covers_pt | buff_10m_covers_cent\n"
#~ "----------------+------------------\n"
#~ " f              | t"
#~ msgstr ""
#~ "-- ein Punkt mit einem Puffer von 300 Metern mit einem Punkt vergleichen, "
#~ "ein Punkt und sein Puffer mit 10 Metern\n"
#~ "SELECT ST_Covers(geog_poly, geog_pt) As poly_covers_pt,\n"
#~ "        ST_Covers(ST_Buffer(geog_pt,10), geog_pt) As "
#~ "buff_10m_covers_cent\n"
#~ "        FROM (SELECT ST_Buffer(ST_GeogFromText('SRID=4326;POINT(-99.327 "
#~ "31.4821)'), 300) As geog_poly,\n"
#~ "                                ST_GeogFromText('SRID=4326;POINT(-99.33 "
#~ "31.483)') As geog_pt ) As foo;\n"
#~ "\n"
#~ " poly_covers_pt | buff_10m_covers_cent\n"
#~ "----------------+------------------\n"
#~ " f              | t"

#~ msgid ", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Within\"/>"
#~ msgstr ", <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Within\"/>"

#~ msgid "ST_CoveredBy"
#~ msgstr "ST_CoveredBy"

#~ msgid ""
#~ "<refpurpose>Returns 1 (TRUE) if no point in Geometry/Geography A is "
#~ "outside Geometry/Geography B</refpurpose>"
#~ msgstr ""
#~ "<refpurpose>Gibt 1 (TRUE) zurück, falls kein Punkt der Geometrie/"
#~ "Geographie A außerhalb von Geometry/Geographie B liegt<refpurpose>"

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_CoveredBy</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>geomA</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>geomB</parameter></"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
#~ "<function>ST_CoveredBy</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>geogA</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>geogB</parameter></paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_CoveredBy</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>geomA</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>geomB</parameter></"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
#~ "<function>ST_CoveredBy</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>geogA</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>geogB</parameter></paramdef> </funcprototype>"

#~ msgid ""
#~ "<para>Returns 1 (TRUE) if no point in Geometry/Geography A is outside "
#~ "Geometry/Geography B</para>"
#~ msgstr ""
#~ "<para>Gibt 1 (TRUE) zurück, falls kein Punkt der Geometrie/Geographie A "
#~ "außerhalb von Geometry/Geographie B liegt<para>"

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_CoveredBy."
#~ msgstr ""
#~ "Dieser Funktionsaufruf schließt einen Lagevergleich der umschreibenden "
#~ "Rechtecke mit ein, wodurch sämtlichen verfügbaren Indizes der Geometrie "
#~ "genutzt werden. Um die Verwendung von Indizes zu verhindern, benutzen Sie "
#~ "bitte _ST_CoveredBy."

#~ msgid ""
#~ "--a circle coveredby a circle\n"
#~ "SELECT ST_CoveredBy(smallc,smallc) As smallinsmall,\n"
#~ "        ST_CoveredBy(smallc, bigc) As smallcoveredbybig,\n"
#~ "        ST_CoveredBy(ST_ExteriorRing(bigc), bigc) As "
#~ "exteriorcoveredbybig,\n"
#~ "        ST_Within(ST_ExteriorRing(bigc),bigc) As exeriorwithinbig\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        --Result\n"
#~ " smallinsmall | smallcoveredbybig | exteriorcoveredbybig | "
#~ "exeriorwithinbig\n"
#~ "--------------+-------------------+----------------------"
#~ "+------------------\n"
#~ " t            | t                 | t                    | f\n"
#~ "(1 row)"
#~ msgstr ""
#~ "--Ein Kreis abgedeckt durch einen Kreis\n"
#~ "SELECT ST_CoveredBy(smallc,smallc) As smallinsmall,\n"
#~ "        ST_CoveredBy(smallc, bigc) As smallcoveredbybig,\n"
#~ "        ST_CoveredBy(ST_ExteriorRing(bigc), bigc) As "
#~ "exteriorcoveredbybig,\n"
#~ "        ST_Within(ST_ExteriorRing(bigc),bigc) As exeriorwithinbig\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 2)'), 10) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(1 2)'), 20) As bigc) As foo;\n"
#~ "        --Result\n"
#~ " smallinsmall | smallcoveredbybig | exteriorcoveredbybig | "
#~ "exeriorwithinbig\n"
#~ "--------------+-------------------+----------------------"
#~ "+------------------\n"
#~ " t            | t                 | t                    | f\n"
#~ "(1 row)"

#~ msgid ""
#~ ", <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_ExteriorRing\"/>, "
#~ "<xref linkend=\"ST_Within\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_ExteriorRing\"/>, "
#~ "<xref linkend=\"ST_Within\"/>"

#~ msgid "ST_Crosses"
#~ msgstr "ST_Crosses"

#~ msgid ""
#~ "Returns <varname>TRUE</varname> if the supplied geometries have some, but "
#~ "not all, interior points in common."
#~ msgstr ""
#~ "Gibt <varname>TRUE</varname> zurück, wenn die übergebenen geometrischen "
#~ "Objekte einige aber nicht alle Punkte im Inneren gemeinsam haben."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Crosses</function></funcdef> "
#~ "<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type><parameter>g2</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Crosses</function></funcdef> "
#~ "<paramdef><type>geometry </type><parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type><parameter>g2</parameter></paramdef>"

#~ msgid ""
#~ "<function>ST_Crosses</function> takes two geometry objects and returns "
#~ "<varname>TRUE</varname> if their intersection \"spatially cross\", that "
#~ "is, the geometries have some, but not all interior points in common. The "
#~ "intersection of the interiors of the geometries must not be the empty set "
#~ "and must have a dimensionality less than the maximum dimension of the two "
#~ "input geometries. Additionally, the intersection of the two geometries "
#~ "must not equal either of the source geometries. Otherwise, it returns "
#~ "<varname>FALSE</varname>."
#~ msgstr ""
#~ "<function>ST_Crosses</function> nimmt zwei geometrische Objekte entgegen "
#~ "und gibt <varname>TRUE</varname> zurück, wenn sich ihre Verschneidung "
#~ "\"räumlich kreuzt\"; das heißt die geometrischen Objekte haben einige, "
#~ "aber nicht alle Punkte in ihrem Inneren gemeinsam. Die Verschneidung des "
#~ "Inneren der geometrischen Objekte darf keine leere Menge ergeben und muss "
#~ "eine Dimensionalität aufweisen, die kleiner als die maximale Dimension "
#~ "der beiden gegebenen geometrischen Objekte ist. Weiters darf die "
#~ "Verschneidung der beiden geometrischen Objekte nicht mit einer "
#~ "Ausgangsgeometrie übereinstimmen. Sonst wird <varname>FALSE</varname> "
#~ "zurückgegeben."

#~ msgid "In mathematical terms, this is expressed as:"
#~ msgstr "Mathematisch wird dies folgendermaßen ausgedrückt:"

#~ msgid ""
#~ "TODO: Insert appropriate MathML markup here or use a gif. Simple HTML "
#~ "markup does not work well in both IE and Firefox."
#~ msgstr ""
#~ "TODO: Insert appropriate MathML markup here or use a gif. Simple HTML "
#~ "markup does not work well in both IE and Firefox."

#~ msgid "The DE-9IM Intersection Matrix for the two geometries is:"
#~ msgstr "Die DE-9IM-Matrix für die zwei geometrischen Objekte lautet:"

#~ msgid ""
#~ "<markup>T*T******</markup> (for Point/Line, Point/Area, and Line/Area "
#~ "situations)"
#~ msgstr ""
#~ "<markup>T*T******</markup> (für die Zustände Punkt/Linie, Punkt/Fläche "
#~ "und Linie/Fläche)"

#~ msgid ""
#~ "<markup>T*****T**</markup> (for Line/Point, Area/Point, and Area/Line "
#~ "situations)"
#~ msgstr ""
#~ "<markup>T*****T**</markup> (für die Zustände Linie/Punkt, Fläche/Punkt "
#~ "und Fläche/Linie)"

#~ msgid "<markup>0********</markup> (for Line/Line situations)"
#~ msgstr "<markup>0********</markup> (für den Zustand Linie/Linie)"

#~ msgid ""
#~ "For any other combination of dimensions this predicate returns false."
#~ msgstr ""
#~ "Bei jeder anderen Kombination von geometrischen Dimensionen gibt das "
#~ "Prädikat FALSE zurück."

#~ msgid ""
#~ "The OpenGIS Simple Features Specification defines this predicate only for "
#~ "Point/Line, Point/Area, Line/Line, and Line/Area situations. JTS / GEOS "
#~ "extends the definition to apply to Line/Point, Area/Point and Area/Line "
#~ "situations as well. This makes the relation symmetric."
#~ msgstr ""
#~ "Die \"OpenGIS Simple Features Specification\" definiert dieses Prädikat "
#~ "nur für die Fälle Punkt/Linie, Punkt/Fläche, Linie/Linie und Linie/"
#~ "Fläche. JTS / GEOS erweitert diese Definition um die Fälle Linie/Punkt, "
#~ "Fläche/Punkt und Fläche/Linie, wodurch sich eine symmetrische Beziehung "
#~ "ergibt."

#~ msgid "&sfs_compliant; s2.1.13.3"
#~ msgstr "&sfs_compliant; s2.1.13.3"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.29"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.29"

#~ msgid "The following illustrations all return <varname>TRUE</varname>."
#~ msgstr ""
#~ "Bei den folgenden Abbildungen wird immer <varname>TRUE</varname> "
#~ "zurückgegeben."

#~ msgid "<varname>MULTIPOINT</varname> / <varname>LINESTRING</varname>"
#~ msgstr "<varname>MULTIPOINT</varname> / <varname>LINESTRING</varname>"

#~ msgid "<varname>MULTIPOINT</varname> / <varname>POLYGON</varname>"
#~ msgstr "<varname>MULTIPOINT</varname> / <varname>POLYGON</varname>"

#~ msgid "<varname>LINESTRING</varname> / <varname>POLYGON</varname>"
#~ msgstr "<varname>LINESTRING</varname> / <varname>POLYGON</varname>"

#~ msgid "<varname>LINESTRING</varname> / <varname>LINESTRING</varname>"
#~ msgstr "<varname>LINESTRING</varname> / <varname>LINESTRING</varname>"

#~ msgid ""
#~ "Consider a situation where a user has two tables: a table of roads and a "
#~ "table of highways."
#~ msgstr ""
#~ "Betrachten wir eine Situation, wo ein Anwender zwei Tabellen hat: eine "
#~ "Tabelle mit Landstraßen und eine mit Autobahnen."

#~ msgid ""
#~ "CREATE TABLE roads (\n"
#~ "  id serial NOT NULL,\n"
#~ "  the_geom geometry,\n"
#~ "  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
#~ ");"
#~ msgstr ""
#~ "CREATE TABLE roads (\n"
#~ "  id serial NOT NULL,\n"
#~ "  the_geom geometry,\n"
#~ "  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
#~ ");"

#~ msgid ""
#~ "CREATE TABLE highways (\n"
#~ "  id serial NOT NULL,\n"
#~ "  the_gem geometry,\n"
#~ "  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
#~ ");"
#~ msgstr ""
#~ "CREATE TABLE highways (\n"
#~ "  id serial NOT NULL,\n"
#~ "  the_gem geometry,\n"
#~ "  CONSTRAINT roads_pkey PRIMARY KEY (road_id)\n"
#~ ");"

#~ msgid ""
#~ "To determine a list of roads that cross a highway, use a query similiar "
#~ "to:"
#~ msgstr ""
#~ "Um die Landstraßen zu erhalten, die eine Autobahn kreuzen, können Sie "
#~ "eine ähnliche Anfrage wie folgt ausführen:"

#~ msgid ""
#~ "SELECT roads.id\n"
#~ "FROM roads, highways\n"
#~ "WHERE ST_Crosses(roads.the_geom, highways.the_geom);"
#~ msgstr ""
#~ "SELECT roads.id\n"
#~ "FROM roads, highways\n"
#~ "WHERE ST_Crosses(roads.the_geom, highways.the_geom);"

#~ msgid "ST_LineCrossingDirection"
#~ msgstr "ST_LineCrossingDirection"

#~ msgid ""
#~ "Given 2 linestrings, returns a number between -3 and 3 denoting what kind "
#~ "of crossing behavior. 0 is no crossing."
#~ msgstr ""
#~ "Für 2 gegebene Linienstücke wird eine Zahl zwischen -3 und 3 "
#~ "zurückgegeben, welche die Art des Kreuzens angibt. Wenn sich die Linien "
#~ "nicht kreuzen, wird 0 zurückgegeben."

#~ msgid ""
#~ "<funcdef>integer <function>ST_LineCrossingDirection</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>linestringA</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>linestringB</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>integer <function>ST_LineCrossingDirection</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>linestringA</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>linestringB</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "Given 2 linestrings, returns a number between -3 and 3 denoting what kind "
#~ "of crossing behavior. 0 is no crossing. This is only supported for "
#~ "<varname>LINESTRING</varname>"
#~ msgstr ""
#~ "Für 2 gegebene Linienstücke wird eine Zahl zwischen -3 und 3 "
#~ "zurückgegeben, welche die Art des Kreuzens angibt. Wenn sich die Linien "
#~ "nicht kreuzen, wird 0 zurückgegeben. Unterstützt lediglich "
#~ "<varname>LINESTRING</varname>"

#~ msgid "Definition of integer constants is as follows:"
#~ msgstr "Die ganzzahligen Konstanten sind wie folgt definiert:"

#~ msgid "0: LINE NO CROSS"
#~ msgstr "0: LINIE KREUZT NICHT"

#~ msgid "-1: LINE CROSS LEFT"
#~ msgstr "-1: LINIE KREUZT VON LINKS"

#~ msgid "1: LINE CROSS RIGHT"
#~ msgstr "-1: LINIE KREUZT VON RECHTS"

#~ msgid "-2: LINE MULTICROSS END LEFT"
#~ msgstr "-2: LINE KREUZT MEHRFACH - ENDE LINKS"

#~ msgid "2: LINE MULTICROSS END RIGHT"
#~ msgstr "2: LINE KREUZT MEHRFACH - ENDE RECHTS"

#~ msgid "-3: LINE MULTICROSS END SAME FIRST LEFT"
#~ msgstr "-3: LINIE KREUZT MEHRFACH - ENDET GLEICH - BEGINNT VON LINKS"

#~ msgid "3: LINE MULTICROSS END SAME FIRST RIGHT"
#~ msgstr "3: LINIE KREUZT MEHRFACH - ENDET GLEICH - BEGINNT VON RECHTS"

#~ msgid "Availability: 1.4"
#~ msgstr "Verfügbarkeit: 1.4"

#~ msgid ""
#~ "Line 1 (green), Line 2 ball is start point, triangle are end points. "
#~ "Query below."
#~ msgstr ""
#~ "Linie 1 (grün), Linie 2 (blau); der Ball ist der Anfangspunkt, das "
#~ "Dreieck der Endpunkt. Abfrage unterhalb."

#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ "SELECT\n"
#~ " ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ " ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As line2\n"
#~ "        ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           3 |          -3"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ "SELECT\n"
#~ " ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ " ST_GeomFromText('LINESTRING(171 154,20 140,71 74,161 53)') As line2\n"
#~ "        ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           3 |          -3"

#~ msgid ""
#~ "Line 1 (green), Line 2 (blue) ball is start point, triangle are end "
#~ "points. Query below."
#~ msgstr ""
#~ "Linie 1 (grün), Linie 2 (blau); der Ball ist der Anfangspunkt, das "
#~ "Dreieck der Endpunkt. Abfrage unterhalb."

#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (171 154, 20 140, 71 74, 2.99 90.16)') As "
#~ "line2\n"
#~ ") As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           2 |          -2"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (171 154, 20 140, 71 74, 2.99 90.16)') As "
#~ "line2\n"
#~ ") As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "           2 |          -2"

#~ msgid ""
#~ "SELECT\n"
#~ "        ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "        ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -1 |          1"
#~ msgstr ""
#~ "SELECT\n"
#~ "        ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "        ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (\n"
#~ " SELECT\n"
#~ "  ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As line1,\n"
#~ "  ST_GeomFromText('LINESTRING (20 140, 71 74, 161 53)') As line2\n"
#~ "  ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -1 |          1"

#~ msgid ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (SELECT\n"
#~ "        ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As "
#~ "line1,\n"
#~ "        ST_GeomFromText('LINESTRING(2.99 90.16,71 74,20 140,171 154)') As "
#~ "line2\n"
#~ "        ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -2 |          2"
#~ msgstr ""
#~ "SELECT ST_LineCrossingDirection(foo.line1, foo.line2) As l1_cross_l2 ,\n"
#~ "          ST_LineCrossingDirection(foo.line2, foo.line1) As l2_cross_l1\n"
#~ "FROM (SELECT\n"
#~ "        ST_GeomFromText('LINESTRING(25 169,89 114,40 70,86 43)') As "
#~ "line1,\n"
#~ "        ST_GeomFromText('LINESTRING(2.99 90.16,71 74,20 140,171 154)') As "
#~ "line2\n"
#~ "        ) As foo;\n"
#~ "\n"
#~ " l1_cross_l2 | l2_cross_l1\n"
#~ "-------------+-------------\n"
#~ "          -2 |          2"

#~ msgid ""
#~ "SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.the_geom, s2."
#~ "the_geom)\n"
#~ "        FROM streets s1 CROSS JOIN streets s2 ON (s1.gid != s2.gid AND s1."
#~ "the_geom &amp;&amp; s2.the_geom )\n"
#~ "WHERE ST_CrossingDirection(s1.the_geom, s2.the_geom) > 0;"
#~ msgstr ""
#~ "SELECT s1.gid, s2.gid, ST_LineCrossingDirection(s1.the_geom, s2."
#~ "the_geom)\n"
#~ "        FROM streets s1 CROSS JOIN streets s2 ON (s1.gid != s2.gid AND s1."
#~ "the_geom &amp;&amp; s2.the_geom )\n"
#~ "WHERE ST_CrossingDirection(s1.the_geom, s2.the_geom) > 0;"

#~ msgid "ST_Disjoint"
#~ msgstr "ST_Disjoint"

#~ msgid ""
#~ "Returns TRUE if the Geometries do not \"spatially intersect\" - if they "
#~ "do not share any space together."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn sich die geometrischen Objekte nicht \"räumlich "
#~ "schneiden\" - wenn sie sich keinen gemeinsamen Raum teilen."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Disjoint</function></funcdef> <paramdef> "
#~ "<type>geometry</type> <parameter>A</parameter> </paramdef> <paramdef> "
#~ "<type>geometry</type> <parameter>B</parameter> </paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Disjoint</function></funcdef> <paramdef> "
#~ "<type>geometry</type> <parameter>A</parameter> </paramdef> <paramdef> "
#~ "<type>geometry</type> <parameter>B</parameter> </paramdef>"

#~ msgid ""
#~ "Overlaps, Touches, Within all imply geometries are not spatially "
#~ "disjoint. If any of the aforementioned returns true, then the geometries "
#~ "are not spatially disjoint. Disjoint implies false for spatial "
#~ "intersection."
#~ msgstr ""
#~ "ST_Overlaps, ST_Touches und ST_Within implizieren alle, dass die "
#~ "geometrischen Objekte räumlich getrennt sind. Wenn irgendeine der "
#~ "genannten Funtionen TRUE zurückgibt, dann sind die geometrischen Objekte "
#~ "nicht räumlich getrennt. ST_Disjoint impliziert FALSE für \"räumliches "
#~ "Schneiden\"."

#~ msgid "This function call does not use indexes"
#~ msgstr "Dieser Funktionsaufruf verwendet keine Indizes"

#~ msgid "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - a.Relate(b, 'FF*FF****')"
#~ msgstr "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - a.Relate(b, 'FF*FF****')"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.26"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.26"

#~ msgid ""
#~ "SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_disjoint\n"
#~ "---------------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_disjoint\n"
#~ "---------------\n"
#~ " f\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_disjoint\n"
#~ "---------------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "SELECT ST_Disjoint('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_disjoint\n"
#~ "---------------\n"
#~ " f\n"
#~ "(1 row)"

#~ msgid ""
#~ "For geometry type returns the 2D Cartesian distance between two "
#~ "geometries in projected units (based on spatial reference system). For "
#~ "geography type defaults to return minimum geodesic distance between two "
#~ "geographies in meters."
#~ msgstr ""
#~ "Beim geometrischen Datentyp wird die kartesische Distanz in 2D zwischen "
#~ "zwei geometrischen Objekten in projizierten Einheiten (Einheiten des "
#~ "Koordinatenreferenzsystems) zurückgegeben. Beim geographischen Datentyp "
#~ "wird standardmäßig die geringste geodätische Distanz zwischen zwei "
#~ "geographischen Objekten in Meter zurückgegeben."

#~ msgid ""
#~ "<funcprototype> <funcdef>float <function>ST_Distance</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> </"
#~ "funcprototype> <funcprototype> <funcdef>float <function>ST_Distance</"
#~ "function></funcdef> <paramdef><type>geography </type> <parameter>gg1</"
#~ "parameter></paramdef> <paramdef><type>geography </type> <parameter>gg2</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>float "
#~ "<function>ST_Distance</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>gg1</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>gg2</parameter></paramdef> <paramdef><type>boolean </"
#~ "type> <parameter>use_spheroid</parameter></paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>float <function>ST_Distance</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> </"
#~ "funcprototype> <funcprototype> <funcdef>float <function>ST_Distance</"
#~ "function></funcdef> <paramdef><type>geography </type> <parameter>gg1</"
#~ "parameter></paramdef> <paramdef><type>geography </type> <parameter>gg2</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>float "
#~ "<function>ST_Distance</function></funcdef> <paramdef><type>geography </"
#~ "type> <parameter>gg1</parameter></paramdef> <paramdef><type>geography </"
#~ "type> <parameter>gg2</parameter></paramdef> <paramdef><type>boolean </"
#~ "type> <parameter>use_spheroid</parameter></paramdef> </funcprototype>"

#~ msgid ""
#~ "--Geometry example - units in planar degrees 4326 is WGS 84 long lat "
#~ "unit=degrees\n"
#~ "SELECT ST_Distance(\n"
#~ "                'SRID=4326;POINT(-72.1235 42.3521)'::geometry,\n"
#~ "                'SRID=4326;LINESTRING(-72.1260 42.45, -72.123 42.1546)'::"
#~ "geometry\n"
#~ "        );\n"
#~ "st_distance\n"
#~ "-----------------\n"
#~ "0.00150567726382282\n"
#~ "\n"
#~ "-- Geometry example - units in meters (SRID: 3857, proportional to pixels "
#~ "on popular web maps)\n"
#~ "-- although the value is off, nearby ones can be compared correctly,\n"
#~ "-- which makes it a good choice for algorithms like KNN or KMeans.\n"
#~ "SELECT ST_Distance(\n"
#~ "                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
#~ "geometry, 3857),\n"
#~ "                        ST_Transform('SRID=4326;LINESTRING(-72.1260 "
#~ "42.45, -72.123 42.1546)'::geometry, 3857)\n"
#~ "                );\n"
#~ "st_distance\n"
#~ "-----------------\n"
#~ "167.441410065196\n"
#~ "\n"
#~ "-- Geometry example - units in meters (SRID: 3857 as above, but corrected "
#~ "by cos(lat) to account for distortion)\n"
#~ "SELECT ST_Distance(\n"
#~ "                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
#~ "geometry, 3857),\n"
#~ "                        ST_Transform('SRID=4326;LINESTRING(-72.1260 "
#~ "42.45, -72.123 42.1546)'::geometry, 3857)\n"
#~ "                ) * cosd(42.3521);\n"
#~ "st_distance\n"
#~ "-----------------\n"
#~ "123.742351254151\n"
#~ "\n"
#~ "-- Geometry example - units in meters (SRID: 26986 Massachusetts state "
#~ "plane meters) (most accurate for Massachusetts)\n"
#~ "SELECT ST_Distance(\n"
#~ "                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
#~ "geometry, 26986),\n"
#~ "                        ST_Transform('SRID=4326;LINESTRING(-72.1260 "
#~ "42.45, -72.123 42.1546)'::geometry, 26986)\n"
#~ "                );\n"
#~ "st_distance\n"
#~ "-----------------\n"
#~ "123.797937878454\n"
#~ "\n"
#~ "-- Geometry example - units in meters (SRID: 2163 US National Atlas Equal "
#~ "area) (least accurate)\n"
#~ "SELECT ST_Distance(\n"
#~ "                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
#~ "geometry, 2163),\n"
#~ "                        ST_Transform('SRID=4326;LINESTRING(-72.1260 "
#~ "42.45, -72.123 42.1546)'::geometry, 2163)\n"
#~ "                );\n"
#~ "\n"
#~ "st_distance\n"
#~ "------------------\n"
#~ "126.664256056812"
#~ msgstr ""
#~ "--- Beispiel Geometrie - Einheiten in Grad; 4326 ist WGS 84 long lat "
#~ "unit=degrees\n"
#~ "SELECT ST_Distance(\n"
#~ "                'SRID=4326;POINT(-72.1235 42.3521)'::geometry,\n"
#~ "                'SRID=4326;LINESTRING(-72.1260 42.45, -72.123 42.1546)'::"
#~ "geometry\n"
#~ "        );\n"
#~ "st_distance\n"
#~ "-----------------\n"
#~ "0.00150567726382282\n"
#~ "\n"
#~ "-- Beispiel Geometrie - Einheiten in Meter (SRID: 3857, proportional zu "
#~ "den Pixeln gängiger Webkarten)\n"
#~ "-- obwohl use_spheroid FALSE ist, können nahe beisammenliegende Punkte "
#~ "korrekt verglichen werden,\n"
#~ "-- wodurch dies eine gute Wahl für Algorithmen wie kNN oder KMeans "
#~ "darstellt.\n"
#~ "SELECT ST_Distance(\n"
#~ "                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
#~ "geometry, 3857),\n"
#~ "                        ST_Transform('SRID=4326;LINESTRING(-72.1260 "
#~ "42.45, -72.123 42.1546)'::geometry, 3857)\n"
#~ "                );\n"
#~ "st_distance\n"
#~ "-----------------\n"
#~ "167.441410065196\n"
#~ "\n"
#~ "-- Beispiel Geometrie - Einheiten in Meter (SRID: 3857 wie oben,aber mit "
#~ "cos(lat) korrigiert um der Verzerrung Rechnung zu tragen)\n"
#~ "SELECT ST_Distance(\n"
#~ "                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
#~ "geometry, 3857),\n"
#~ "                        ST_Transform('SRID=4326;LINESTRING(-72.1260 "
#~ "42.45, -72.123 42.1546)'::geometry, 3857)\n"
#~ "                ) * cosd(42.3521);\n"
#~ "st_distance\n"
#~ "-----------------\n"
#~ "123.742351254151\n"
#~ "\n"
#~ "-- Beispiel Geometrie - Einheiten in Meter (SRID: 26986 Massachusetts "
#~ "state plane meters) (am präzisesten für Massachusetts)\n"
#~ "SELECT ST_Distance(\n"
#~ "                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
#~ "geometry, 26986),\n"
#~ "                        ST_Transform('SRID=4326;LINESTRING(-72.1260 "
#~ "42.45, -72.123 42.1546)'::geometry, 26986)\n"
#~ "                );\n"
#~ "st_distance\n"
#~ "-----------------\n"
#~ "123.797937878454\n"
#~ "\n"
#~ "-- Beispiel Geometrie - Einheiten in Meter (SRID: 2163 US National Atlas "
#~ "Equal area) (am wenigsten akkurat)\n"
#~ "SELECT ST_Distance(\n"
#~ "                        ST_Transform('SRID=4326;POINT(-72.1235 42.3521)'::"
#~ "geometry, 2163),\n"
#~ "                        ST_Transform('SRID=4326;LINESTRING(-72.1260 "
#~ "42.45, -72.123 42.1546)'::geometry, 2163)\n"
#~ "                );\n"
#~ "\n"
#~ "st_distance\n"
#~ "------------------\n"
#~ "126.664256056812"

#~ msgid "Availability: 1.5.0 - requires GEOS &gt;= 3.2.0"
#~ msgstr "Verfügbarkeit: 1.5.0 - benötigt GEOS &gt;= 3.2.0"

#~ msgid ""
#~ "Returns the Fréchet distance between two geometries. This is a measure of "
#~ "similarity between curves that takes into account the location and "
#~ "ordering of the points along the curves. Units are in the units of the "
#~ "spatial reference system of the geometries."
#~ msgstr ""
#~ "Gibt die Fréchet-Metrik von zwei geometrischen Objekten zurück. Dies ist "
#~ "ein Maß für die Ähnlichkeit von Kurven, das die Lage und die Reihenfolge "
#~ "der Punkte entlang der Kurve berücksichtigt. Die Einheiten sind in den "
#~ "Einheiten des Koordinatenreferenzsystems der Geometrie."

#~ msgid ""
#~ "Returns minimum distance in meters between two lon/lat geometries. Uses a "
#~ "spherical earth and radius derived from the spheroid defined by the SRID. "
#~ "Faster than ST_DistanceSpheroid <xref linkend=\"ST_Distance_Spheroid\"/>, "
#~ "but less accurate. PostGIS versions prior to 1.5 only implemented for "
#~ "points."
#~ msgstr ""
#~ "Gibt die kürzeste Distanz zwischen zwei geometrischen Objekten zurück, "
#~ "die über Länge und Breite gegeben sind. Verwendet die Kugelform für die "
#~ "Erde und den Radius des Referenzellipsoids, der durch die SRID festgelegt "
#~ "ist. Ist schneller als ST_DistanceSpheroid <xref linkend="
#~ "\"ST_Distance_Spheroid\"/>, aber weniger genau. Bei Vorgängerversionen "
#~ "von PostGIS 1.5 war dies nur für Punkte umgesetzt."

#~ msgid "ST_DFullyWithin"
#~ msgstr "ST_DFullyWithin"

#~ msgid ""
#~ "Returns true if all of the geometries are within the specified distance "
#~ "of one another"
#~ msgstr ""
#~ "Gibt TRUE zurück wenn alle geometrischen Objekte innerhalb einer "
#~ "bestimmten Entfernung zueinander liegen"

#~ msgid ""
#~ "<funcdef>boolean <function>ST_DFullyWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance</parameter></"
#~ "paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_DFullyWithin</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef> "
#~ "<paramdef><type>double precision </type> <parameter>distance</parameter></"
#~ "paramdef>"

#~ msgid ""
#~ "Returns true if the geometries is fully within the specified distance of "
#~ "one another. The distance is specified in units defined by the spatial "
#~ "reference system of the geometries. For this function to make sense, the "
#~ "source geometries must both be of the same coordinate projection, having "
#~ "the same SRID."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn die geometrischen Objekte zur Gänze innerhalb der "
#~ "festgelegten Entfernung zueinander liegen. Die Entfernung wird in den "
#~ "Einheiten des Koordinatenreferenzsystems der Geometrie angegeben. Damit "
#~ "diese Funktion sinnvoll angewendet werden kann, müssen die beiden "
#~ "geometrischen Layer die gleiche Projektion und die gleiche SRID haben."

#~ msgid ""
#~ "postgis=# SELECT ST_DFullyWithin(geom_a, geom_b, 10) as DFullyWithin10, "
#~ "ST_DWithin(geom_a, geom_b, 10) as DWithin10, ST_DFullyWithin(geom_a, "
#~ "geom_b, 20) as DFullyWithin20 from\n"
#~ "                (select ST_GeomFromText('POINT(1 1)') as geom_a,"
#~ "ST_GeomFromText('LINESTRING(1 5, 2 7, 1 9, 14 12)') as geom_b) t1;\n"
#~ "\n"
#~ "-----------------\n"
#~ " DFullyWithin10 | DWithin10 | DFullyWithin20 |\n"
#~ "---------------+----------+---------------+\n"
#~ " f             | t        | t             |"
#~ msgstr ""
#~ "postgis=# SELECT ST_DFullyWithin(geom_a, geom_b, 10) as DFullyWithin10, "
#~ "ST_DWithin(geom_a, geom_b, 10) as DWithin10, ST_DFullyWithin(geom_a, "
#~ "geom_b, 20) as DFullyWithin20 from\n"
#~ "                (select ST_GeomFromText('POINT(1 1)') as geom_a,"
#~ "ST_GeomFromText('LINESTRING(1 5, 2 7, 1 9, 14 12)') as geom_b) t1;\n"
#~ "\n"
#~ "-----------------\n"
#~ " DFullyWithin10 | DWithin10 | DFullyWithin20 |\n"
#~ "---------------+----------+---------------+\n"
#~ " f             | t        | t             |"

#~ msgid ", <xref linkend=\"ST_DWithin\"/>"
#~ msgstr ", <xref linkend=\"ST_DWithin\"/>"

#~ msgid "ST_DWithin"
#~ msgstr "ST_DWithin"

#~ msgid ""
#~ "Returns true if the geometries are within the specified distance of one "
#~ "another. For geometry units are in those of spatial reference and for "
#~ "geography units are in meters and measurement is defaulted to "
#~ "use_spheroid=true (measure around spheroid), for faster check, "
#~ "use_spheroid=false to measure along sphere."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn die geometrischen Objekte innerhalb einer "
#~ "bestimmten Entfernung voneinander liegen. Beim geometrischen Datentyp "
#~ "entsprechen die Einheiten dem Koordinatenreferenzsystem. Beim "
#~ "geographischen Datentyp sind die Einheiten in Meter und die Messung wird "
#~ "mit der Standardeinstellung \"use_speroid=true\" (Messung am "
#~ "Referenzellipsoid) durchgeführt; für eine schnellere Überprüfung können "
#~ "Sie \"use_spheroid=false\" setzen, um auf einer Kugel zu messen."

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_of_srid</parameter></paramdef> </funcprototype> "
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geography </type> <parameter>gg1</parameter></"
#~ "paramdef> <paramdef><type>geography </type> <parameter>gg2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_meters</parameter></paramdef> </funcprototype> "
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geography </type> <parameter>gg1</parameter></"
#~ "paramdef> <paramdef><type>geography </type> <parameter>gg2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_meters</parameter></paramdef> <paramdef><type>boolean "
#~ "</type> <parameter>use_spheroid</parameter></paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geometry </type> <parameter>g1</parameter></"
#~ "paramdef> <paramdef><type>geometry </type> <parameter>g2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_of_srid</parameter></paramdef> </funcprototype> "
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geography </type> <parameter>gg1</parameter></"
#~ "paramdef> <paramdef><type>geography </type> <parameter>gg2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_meters</parameter></paramdef> </funcprototype> "
#~ "<funcprototype> <funcdef>boolean <function>ST_DWithin</function></"
#~ "funcdef> <paramdef><type>geography </type> <parameter>gg1</parameter></"
#~ "paramdef> <paramdef><type>geography </type> <parameter>gg2</parameter></"
#~ "paramdef> <paramdef><type>double precision </type> "
#~ "<parameter>distance_meters</parameter></paramdef> <paramdef><type>boolean "
#~ "</type> <parameter>use_spheroid</parameter></paramdef> </funcprototype>"

#~ msgid ""
#~ "Returns true if the geometries are within the specified distance of one "
#~ "another."
#~ msgstr ""
#~ "Gibt TRUE zurück wenn die geometrischen Objekte innerhalb einer "
#~ "bestimmten Entfernung zueinander liegen."

#~ msgid ""
#~ "For <type>geometry</type>: The distance is specified in units defined by "
#~ "the spatial reference system of the geometries. For this function to make "
#~ "sense, the source geometries must both be of the same coordinate "
#~ "projection, having the same SRID."
#~ msgstr ""
#~ "Beim geometrischen Datentyp <type>geometry</type> wird die Entfernung in "
#~ "den Einheiten des Koordinatenreferenzsystems der Geometrie angegeben. "
#~ "Damit diese Funktion sinnvolle Ergebnisse liefert, müssen die beiden "
#~ "geometrischen Layer dieselbe Projektion und dieselbe SRID aufweisen."

#~ msgid ""
#~ "For <type>geography</type> units are in meters and measurement is "
#~ "defaulted to <varname>use_spheroid</varname>=true, for faster check, "
#~ "<varname>use_spheroid</varname>=false to measure along sphere."
#~ msgstr ""
#~ "Beim geographischen Datentyp <type>geography</type> ist die Einheit Meter "
#~ "und die Messung wird standardmäßig mit <varname>use_spheroid</"
#~ "varname>=true ausgeführt. Für eine schnellere Überprüfung können Sie "
#~ "<varname>use_spheroid</varname>=false setzen, um auf einer Kugel zu "
#~ "messen."

#~ msgid ""
#~ "Prior to 1.3, ST_Expand was commonly used in conjunction with &amp;&amp; "
#~ "and ST_Distance to achieve the same effect and in pre-1.3.4 this function "
#~ "was basically short-hand for that construct. From 1.3.4, ST_DWithin uses "
#~ "a more short-circuit distance function which should make it more "
#~ "efficient than prior versions for larger buffer regions."
#~ msgstr ""
#~ "Vor 1.3 wurde ST_Expand üblicherweise in Verbindung mit &amp;&amp; und "
#~ "ST_Distance verwendet um den selben Effekt zu erzielen. In "
#~ "Vorgängerversionen von 1.3.4 war dieser Funktionsname grundsätzlich das "
#~ "Kürzel für dieses Konstrukt. Ab 1.3.4 verwendet ST_DWithin eine kürzere "
#~ "Auswertung für die Distanzfunktion, wodurch sie bei größeren "
#~ "Pufferbereichen effizienter machen dürfte."

#~ msgid "Use ST_3DDWithin if you have 3D geometries."
#~ msgstr "Verwenden Sie bitte ST_3DDWithin für eine 3D-Geometrie."

#~ msgid "Availability: 1.5.0 support for geography was introduced"
#~ msgstr ""
#~ "Verfügbarkeit: Mit 1.5.0 wurde die Unterstützung von geograpischen "
#~ "Koordinaten eingeführt"

#~ msgid ""
#~ "Enhanced: 2.1.0 improved speed for geography. See <ulink url=\"http://"
#~ "blog.opengeo.org/2012/07/12/making-geography-faster/\">Making Geography "
#~ "faster</ulink> for details."
#~ msgstr ""
#~ "Enhanced: 2.1.0 Geschwindigkeitsverbesserung beim geographischen "
#~ "Datentyp. Siehe <ulink url=\"http://blog.opengeo.org/2012/07/12/making-"
#~ "geography-faster/\">Making Geography faster</ulink> für Details."

#~ msgid "Enhanced: 2.1.0 support for curved geometries was introduced."
#~ msgstr ""
#~ "Erweiterung: 2.1.0 - Unterstützung für Kurven beim geometrischen Datentyp "
#~ "eingeführt."

#~ msgid ""
#~ "-- Find the nearest hospital to each school\n"
#~ "-- that is within 3000 units of the school.\n"
#~ "--  We do an ST_DWithin search to utilize indexes to limit our search "
#~ "list\n"
#~ "--  that the non-indexable ST_Distance needs to process\n"
#~ "-- If the units of the spatial reference is meters then units would be "
#~ "meters\n"
#~ "SELECT DISTINCT ON (s.gid) s.gid, s.school_name, s.geom, h.hospital_name\n"
#~ "        FROM schools s\n"
#~ "                LEFT JOIN hospitals h ON ST_DWithin(s.the_geom, h.geom, "
#~ "3000)\n"
#~ "        ORDER BY s.gid, ST_Distance(s.geom, h.geom);\n"
#~ "\n"
#~ "-- The schools with no close hospitals\n"
#~ "-- Find all schools with no hospital within 3000 units\n"
#~ "-- away from the school.  Units is in units of spatial ref (e.g. meters, "
#~ "feet, degrees)\n"
#~ "SELECT s.gid, s.school_name\n"
#~ "        FROM schools s\n"
#~ "                LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, "
#~ "3000)\n"
#~ "        WHERE h.gid IS NULL;\n"
#~ "\n"
#~ "-- Find broadcasting towers that receiver with limited range can "
#~ "receive.\n"
#~ "-- Data is geometry in Spherical Mercator (SRID=3857), ranges are "
#~ "approximate.\n"
#~ "\n"
#~ "-- Create geometry index that will check proximity limit of user to "
#~ "tower\n"
#~ "CREATE INDEX ON broadcasting_towers using gist (geom);\n"
#~ "\n"
#~ "-- Create geometry index that will check proximity limit of tower to "
#~ "user\n"
#~ "CREATE INDEX ON broadcasting_towers using gist (ST_Expand(geom, "
#~ "sending_range));\n"
#~ "\n"
#~ "-- Query towers that 4-kilometer receiver in Minsk Hackerspace can get\n"
#~ "-- Note: two conditions, because shorter LEAST(b.sending_range, 4000) "
#~ "will not use index.\n"
#~ "SELECT b.tower_id, b.geom\n"
#~ "  FROM broadcasting_towers b\n"
#~ "  WHERE ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', 4000)\n"
#~ "          AND ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', "
#~ "b.sending_range);"
#~ msgstr ""
#~ "-- Das nächstgelegene Spital zu jeder Schule finden\n"
#~ "-- das innerhalb von 3000 Einheiten zur Schule liegt.\n"
#~ "--  Wir führen eine Suche mit ST_DWithin aus um die Indizes zu nutzen und "
#~ "die Suchliste einzugrenzen,\n"
#~ "--  welche eine nicht mit ST_Distanceindizierte Suche verarbeiten müsste\n"
#~ "--Wenn die Einheiten des Koordinatenreferenzsystems Meter sind, dann sind "
#~ "die Einheiten in Meter\n"
#~ "SELECT DISTINCT ON (s.gid) s.gid, s.school_name, s.geom, h.hospital_name\n"
#~ "        FROM schools s\n"
#~ "                LEFT JOIN hospitals h ON ST_DWithin(s.the_geom, h.geom, "
#~ "3000)\n"
#~ "        ORDER BY s.gid, ST_Distance(s.geom, h.geom);\n"
#~ "\n"
#~ "-- Die Schulen ohne Spital in der Nähe\n"
#~ "-- Alle Schulen finden, die kein Spital innerhalb einer Entfernung von "
#~ "3000 Einheiten haben\n"
#~ "-- Die Einheiten sind in den Einheiten des Koordinatenreferenzsystem (z."
#~ "B. Meter, Fuß, Grad)\n"
#~ "SELECT s.gid, s.school_name\n"
#~ "        FROM schools s\n"
#~ "                LEFT JOIN hospitals h ON ST_DWithin(s.geom, h.geom, "
#~ "3000)\n"
#~ "        WHERE h.gid IS NULL;\n"
#~ "\n"
#~ "-- Find broadcasting towers that receiver with limited range can "
#~ "receive.\n"
#~ "-- Data is geometry in Spherical Mercator (SRID=3857), ranges are "
#~ "approximate.\n"
#~ "\n"
#~ "-- Create geometry index that will check proximity limit of user to "
#~ "tower\n"
#~ "CREATE INDEX ON broadcasting_towers using gist (geom);\n"
#~ "\n"
#~ "-- Create geometry index that will check proximity limit of tower to "
#~ "user\n"
#~ "CREATE INDEX ON broadcasting_towers using gist (ST_Expand(geom, "
#~ "sending_range));\n"
#~ "\n"
#~ "-- Query towers that 4-kilometer receiver in Minsk Hackerspace can get\n"
#~ "-- Note: two conditions, because shorter LEAST(b.sending_range, 4000) "
#~ "will not use index.\n"
#~ "SELECT b.tower_id, b.geom\n"
#~ "  FROM broadcasting_towers b\n"
#~ "  WHERE ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', 4000)\n"
#~ "          AND ST_DWithin(b.geom, 'SRID=3857;POINT(3072163.4 7159374.1)', "
#~ "b.sending_range);"

#~ msgid ", <xref linkend=\"ST_Expand\"/>, <xref linkend=\"ST_3DDWithin\"/>"
#~ msgstr ", <xref linkend=\"ST_Expand\"/>, <xref linkend=\"ST_3DDWithin\"/>"

#~ msgid "ST_Equals"
#~ msgstr "ST_Equals"

#~ msgid ""
#~ "Returns true if the given geometries represent the same geometry. "
#~ "Directionality is ignored."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn die gegebenen geometrischen Objekte dieselbe "
#~ "Geometrie repräsentieren. Die Richtungsabhängigkeit wird ignoriert."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Equals</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Equals</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#~ msgid ""
#~ "Returns TRUE if the given Geometries are \"spatially equal\". Use this "
#~ "for a 'better' answer than '='. Note by spatially equal we mean "
#~ "ST_Within(A,B) = true and ST_Within(B,A) = true and also mean ordering of "
#~ "points can be different but represent the same geometry structure. To "
#~ "verify the order of points is consistent, use ST_OrderingEquals (it must "
#~ "be noted ST_OrderingEquals is a little more stringent than simply "
#~ "verifying order of points are the same)."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn die gegebenen Geometrien \"räumlich ident\" sind. "
#~ "Sie können dies als eine genauere Antwort als mit '=' ansehen. Mit "
#~ "\"räumlich ident\" meinen wir ST_Within(A,B) = TRUE und ST_Within(B,A) = "
#~ "TRUE; und weiters, dass die Reihenfolge der Stützpunkte unterschiedlich "
#~ "sein kann, aber die gleiche geometrische Form ergeben muss. Um zu "
#~ "überprüfen ob die Reihenfolge der Punkte übereinstimmt, können Sie "
#~ "ST_OrderingEquals verwenden (es muss allerdings erwähnt werden, dass "
#~ "ST_OrderingEquals noch strikter ist und mehr als nur die Übereinstimmung "
#~ "der Reihenfolge der Punkte überprüft)."

#~ msgid ""
#~ "This function will return false if either geometry is invalid except in "
#~ "the case where they are binary equal."
#~ msgstr ""
#~ "Diese Funktion gibt FALSE zurück, wenn eines der geometrischen Objekte "
#~ "invalid ist; ausgenommen sie sind binär ident."

#~ msgid "Do not call with a GEOMETRYCOLLECTION as an argument."
#~ msgstr "Bitte nicht mit einer GEOMETRYCOLLECTION als Übergabewert aufrufen."

#~ msgid "&sfs_compliant; s2.1.1.2"
#~ msgstr "&sfs_compliant; s2.1.1.2"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.24"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.24"

#~ msgid ""
#~ "Changed: 2.2.0 Returns true even for invalid geometries if they are "
#~ "binary equal"
#~ msgstr ""
#~ "Änderung: 2.2.0 Gibt auch bei nicht validen geometrischen Objekten TRUE "
#~ "zurück, wenn sie binär ident sind"

#~ msgid ""
#~ "SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_equals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_Equals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_equals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_Equals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_equals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_Equals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 10)')),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_equals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)"

#~ msgid ""
#~ ", <xref linkend=\"ST_OrderingEquals\"/>, <xref linkend=\"ST_Reverse\"/>, "
#~ "<xref linkend=\"ST_Within\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_OrderingEquals\"/>, <xref linkend=\"ST_Reverse\"/>, "
#~ "<xref linkend=\"ST_Within\"/>"

#~ msgid "ST_GeometricMedian"
#~ msgstr "ST_GeometricMedian"

#~ msgid "Returns the geometric median of a MultiPoint."
#~ msgstr "Gibt den geometrischen Median eines Mehrfachpunktes zurück."

#~ msgid ""
#~ "<funcdef>geometry <function> ST_GeometricMedian </function> </funcdef> "
#~ "<paramdef> <type> geometry </type> <parameter> g </parameter> </paramdef> "
#~ "<paramdef> <type> float8 </type> <parameter> tolerance </parameter> </"
#~ "paramdef> <paramdef> <type> int </type> <parameter> max_iter </parameter> "
#~ "</paramdef> <paramdef> <type> boolean </type> <parameter> "
#~ "fail_if_not_converged </parameter> </paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function> ST_GeometricMedian </function> </funcdef> "
#~ "<paramdef> <type> geometry </type> <parameter> g </parameter> </paramdef> "
#~ "<paramdef> <type> float8 </type> <parameter> tolerance </parameter> </"
#~ "paramdef> <paramdef> <type> int </type> <parameter> max_iter </parameter> "
#~ "</paramdef> <paramdef> <type> boolean </type> <parameter> "
#~ "fail_if_not_converged </parameter> </paramdef>"

#~ msgid ""
#~ "Computes the approximate geometric median of a MultiPoint geometry using "
#~ "the Weiszfeld algorithm. The geometric median provides a centrality "
#~ "measure that is less sensitive to outlier points than the centroid."
#~ msgstr ""
#~ "Näherungsweise Berechnung des geometrischen Median einer MultiPoint-"
#~ "Geometrie mit dem Weiszfeld Algorithmus. Der geometrische Median ist ein "
#~ "Maß von zentraler Bedeutung, das weniger anfällig für Ausreißer ist als "
#~ "der geometrische Schwerpunkt. "

#~ msgid ""
#~ "The algorithm will iterate until the distance change between successive "
#~ "iterations is less than the supplied <varname>tolerance</varname> "
#~ "parameter. If this condition has not been met after "
#~ "<varname>max_iterations</varname> iterations, the function will produce "
#~ "an error and exit, unless <varname>fail_if_not_converged</varname> is set "
#~ "to false."
#~ msgstr ""
#~ "Der Algorithmus iteriert solange, bis die Distanzänderung zwischen "
#~ "aufeinanderfolgenden Iterationen kleiner ist als der für den Parameter "
#~ "<varname>tolerance</varname> gegebene Wert. Wenn diese Bedingung nach "
#~ "<varname>max_iterations</varname> Iterationen nicht erfüllt ist, dann "
#~ "gibt die Funktion eine Fehlermeldung aus und endet; außer es wird "
#~ "<varname>fail_if_not_converged</varname> auf FALSE gesetzt. Wenn kein "
#~ "Toleranzwert angegeben ist, dann wird basierend auf der Ausdehnung der "
#~ "Eingabegeometrie ein Standardtoleranzwert errechnet."

#~ msgid ""
#~ "If a <varname>tolerance</varname> value is not provided, a default "
#~ "tolerance value will be calculated based on the extent of the input "
#~ "geometry."
#~ msgstr ""
#~ "Wenn kein Toleranzwert <varname>tolerance</varname> angegeben ist, dann "
#~ "wird basierend auf der Ausdehnung der Eingabegeometrie ein "
#~ "Standardtoleranzwert errechnet."

#~ msgid ""
#~ "M value of points, if present, is interpreted as their relative weight."
#~ msgstr ""
#~ "Der Wert M der Punkte wird als deren relatives Gewicht interpretiert."

#~ msgid "Enhanced: 2.5.0 Added support for M as weight of points."
#~ msgstr ""
#~ " Erweiterung: 2.5.0 Unterstützung für M zur Gewichtung nach Punkten."

#~ msgid "&M_support;"
#~ msgstr "&M_support;"

#~ msgid ""
#~ "Comparison of the centroid (turquoise point) and geometric median (red "
#~ "point) of a four-point MultiPoint (yellow points)."
#~ msgstr ""
#~ "Vergleich zwischen geometrischem Schwerpunkt (türkiser Punkt) und "
#~ "geometrischem Median (roter Punkt) für einen Mehrfachpunkt (gelbe Punkte) "
#~ "aus vier Punkten."

#~ msgid ""
#~ "WITH test AS (\n"
#~ "SELECT 'MULTIPOINT((0 0), (1 1), (2 2), (200 200))'::geometry geom)\n"
#~ "SELECT\n"
#~ "  ST_AsText(ST_Centroid(geom)) centroid,\n"
#~ "  ST_AsText(ST_GeometricMedian(geom)) median\n"
#~ "FROM test;\n"
#~ "      centroid      |                 median\n"
#~ "--------------------+----------------------------------------\n"
#~ " POINT(50.75 50.75) | POINT(1.9761550281255 1.9761550281255)\n"
#~ "(1 row)"
#~ msgstr ""
#~ "WITH test AS (\n"
#~ "SELECT 'MULTIPOINT((0 0), (1 1), (2 2), (200 200))'::geometry geom)\n"
#~ "SELECT\n"
#~ "  ST_AsText(ST_Centroid(geom)) centroid,\n"
#~ "  ST_AsText(ST_GeometricMedian(geom)) median\n"
#~ "FROM test;\n"
#~ "      centroid      |                 median\n"
#~ "--------------------+----------------------------------------\n"
#~ " POINT(50.75 50.75) | POINT(1.9761550281255 1.9761550281255)\n"
#~ "(1 row)"

#~ msgid "ST_HasArc"
#~ msgstr "ST_HasArc"

#~ msgid ""
#~ "<refpurpose>Returns true if a geometry or geometry collection contains a "
#~ "circular string</refpurpose>"
#~ msgstr ""
#~ "<refpurpose>Gibt TRUE zurück, wenn eine Geometrie oder eine "
#~ "Sammelgeometrie einen Kreisbogen enthält</refpurpose>"

#~ msgid ""
#~ "<funcdef>boolean <function>ST_HasArc</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_HasArc</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>"

#~ msgid ""
#~ "<para>Returns true if a geometry or geometry collection contains a "
#~ "circular string</para>"
#~ msgstr ""
#~ "<para>Gibt TRUE zurück, wenn eine Geometrie oder eine Sammelgeometrie "
#~ "einen Kreisbogen enthält</para>"

#~ msgid "Availability: 1.2.3?"
#~ msgstr "Verfügbarkeit: 1.2.3?"

#~ msgid ""
#~ "SELECT ST_HasArc(ST_Collect('LINESTRING(1 2, 3 4, 5 6)', "
#~ "'CIRCULARSTRING(1 1, 2 3, 4 5, 6 7, 5 6)'));\n"
#~ "                st_hasarc\n"
#~ "                --------\n"
#~ "                t"
#~ msgstr ""
#~ "SELECT ST_HasArc(ST_Collect('LINESTRING(1 2, 3 4, 5 6)', "
#~ "'CIRCULARSTRING(1 1, 2 3, 4 5, 6 7, 5 6)'));\n"
#~ "                st_hasarc\n"
#~ "                --------\n"
#~ "                t"

#~ msgid ", <xref linkend=\"ST_LineToCurve\"/>"
#~ msgstr ", <xref linkend=\"ST_LineToCurve\"/>"

#~ msgid "ST_Intersects"
#~ msgstr "ST_Intersects"

#~ msgid ""
#~ "Returns TRUE if the Geometries/Geography \"spatially intersect in 2D\" - "
#~ "(share any portion of space) and FALSE if they don't (they are Disjoint). "
#~ "For geography -- tolerance is 0.00001 meters (so any points that close "
#~ "are considered to intersect)"
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn sich die geometrischen/geographischen Objekte "
#~ "\"räumlich in 2D schneiden\" (einen Teil des Raumes teilen); und FALSE "
#~ "wenn nicht (sie getrennt sind). Beim geographischen Datentyp beträgt die "
#~ "Toleranz 0.00001 Meter (d.h.: Punkte die so knapp beisammen liegen werden "
#~ "als sich schneidend betrachtet)"

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Intersects</function></"
#~ "funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
#~ "paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
#~ "<function>ST_Intersects</function></funcdef> <paramdef> <type>geography</"
#~ "type> <parameter>geogA</parameter> </paramdef> <paramdef> "
#~ "<type>geography</type> <parameter>geogB</parameter> </paramdef> </"
#~ "funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Intersects</function></"
#~ "funcdef> <paramdef> <type>geometry</type> <parameter>geomA</parameter> </"
#~ "paramdef> <paramdef> <type>geometry</type> <parameter>geomB</parameter> </"
#~ "paramdef> </funcprototype> <funcprototype> <funcdef>boolean "
#~ "<function>ST_Intersects</function></funcdef> <paramdef> <type>geography</"
#~ "type> <parameter>geogA</parameter> </paramdef> <paramdef> "
#~ "<type>geography</type> <parameter>geogB</parameter> </paramdef> </"
#~ "funcprototype>"

#~ msgid ""
#~ "If a geometry or geography shares any portion of space then they "
#~ "intersect. For geography -- tolerance is 0.00001 meters (so any points "
#~ "that are close are considered to intersect)"
#~ msgstr ""
#~ "Wenn sich geometrische oder geographische Objekte einen Teil des Raums "
#~ "teilen, dann schneiden sie sich. Beim geographischen Datentyp beträgt die "
#~ "Toleranz 0.00001 Meter (d.h.: Punkte die so knapp beisammen liegen werden "
#~ "als sich schneidend betrachtet)"

#~ msgid "Enhanced: 2.5.0 Supports GEOMETRYCOLLECTION."
#~ msgstr "Erweiterung: 2.5.0 Unterstützng von GEOMETRYCOLLECTION."

#~ msgid "Performed by the GEOS module (for geometry), geography is native"
#~ msgstr ""
#~ "Wird beim geometrischen Datentyp mit dem GEOS Modul ausgeführt; beim "
#~ "geographischen Datentyp nativ."

#~ msgid "Availability: 1.5 support for geography was introduced."
#~ msgstr "Verfügbarkeit: 1.5 - Unterstützung von geograpischen Koordinaten."

#~ msgid ""
#~ "For geography, this function has a distance tolerance of about 0.00001 "
#~ "meters and uses the sphere rather than spheroid calculation."
#~ msgstr ""
#~ "Beim geographischen Datentyp beträgt die Abstandstoleranz für diese "
#~ "Funktion etwa 0.00001 Meter und die Berechnung erfolgt auf einer Kugel "
#~ "anstatt auf dem Referenzellipsoid."

#~ msgid ""
#~ "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - ST_Intersects(g1, g2 ) --&gt; Not "
#~ "(ST_Disjoint(g1, g2 ))"
#~ msgstr ""
#~ "&sfs_compliant; s2.1.1.2 //s2.1.13.3 - ST_Intersects(g1, g2 ) --&gt; Not "
#~ "(ST_Disjoint(g1, g2 ))"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.27"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.27"

#~ msgid ""
#~ "SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_intersects\n"
#~ "---------------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_intersects\n"
#~ "---------------\n"
#~ " t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_intersects\n"
#~ "---------------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "SELECT ST_Intersects('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::"
#~ "geometry);\n"
#~ " st_intersects\n"
#~ "---------------\n"
#~ " t\n"
#~ "(1 row)"

#~ msgid ", <xref linkend=\"ST_Disjoint\"/>"
#~ msgstr ", <xref linkend=\"ST_Disjoint\"/>"

#~ msgid ""
#~ "Returns the 2D length of the geometry if it is a LineString or "
#~ "MultiLineString. geometry are in units of spatial reference and geography "
#~ "are in meters (default spheroid)"
#~ msgstr ""
#~ "Gibt die 2D -Länge einer Linie oder einer Mehrfachlinie zurück. Beim "
#~ "geometrischen Datentyp sind die Einheiten in jenen des "
#~ "Koordinatenreferenzsystems, beim geographischen Datentyp in Meter "
#~ "(Standardmäßiges Referenzellipsoid)"

#~ msgid ""
#~ "<refpurpose>Returns the 2-dimensional length of the geometry if it is a "
#~ "linestring or multi-linestring. This is an alias for <varname>ST_Length</"
#~ "varname></refpurpose>"
#~ msgstr ""
#~ "<refpurpose>Gibt die 2-dimensionale Länge einer Linie oder einer "
#~ "Mehrfachlinie zurück. Dies ist ein Alias für <varname>ST_Length</"
#~ "varname></refpurpose>"

#~ msgid ""
#~ "Returns the 3-dimensional or 2-dimensional length of the geometry if it "
#~ "is a linestring or multi-linestring."
#~ msgstr ""
#~ "Gibt die 2- oder 3-dimensionale Länge einer Linie oder einer "
#~ "Mehrfachlinie zurück."

#~ msgid ""
#~ "Calculates the 2D or 3D length/perimeter of a geometry on an ellipsoid. "
#~ "This is useful if the coordinates of the geometry are in longitude/"
#~ "latitude and a length is desired without reprojection."
#~ msgstr ""
#~ "Berechnet die/den 2D oder 3D Länge/Umfang einer Geometrie auf einem "
#~ "Ellipsoid. Dies ist nützlich wenn die Koordinaten der Geometrie in Länge "
#~ "und Breite vorliegen, und die Länge der Geometrie benötigt wird, ohne "
#~ "dass umprojiziert werden muss."

#~ msgid "ST_Length2D_Spheroid"
#~ msgstr "ST_Length2D_Spheroid"

#~ msgid ""
#~ "Calculates the 2D length/perimeter of a geometry on an ellipsoid. This is "
#~ "useful if the coordinates of the geometry are in longitude/latitude and a "
#~ "length is desired without reprojection."
#~ msgstr ""
#~ "Berechnet die/den 2D Länge/Umfang einer Geometrie auf einem Ellipsoid. "
#~ "Dies ist nützlich wenn die Koordinaten der Geometrie in Länge und Breite "
#~ "vorliegen, und die Länge der Geometrie benötigt wird, ohne dass "
#~ "umprojiziert werden muss."

#~ msgid ""
#~ "<funcdef>float <function>ST_Length2D_Spheroid</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>a_geometry</parameter></"
#~ "paramdef> <paramdef><type>spheroid </type> <parameter>a_spheroid</"
#~ "parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>float <function>ST_Length2D_Spheroid</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>a_geometry</parameter></"
#~ "paramdef> <paramdef><type>spheroid </type> <parameter>a_spheroid</"
#~ "parameter></paramdef>"

#~ msgid ""
#~ "Calculates the 2D length/perimeter of a geometry on an ellipsoid. This is "
#~ "useful if the coordinates of the geometry are in longitude/latitude and a "
#~ "length is desired without reprojection. The ellipsoid is a separate "
#~ "database type and can be constructed as follows:"
#~ msgstr ""
#~ "Berechnet die/den 2D Länge/Umfang einer Geometrie auf einem Ellipsoid. "
#~ "Dies ist nützlich wenn die Koordinaten der Geometrie in Länge und Breite "
#~ "vorliegen, und die Länge der Geometrie ohne benötigt wird, ohne dass "
#~ "umprojiziert werden muss. Das Ellipsoid ist ein eigener Datentyp und kann "
#~ "wie folgt erstellt werden:"

#~ msgid ""
#~ "This is much like <xref linkend=\"ST_Length_Spheroid\"/> except it will "
#~ "ignore the Z ordinate in calculations."
#~ msgstr ""
#~ "Dies ist ähnlich zu <xref linkend=\"ST_Length_Spheroid\"/>, außer dass "
#~ "die Z-Ordinate in den Berechnungen ignoriert wird."

#~ msgid ""
#~ "SELECT ST_Length2D_Spheroid( geometry_column,\n"
#~ "                          'SPHEROID[\"GRS_1980\",6378137,298.257222101]' )\n"
#~ "                          FROM geometry_table;\n"
#~ "\n"
#~ "SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
#~ "                          FROM (SELECT "
#~ "ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),\n"
#~ "        (-71.05957 42.3589 , -71.061 43))') As the_geom,\n"
#~ "CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As "
#~ "sph_m)  as foo;\n"
#~ "        tot_len      |    len_line1     |    len_line2\n"
#~ "------------------+------------------+------------------\n"
#~ " 85204.5207562955 | 13986.8725229309 | 71217.6482333646\n"
#~ "\n"
#~ " --3D Observe same answer\n"
#~ "SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
#~ "                          FROM (SELECT "
#~ "ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),\n"
#~ "        (-71.05957 42.3589 75, -71.061 43 90))') As the_geom,\n"
#~ "CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As "
#~ "sph_m)  as foo;\n"
#~ "\n"
#~ "        tot_len      |    len_line1     |    len_line2\n"
#~ "------------------+------------------+------------------\n"
#~ " 85204.5207562955 | 13986.8725229309 | 71217.6482333646"
#~ msgstr ""
#~ "SELECT ST_Length2D_Spheroid( geometry_column,\n"
#~ "                          'SPHEROID[\"GRS_1980\",6378137,298.257222101]' )\n"
#~ "                          FROM geometry_table;\n"
#~ "\n"
#~ "SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
#~ "                          FROM (SELECT "
#~ "ST_GeomFromText('MULTILINESTRING((-118.584 38.374,-118.583 38.5),\n"
#~ "        (-71.05957 42.3589 , -71.061 43))') As the_geom,\n"
#~ "CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As "
#~ "sph_m)  as foo;\n"
#~ "        tot_len      |    len_line1     |    len_line2\n"
#~ "------------------+------------------+------------------\n"
#~ " 85204.5207562955 | 13986.8725229309 | 71217.6482333646\n"
#~ "\n"
#~ " --3D Observe same answer\n"
#~ "SELECT ST_Length2D_Spheroid( the_geom, sph_m ) As tot_len,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,1), sph_m) As len_line1,\n"
#~ "ST_Length2D_Spheroid(ST_GeometryN(the_geom,2), sph_m) As len_line2\n"
#~ "                          FROM (SELECT "
#~ "ST_GeomFromEWKT('MULTILINESTRING((-118.584 38.374 20,-118.583 38.5 30),\n"
#~ "        (-71.05957 42.3589 75, -71.061 43 90))') As the_geom,\n"
#~ "CAST('SPHEROID[\"GRS_1980\",6378137,298.257222101]' As spheroid) As "
#~ "sph_m)  as foo;\n"
#~ "\n"
#~ "        tot_len      |    len_line1     |    len_line2\n"
#~ "------------------+------------------+------------------\n"
#~ " 85204.5207562955 | 13986.8725229309 | 71217.6482333646"

#~ msgid ", <xref linkend=\"ST_Length_Spheroid\"/>"
#~ msgstr ", <xref linkend=\"ST_Length_Spheroid\"/>"

#~ msgid ""
#~ "Returns the 2-dimensional longest line points of two geometries. The "
#~ "function will only return the first longest line if more than one, that "
#~ "the function finds. The line returned will always start in g1 and end in "
#~ "g2. The length of the line this function returns will always be the same "
#~ "as st_maxdistance returns for g1 and g2."
#~ msgstr ""
#~ "Gibt den größten 2-dimensionalen Abstand zwischen zwei geometrischen "
#~ "Objekten als Linie zurück. Wenn es mehr als einen größten Abstand gibt, "
#~ "dann wird nur die erste Linie zurückgegeben, die von der Funktion "
#~ "gefunden wird. Die zurückgegebene Linie fängt immer mit \"g1\" an und "
#~ "endet mit \"g2\". Die Länge der Linie die von dieser Funktion "
#~ "zurückgegeben wird ist immer ident mit der von st_maxdistance für \"g1\" "
#~ "und \"g2\" zurückgegebenen Distanz."

#~ msgid "ST_OrderingEquals"
#~ msgstr "ST_OrderingEquals"

#~ msgid ""
#~ "Returns true if the given geometries represent the same geometry and "
#~ "points are in the same directional order."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn die gegebenen geometrischen Objekte ident sind und "
#~ "deren Punkte in der selben Reihenfolge ausgerichtet sind."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_OrderingEquals</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_OrderingEquals</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#~ msgid ""
#~ "ST_OrderingEquals compares two geometries and returns t (TRUE) if the "
#~ "geometries are equal and the coordinates are in the same order; otherwise "
#~ "it returns f (FALSE)."
#~ msgstr ""
#~ "ST_OrderingEquals vergleicht zwei geometrische Objekte und gibt t (TRUE) "
#~ "zurück, wenn die geometrischen Objekte übereinstimmen und die Koordinaten "
#~ "in der gleichen Reihenfolge vorliegen; sonst wird f (FALSE) zurückgegeben."

#~ msgid ""
#~ "This function is implemented as per the ArcSDE SQL specification rather "
#~ "than SQL-MM. http://edndoc.esri.com/arcsde/9.1/sql_api/sqlapi3."
#~ "htm#ST_OrderingEquals"
#~ msgstr ""
#~ "Diese Funktion implementiert die ArcSDE SQL Spezifikation anstatt SQL-MM. "
#~ "http://edndoc.esri.com/arcsde/9.1/sql_api/sqlapi3.htm#ST_OrderingEquals"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.43"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.43"

#~ msgid ""
#~ "SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_OrderingEquals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 "
#~ "10)')),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " f\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 5 5, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_OrderingEquals(ST_GeomFromText('LINESTRING(0 0, 10 10)'),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " t\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_OrderingEquals(ST_Reverse(ST_GeomFromText('LINESTRING(0 0, 10 "
#~ "10)')),\n"
#~ "                ST_GeomFromText('LINESTRING(0 0, 0 0, 10 10)'));\n"
#~ " st_orderingequals\n"
#~ "-----------\n"
#~ " f\n"
#~ "(1 row)"

#~ msgid ", <xref linkend=\"ST_Reverse\"/>"
#~ msgstr ", <xref linkend=\"ST_Reverse\"/>"

#~ msgid "ST_Overlaps"
#~ msgstr "ST_Overlaps"

#~ msgid ""
#~ "Returns TRUE if the Geometries share space, are of the same dimension, "
#~ "but are not completely contained by each other."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn sich die geometrischen Objekte einen Raum teilen, "
#~ "die gleiche Dimension haben, aber sich nicht zur Gänze beinhalten."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Overlaps</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Overlaps</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#~ msgid ""
#~ "Returns TRUE if the Geometries \"spatially overlap\". By that we mean "
#~ "they intersect, but one does not completely contain another."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn sich die geometrischen Objekte \"räumlich "
#~ "überdecken\". Das heißt sie schneiden sich und eine Geometrie enthält die "
#~ "andere Geometrie nicht zur Gänze."

#~ msgid "Do not call with a GeometryCollection as an argument"
#~ msgstr "Bitte nicht mit dem Argument \"GeometryCollection\" aufrufen"

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_Overlaps."
#~ msgstr ""
#~ "Dieser Funktionsaufruf bezieht einen automatischen Lagevergleich der "
#~ "umschreibenden Rechtecke mit ein. Dadurch werden sämtliche Indizes "
#~ "genutzt, die für die geometrischen Objekte vorhanden sind. Um die "
#~ "Verwendung von Indizes zu verhindern, benutzen Sie bitte _ST_Overlaps."

#~ msgid "&sfs_compliant; s2.1.1.2 // s2.1.13.3"
#~ msgstr "&sfs_compliant; s2.1.1.2 // s2.1.13.3"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.32"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.32"

#~ msgid "<varname>MULTIPOINT</varname> / <varname>MULTIPOINT</varname>"
#~ msgstr "<varname>MULTIPOINT</varname> / <varname>MULTIPOINT</varname>"

#~ msgid ""
#~ "--a point on a line is contained by the line and is of a lower dimension, "
#~ "and therefore does not overlap the line\n"
#~ "                        nor crosses\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b,\n"
#~ "        ST_Crosses(a,b) As a_crosses_b,\n"
#~ "                ST_Intersects(a, b) As a_intersects_b, ST_Contains(b,a) "
#~ "As b_contains_a\n"
#~ "FROM (SELECT ST_GeomFromText('POINT(1 0.5)') As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "        As foo\n"
#~ "\n"
#~ "a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a\n"
#~ "------------+-------------+----------------+--------------\n"
#~ "f           | f           | t              | t\n"
#~ "\n"
#~ "--a line that is partly contained by circle, but not fully is defined as "
#~ "intersecting and crossing,\n"
#~ "-- but since of different dimension it does not overlap\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b,\n"
#~ "        ST_Intersects(a, b) As a_intersects_b,\n"
#~ "        ST_Contains(a,b) As a_contains_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "        As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | a_contains_b\n"
#~ "-------------+-------------+----------------+--------------\n"
#~ " f           | t           | t              | f\n"
#~ "\n"
#~ " -- a 2-dimensional bent hot dog (aka buffered line string) that "
#~ "intersects a circle,\n"
#~ " --        but is not fully contained by the circle is defined as "
#~ "overlapping since they are of the same dimension,\n"
#~ "--        but it does not cross, because the intersection of the 2 is of "
#~ "the same dimension\n"
#~ "--        as the maximum dimension of the 2\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b, "
#~ "ST_Intersects(a, b) As a_intersects_b,\n"
#~ "ST_Contains(b,a) As b_contains_a,\n"
#~ "ST_Dimension(a) As dim_a, ST_Dimension(b) as dim_b, "
#~ "ST_Dimension(ST_Intersection(a,b)) As dima_intersection_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a,\n"
#~ "        ST_Buffer(ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)'),0.5)  As "
#~ "b)\n"
#~ "        As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a | dim_a | "
#~ "dim_b | dima_intersection_b\n"
#~ "-------------+-------------+----------------+--------------+-------"
#~ "+-------+---------------------\n"
#~ " t           | f           | t              | f            |     2 |     "
#~ "2 |              2"
#~ msgstr ""
#~ "-- ein Punkt auf einer Linie ist in der Linie enthalten und hat eine "
#~ "niedrigere Dimension, wodurch er die Linie weder überlappt noch kreuzt\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b,\n"
#~ "        ST_Crosses(a,b) As a_crosses_b,\n"
#~ "                ST_Intersects(a, b) As a_intersects_b, ST_Contains(b,a) "
#~ "As b_contains_a\n"
#~ "FROM (SELECT ST_GeomFromText('POINT(1 0.5)') As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "        As foo\n"
#~ "\n"
#~ "a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a\n"
#~ "------------+-------------+----------------+--------------\n"
#~ "f           | f           | t              | t\n"
#~ "\n"
#~ "-- eine Linie ist teilweise in einem Kreis enthalten, aber nicht "
#~ "vollständig als schneidend oder kreuzend bestimmt,\n"
#~ "-- da aufgrund unterschiedlicher Dimensionen keine Überlappung gegeben "
#~ "ist\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b,\n"
#~ "        ST_Intersects(a, b) As a_intersects_b,\n"
#~ "        ST_Contains(a,b) As a_contains_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a, "
#~ "ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)')  As b)\n"
#~ "        As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | a_contains_b\n"
#~ "-------------+-------------+----------------+--------------\n"
#~ " f           | t           | t              | f\n"
#~ "\n"
#~ " -- ein 2-dimensionales gebogenes Würstchen (aka gepufferter Linienzug) "
#~ "das einen Kreis schneidet,\n"
#~ " --        aber nicht vollständig in dem Kreis enthalten ist, wird als "
#~ "überlappend bestimmt, da beide die gleiche Dimension haben,\n"
#~ "--        aber es kreuzt nicht, da die Verschneidung der 2 die maximale "
#~ "Dimension von 2 aufweist\n"
#~ "\n"
#~ "SELECT ST_Overlaps(a,b) As a_overlap_b, ST_Crosses(a,b) As a_crosses_b, "
#~ "ST_Intersects(a, b) As a_intersects_b,\n"
#~ "ST_Contains(b,a) As b_contains_a,\n"
#~ "ST_Dimension(a) As dim_a, ST_Dimension(b) as dim_b, "
#~ "ST_Dimension(ST_Intersection(a,b)) As dima_intersection_b\n"
#~ "FROM (SELECT ST_Buffer(ST_GeomFromText('POINT(1 0.5)'), 3)  As a,\n"
#~ "        ST_Buffer(ST_GeomFromText('LINESTRING(1 0, 1 1, 3 5)'),0.5)  As "
#~ "b)\n"
#~ "        As foo;\n"
#~ "\n"
#~ " a_overlap_b | a_crosses_b | a_intersects_b | b_contains_a | dim_a | "
#~ "dim_b | dima_intersection_b\n"
#~ "-------------+-------------+----------------+--------------+-------"
#~ "+-------+---------------------\n"
#~ " t           | f           | t              | f            |     2 |     "
#~ "2 |              2"

#~ msgid ""
#~ ", <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Dimension\"/>, <xref "
#~ "linkend=\"ST_Intersects\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Dimension\"/>, <xref "
#~ "linkend=\"ST_Intersects\"/>"

#~ msgid ""
#~ "Return the length measurement of the boundary of an ST_Surface or "
#~ "ST_MultiSurface geometry or geography. (Polygon, MultiPolygon). geometry "
#~ "measurement is in units of spatial reference and geography is in meters."
#~ msgstr ""
#~ "Gibt für den geometrischen und den geographischen Datentyp die Länge der "
#~ "Begrenzung eines ST_Surface oder eines ST_MultiSurface (Polygon, "
#~ "MultiPolygon) zurück. Beim geometrischen Datentyp (Polygon, MultiPolygon) "
#~ "wird in den Einheiten des Koordinatenreferenzsystems gemessen, bei "
#~ "geographischen Koordinaten in Meter."

#~ msgid ""
#~ "Returns the 2-dimensional perimeter of the geometry, if it is a polygon "
#~ "or multi-polygon. This is currently an alias for ST_Perimeter."
#~ msgstr ""
#~ "Gibt den 2-dimensionalen Umfang eines Polygons oder eines "
#~ "Mehrfachpolygons zurück. Zurzeit ein Alias für ST_Perimeter."

#~ msgid ""
#~ "Returns the 3-dimensional perimeter of the geometry, if it is a polygon "
#~ "or multi-polygon."
#~ msgstr ""
#~ "Gibt den 3-dimensionalen Umfang eines Polygons oder eines "
#~ "Mehrfachpolygons zurück."

#~ msgid "ST_PointOnSurface"
#~ msgstr "ST_PointOnSurface"

#~ msgid "Returns a <varname>POINT</varname> guaranteed to lie on the surface."
#~ msgstr ""
#~ "Gibt einen <varname>POINT</varname> zurück, der garantiert auf der "
#~ "Oberfläche liegt."

#~ msgid ""
#~ "<funcdef>geometry <function>ST_PointOnSurface</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>geometry <function>ST_PointOnSurface</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>"

#~ msgid ""
#~ "Returns a <varname>POINT</varname> guaranteed to intersect a surface."
#~ msgstr ""
#~ "Gibt einen <varname>POINT</varname> zurück, der die Oberfläche sicher "
#~ "schneidet."

#~ msgid "&sfs_compliant; s3.2.14.2 // s3.2.18.2"
#~ msgstr "&sfs_compliant; s3.2.14.2 // s3.2.18.2"

#~ msgid ""
#~ "&sqlmm_compliant; SQL-MM 3: 8.1.5, 9.5.6. According to the specs, "
#~ "ST_PointOnSurface works for surface geometries (POLYGONs, MULTIPOLYGONS, "
#~ "CURVED POLYGONS). So PostGIS seems to be extending what the spec allows "
#~ "here. Most databases Oracle,DB II, ESRI SDE seem to only support this "
#~ "function for surfaces. SQL Server 2008 like PostGIS supports for all "
#~ "common geometries."
#~ msgstr ""
#~ "&sqlmm_compliant; SQL-MM 3: 8.1.5, 9.5.6. Entsprechend den "
#~ "Spezifikationen kann ST_PointOnSurface mit geometrischen Oberflächen "
#~ "(POLYGONs, MULTIPOLYGONs, CURVED POLYGONs) arbeiten. Daher scheint es, "
#~ "dass PostGIS die Spezifikationen in diesem Bereich erweitert. Die meisten "
#~ "Datenbanken, wie Oracle, DB II, ESRI SDE scheinen lediglich die "
#~ "Funktionen der Spezifikationen zu unterstützen. SQL Server 2008 "
#~ "unterstützt so wie PostGIS alle üblichen geometrischen Datentypen."

#~ msgid ""
#~ "SELECT ST_AsText(ST_PointOnSurface('POINT(0 5)'::geometry));\n"
#~ " st_astext\n"
#~ "------------\n"
#~ " POINT(0 5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_PointOnSurface('LINESTRING(0 5, 0 10)'::geometry));\n"
#~ " st_astext\n"
#~ "------------\n"
#~ " POINT(0 5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_PointOnSurface('POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))'::"
#~ "geometry));\n"
#~ "   st_astext\n"
#~ "----------------\n"
#~ " POINT(2.5 2.5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsEWKT(ST_PointOnSurface(ST_GeomFromEWKT('LINESTRING(0 5 1, 0 0 "
#~ "1, 0 10 2)')));\n"
#~ "   st_asewkt\n"
#~ "----------------\n"
#~ " POINT(0 0 1)\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_AsText(ST_PointOnSurface('POINT(0 5)'::geometry));\n"
#~ " st_astext\n"
#~ "------------\n"
#~ " POINT(0 5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_PointOnSurface('LINESTRING(0 5, 0 10)'::geometry));\n"
#~ " st_astext\n"
#~ "------------\n"
#~ " POINT(0 5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsText(ST_PointOnSurface('POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))'::"
#~ "geometry));\n"
#~ "   st_astext\n"
#~ "----------------\n"
#~ " POINT(2.5 2.5)\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_AsEWKT(ST_PointOnSurface(ST_GeomFromEWKT('LINESTRING(0 5 1, 0 0 "
#~ "1, 0 10 2)')));\n"
#~ "   st_asewkt\n"
#~ "----------------\n"
#~ " POINT(0 0 1)\n"
#~ "(1 row)"

#~ msgid ", <xref linkend=\"ST_Point_Inside_Circle\"/>"
#~ msgstr ", <xref linkend=\"ST_Point_Inside_Circle\"/>"

#~ msgid "ST_Relate"
#~ msgstr "ST_Relate"

#~ msgid ""
#~ "Returns true if this Geometry is spatially related to anotherGeometry, by "
#~ "testing for intersections between the Interior, Boundary and Exterior of "
#~ "the two geometries as specified by the values in the "
#~ "intersectionMatrixPattern. If no intersectionMatrixPattern is passed in, "
#~ "then returns the maximum intersectionMatrixPattern that relates the 2 "
#~ "geometries."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn die Geometrie einen räumlichen Zusammenhang mit "
#~ "einer anderen Geometrie hat; die Überprüfung erfolgt durch Verschneidung "
#~ "des Inneren, der Begrenzung und des Äusseren der beiden geometrischen "
#~ "Objekte, so wie es in den Werten des \"intersectionMatrixPattern\" "
#~ "festgelegt ist. Wenn kein \"intersectionMatrixPattern\" übergeben wird, "
#~ "dann wird der maximale \"intersectionMatrixPattern\" zurückgegeben, über "
#~ "den die 2 geometrischen Objekte in räumlichen Zusammenhang stehen."

#~ msgid ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Relate</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "<paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>text "
#~ "<function>ST_Relate</function></funcdef> <paramdef><type>geometry </type> "
#~ "<parameter>geomA</parameter></paramdef> <paramdef><type>geometry </type> "
#~ "<parameter>geomB</parameter></paramdef> </funcprototype> <funcprototype> "
#~ "<funcdef>text <function>ST_Relate</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "<paramdef><type>integer </type> <parameter>BoundaryNodeRule</parameter></"
#~ "paramdef> </funcprototype>"
#~ msgstr ""
#~ "<funcprototype> <funcdef>boolean <function>ST_Relate</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "<paramdef><type>text </type> <parameter>intersectionMatrixPattern</"
#~ "parameter></paramdef> </funcprototype> <funcprototype> <funcdef>text "
#~ "<function>ST_Relate</function></funcdef> <paramdef><type>geometry </type> "
#~ "<parameter>geomA</parameter></paramdef> <paramdef><type>geometry </type> "
#~ "<parameter>geomB</parameter></paramdef> </funcprototype> <funcprototype> "
#~ "<funcdef>text <function>ST_Relate</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef> "
#~ "<paramdef><type>integer </type> <parameter>BoundaryNodeRule</parameter></"
#~ "paramdef> </funcprototype>"

#~ msgid ""
#~ "Version 1: Takes geomA, geomB, intersectionMatrix and Returns 1 (TRUE) if "
#~ "this Geometry is spatially related to anotherGeometry, by testing for "
#~ "intersections between the Interior, Boundary and Exterior of the two "
#~ "geometries as specified by the values in the <ulink url=\"http://en."
#~ "wikipedia.org/wiki/DE-9IM\">DE-9IM matrix pattern</ulink>."
#~ msgstr ""
#~ "Version 1: Nimmt geomA, geomB und intersectionMatrixPattern. Gibt 1 "
#~ "(TRUE) zurück, wenn die Geometrie einen räumlichen Zusammenhang mit einer "
#~ "anderen Geometrie hat; die Überprüfung erfolgt durch Verschneidung des "
#~ "Inneren, der Begrenzung und des Äusseren der beiden geometrischen "
#~ "Objekte, so wie es in den Werten der <ulink url=\"http://en.wikipedia.org/"
#~ "wiki/DE-9IM\">DE-9IM-Matrix</ulink> festgelegt ist"

#~ msgid ""
#~ "This is especially useful for testing compound checks of intersection, "
#~ "crosses, etc in one step."
#~ msgstr ""
#~ "Dies ist besonders nützlich, wenn man die Überprüfungen auf Schneiden, "
#~ "Kreuzen, etc. in einen Schritt zusammenfassen will"

#~ msgid ""
#~ "This is the \"allowable\" version that returns a boolean, not an integer. "
#~ "This is defined in OGC spec"
#~ msgstr ""
#~ "Dies ist die \"erlaubende\" Version, welche einen booleschen Wert und "
#~ "keine Ganzzahl zurückgibt. Dies ist in der OGC Spezifikation definiert"

#~ msgid ""
#~ "This DOES NOT automagically include an index call. The reason for that is "
#~ "some relationships are anti e.g. Disjoint. If you are using a "
#~ "relationship pattern that requires intersection, then include the &amp;"
#~ "&amp; index call."
#~ msgstr ""
#~ "Dies bezieht nicht automatisch den Aufruf eines Index mit ein. Der Grund "
#~ "dafür ist, dass einige Lagevergleiche \"anti\" sind, z.B. Disjoint "
#~ "(getrennt). Wenn Sie einen Lagevergleich durchführen, der eine "
#~ "Verschneidungsoperation beinhaltet, dann sollten Sie &amp;&amp; für den "
#~ "Aufruf des Index mit einbeziehen"

#~ msgid ""
#~ "Version 2: Takes geomA and geomB and returns the <xref linkend=\"DE-9IM\"/"
#~ ">"
#~ msgstr ""
#~ "Version 2: Nimmt geomA und geomB entgegen und gibt die <xref linkend="
#~ "\"DE-9IM\"/> zurück"

#~ msgid ""
#~ "Version 3: same as version 2, but allows to specify a boundary node rule "
#~ "(1:OGC/MOD2, 2:Endpoint, 3:MultivalentEndpoint, 4:MonovalentEndpoint)"
#~ msgstr ""
#~ "Version 3: gleich wie Version 2, bietet jedoch die Möglichkeit eine Regel "
#~ "für die Begrenzungsknoten festzulegen (1:OGC/MOD2, 2:Endpoint, 3:"
#~ "MultivalentEndpoint, 4:MonovalentEndpoint)"

#~ msgid "not in OGC spec, but implied. see s2.1.13.2"
#~ msgstr "nicht in der OGC Spezifikation, aber angedeutet. siehe s2.1.13.2"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.25"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.25"

#~ msgid ""
#~ "Enhanced: 2.0.0 - added support for specifying boundary node rule "
#~ "(requires GEOS &gt;= 3.0)."
#~ msgstr ""
#~ "Erweiterung: 2.0.0 - eine Regel für die Begrenzungsknoten kann festgelegt "
#~ "werden (benötigt GEOS &gt;=3.0)."

#~ msgid ""
#~ "--Find all compounds that intersect and not touch a poly (interior "
#~ "intersects)\n"
#~ "SELECT l.* , b.name As poly_name\n"
#~ "        FROM polys As b\n"
#~ "INNER JOIN compounds As l\n"
#~ "ON (p.the_geom &amp;&amp; b.the_geom\n"
#~ "AND ST_Relate(l.the_geom, b.the_geom,'T********'));\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "0FFFFF212\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('LINESTRING(1 2, 3 4)'), "
#~ "ST_GeometryFromText('LINESTRING(5 6, 7 8)'));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "FF1FF0102\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '0FFFFF212');\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "t\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '*FF*FF212');\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "t"
#~ msgstr ""
#~ "--Alle \"compounds\" finden, die ein Polygon schneiden aber nicht "
#~ "berühren (das Innere schneidet sich)\n"
#~ "SELECT l.* , b.name As poly_name\n"
#~ "        FROM polys As b\n"
#~ "INNER JOIN compounds As l\n"
#~ "ON (p.the_geom &amp;&amp; b.the_geom\n"
#~ "AND ST_Relate(l.the_geom, b.the_geom,'T********'));\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "0FFFFF212\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('LINESTRING(1 2, 3 4)'), "
#~ "ST_GeometryFromText('LINESTRING(5 6, 7 8)'));\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "FF1FF0102\n"
#~ "\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '0FFFFF212');\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "t\n"
#~ "\n"
#~ "SELECT ST_Relate(ST_GeometryFromText('POINT(1 2)'), "
#~ "ST_Buffer(ST_GeometryFromText('POINT(1 2)'),2), '*FF*FF212');\n"
#~ "st_relate\n"
#~ "-----------\n"
#~ "t"

#~ msgid ""
#~ ", <xref linkend=\"DE-9IM\"/>, <xref linkend=\"ST_Disjoint\"/>, <xref "
#~ "linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>"
#~ msgstr ""
#~ ", <xref linkend=\"DE-9IM\"/>, <xref linkend=\"ST_Disjoint\"/>, <xref "
#~ "linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Touches\"/>"

#~ msgid "ST_RelateMatch"
#~ msgstr "ST_RelateMatch"

#~ msgid ""
#~ "Returns true if intersectionMattrixPattern1 implies "
#~ "intersectionMatrixPattern2"
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn intersectionMatrixPattern1 "
#~ "intersectionMatrixPattern2 impliziert"

#~ msgid ""
#~ "<funcdef>boolean <function>ST_RelateMatch</function></funcdef> "
#~ "<paramdef><type>text </type> <parameter>intersectionMatrix</parameter></"
#~ "paramdef> <paramdef><type>text </type> "
#~ "<parameter>intersectionMatrixPattern</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_RelateMatch</function></funcdef> "
#~ "<paramdef><type>text </type> <parameter>intersectionMatrix</parameter></"
#~ "paramdef> <paramdef><type>text </type> "
#~ "<parameter>intersectionMatrixPattern</parameter></paramdef>"

#~ msgid ""
#~ "Takes intersectionMatrix and intersectionMatrixPattern and Returns true "
#~ "if the intersectionMatrix satisfies the intersectionMatrixPattern. For "
#~ "more information refer to <xref linkend=\"DE-9IM\"/>."
#~ msgstr ""
#~ "Nimmt eine intersectionMatrix und einen intersectionMatrixPattern "
#~ "entgegen. Gibt TRUE zurück, wenn die intersectionMatrix den "
#~ "intersectionMatrixPattern erfüllt. Weitere Informationen finden Sie unter "
#~ "<xref linkend=\"DE-9IM\"/>."

#~ msgid "Availability: 2.0.0 - requires GEOS &gt;= 3.3.0."
#~ msgstr "Verfügbarkeit: 2.0.0 - benötigt GEOS &gt;= 3.3.0."

#~ msgid ""
#~ "SELECT ST_RelateMatch('101202FFF', 'TTTTTTFFF') ;\n"
#~ "-- result --\n"
#~ "t\n"
#~ "--example of common intersection matrix patterns and example matrices\n"
#~ "-- comparing relationships of involving one invalid geometry and ( a line "
#~ "and polygon that intersect at interior and boundary)\n"
#~ "SELECT mat.name, pat.name, ST_RelateMatch(mat.val, pat.val) As satisfied\n"
#~ "    FROM\n"
#~ "        ( VALUES ('Equality', 'T1FF1FFF1'),\n"
#~ "                ('Overlaps', 'T*T***T**'),\n"
#~ "                ('Within', 'T*F**F***'),\n"
#~ "                ('Disjoint', 'FF*FF****') As pat(name,val)\n"
#~ "        CROSS JOIN\n"
#~ "            (        VALUES ('Self intersections (invalid)', "
#~ "'111111111'),\n"
#~ "                    ('IE2_BI1_BB0_BE1_EI1_EE2', 'FF2101102'),\n"
#~ "                    ('IB1_IE1_BB0_BE0_EI2_EI1_EE2', 'F11F00212')\n"
#~ "            ) As mat(name,val);"
#~ msgstr ""
#~ "SELECT ST_RelateMatch('101202FFF', 'TTTTTTFFF') ;\n"
#~ "-- result --\n"
#~ "t\n"
#~ "-- Ein typisches Beispiel für intersectionMatrixPattern und "
#~ "intersectionMatrix\n"
#~ "-- Ein Lagevergleich zwischen einer ungültigen Geometrie und ( einer "
#~ "Linie und einem Polygon, die sich im Inneren und an der Begrenzung "
#~ "schneiden)\n"
#~ "SELECT mat.name, pat.name, ST_RelateMatch(mat.val, pat.val) As satisfied\n"
#~ "    FROM\n"
#~ "        ( VALUES ('Equality', 'T1FF1FFF1'),\n"
#~ "                ('Overlaps', 'T*T***T**'),\n"
#~ "                ('Within', 'T*F**F***'),\n"
#~ "                ('Disjoint', 'FF*FF****') As pat(name,val)\n"
#~ "        CROSS JOIN\n"
#~ "            (        VALUES ('Self intersections (invalid)', "
#~ "'111111111'),\n"
#~ "                    ('IE2_BI1_BB0_BE1_EI1_EE2', 'FF2101102'),\n"
#~ "                    ('IB1_IE1_BB0_BE0_EI2_EI1_EE2', 'F11F00212')\n"
#~ "            ) As mat(name,val);"

#~ msgid ", <xref linkend=\"ST_Relate\"/>"
#~ msgstr ", <xref linkend=\"ST_Relate\"/>"

#~ msgid "ST_Touches"
#~ msgstr "ST_Touches"

#~ msgid ""
#~ "Returns <varname>TRUE</varname> if the geometries have at least one point "
#~ "in common, but their interiors do not intersect."
#~ msgstr ""
#~ "Gibt <varname>TRUE</varname> zurück wenn die geometrischen Objekte einen "
#~ "Punkt gemeinsam haben und ihr Inneres sich nicht schneidet."

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Touches</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Touches</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>g2</parameter></paramdef>"

#~ msgid ""
#~ "Returns <varname>TRUE</varname> if the only points in common between "
#~ "<parameter>g1</parameter> and <parameter>g2</parameter> lie in the union "
#~ "of the boundaries of <parameter>g1</parameter> and <parameter>g2</"
#~ "parameter>. The <function>ST_Touches</function> relation applies to all "
#~ "Area/Area, Line/Line, Line/Area, Point/Area and Point/Line pairs of "
#~ "relationships, but <emphasis>not</emphasis> to the Point/Point pair."
#~ msgstr ""
#~ "Gibt <varname>TRUE</varname> zurück, wenn die einzigen gemeinsamen Punkte "
#~ "zwischen <parameter>g1</parameter> und <parameter>g2</parameter> in der "
#~ "Vereinigung der Begrenzungen von <parameter>g1</parameter> und "
#~ "<parameter>g2</parameter> liegen. Der Lagevergleich <function>ST_Touches</"
#~ "function>  kann auf alle Paare vom Typ Fläche/Fläche, Linie/Linie, Linie/"
#~ "Fläche, Punkt/Fläche und Punkt/Linie, aber <emphasis>nicht</emphasis> auf "
#~ "Punkt/Punkt angewendet werden."

#~ msgid "In mathematical terms, this predicate is expressed as:"
#~ msgstr "Mathematisch wird dieses Prädikat folgendermaßen ausgedrückt:"

#~ msgid ""
#~ "The allowable DE-9IM Intersection Matrices for the two geometries are:"
#~ msgstr ""
#~ "Die zulässigen DE-9IM-Matrizen der beiden geometrischen Objekte lauten:"

#~ msgid "FT*******"
#~ msgstr "FT*******"

#~ msgid "F**T*****"
#~ msgstr "F**T*****"

#~ msgid "F***T****"
#~ msgstr "F***T****"

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid using an index, use <function>_ST_Touches</function> instead."
#~ msgstr ""
#~ "Dieser Funktionsaufruf schließt einen Lagevergleich der umschreibenden "
#~ "Rechtecke mit ein, wodurch sämtlichen verfügbaren Indizes der Geometrie "
#~ "genutzt werden. Um die Verwendung von Indizes zu verhindern, benutzen Sie "
#~ "bitte <function>_ST_Touches</function> stattdessen."

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.28"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.28"

#~ msgid ""
#~ "The <function>ST_Touches</function> predicate returns <varname>TRUE</"
#~ "varname> in all the following illustrations."
#~ msgstr ""
#~ "Das Prädikat <function>ST_Touches</function> gibt bei den folgenden "
#~ "Abbildungen immer <varname>TRUE</varname> zurück."

#~ msgid ""
#~ "SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(1 1)'::"
#~ "geometry);\n"
#~ " st_touches\n"
#~ "------------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(0 2)'::"
#~ "geometry);\n"
#~ " st_touches\n"
#~ "------------\n"
#~ " t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(1 1)'::"
#~ "geometry);\n"
#~ " st_touches\n"
#~ "------------\n"
#~ " f\n"
#~ "(1 row)\n"
#~ "\n"
#~ "SELECT ST_Touches('LINESTRING(0 0, 1 1, 0 2)'::geometry, 'POINT(0 2)'::"
#~ "geometry);\n"
#~ " st_touches\n"
#~ "------------\n"
#~ " t\n"
#~ "(1 row)"

#~ msgid "ST_Within"
#~ msgstr "ST_Within"

#~ msgid "Returns true if the geometry A is completely inside geometry B"
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn Geometrie A zur Gänze innerhalb von Geometrie B "
#~ "liegt"

#~ msgid ""
#~ "<funcdef>boolean <function>ST_Within</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"
#~ msgstr ""
#~ "<funcdef>boolean <function>ST_Within</function></funcdef> "
#~ "<paramdef><type>geometry </type> <parameter>A</parameter></paramdef> "
#~ "<paramdef><type>geometry </type> <parameter>B</parameter></paramdef>"

#~ msgid ""
#~ "Returns TRUE if geometry A is completely inside geometry B. For this "
#~ "function to make sense, the source geometries must both be of the same "
#~ "coordinate projection, having the same SRID. It is a given that if "
#~ "ST_Within(A,B) is true and ST_Within(B,A) is true, then the two "
#~ "geometries are considered spatially equal."
#~ msgstr ""
#~ "Gibt TRUE zurück, wenn die Geometrie A zur Gänze im Inneren der Geometrie "
#~ "B liegt. Damit diese Funktion sinnvoll angewendet werden kann, muss die "
#~ "Geometrie von A und B sowohl im gleichen Koordinatenreferenzsystem "
#~ "vorliegen als auch die selbe SRID aufweisen. Wenn ST_Within(A,B) TRUE ist "
#~ "und ST_Within(B,A) TRUE ist, dann sind die beiden geometrischen Objekte "
#~ "räumlich ident."

#~ msgid ""
#~ "This function call will automatically include a bounding box comparison "
#~ "that will make use of any indexes that are available on the geometries. "
#~ "To avoid index use, use the function _ST_Within."
#~ msgstr ""
#~ "Dieser Funktionsaufruf schließt einen Lagevergleich der umschreibenden "
#~ "Rechtecke mit ein, wodurch sämtlichen verfügbaren Indizes der Geometrie "
#~ "genutzt werden. Um die Verwendung von Indizes zu verhindern, benutzen Sie "
#~ "bitte _ST_Within."

#~ msgid "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*F**F***')"
#~ msgstr "&sfs_compliant; s2.1.1.2 // s2.1.13.3 - a.Relate(b, 'T*F**F***')"

#~ msgid "&sqlmm_compliant; SQL-MM 3: 5.1.30"
#~ msgstr "&sqlmm_compliant; SQL-MM 3: 5.1.30"

#~ msgid ""
#~ "--a circle within a circle\n"
#~ "SELECT ST_Within(smallc,smallc) As smallinsmall,\n"
#~ "        ST_Within(smallc, bigc) As smallinbig,\n"
#~ "        ST_Within(bigc,smallc) As biginsmall,\n"
#~ "        ST_Within(ST_Union(smallc, bigc), bigc) as unioninbig,\n"
#~ "        ST_Within(bigc, ST_Union(smallc, bigc)) as biginunion,\n"
#~ "        ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion\n"
#~ "FROM\n"
#~ "(\n"
#~ "SELECT ST_Buffer(ST_GeomFromText('POINT(50 50)'), 20) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(50 50)'), 40) As bigc) As foo;\n"
#~ "--Result\n"
#~ " smallinsmall | smallinbig | biginsmall | unioninbig | biginunion | "
#~ "bigisunion\n"
#~ "--------------+------------+------------+------------+------------"
#~ "+------------\n"
#~ " t            | t          | f          | t          | t          | t\n"
#~ "(1 row)"
#~ msgstr ""
#~ "--Ein Kreis innerhalb eines Kreises\n"
#~ "SELECT ST_Within(smallc,smallc) As smallinsmall,\n"
#~ "        ST_Within(smallc, bigc) As smallinbig,\n"
#~ "        ST_Within(bigc,smallc) As biginsmall,\n"
#~ "        ST_Within(ST_Union(smallc, bigc), bigc) as unioninbig,\n"
#~ "        ST_Within(bigc, ST_Union(smallc, bigc)) as biginunion,\n"
#~ "        ST_Equals(bigc, ST_Union(smallc, bigc)) as bigisunion\n"
#~ "FROM\n"
#~ "(\n"
#~ "SELECT ST_Buffer(ST_GeomFromText('POINT(50 50)'), 20) As smallc,\n"
#~ "        ST_Buffer(ST_GeomFromText('POINT(50 50)'), 40) As bigc) As foo;\n"
#~ "--Result\n"
#~ " smallinsmall | smallinbig | biginsmall | unioninbig | biginunion | "
#~ "bigisunion\n"
#~ "--------------+------------+------------+------------+------------"
#~ "+------------\n"
#~ " t            | t          | f          | t          | t          | t\n"
#~ "(1 row)"

#~ msgid ", <xref linkend=\"ST_Equals\"/>, <xref linkend=\"ST_IsValid\"/>"
#~ msgstr ", <xref linkend=\"ST_Equals\"/>, <xref linkend=\"ST_IsValid\"/>"
