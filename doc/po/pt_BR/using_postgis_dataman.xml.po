# SOME DESCRIPTIVE TITLE.
#
# Translators:
# georgersilva <georger.silva@gmail.com>, 2016
# georgersilva <georger.silva@gmail.com>, 2016-2017
# Poliana Palhares <p.palhares@plamu.com.br>, 2016
msgid ""
msgstr ""
"Project-Id-Version: PostGIS\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2020-12-19 17:06+0000\n"
"PO-Revision-Date: 2018-07-23 18:01+0000\n"
"Last-Translator: Poliana Palhares <p.palhares@plamu.com.br>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/postgis/postgis/"
"language/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#. Tag: title
#: using_postgis_dataman.xml:3
#, no-c-format
msgid "Data Management"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:6
#, no-c-format
msgid "GIS Objects"
msgstr "Objetos GIS"

#. Tag: para
#: using_postgis_dataman.xml:8
#, no-c-format
msgid ""
"The GIS objects supported by PostGIS are a superset of the \"Simple Features"
"\" standard defined by the OpenGIS Consortium (OGC). PostGIS supports all "
"the objects and functions specified in the OGC \"Simple Features for SQL\" "
"specification (SFS)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:13
#, no-c-format
msgid ""
"PostGIS extends the standard with support for embedded SRID information."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:16
#, no-c-format
msgid "OpenGIS WKB and WKT"
msgstr "OpenGIS WKB e WKT"

#. Tag: para
#: using_postgis_dataman.xml:18
#, no-c-format
msgid ""
"The OpenGIS specification defines two standard ways of expressing spatial "
"objects: the Well-Known Text (WKT) form and the Well-Known Binary (WKB) "
"form. Both WKT and WKB include information about the type of the object and "
"the coordinates which form the object."
msgstr ""
"A especificação OpenGIS define dois caminhos padrão de expressar objetos "
"espaciais: o Well-Known Text (WKT) e o Well-Known Binary (WKB). Ambos "
"incluem informação sobre o tipo do objeto e as coordenadas que os formam."

#. Tag: para
#: using_postgis_dataman.xml:23
#, no-c-format
msgid ""
"Examples of the text representations (WKT) of the spatial objects of the "
"features are as follows:"
msgstr ""
"A seguir, exemplos das representações de textos (WKT) dos objetos espaciais "
"das características: "

#. Tag: para
#: using_postgis_dataman.xml:28
#, no-c-format
msgid "POINT(0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:32
#, fuzzy, no-c-format
msgid "POINT Z (0 0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:36
#, fuzzy, no-c-format
msgid "POINT ZM (0 0 0 0)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:40
#, no-c-format
msgid "LINESTRING(0 0,1 1,1 2)"
msgstr "LINESTRING(0 0,1 1,1 2)"

#. Tag: para
#: using_postgis_dataman.xml:44
#, no-c-format
msgid "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"
msgstr "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))"

#. Tag: para
#: using_postgis_dataman.xml:48
#, no-c-format
msgid "MULTIPOINT((0 0),(1 2))"
msgstr "MULTIPOINT((0 0),(1 2))"

#. Tag: para
#: using_postgis_dataman.xml:52
#, fuzzy, no-c-format
msgid "MULTIPOINT Z ((0 0 0),(1 2 3))"
msgstr "MULTIPOINT((0 0),(1 2))"

#. Tag: para
#: using_postgis_dataman.xml:56
#, no-c-format
msgid "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"
msgstr "MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))"

#. Tag: para
#: using_postgis_dataman.xml:60
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"
msgstr ""
"MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)), ((-1 -1,-1 -2,-2 "
"-2,-2 -1,-1 -1)))"

#. Tag: para
#: using_postgis_dataman.xml:65
#, no-c-format
msgid "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"
msgstr "GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))"

#. Tag: para
#: using_postgis_dataman.xml:69
#, no-c-format
msgid ""
"The OpenGIS specification also requires that the internal storage format of "
"spatial objects include a spatial referencing system identifier (SRID). The "
"SRID is required when creating spatial objects for insertion into the "
"database."
msgstr ""
"A especificação OpenGIS também requer que o formato do armazenamento interno "
"dos objetos espacias incluam um identificador de sistema de referência "
"espacial (SRID). O SRID é fundamental na criação de objetos espaciais para a "
"inserção no banco de dados. "

#. Tag: para
#: using_postgis_dataman.xml:74
#, no-c-format
msgid ""
"Input/Output of these formats are available using the following interfaces:"
msgstr ""
"Entrada/Saída destes formatos estão disponíveis usando as seguintes "
"interfaces:"

#. Tag: programlisting
#: using_postgis_dataman.xml:77
#, no-c-format
msgid ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"
msgstr ""
"bytea WKB = ST_AsBinary(geometry);\n"
"text WKT = ST_AsText(geometry);\n"
"geometry = ST_GeomFromWKB(bytea WKB, SRID);\n"
"geometry = ST_GeometryFromText(text WKT, SRID);"

#. Tag: para
#: using_postgis_dataman.xml:79
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert an OGC spatial "
"object would be:"
msgstr ""
"Por exemplo, uma declaração inserida válida para criar e inserir um objeto "
"espacial OGC seria:"

#. Tag: programlisting
#: using_postgis_dataman.xml:82
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromText('POINT(-126.4 45.32)', 312), 'A Place');"

#. Tag: title
#: using_postgis_dataman.xml:86
#, no-c-format
msgid "PostGIS EWKB, EWKT and Canonical Forms"
msgstr "PostGIS EWKB, EWKT e Formas Canônicas "

#. Tag: para
#: using_postgis_dataman.xml:88
#, no-c-format
msgid ""
"First OpenGIS specifications (prior to 1.2.0) only support 2D geometries, "
"and the associated SRID is *never* embedded in the input/output "
"representations."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:91
#, no-c-format
msgid ""
"Even though the last OpenGIS specification 1.2.1 supports 3DM and 3DZ "
"coordinates specifing ZM qualifiers, it does not include yet the associated "
"SRID in the input/output representations."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:95
#, no-c-format
msgid ""
"PostGIS extended formats add 3DM, 3DZ, 4D coordinates support and embedded "
"SRID information. However, PostGIS EWKB/EWKT outputs have several "
"peculiarities:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:100
#, no-c-format
msgid "For 3DZ geometries they will drop the Z qualifier:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:101
#, no-c-format
msgid "OpenGIS: POINT Z (1 2 3)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:102
#, no-c-format
msgid "EWKB/EWKT: POINT(1 2 3)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:105
#, no-c-format
msgid "For 3DM geometries they will keep the M qualifier:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:106
#, no-c-format
msgid "OpenGIS: POINT M (1 2 3)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:107
#, no-c-format
msgid "EWKB/EWKT: POINTM(1 2 3)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:110
#, no-c-format
msgid "For 4D geometries they will drop the ZM qualifiers:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:111
#, no-c-format
msgid "OpenGIS: POINT ZM (1 2 3 4)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:112
#, no-c-format
msgid "EWKB/EWKT: POINT(1 2 3 4)"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:116
#, no-c-format
msgid ""
"By doing this, PostGIS EWKB/EWKT avoids over-specifying dimensionality and a "
"whole categories of potential errors that ISO admits, e.g.:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:121
#, fuzzy, no-c-format
msgid "POINT ZM (1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:124
#, fuzzy, no-c-format
msgid "POINT ZM (1 1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:127
#, fuzzy, no-c-format
msgid "POINT (1 1 1 1)"
msgstr "POINT(0 0)"

#. Tag: para
#: using_postgis_dataman.xml:132
#, fuzzy, no-c-format
msgid ""
"PostGIS extended formats are currently superset of the OGC one (every valid "
"WKB/WKT is a valid EWKB/EWKT) but this might vary in the future, "
"specifically if OGC comes out with a new format conflicting with our "
"extensions. Thus you SHOULD NOT rely on this feature!"
msgstr ""
"Os formatos estendidos do PostGIS estão atualmente superset de OGC  (cada "
"WKB/WKT válido é um EWKB/EWKT válido), mas isto pode airar no futuro, "
"especificamente se OGC sai com um novo formato conflitando com nossas "
"extensões. Assim, você NÃO DEVE confiar neste aspecto!  "

#. Tag: para
#: using_postgis_dataman.xml:137
#, no-c-format
msgid ""
"Examples of the text representations (EWKT) of the extended spatial objects "
"of the features are as follows."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:142
#, no-c-format
msgid "POINT(0 0 0) -- XYZ"
msgstr "POINT(0 0 0) -- XYZ"

#. Tag: para
#: using_postgis_dataman.xml:146
#, no-c-format
msgid "SRID=32632;POINT(0 0) -- XY with SRID"
msgstr "SRID=32632;POINT(0 0) -- XY with SRID"

#. Tag: para
#: using_postgis_dataman.xml:150
#, no-c-format
msgid "POINTM(0 0 0) -- XYM"
msgstr "POINTM(0 0 0) -- XYM"

#. Tag: para
#: using_postgis_dataman.xml:154
#, no-c-format
msgid "POINT(0 0 0 0) -- XYZM"
msgstr "POINT(0 0 0 0) -- XYZM"

#. Tag: para
#: using_postgis_dataman.xml:158
#, no-c-format
msgid "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"
msgstr "SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID"

#. Tag: para
#: using_postgis_dataman.xml:162
#, no-c-format
msgid "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"
msgstr "MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))"

#. Tag: para
#: using_postgis_dataman.xml:167
#, no-c-format
msgid ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"
msgstr ""
"POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))"

#. Tag: para
#: using_postgis_dataman.xml:172
#, no-c-format
msgid ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"
msgstr ""
"MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 "
"0)),((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))"

#. Tag: para
#: using_postgis_dataman.xml:177
#, no-c-format
msgid "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"
msgstr "GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )"

#. Tag: para
#: using_postgis_dataman.xml:181
#, no-c-format
msgid "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"
msgstr "MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )"

#. Tag: para
#: using_postgis_dataman.xml:185
#, no-c-format
msgid ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"
msgstr ""
"POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 "
"1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, "
"1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 "
"1, 1 1 1, 0 1 1, 0 0 1)) )"

#. Tag: para
#: using_postgis_dataman.xml:191
#, no-c-format
msgid "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"
msgstr "TRIANGLE ((0 0, 0 9, 9 0, 0 0))"

#. Tag: para
#: using_postgis_dataman.xml:195
#, no-c-format
msgid "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"
msgstr "TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )"

#. Tag: para
#: using_postgis_dataman.xml:200
#, no-c-format
msgid ""
"Conversion between these formats is available using the following interfaces:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:202
#, no-c-format
msgid ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"
msgstr ""
"bytea EWKB = ST_AsEWKB(geometry);\n"
"text EWKT = ST_AsEWKT(geometry);\n"
"geometry = ST_GeomFromEWKB(bytea EWKB);\n"
"geometry = ST_GeomFromEWKT(text EWKT);"

#. Tag: para
#: using_postgis_dataman.xml:204
#, no-c-format
msgid ""
"For example, a valid insert statement to create and insert a PostGIS spatial "
"object would be:"
msgstr ""
"Por exemplo, uma declaração inserida válida para criar e inserir um objeto "
"espacial seria:"

#. Tag: programlisting
#: using_postgis_dataman.xml:207
#, no-c-format
msgid ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"
msgstr ""
"INSERT INTO geotable ( the_geom, the_name )\n"
"  VALUES ( ST_GeomFromEWKT('SRID=312;POINTM(-126.4 45.32 15)'), 'A Place' )"

#. Tag: para
#: using_postgis_dataman.xml:209
#, no-c-format
msgid ""
"The \"canonical forms\" of a PostgreSQL type are the representations you get "
"with a simple query (without any function call) and the one which is "
"guaranteed to be accepted with a simple insert, update or copy. For the "
"PostGIS 'geometry' type these are:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:213
#, no-c-format
msgid ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"
msgstr ""
"- Output\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB (EWKB in hex form)\n"
"- Input\n"
"  - binary: EWKB\n"
"        ascii: HEXEWKB|EWKT"

#. Tag: para
#: using_postgis_dataman.xml:215
#, no-c-format
msgid ""
"For example this statement reads EWKT and returns HEXEWKB in the process of "
"canonical ascii input/output:"
msgstr ""
"Por exemplo, esta declaração lê EWKT e retorna HEXEWKB no processo de "
"entrada/saída ascii canônica:  "

#. Tag: programlisting
#: using_postgis_dataman.xml:218
#, no-c-format
msgid ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"
msgstr ""
"=# SELECT 'SRID=4;POINT(0 0)'::geometry;\n"
"\n"
"geometry\n"
"----------------------------------------------------\n"
"01010000200400000000000000000000000000000000000000\n"
"(1 row)"

#. Tag: title
#: using_postgis_dataman.xml:221
#, no-c-format
msgid "SQL-MM Part 3"
msgstr "SQL-MM Part 3"

#. Tag: para
#: using_postgis_dataman.xml:223
#, no-c-format
msgid ""
"The SQL Multimedia Applications Spatial specification extends the simple "
"features for SQL spec by defining a number of circularly interpolated curves."
msgstr ""
"E especificação SQL Multimedia Applications Spatial estende os aspectos "
"simples para SQL spec definindo um número de curvas circularmente "
"interpoladas. "

#. Tag: para
#: using_postgis_dataman.xml:227
#, no-c-format
msgid ""
"The SQL-MM definitions include 3DM, 3DZ and 4D coordinates, but do not allow "
"the embedding of SRID information."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:230
#, no-c-format
msgid ""
"The Well-Known Text extensions are not yet fully supported. Examples of some "
"simple curved geometries are shown below:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:235
#, no-c-format
msgid "CIRCULARSTRING(0 0, 1 1, 1 0)"
msgstr "CIRCULARSTRING(0 0, 1 1, 1 0)"

#. Tag: para
#: using_postgis_dataman.xml:236
#, no-c-format
msgid "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"
msgstr "CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0)"

#. Tag: para
#: using_postgis_dataman.xml:237
#, no-c-format
msgid ""
"The CIRCULARSTRING is the basic curve type, similar to a LINESTRING in the "
"linear world. A single segment required three points, the start and end "
"points (first and third) and any other point on the arc. The exception to "
"this is for a closed circle, where the start and end points are the same. In "
"this case the second point MUST be the center of the arc, ie the opposite "
"side of the circle. To chain arcs together, the last point of the previous "
"arc becomes the first point of the next arc, just like in LINESTRING. This "
"means that a valid circular string must have an odd number of points greater "
"than 1."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:250
#, no-c-format
msgid "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"
msgstr "COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))"

#. Tag: para
#: using_postgis_dataman.xml:251
#, no-c-format
msgid ""
"A compound curve is a single, continuous curve that has both curved "
"(circular) segments and linear segments. That means that in addition to "
"having well-formed components, the end point of every component (except the "
"last) must be coincident with the start point of the following component."
msgstr ""
"Uma curva composta é uma curva única e contínua que tem segmentos curvados "
"(circulares) e lineares. Isto significa que, além de ter componentes bem "
"formados, o ponto final de cada componente (exceto o último) deve ser "
"coincidente com o ponto inicial do componente seguinte."

#. Tag: para
#: using_postgis_dataman.xml:259
#, no-c-format
msgid ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"
msgstr ""
"CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, 3 1, 1 1))"

#. Tag: para
#: using_postgis_dataman.xml:261
#, no-c-format
msgid ""
"Example compound curve in a curve polygon: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"
msgstr ""
"Exemplo de curva composta em um polígono curvo: "
"CURVEPOLYGON(COMPOUNDCURVE(CIRCULARSTRING(0 0,2 0, 2 1, 2 3, 4 3),(4 3, 4 5, "
"1 4, 0 0)), CIRCULARSTRING(1.7 1, 1.4 0.4, 1.6 0.4, 1.6 0.5, 1.7 1) )"

#. Tag: para
#: using_postgis_dataman.xml:265
#, no-c-format
msgid ""
"A CURVEPOLYGON is just like a polygon, with an outer ring and zero or more "
"inner rings. The difference is that a ring can take the form of a circular "
"string, linear string or compound string."
msgstr ""
"Um POLÍGONOCURVO é como um polígono, com um anel externo e zero ou mais "
"anéis internos. A diferença é que um anel pode obter a forma de uma string "
"circular, linear ou composta. "

#. Tag: para
#: using_postgis_dataman.xml:269
#, no-c-format
msgid "As of PostGIS 1.4 PostGIS supports compound curves in a curve polygon."
msgstr ""
"Assim como o PostGIS 1.4, o PostGIS suporta curvas compostas em um polígono "
"curvo. "

#. Tag: para
#: using_postgis_dataman.xml:273
#, no-c-format
msgid "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"
msgstr "MULTICURVE((0 0, 5 5),CIRCULARSTRING(4 0, 4 4, 8 4))"

#. Tag: para
#: using_postgis_dataman.xml:274
#, no-c-format
msgid ""
"The MULTICURVE is a collection of curves, which can include linear strings, "
"circular strings or compound strings."
msgstr ""
"A MULTICURVA é uma coleção de curvas, que podem incluir strings lineares, "
"circulares e compostas. "

#. Tag: para
#: using_postgis_dataman.xml:279
#, no-c-format
msgid ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"
msgstr ""
"MULTISURFACE(CURVEPOLYGON(CIRCULARSTRING(0 0, 4 0, 4 4, 0 4, 0 0),(1 1, 3 3, "
"3 1, 1 1)),((10 10, 14 12, 11 10, 10 10),(11 11, 11.5 11, 11 11.5, 11 11)))"

#. Tag: para
#: using_postgis_dataman.xml:282
#, no-c-format
msgid ""
"This is a collection of surfaces, which can be (linear) polygons or curve "
"polygons."
msgstr ""
"Esta é uma coleção de superfícies, que podem ser polígonos (lineares) ou "
"polígonos curvos."

#. Tag: para
#: using_postgis_dataman.xml:288
#, no-c-format
msgid ""
"All floating point comparisons within the SQL-MM implementation are "
"performed to a specified tolerance, currently 1E-8."
msgstr ""
"Todos as comparações de pontos flutuantes dentro da implementação SQL-MM são "
"representadas com uma tolerância específica, atualmente 1E-8. "

#. Tag: title
#: using_postgis_dataman.xml:294
#, no-c-format
msgid "PostGIS Geography Type"
msgstr "Tipo de geografia POstGIS"

#. Tag: para
#: using_postgis_dataman.xml:296
#, no-c-format
msgid ""
"The geography type provides native support for spatial features represented "
"on \"geographic\" coordinates (sometimes called \"geodetic\" coordinates, or "
"\"lat/lon\", or \"lon/lat\"). Geographic coordinates are spherical "
"coordinates expressed in angular units (degrees)."
msgstr ""
"O tipo de geografia fornece suporte natural para características "
"representadas nas coordenadas\"geográficas\" (às vezes chamadas de "
"coordenadas \"geodéticas\", ou \"lat/lon\", ou 'lon/lat\"). As coordenadas "
"geográficas são coordenadas esféricas expressadas em unidades angulares "
"(graus)."

#. Tag: para
#: using_postgis_dataman.xml:298
#, no-c-format
msgid ""
"The basis for the PostGIS geometry type is a plane. The shortest path "
"between two points on the plane is a straight line. That means calculations "
"on geometries (areas, distances, lengths, intersections, etc) can be "
"calculated using cartesian mathematics and straight line vectors."
msgstr ""
"A base para a geometria PostGIS é um plano. O menor caminho entre dois "
"pontos no plano é uma linha. Isso quer dizer que cálculos em geometrias "
"(áreas, distâncias, cumprimentos, interseções etc) podem ser feitos usando "
"matemática cartesiana e vetores de linhas. "

#. Tag: para
#: using_postgis_dataman.xml:300
#, no-c-format
msgid ""
"The basis for the PostGIS geographic type is a sphere. The shortest path "
"between two points on the sphere is a great circle arc. That means that "
"calculations on geographies (areas, distances, lengths, intersections, etc) "
"must be calculated on the sphere, using more complicated mathematics. For "
"more accurate measurements, the calculations must take the actual spheroidal "
"shape of the world into account."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:302
#, no-c-format
msgid ""
"Because the underlying mathematics is much more complicated, there are fewer "
"functions defined for the geography type than for the geometry type. Over "
"time, as new algorithms are added, the capabilities of the geography type "
"will expand."
msgstr ""
"Devido à matemática fundamental ser muito mais complicada, existem poucas "
"funções definidas pela geografia em vez da geometria. Ao longo do tempo, à "
"media que os algorítimos forem adicionados, as capacidades da geografia "
"serão expandidas. "

#. Tag: para
#: using_postgis_dataman.xml:304
#, no-c-format
msgid ""
"It uses a data type called <varname>geography</varname>. None of the GEOS "
"functions support the <varname>geography</varname> type. As a workaround one "
"can convert back and forth between geometry and geography types."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:307
#, no-c-format
msgid ""
"Prior to PostGIS 2.2, the geography type only supported WGS 84 long lat "
"(SRID:4326). For PostGIS 2.2 and above, any long/lat based spatial reference "
"system defined in the <varname>spatial_ref_sys</varname> table can be used. "
"You can even add your own custom spheroidal spatial reference system as "
"described in <ulink url=\"http://www.bostongis.com/blog/index.php?/"
"archives/266-geography-type-is-not-limited-to-earth.html\">geography type is "
"not limited to earth</ulink>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:311
#, no-c-format
msgid ""
"Regardless which spatial reference system you use, the units returned by the "
"measurement (<xref linkend=\"ST_Distance\"/>, <xref linkend=\"ST_Length\"/>, "
"<xref linkend=\"ST_Perimeter\"/>, <xref linkend=\"ST_Area\"/>) and for input "
"of <xref linkend=\"ST_DWithin\"/> are in meters."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:313
#, no-c-format
msgid ""
"The geography type uses the PostgreSQL typmod definition format so that a "
"table with a geography field can be added in a single step. All the standard "
"OGC formats except for curves are supported."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:317
#, no-c-format
msgid "Geography Basics"
msgstr "Geografia Básica"

#. Tag: para
#: using_postgis_dataman.xml:318
#, no-c-format
msgid ""
"The geography type does not support curves, TINS, or POLYHEDRALSURFACEs, but "
"other geometry types are supported. Standard geometry type data will "
"autocast to geography if it is of SRID 4326. You can also use the EWKT and "
"EWKB conventions to insert data."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:323
#, no-c-format
msgid ""
"POINT: Creating a table with 2D point geography when srid is not specified "
"defaults to 4326 WGS 84 long lat:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:324
#, no-c-format
msgid "CREATE TABLE ptgeogwgs(gid serial PRIMARY KEY, geog geography(POINT) );"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:325
#, no-c-format
msgid "POINT: Creating a table with 2D point geography in NAD83 longlat:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:326
#, no-c-format
msgid ""
"CREATE TABLE ptgeognad83(gid serial PRIMARY KEY, geog "
"geography(POINT,4269) );"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:327
#, no-c-format
msgid "Creating a table with z coordinate point and explicitly specifying srid"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:328
#, no-c-format
msgid ""
"CREATE TABLE ptzgeogwgs84(gid serial PRIMARY KEY, geog "
"geography(POINTZ,4326) );"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:331
#, no-c-format
msgid "LINESTRING"
msgstr "LINESTRING"

#. Tag: programlisting
#: using_postgis_dataman.xml:332
#, no-c-format
msgid ""
"CREATE TABLE lgeog(gid serial PRIMARY KEY, geog geography(LINESTRING) );"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:335
#, no-c-format
msgid "POLYGON"
msgstr "POLYGON"

#. Tag: programlisting
#: using_postgis_dataman.xml:336
#, no-c-format
msgid ""
"--polygon NAD 1927 long lat\n"
"CREATE TABLE lgeognad27(gid serial PRIMARY KEY, geog "
"geography(POLYGON,4267) );"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:339
#, no-c-format
msgid "MULTIPOINT"
msgstr "MULTIPOINT"

#. Tag: para
#: using_postgis_dataman.xml:342
#, no-c-format
msgid "MULTILINESTRING"
msgstr "MULTILINESTRING"

#. Tag: para
#: using_postgis_dataman.xml:345
#, no-c-format
msgid "MULTIPOLYGON"
msgstr "MULTIPOLYGON"

#. Tag: para
#: using_postgis_dataman.xml:348
#, no-c-format
msgid "GEOMETRYCOLLECTION"
msgstr "GEOMETRYCOLLECTION"

#. Tag: para
#: using_postgis_dataman.xml:352
#, no-c-format
msgid ""
"The geography fields get registered in the <varname>geography_columns</"
"varname> system view."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:354
#, no-c-format
msgid ""
"Now, check the \"geography_columns\" view and see that your table is listed."
msgstr ""
"Agora, veja a view \"geography_columns\" e note que sua tabela está listada."

#. Tag: para
#: using_postgis_dataman.xml:356
#, no-c-format
msgid ""
"You can create a new table with a GEOGRAPHY column using the CREATE TABLE "
"syntax."
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:359
#, no-c-format
msgid ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"
msgstr ""
"CREATE TABLE global_points (\n"
"    id SERIAL PRIMARY KEY,\n"
"    name VARCHAR(64),\n"
"    location GEOGRAPHY(POINT,4326)\n"
"  );"

#. Tag: para
#: using_postgis_dataman.xml:362
#, no-c-format
msgid ""
"Note that the location column has type GEOGRAPHY and that geography type "
"supports two optional modifiers: a type modifier that restricts the kind of "
"shapes and dimensions allowed in the column; an SRID modifier that restricts "
"the coordinate reference identifier to a particular number."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:363
#, no-c-format
msgid ""
"Allowable values for the type modifier are: POINT, LINESTRING, POLYGON, "
"MULTIPOINT, MULTILINESTRING, MULTIPOLYGON. The modifier also supports "
"dimensionality restrictions through suffixes: Z, M and ZM. So, for example a "
"modifier of 'LINESTRINGM' would only allow line strings with three "
"dimensions in, and would treat the third dimension as a measure. Similarly, "
"'POINTZM' would expect four dimensional data."
msgstr ""
"Os valores permitidos para o modificador de tipo são: PONTO, LINESTRING, "
"POLÍGONO, MULTIPONTO, MULTILINESTRING, MULTIPOLÍGONO. O modificador também "
"suporta restrições de dimensionalidade através de sufixos: Z, M, e ZM. "
"Então, por exemplo, um modificador de 'LINESTRINGM' só permitiria line "
"strings com três dimensões, e trataria a terceira dimensão como uma medida. "
"Da mesma forma, 'PONTOZM' esperaria dados de quatro dimensões. "

#. Tag: para
#: using_postgis_dataman.xml:365
#, no-c-format
msgid ""
"If you do not specify an SRID, the SRID will default to 4326 WGS 84 long/lat "
"will be used, and all calculations will proceed using WGS84."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:366
#, no-c-format
msgid ""
"Once you have created your table, you can see it in the GEOGRAPHY_COLUMNS "
"table:"
msgstr ""
"Uma vez que tenha criado sua tabela, você pode vê-la na tabela "
"GEOGRAPHY_COLUMNS:"

#. Tag: programlisting
#: using_postgis_dataman.xml:367
#, no-c-format
msgid ""
"-- See the contents of the metadata view\n"
"SELECT * FROM geography_columns;"
msgstr ""
"-- See the contents of the metadata view\n"
"SELECT * FROM geography_columns;"

#. Tag: para
#: using_postgis_dataman.xml:369
#, no-c-format
msgid ""
"You can insert data into the table the same as you would if it was using a "
"GEOMETRY column:"
msgstr ""
"Você pode inserir dados na tabela da mesma forma que iria se estivesse "
"usando uma coluna GEOMETRIA:"

#. Tag: programlisting
#: using_postgis_dataman.xml:371
#, no-c-format
msgid ""
"-- Add some data into the test table\n"
"INSERT INTO global_points (name, location) VALUES ('Town', 'SRID=4326;"
"POINT(-110 30)');\n"
"INSERT INTO global_points (name, location) VALUES ('Forest', 'SRID=4326;"
"POINT(-109 29)');\n"
"INSERT INTO global_points (name, location) VALUES ('London', 'SRID=4326;"
"POINT(0 49)');"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:373
#, no-c-format
msgid ""
"Creating an index works the same as GEOMETRY. PostGIS will note that the "
"column type is GEOGRAPHY and create an appropriate sphere-based index "
"instead of the usual planar index used for GEOMETRY."
msgstr ""
"Criar um índice funciona da mesma forma que uma GEOMETRIA. O PostGIS irá "
"notar que o tipo de coluna é GEOGRAFIA e criará um índice baseado em esfera "
"apropriado em vez do de costume usado para GEOMETRIA. "

#. Tag: programlisting
#: using_postgis_dataman.xml:376
#, no-c-format
msgid ""
"-- Index the test table with a spherical index\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"
msgstr ""
"-- Index the test table with a spherical index\n"
"  CREATE INDEX global_points_gix ON global_points USING GIST ( location );"

#. Tag: para
#: using_postgis_dataman.xml:379
#, no-c-format
msgid ""
"Query and measurement functions use units of meters. So distance parameters "
"should be expressed in meters, and return values should be expected in "
"meters (or square meters for areas)."
msgstr ""
"As funções de consulta e medida usam unidades em metros. Então, os "
"parâmetros de distância deveriam ser esperados em metros (ou metros "
"quadrados para áreas). "

#. Tag: programlisting
#: using_postgis_dataman.xml:381
#, no-c-format
msgid ""
"-- Show a distance query and note, London is outside the 1000km tolerance\n"
"  SELECT name FROM global_points WHERE ST_DWithin(location, 'SRID=4326;"
"POINT(-110 29)'::geography, 1000000);"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:384
#, no-c-format
msgid ""
"You can see the power of GEOGRAPHY in action by calculating how close a "
"plane flying from Seattle to London (LINESTRING(-122.33 47.606, 0.0 51.5)) "
"comes to Reykjavik (POINT(-21.96 64.15))."
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:386
#, no-c-format
msgid ""
"-- Distance calculation using GEOGRAPHY (122.2km)\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geography, "
"'POINT(-21.96 64.15)'::geography);"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:389
#, no-c-format
msgid ""
"-- Distance calculation using GEOMETRY (13.3 \"degrees\")\n"
"  SELECT ST_Distance('LINESTRING(-122.33 47.606, 0.0 51.5)'::geometry, "
"'POINT(-21.96 64.15)'::geometry);"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:392
#, no-c-format
msgid ""
"Testing different lon/lat projects. Any long lat spatial reference system "
"listed in <varname>spatial_ref_sys</varname> table is allowed."
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:394
#, no-c-format
msgid ""
"-- NAD 83 lon/lat\n"
"SELECT 'SRID=4269;POINT(-123 34)'::geography;\n"
"                    geography\n"
"----------------------------------------------------\n"
" 0101000020AD1000000000000000C05EC00000000000004140\n"
"(1 row)"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:396
#, no-c-format
msgid ""
"-- NAD27 lon/lat\n"
"SELECT 'SRID=4267;POINT(-123 34)'::geography;\n"
"\n"
"                    geography\n"
"----------------------------------------------------\n"
" 0101000020AB1000000000000000C05EC00000000000004140\n"
"(1 row)"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:398
#, no-c-format
msgid ""
"-- NAD83 UTM zone meters, yields error since its a meter based projection\n"
"SELECT 'SRID=26910;POINT(-123 34)'::geography;\n"
"\n"
"ERROR:  Only lon/lat coordinate systems are supported in geography.\n"
"LINE 1: SELECT 'SRID=26910;POINT(-123 34)'::geography;"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:400
#, no-c-format
msgid ""
"The GEOGRAPHY type calculates the true shortest distance over the sphere "
"between Reykjavik and the great circle flight path between Seattle and "
"London."
msgstr ""
"O tipo GEOGRAFIA calcula a verdadeira menor distância sobre a esfera entre "
"Reykjavik e o grande caminho de voo circular entre Seattle e Londres. "

#. Tag: para
#: using_postgis_dataman.xml:402
#, no-c-format
msgid ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> The GEOMETRY type calculates a meaningless cartesian distance "
"between Reykjavik and the straight line path from Seattle to London plotted "
"on a flat map of the world. The nominal units of the result might be called "
"\"degrees\", but the result doesn't correspond to any true angular "
"difference between the points, so even calling them \"degrees\" is "
"inaccurate."
msgstr ""
"<ulink url=\"http://gc.kls2.com/cgi-bin/gc?PATH=SEA-LHR\">Great Circle "
"mapper</ulink> A GEOMETRIA calcula a distância cartesiana insignificante "
"entre Reykjavik e o caminho direto de Seattle para Londres marcado em um "
"mapa. As unidades nominais do resultado podem ser chamadas de \"graus\", mas "
"o resultado não corresponde a nenhuma diferença angular verdadeira entre os "
"pontos, então, chamá-las de \"graus\" é incoerente. "

#. Tag: title
#: using_postgis_dataman.xml:406
#, no-c-format
msgid "When to use Geography Data type over Geometry data type"
msgstr "Quando usar o tipo de dados Geografia sobre os dados Geometria"

#. Tag: para
#: using_postgis_dataman.xml:407
#, no-c-format
msgid ""
"The geography type allows you to store data in longitude/latitude "
"coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY "
"than there are on GEOMETRY; those functions that are defined take more CPU "
"time to execute."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:408
#, no-c-format
msgid ""
"The type you choose should be conditioned on the expected working area of "
"the application you are building. Will your data span the globe or a large "
"continental area, or is it local to a state, county or municipality?"
msgstr ""
"O tipo que você escolheu deveria ser condicionado da área de trabalho "
"esperada da aplicação que você está construindo. Seus dados irão abranger o "
"globo ou uma grande área continental, ou é local para um estado, condado ou "
"município? "

#. Tag: para
#: using_postgis_dataman.xml:410
#, no-c-format
msgid ""
"If your data is contained in a small area, you might find that choosing an "
"appropriate projection and using GEOMETRY is the best solution, in terms of "
"performance and functionality available."
msgstr ""
"Se seus dados estiverem contidos em uma pequena área, talvez perceba que "
"escolher uma projeção apropriada e usar GEOMETRIA é a melhor solução, em "
"termos de desempenho e funcionalidades disponíveis. "

#. Tag: para
#: using_postgis_dataman.xml:411
#, no-c-format
msgid ""
"If your data is global or covers a continental region, you may find that "
"GEOGRAPHY allows you to build a system without having to worry about "
"projection details. You store your data in longitude/latitude, and use the "
"functions that have been defined on GEOGRAPHY."
msgstr ""
"Se seus dados são globais ou cobrem uma região continental, você pode "
"perceber que GEOGRAFIA permite que você construa uma sistema sem ter que se "
"preocupar com detalhes de projeção. Você armazena seus dados em longitude/"
"latitude, e usa as funções que foram definidas em GEOGRAFIA. "

#. Tag: para
#: using_postgis_dataman.xml:413
#, no-c-format
msgid ""
"If you don't understand projections, and you don't want to learn about them, "
"and you're prepared to accept the limitations in functionality available in "
"GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. "
"Simply load your data up as longitude/latitude and go from there."
msgstr ""
"Se você não entende de projeções, não quer aprender sobre elas e está "
"preparado para aceitar as limitações em funcionalidade disponíveis em "
"GEOGRAFIA, então pode ser mais fácil se usar GEOGRAFIA em vez de GEOMETRIA. "
"Simplesmente carregue seus dados como longitude/latitude e comece a partir "
"daqui. "

#. Tag: para
#: using_postgis_dataman.xml:416
#, no-c-format
msgid ""
"Refer to <xref linkend=\"PostGIS_TypeFunctionMatrix\"/> for compare between "
"what is supported for Geography vs. Geometry. For a brief listing and "
"description of Geography functions, refer to <xref linkend="
"\"PostGIS_GeographyFunctions\"/>"
msgstr ""
"Recorra a <xref linkend=\"PostGIS_TypeFunctionMatrix\"/> para uma comparação "
"entre o que é suportado pela Geografia vs. Geometria. Para uma breve lista e "
"descrição das funções da Geografia, recorra a <xref linkend="
"\"PostGIS_GeographyFunctions\"/>"

#. Tag: title
#: using_postgis_dataman.xml:422
#, no-c-format
msgid "Geography Advanced FAQ"
msgstr "FAQ de Geografia Avançada"

#. Tag: para
#: using_postgis_dataman.xml:426
#, no-c-format
msgid "Do you calculate on the sphere or the spheroid?"
msgstr "Você calcula na esfera ou esferoide? "

#. Tag: para
#: using_postgis_dataman.xml:430
#, no-c-format
msgid ""
"By default, all distance and area calculations are done on the spheroid. You "
"should find that the results of calculations in local areas match up will "
"with local planar results in good local projections. Over larger areas, the "
"spheroidal calculations will be more accurate than any calculation done on a "
"projected plane."
msgstr ""
"Por padrão, todos os cálculos de distância e área são feitos no esferoide. "
"Você irá encontrar que os resultados dos cálculos nas áreas locais combinam "
"com os resultados locais planares em boas projeções locais. Em grandes "
"áreas, os cálculos esferoidais são mais precisos que os feitos em um plano "
"projetado. "

#. Tag: para
#: using_postgis_dataman.xml:433
#, no-c-format
msgid ""
"All the geography functions have the option of using a sphere calculation, "
"by setting a final boolean parameter to 'FALSE'. This will somewhat speed up "
"calculations, particularly for cases where the geometries are very simple."
msgstr ""
"Todas as funções de geografia têm a opção de usar um cálculo esférico, "
"configurando um parâmetro booleano final para 'FALSO'. isto irá acelerar os "
"cálculos, particularmente para casos onde as geometrias são bem simples. "

#. Tag: para
#: using_postgis_dataman.xml:439
#, no-c-format
msgid "What about the date-line and the poles?"
msgstr "E a linha de data e os pólos? "

#. Tag: para
#: using_postgis_dataman.xml:443
#, no-c-format
msgid ""
"All the calculations have no conception of date-line or poles, the "
"coordinates are spherical (longitude/latitude) so a shape that crosses the "
"dateline is, from a calculation point of view, no different from any other "
"shape."
msgstr ""
"Nenhum cálculo possui a compreensão de linha de data ou polos, as "
"coordenadas são esféricas (longitude/latitude), então uma forma que cruza a "
"linha de data não é, de um ponto de cálculo de view, diferente de nenhuma "
"outra forma."

#. Tag: para
#: using_postgis_dataman.xml:451
#, no-c-format
msgid "What is the longest arc you can process?"
msgstr "Qual é o maior arco que pode ser processado? "

#. Tag: para
#: using_postgis_dataman.xml:455
#, no-c-format
msgid ""
"We use great circle arcs as the \"interpolation line\" between two points. "
"That means any two points are actually joined up two ways, depending on "
"which direction you travel along the great circle. All our code assumes that "
"the points are joined by the *shorter* of the two paths along the great "
"circle. As a consequence, shapes that have arcs of more than 180 degrees "
"will not be correctly modelled."
msgstr ""
"Nós usamos grandes arcos círculos como a \"linha de interpolação\" entre "
"dois pontos. Isso significa que quaisquer dois pontos estão de fato juntaram-"
"se de duas maneiras, depende qual direção você vá no grande círculo. Todo o "
"nosso código assume que os pontos estão juntos pelo *menor* dos dois "
"caminhos ao longo do grande círculo. Como consequência, formas que têm arcos "
"de mais de 180 graus não serão modeladas corretamente. "

#. Tag: para
#: using_postgis_dataman.xml:462
#, no-c-format
msgid ""
"Why is it so slow to calculate the area of Europe / Russia / insert big "
"geographic region here ?"
msgstr ""
"Por que é tão lento para calcular a área da Europa / Rússia / insira uma "
"grande região geográfica aqui ?"

#. Tag: para
#: using_postgis_dataman.xml:466
#, no-c-format
msgid ""
"Because the polygon is so darned huge! Big areas are bad for two reasons: "
"their bounds are huge, so the index tends to pull the feature no matter what "
"query you run; the number of vertices is huge, and tests (distance, "
"containment) have to traverse the vertex list at least once and sometimes N "
"times (with N being the number of vertices in the other candidate feature)."
msgstr ""
"Porque o polígono é muito grande! Grandes áreas são ruins por duas razões: "
"seus limites são grandes, logo o índice tende a puxar o traço, não importa "
"qual consulta você execute; o número de vértices é enorme, e testes "
"(distância, contenção) têm que atravessar a lista de vértices pelo meno uma "
"vez e algumas vezes, N vezes (com N sendo o número de vértices em outra "
"característica candidata). "

#. Tag: para
#: using_postgis_dataman.xml:471
#, no-c-format
msgid ""
"As with GEOMETRY, we recommend that when you have very large polygons, but "
"are doing queries in small areas, you \"denormalize\" your geometric data "
"into smaller chunks so that the index can effectively subquery parts of the "
"object and so queries don't have to pull out the whole object every time. "
"Please consult <xref linkend=\"ST_Subdivide\"/> function documentation. Just "
"because you *can* store all of Europe in one polygon doesn't mean you "
"*should*."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:480
#, fuzzy, no-c-format
msgid "Spatial Tables"
msgstr "Criando uma Tabela Espacial "

#. Tag: title
#: using_postgis_dataman.xml:483
#, no-c-format
msgid "Creating a Spatial Table"
msgstr "Criando uma Tabela Espacial "

#. Tag: para
#: using_postgis_dataman.xml:485
#, no-c-format
msgid ""
"Creating a table with spatial data, can be done in one step. As shown in the "
"following example which creates a roads table with a 2D linestring geometry "
"column in WGS84 long lat"
msgstr ""
"Criando uma tabela com dados espaciais, pode ser feito em um passo. Como "
"mostra no exemplo seguinte, o qual cria tabelas de ruas com uma coluna de "
"geometria linestring 2D em WGS84 long lat"

#. Tag: programlisting
#: using_postgis_dataman.xml:487
#, no-c-format
msgid ""
"CREATE TABLE ROADS (ID serial, ROAD_NAME text, geom "
"geometry(LINESTRING,4326) );"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:489
#, no-c-format
msgid ""
"We can add additional columns using standard ALTER TABLE command as we do in "
"this next example where we add a 3-D linestring."
msgstr ""
"Podemos adicionar colunas usando o comando padrão ALTERAR TABELA como "
"fazemos no próximo exemplo onde adicionamos uma linestring 3-D. "

#. Tag: programlisting
#: using_postgis_dataman.xml:490
#, no-c-format
msgid "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"
msgstr "ALTER TABLE roads ADD COLUMN geom2 geometry(LINESTRINGZ,4326);"

#. Tag: title
#: using_postgis_dataman.xml:494
#, fuzzy, no-c-format
msgid "The GEOMETRY_COLUMNS View"
msgstr "A GEOMETRY_COLUMNS VIEW"

#. Tag: para
#: using_postgis_dataman.xml:496
#, fuzzy, no-c-format
msgid ""
"The OpenGIS \"Simple Features Specification for SQL\" defines the "
"<varname>GEOMETRY_COLUMNS</varname> metadata table to describe geometry "
"table structure. In order to ensure that metadata remains consistent, "
"operations such as creating and removing a spatial column are carried out "
"through special procedures defined by OpenGIS."
msgstr ""
"O OpenGIS \"Especificação de Características Simples para SQL\" define tipos "
"padrão de objetos GIS, as funções requeridas para manipulá-los e um conjunto "
"de tabelas de metadados. Querendo certificar-se de que os metadados "
"permaneçam consistentes, operações como criar e remover uma coluna espacial "
"são carregadas para fora dos procedimentos especiais definido pelo OpenGIS. "

#. Tag: para
#: using_postgis_dataman.xml:502
#, no-c-format
msgid ""
"In PostGIS <varname>geometry_columns</varname> is a view reading from "
"database system catalog tables. Its structure is:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:505
#, no-c-format
msgid "\\d geometry_columns"
msgstr "\\d geometry_columns"

#. Tag: screen
#: using_postgis_dataman.xml:506
#, no-c-format
msgid ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"
msgstr ""
"View \"public.geometry_columns\"\n"
"      Column       |          Type          | Modifiers\n"
"-------------------+------------------------+-----------\n"
" f_table_catalog   | character varying(256) |\n"
" f_table_schema    | character varying(256) |\n"
" f_table_name      | character varying(256) |\n"
" f_geometry_column | character varying(256) |\n"
" coord_dimension   | integer                |\n"
" srid              | integer                |\n"
" type              | character varying(30)  |"

#. Tag: para
#: using_postgis_dataman.xml:508 using_postgis_dataman.xml:630
#, fuzzy, no-c-format
msgid "The columns are:"
msgstr "As opções da commandline são:"

#. Tag: term
#: using_postgis_dataman.xml:512
#, no-c-format
msgid "f_table_catalog, f_table_schema, f_table_name"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:515
#, fuzzy, no-c-format
msgid ""
"The fully qualified name of the feature table containing the geometry "
"column. Note that the terms \"catalog\" and \"schema\" are Oracle-ish. There "
"is no PostgreSQL analogue of \"catalog\" so that column is left blank . For "
"\"schema\" the PostgreSQL schema name is used (<varname>public</varname> is "
"the default)."
msgstr ""
"O nome completo da tabela de característica que contém a coluna geométrica. "
"Note que os termos \"catálogo\" e \"esquema\" são Oracle. Não existe um "
"análogo do \"catálogo\" PostgreSQL, logo a coluna é deixada em branco -- "
"para \"esquema\" o nome do esquema PostgreSQL é usado (<varname>public</"
"varname> é o padrão)."

#. Tag: term
#: using_postgis_dataman.xml:524
#, fuzzy, no-c-format
msgid "f_geometry_column"
msgstr "\\d geometry_columns"

#. Tag: para
#: using_postgis_dataman.xml:527
#, no-c-format
msgid "The name of the geometry column in the feature table."
msgstr "O nome da coluna geométrica na tabela característica. "

#. Tag: term
#: using_postgis_dataman.xml:532
#, no-c-format
msgid "coord_dimension"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:535
#, no-c-format
msgid "The spatial dimension (2, 3 or 4 dimensional) of the column."
msgstr "A dimensão espacial (2, 3 ou 4 dimensões) da coluna. "

#. Tag: term
#: using_postgis_dataman.xml:541 using_postgis_dataman.xml:634
#, no-c-format
msgid "srid"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:544
#, fuzzy, no-c-format
msgid ""
"The ID of the spatial reference system used for the coordinate geometry in "
"this table. It is a foreign key reference to the <varname>spatial_ref_sys</"
"varname> table (see <xref linkend=\"spatial_ref_sys_table\"/>)."
msgstr ""
"A ID do sistema de referência espacial usada pela coordenada nesta coluna. É "
"uma referência de chave estrangeira para <varname>SPATIAL_REF_SYS</varname>."

#. Tag: term
#: using_postgis_dataman.xml:552
#, no-c-format
msgid "type"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:555
#, no-c-format
msgid ""
"The type of the spatial object. To restrict the spatial column to a single "
"type, use one of: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, "
"MULTIPOLYGON, GEOMETRYCOLLECTION or corresponding XYM versions POINTM, "
"LINESTRINGM, POLYGONM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLYGONM, "
"GEOMETRYCOLLECTIONM. For heterogeneous (mixed-type) collections, you can use "
"\"GEOMETRY\" as the type."
msgstr ""
"O tipo do objeto espacial. Para restringir a coluna espacial a um tipo só, "
"use um dos: PONTO, LINESTRING, POLÍGONO, MULTIPONTO, MULTILINESTRING, "
"MULTIPOLÍGONO, GEOMETRYCOLLECTION ou versões correspondentes XYM  PONTOM, "
"LINESTRINGM, POLÍGONOM, MULTIPOINTM, MULTILINESTRINGM, MULTIPOLÍGONOM, "
"GEOMETRYCOLLECTIONM. Para coleções heterogêneas (do tipo mistas), você pode "
"usar \"GEOMETRIA\" como o tipo. "

#. Tag: para
#: using_postgis_dataman.xml:564
#, no-c-format
msgid ""
"This attribute is (probably) not part of the OpenGIS specification, but is "
"required for ensuring type homogeneity."
msgstr ""
"Este atributo (provavelmente) não é parte da especificação OpenGIS, mas é "
"solicitada para assegurar a homogeneidade do tipo. "

#. Tag: title
#: using_postgis_dataman.xml:574
#, fuzzy, no-c-format
msgid "Manually Registering Geometry Columns"
msgstr "Registrando manualmente as colunas geométricas em geometry_columns"

#. Tag: para
#: using_postgis_dataman.xml:576
#, no-c-format
msgid ""
"Two of the cases where you may need this are the case of SQL Views and bulk "
"inserts. For bulk insert case, you can correct the registration in the "
"geometry_columns table by constraining the column or doing an alter table. "
"For views, you could expose using a CAST operation. Note, if your column is "
"typmod based, the creation process would register it correctly, so no need "
"to do anything. Also views that have no spatial function applied to the "
"geometry will register the same as the underlying table geometry column."
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:581
#, no-c-format
msgid ""
"-- Lets say you have a view created like this\n"
"CREATE VIEW public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom, 3395) As geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- For it to register correctly\n"
"-- You need to cast the geometry\n"
"--\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom, 3395)::geometry(Geometry, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;\n"
"\n"
"-- If you know the geometry type for sure is a 2D POLYGON then you could do\n"
"DROP VIEW public.vwmytablemercator;\n"
"CREATE VIEW  public.vwmytablemercator AS\n"
"        SELECT gid, ST_Transform(geom,3395)::geometry(Polygon, 3395) As "
"geom, f_name\n"
"        FROM public.mytable;"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:582
#, no-c-format
msgid ""
"--Lets say you created a derivative table by doing a bulk insert\n"
"SELECT poi.gid, poi.geom, citybounds.city_name\n"
"INTO myschema.my_special_pois\n"
"FROM poi INNER JOIN citybounds ON ST_Intersects(citybounds.geom, poi.geom);\n"
"\n"
"-- Create 2D index on new table\n"
"CREATE INDEX idx_myschema_myspecialpois_geom_gist\n"
"  ON myschema.my_special_pois USING gist(geom);\n"
"\n"
"-- If your points are 3D points or 3M points,\n"
"-- then you might want to create an nd index instead of a 2D index\n"
"CREATE INDEX my_special_pois_geom_gist_nd\n"
"        ON my_special_pois USING gist(geom gist_geometry_ops_nd);\n"
"\n"
"-- To manually register this new table's geometry column in "
"geometry_columns.\n"
"-- Note it will also change the underlying structure of the table to\n"
"-- to make the column typmod based.\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass);\n"
"\n"
"-- If you are using PostGIS 2.0 and for whatever reason, you\n"
"-- you need the constraint based definition behavior\n"
"-- (such as case of inherited tables where all children do not have the same "
"type and srid)\n"
"-- set optional use_typmod argument to false\n"
"SELECT populate_geometry_columns('myschema.my_special_pois'::regclass, "
"false);"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:584
#, no-c-format
msgid ""
"Although the old-constraint based method is still supported, a constraint-"
"based geometry column used directly in a view, will not register correctly "
"in geometry_columns, as will a typmod one. In this example we define a "
"column using typmod and another using constraints."
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:587
#, no-c-format
msgid ""
"CREATE TABLE pois_ny(gid SERIAL PRIMARY KEY, poi_name text, cat text, geom "
"geometry(POINT,4326));\n"
"SELECT AddGeometryColumn('pois_ny', 'geom_2160', 2160, 'POINT', 2, false);"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:588
#, no-c-format
msgid "If we run in psql"
msgstr "Se executarmos em psql"

#. Tag: programlisting
#: using_postgis_dataman.xml:589
#, no-c-format
msgid "\\d pois_ny;"
msgstr "\\d pois_ny;"

#. Tag: para
#: using_postgis_dataman.xml:590
#, no-c-format
msgid ""
"We observe they are defined differently -- one is typmod, one is constraint"
msgstr ""
"Observamos que elas são definidas de maneira diferente -- uma é typmod, "
"outra é restrição "

#. Tag: screen
#: using_postgis_dataman.xml:591
#, no-c-format
msgid ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"
msgstr ""
"Table \"public.pois_ny\"\n"
"  Column   |         Type          |                       Modifiers\n"
"\n"
"-----------+-----------------------"
"+------------------------------------------------------\n"
" gid       | integer               | not null default "
"nextval('pois_ny_gid_seq'::regclass)\n"
" poi_name  | text                  |\n"
" cat       | character varying(20) |\n"
" geom      | geometry(Point,4326)  |\n"
" geom_2160 | geometry              |\n"
"Indexes:\n"
"    \"pois_ny_pkey\" PRIMARY KEY, btree (gid)\n"
"Check constraints:\n"
"    \"enforce_dims_geom_2160\" CHECK (st_ndims(geom_2160) = 2)\n"
"    \"enforce_geotype_geom_2160\" CHECK (geometrytype(geom_2160) = 'POINT'::"
"text\n"
"        OR geom_2160 IS NULL)\n"
"    \"enforce_srid_geom_2160\" CHECK (st_srid(geom_2160) = 2160)"

#. Tag: para
#: using_postgis_dataman.xml:592
#, no-c-format
msgid "In geometry_columns, they both register correctly"
msgstr "Nas geometry_columns, elas registram corretamente"

#. Tag: programlisting
#: using_postgis_dataman.xml:593
#, no-c-format
msgid ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"
msgstr ""
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'pois_ny';"

#. Tag: screen
#: using_postgis_dataman.xml:594
#, no-c-format
msgid ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name | f_geometry_column | srid | type\n"
"-------------+-------------------+------+-------\n"
"pois_ny      | geom              | 4326 | POINT\n"
"pois_ny      | geom_2160         | 2160 | POINT"

#. Tag: para
#: using_postgis_dataman.xml:595
#, no-c-format
msgid "However -- if we were to create a view like this"
msgstr "Entretanto -- se se quiséssemos criar uma view como essa"

#. Tag: programlisting
#: using_postgis_dataman.xml:596
#, no-c-format
msgid ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT *\n"
"  FROM pois_ny\n"
"  WHERE cat='park';\n"
"\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"

#. Tag: para
#: using_postgis_dataman.xml:597
#, no-c-format
msgid ""
"The typmod based geom view column registers correctly, but the constraint "
"based one does not."
msgstr ""
"A coluna baseada em typmod registra corretamente, mas a baseada em "
"restrições não."

#. Tag: screen
#: using_postgis_dataman.xml:599
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"
msgstr ""
"f_table_name   | f_geometry_column | srid |   type\n"
"------------------+-------------------+------+----------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         |    0 | GEOMETRY"

#. Tag: para
#: using_postgis_dataman.xml:601
#, fuzzy, no-c-format
msgid ""
"This may change in future versions of PostGIS, but for now to force the "
"constraint-based view column to register correctly, you need to do this:"
msgstr ""
"Isto pode modificar as versões futuras do PostGIS, mas por enquanto para "
"forçar a restrição baseada em coluna view registrar corretamente, precisamos "
"fazer isto: "

#. Tag: programlisting
#: using_postgis_dataman.xml:603
#, no-c-format
msgid ""
"DROP VIEW vw_pois_ny_parks;\n"
"CREATE VIEW vw_pois_ny_parks AS\n"
"SELECT gid, poi_name, cat,\n"
"  geom,\n"
"  geom_2160::geometry(POINT,2160) As geom_2160\n"
"  FROM pois_ny\n"
"  WHERE cat = 'park';\n"
"SELECT f_table_name, f_geometry_column, srid, type\n"
"        FROM geometry_columns\n"
"        WHERE f_table_name = 'vw_pois_ny_parks';"
msgstr ""

#. Tag: screen
#: using_postgis_dataman.xml:604
#, no-c-format
msgid ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"
msgstr ""
"f_table_name   | f_geometry_column | srid | type\n"
"------------------+-------------------+------+-------\n"
" vw_pois_ny_parks | geom              | 4326 | POINT\n"
" vw_pois_ny_parks | geom_2160         | 2160 | POINT"

#. Tag: title
#: using_postgis_dataman.xml:610
#, fuzzy, no-c-format
msgid "Spatial Reference Systems"
msgstr "The SPATIAL_REF_SYS Table and Spatial Reference Systems"

#. Tag: para
#: using_postgis_dataman.xml:612
#, no-c-format
msgid ""
"<ulink url=\"https://en.wikipedia.org/wiki/Spatial_reference_system"
"\">Spatial Reference Systems</ulink> (SRS) define how geometry is referenced "
"to locations on the Earth's surface."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:616
#, no-c-format
msgid "SPATIAL_REF_SYS Table"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:618
#, no-c-format
msgid ""
"The <varname>SPATIAL_REF_SYS</varname> table used by PostGIS is an OGC-"
"compliant database table that defines the available spatial reference "
"systems. It holds the numeric IDs and textual descriptions of the coordinate "
"systems. The main use is to support transformation (reprojection) between "
"them using <xref linkend=\"ST_Transform\"/>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:626
#, fuzzy, no-c-format
msgid "The <varname>spatial_ref_sys</varname> table definition is:"
msgstr ""
"A tabela <varname>SPATIAL_REF_SYS</varname> de definição está como segue:"

#. Tag: programlisting
#: using_postgis_dataman.xml:628
#, no-c-format
msgid ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"
msgstr ""
"CREATE TABLE spatial_ref_sys (\n"
"  srid       INTEGER NOT NULL PRIMARY KEY,\n"
"  auth_name  VARCHAR(256),\n"
"  auth_srid  INTEGER,\n"
"  srtext     VARCHAR(2048),\n"
"  proj4text  VARCHAR(2048)\n"
")"

#. Tag: para
#: using_postgis_dataman.xml:637
#, fuzzy, no-c-format
msgid ""
"An integer code that uniquely identifies the <ulink url=\"http://en."
"wikipedia.org/wiki/SRID\">Spatial Reference System</ulink> (SRS) within the "
"database."
msgstr ""
"Um valor inteiro que só identifica o Sistema de Referenciação Espacial (SRS) "
"dentro do banco de dados. "

#. Tag: term
#: using_postgis_dataman.xml:643
#, no-c-format
msgid "auth_name"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:646
#, fuzzy, no-c-format
msgid ""
"The name of the standard or standards body that is being cited for this "
"reference system. For example, \"EPSG\" is a valid <varname>auth_name</"
"varname>."
msgstr ""
"O nome do corpo padrão ou corpos padrẽos que estão sendo citados por este "
"sistema de referência. Por exemplo, \"EPSG\" seria um <varname>AUTH_NAME</"
"varname> válido."

#. Tag: term
#: using_postgis_dataman.xml:653
#, no-c-format
msgid "auth_srid"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:656
#, fuzzy, no-c-format
msgid ""
"The ID of the Spatial Reference System as defined by the Authority cited in "
"the <varname>auth_name</varname>. In the case of EPSG, this is where the "
"EPSG projection code would go."
msgstr ""
"A ID do sistema de referência espacial como definido pela autoridade citada "
"no <varname>AUTH_NAME</varname>. No caso do EPSG, isto é onde o código da "
"projeção EPSG estaria. "

#. Tag: term
#: using_postgis_dataman.xml:663
#, no-c-format
msgid "srtext"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:666
#, no-c-format
msgid ""
"The Well-Known Text representation of the Spatial Reference System. An "
"example of a WKT SRS representation is:"
msgstr ""
"A representação bem conhecida de texto do sistema de referência espacial. Um "
"exemplo de uma representação WKT SRS é:"

#. Tag: programlisting
#: using_postgis_dataman.xml:669
#, no-c-format
msgid ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"
msgstr ""
"PROJCS[\"NAD83 / UTM Zone 10N\",\n"
"  GEOGCS[\"NAD83\",\n"
"        DATUM[\"North_American_Datum_1983\",\n"
"          SPHEROID[\"GRS 1980\",6378137,298.257222101]\n"
"        ],\n"
"        PRIMEM[\"Greenwich\",0],\n"
"        UNIT[\"degree\",0.0174532925199433]\n"
"  ],\n"
"  PROJECTION[\"Transverse_Mercator\"],\n"
"  PARAMETER[\"latitude_of_origin\",0],\n"
"  PARAMETER[\"central_meridian\",-123],\n"
"  PARAMETER[\"scale_factor\",0.9996],\n"
"  PARAMETER[\"false_easting\",500000],\n"
"  PARAMETER[\"false_northing\",0],\n"
"  UNIT[\"metre\",1]\n"
"]"

#. Tag: para
#: using_postgis_dataman.xml:671
#, fuzzy, no-c-format
msgid ""
"For a listing of EPSG projection codes and their corresponding WKT "
"representations, see <ulink url=\"http://www.opengeospatial.org/\">http://"
"www.opengeospatial.org/</ulink>. For a discussion of SRS WKT in general, see "
"the OpenGIS \"Coordinate Transformation Services Implementation Specification"
"\" at <ulink url=\"http://www.opengeospatial.org/standards\">http://www."
"opengeospatial.org/standards</ulink>. For information on the European "
"Petroleum Survey Group (EPSG) and their database of spatial reference "
"systems, see <ulink url=\"http://www.epsg.org/\">http://www.epsg.org</ulink>."
msgstr ""
"Para uma listagem de códigos de projeção EPSG e suas correspondentes "
"representações WKT, veja <ulink url=\"http://www.opengeospatial.org/"
"\">http://www.opengeospatial.org/</ulink>. Para uma discussão geral de WKT, "
"veja o OpenGIS \"Coordinate Transformation Services Implementation "
"Specification\" em <ulink url=\"http://www.opengeospatial.org/standards"
"\">http://www.opengeospatial.org/standards</ulink>. Para maiores informações "
"no European Petroleum Survey Group (EPSG) e no banco de dados deles de "
"sistemas de referência espacial, veja <ulink url=\"http://www.epsg.org/"
"\">http://www.epsg.org</ulink>."

#. Tag: term
#: using_postgis_dataman.xml:684
#, no-c-format
msgid "proj4text"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:687
#, fuzzy, no-c-format
msgid ""
"PostGIS uses the PROJ library to provide coordinate transformation "
"capabilities. The <varname>proj4text</varname> column contains the PROJ "
"coordinate definition string for a particular SRID. For example:"
msgstr ""
"O PostGIS usa a biblioteca Proj4 para fornecer capacidades de transformação "
"de coordenada. A coluna <varname>PROJ4TEXT</varname> contém a string de "
"definição da coordenada Proj4 para um SRID específico. Por exemplo:"

#. Tag: programlisting
#: using_postgis_dataman.xml:692
#, no-c-format
msgid "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"
msgstr "+proj=utm +zone=10 +ellps=clrk66 +datum=NAD27 +units=m"

#. Tag: para
#: using_postgis_dataman.xml:694
#, fuzzy, no-c-format
msgid ""
"For more information see the <ulink url=\"https://proj.org/\">PROJ web site</"
"ulink>. The <filename>spatial_ref_sys.sql</filename> file contains both "
"<varname>srtext</varname> and <varname>proj4text</varname> definitions for "
"all EPSG projections."
msgstr ""
"Para maiores informações a respeito, veja o website do Proj4 <ulink url="
"\"http://trac.osgeo.org/proj/\">http://trac.osgeo.org/proj/</ulink>. O "
"arquivo <filename>spatial_ref_sys.sql</filename> contém as definições "
"<varname>SRTEXT</varname> e <varname>PROJ4TEXT</varname> para todas as "
"projeções EPSG."

#. Tag: para
#: using_postgis_dataman.xml:703
#, no-c-format
msgid ""
"When retrieving spatial reference system definitions for use in "
"transformations, PostGIS uses fhe following strategy:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:707
#, no-c-format
msgid ""
"If <varname>auth_name</varname> and <varname>auth_srid</varname> are present "
"(non-NULL) use the PROJ SRS based on those entries (if one exists)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:711
#, no-c-format
msgid ""
"If <varname>srtext</varname> is present create a SRS using it, if possible."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:714
#, no-c-format
msgid ""
"If <varname>proj4text</varname> is present create a SRS using it, if "
"possible."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:720
#, fuzzy, no-c-format
msgid "User-Defined Spatial Reference Systems"
msgstr "The SPATIAL_REF_SYS Table and Spatial Reference Systems"

#. Tag: para
#: using_postgis_dataman.xml:722
#, no-c-format
msgid ""
"The PostGIS <varname>spatial_ref_sys</varname> table contains over 3000 of "
"the most common spatial reference system definitions that are handled by the "
"<ulink url=\"https://proj.org\">PROJ</ulink> projection library. But there "
"are many coordinate systems that it does not contain. You can add SRS "
"definitions to the table if you have the required information about the "
"spatial reference system. Or, you can define your own custom spatial "
"reference system if you are familiar with PROJ constructs. Keep in mind that "
"most spatial reference systems are regional and have no meaning when used "
"outside of the bounds they were intended for."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:732
#, fuzzy, no-c-format
msgid ""
"A resource for finding spatial reference systems not defined in the core set "
"is <ulink url=\"http://spatialreference.org/\">http://spatialreference.org/</"
"ulink>"
msgstr ""
"Uma ótima fonte para encontrar sistemas de referência espacial não definidos "
"na configuração central é <ulink url=\"http://spatialreference.org/\">http://"
"spatialreference.org/</ulink>"

#. Tag: para
#: using_postgis_dataman.xml:734
#, fuzzy, no-c-format
msgid ""
"Some commonly used spatial reference systems are: <ulink url=\"http://"
"spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</ulink>, <ulink "
"url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD 83 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/\">3395 - WGS "
"84 World Mercator</ulink>, <ulink url=\"http://spatialreference.org/ref/"
"epsg/2163/\">2163 - US National Atlas Equal Area</ulink>, and the 60 WGS84 "
"UTM zones. UTM zones are one of the most ideal for measurement, but only "
"cover 6-degree regions. (To determine which UTM zone to use for your area of "
"interest, see the <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
"UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper function</"
"ulink>.)"
msgstr ""
"Alguns dos sistemas de referência espacial mais comumente usados são: <ulink "
"url=\"http://spatialreference.org/ref/epsg/4326/\">4326 - WGS 84 Long Lat</"
"ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/4269/\">4269 - NAD "
"83 Long Lat</ulink>, <ulink url=\"http://spatialreference.org/ref/epsg/3395/"
"\">3395 - WGS 84 World Mercator</ulink>, <ulink url=\"http://"
"spatialreference.org/ref/epsg/2163/\">2163 - US National Atlas Equal Area</"
"ulink>,  Spatial reference systems para cadaNAD 83, WGS 84 UTM zona - zonas "
"UTM  são as mais ideais para medição, mas só cobrem 6-graus regiões. "

#. Tag: para
#: using_postgis_dataman.xml:743
#, fuzzy, no-c-format
msgid ""
"US states use State Plane spatial reference systems (meter or feet based) - "
"usually one or 2 exists per state. Most of the meter-based ones are in the "
"core set, but many of the feet-based ones or ESRI-created ones will need to "
"be copied from <ulink url=\"http://spatialreference.org\">spatialreference."
"org</ulink>."
msgstr ""
"Vários estados dos EUA no sistema de referência espacial (em metros ou pés) "
"- normalmente um ou 2 existem por estado. A maioria dos que estão em metros "
"estão no centro, mas muitos dos que estão em pés ou foram criados por ESRI "
"precisarão de <ulink url=\"http://spatialreference.org\">spatialreference."
"org</ulink>."

#. Tag: para
#: using_postgis_dataman.xml:749
#, no-c-format
msgid ""
"You can even define non-Earth-based coordinate systems, such as <ulink url="
"\"http://spatialreference.org/ref/iau2000/mars-2000/\">Mars 2000</ulink> "
"This Mars coordinate system is non-planar (it's in degrees spheroidal), but "
"you can use it with the <varname>geography</varname> type to obtain length "
"and proximity measurements in meters instead of degrees."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:755
#, no-c-format
msgid ""
"Here is an example of loading a custom coordinate system using an unassigned "
"SRID and the PROJ definition for a US-centric Lambert Conformal projection:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:758
#, no-c-format
msgid ""
"INSERT INTO spatial_ref_sys (srid, proj4text)\n"
"VALUES ( 990000,\n"
"  '+proj=lcc  +lon_0=-95 +lat_0=25 +lat_1=25 +lat_2=25 +x_0=0 +y_0=0 "
"+datum=WGS84 +units=m +no_defs'\n"
");"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:765
#, no-c-format
msgid "Geometry Validation"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:767
#, no-c-format
msgid ""
"PostGIS is compliant with the Open Geospatial Consortium’s (OGC) OpenGIS "
"Specifications. As such, many PostGIS methods require, or more accurately, "
"assume that geometries that are operated on are both simple and valid. For "
"example, it does not make sense to calculate the area of a polygon that has "
"a hole defined outside of the polygon, or to construct a polygon from a non-"
"simple boundary line."
msgstr ""
"O PostGIS é condescendente com as Open Geospatial Consortium’s (OGC) OpenGIS "
"Specifications. Dessa forma, vários métodos PostGIS requerem, ou mais "
"precisamente, presumem que as geometrias que são operadas são simples e "
"válidas. Por exemplo, não faz sentido calcular a área de um polígono que tem "
"um buraco definido fora do polígono, ou construir um polígono de uma linha "
"delimitadora não simples. "

#. Tag: para
#: using_postgis_dataman.xml:774
#, no-c-format
msgid ""
"According to the OGC Specifications, a <emphasis>simple</emphasis> geometry "
"is one that has no anomalous geometric points, such as self intersection or "
"self tangency and primarily refers to 0 or 1-dimensional geometries (i.e. "
"<varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). Geometry validity, on "
"the other hand, primarily refers to 2-dimensional geometries (i.e. "
"<varname>[MULTI]POLYGON)</varname> and defines the set of assertions that "
"characterizes a valid polygon. The description of each geometric class "
"includes specific conditions that further detail geometric simplicity and "
"validity."
msgstr ""
"De acordo com as especificações OGC, uma geometria <emphasis>simple</"
"emphasis> é aquela que não possui pontos geométricos anômalos, como: auto "
"interseção ou auto tangenciação e refere-se primeiramente a geometrias 0 ou "
"1-diemensional  (ex.: <varname>[MULTI]POINT, [MULTI]LINESTRING</varname>). "
"Por outro lado, a validade da geometria refere-se primeiramente a geometrias "
"2-dimensional (ex.: <varname>[MULTI]POLYGON)</varname> e define o conjunto "
"de afirmações que caracterizam um polígono válido. A descrição de cada "
"classe de geometria inclui condições específicas que detalham mais a "
"simplicidade e validade geométricas.  "

#. Tag: para
#: using_postgis_dataman.xml:784
#, fuzzy, no-c-format
msgid ""
"A <varname>POINT</varname> is inherently <emphasis>simple</emphasis> as a 0-"
"dimensional geometry object."
msgstr ""
"Um <varname>POINT</varname> é herdado <emphasis>simple</emphasis> como um "
"objeto geométrico 0-dimensional. "

#. Tag: para
#: using_postgis_dataman.xml:787
#, no-c-format
msgid ""
"<varname>MULTIPOINT</varname>s are <emphasis>simple</emphasis> if no two "
"coordinates (<varname>POINT</varname>s) are equal (have identical coordinate "
"values)."
msgstr ""
"<varname>MULTIPOINT</varname>s são <emphasis>simple</emphasis> se nenhuma de "
"duas coordenadas (<varname>POINT</varname>s) forem iguais (tenham o valor de "
"coordenadas idêntico)."

#. Tag: para
#: using_postgis_dataman.xml:791
#, no-c-format
msgid ""
"A <varname>LINESTRING</varname> is <emphasis>simple</emphasis> if it does "
"not pass through the same <varname>POINT</varname> twice (except for the "
"endpoints, in which case it is referred to as a linear ring and additionally "
"considered closed)."
msgstr ""
"Uma  <varname>LINESTRING</varname> é <emphasis>simple</emphasis> se não "
"passa pelo mesmo <varname>POINT</varname> duas vezes (exceto para ponto "
"finais, em cada caso são referidos como um anel linear e considerados "
"fechados). "

#. Tag: emphasis
#: using_postgis_dataman.xml:806
#, no-c-format
msgid "<emphasis>(a)</emphasis>"
msgstr "<emphasis>(a)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:816
#, no-c-format
msgid "<emphasis>(b)</emphasis>"
msgstr "<emphasis>(b)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:828
#, no-c-format
msgid "<emphasis>(c)</emphasis>"
msgstr "<emphasis>(c)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:838
#, no-c-format
msgid "<emphasis>(d)</emphasis>"
msgstr "<emphasis>(d)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:848
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(a)</emphasis> and <emphasis role=\"bold\">(c)</"
"emphasis> are simple <varname>LINESTRING</varname>s, <emphasis role=\"bold"
"\">(b)</emphasis> and <emphasis role=\"bold\">(d)</emphasis> are not."
msgstr ""
"<emphasis role=\"bold\">(a)</emphasis> e <emphasis role=\"bold\">(c)</"
"emphasis> são simples <varname>LINESTRING</varname>s, <emphasis role=\"bold"
"\">(b)</emphasis> e <emphasis role=\"bold\">(d)</emphasis> não são."

#. Tag: para
#: using_postgis_dataman.xml:857
#, no-c-format
msgid ""
"A <varname>MULTILINESTRING</varname> is <emphasis>simple</emphasis> only if "
"all of its elements are simple and the only intersection between any two "
"elements occurs at <varname>POINT</varname>s that are on the boundaries of "
"both elements."
msgstr ""
"Uma <varname>MULTILINESTRING</varname> é <emphasis>simple</emphasis> somente "
"se todos seus elementos forem simples e a única interseção entre qualquer um "
"dos dois elementos ocorre em <varname>POINT</varname>s que estão nos limites "
"dos dois elementos. "

#. Tag: emphasis
#: using_postgis_dataman.xml:872
#, no-c-format
msgid "<emphasis>(e)</emphasis>"
msgstr "<emphasis>(e)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:882
#, no-c-format
msgid "<emphasis>(f)</emphasis>"
msgstr "<emphasis>(f)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:892
#, no-c-format
msgid "<emphasis>(g)</emphasis>"
msgstr "<emphasis>(g)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:902
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(e)</emphasis> and <emphasis role=\"bold\">(f)</"
"emphasis> are simple <varname>MULTILINESTRING</varname>s, <emphasis role="
"\"bold\">(g)</emphasis> is not."
msgstr ""
"<emphasis role=\"bold\">(e)</emphasis> e <emphasis role=\"bold\">(f)</"
"emphasis> são simples <varname>MULTILINESTRING</varname>s, <emphasis role="
"\"bold\">(g)</emphasis> não são."

#. Tag: para
#: using_postgis_dataman.xml:911
#, no-c-format
msgid ""
"By definition, a <varname>POLYGON</varname> is always <emphasis>simple</"
"emphasis>. It is <emphasis>valid</emphasis> if no two rings in the boundary "
"(made up of an exterior ring and interior rings) cross. The boundary of a "
"<varname>POLYGON</varname> may intersect at a <varname>POINT</varname> but "
"only as a tangent (i.e. not on a line). A <varname>POLYGON</varname> may not "
"have cut lines or spikes and the interior rings must be contained entirely "
"within the exterior ring."
msgstr ""
"Por definição, um <varname>POLYGON</varname> é sempre <emphasis>simple</"
"emphasis>. Ele é <emphasis>valid</emphasis> se nenhum dos dois anéis (feitos "
"de um exterior e um interior) no limite cruzar. O limite de um "
"<varname>POLYGON</varname> pode intersectar em um <varname>POINT</varname> "
"mas só como uma tangente (ex.: não em uma linha). Um <varname>POLYGON</"
"varname> pode não ter linhas cortadas ou extremidades e os anéis interiores "
"devem estar inteiramente contidos dentro dos anéis exteriores. "

#. Tag: emphasis
#: using_postgis_dataman.xml:929
#, no-c-format
msgid "<emphasis>(h)</emphasis>"
msgstr "<emphasis>(h)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:939
#, no-c-format
msgid "<emphasis>(i)</emphasis>"
msgstr "<emphasis>(i)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:949
#, no-c-format
msgid "<emphasis>(j)</emphasis>"
msgstr "<emphasis>(j)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:961
#, no-c-format
msgid "<emphasis>(k)</emphasis>"
msgstr "<emphasis>(k)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:971
#, no-c-format
msgid "<emphasis>(l)</emphasis>"
msgstr "<emphasis>(l)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:981
#, no-c-format
msgid "<emphasis>(m)</emphasis>"
msgstr "<emphasis>(m)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:990
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(h)</emphasis> and <emphasis role=\"bold\">(i)</"
"emphasis> are valid <varname>POLYGON</varname>s, <emphasis role=\"bold\">(j-"
"m)</emphasis> cannot be represented as single <varname>POLYGON</varname>s, "
"but <emphasis role=\"bold\">(j)</emphasis> and <emphasis role=\"bold\">(m)</"
"emphasis> could be represented as a valid <varname>MULTIPOLYGON</varname>."
msgstr ""
"<emphasis role=\"bold\">(h)</emphasis> e <emphasis role=\"bold\">(i)</"
"emphasis> são válidas <varname>POLYGON</varname>s, <emphasis role=\"bold"
"\">(j-m)</emphasis> não podem ser representados como <varname>POLYGON</"
"varname>s, mas <emphasis role=\"bold\">(j)</emphasis> e <emphasis role=\"bold"
"\">(m)</emphasis> podem ser representados como uma <varname>MULTIPOLYGON</"
"varname> válida."

#. Tag: para
#: using_postgis_dataman.xml:1002
#, no-c-format
msgid ""
"A <varname>MULTIPOLYGON</varname> is <emphasis>valid</emphasis> if and only "
"if all of its elements are valid and the interiors of no two elements "
"intersect. The boundaries of any two elements may touch, but only at a "
"finite number of <varname>POINT</varname>s."
msgstr ""
"Um <varname>MULTIPOLYGON</varname> é <emphasis>valid</emphasis> somente se "
"todos seus elementos forem válidos e os interiores de nenhum dos dois "
"elementos intersectarem. Os limites de quaisquer dois elementos podem se "
"tocar, mas somente em um número finito de <varname>POINT</varname>s."

#. Tag: emphasis
#: using_postgis_dataman.xml:1017
#, no-c-format
msgid "<emphasis>(n)</emphasis>"
msgstr "<emphasis>(n)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1027
#, no-c-format
msgid "<emphasis>(o)</emphasis>"
msgstr "<emphasis>(o)</emphasis>"

#. Tag: emphasis
#: using_postgis_dataman.xml:1037
#, no-c-format
msgid "<emphasis>(p)</emphasis>"
msgstr "<emphasis>(p)</emphasis>"

#. Tag: para
#: using_postgis_dataman.xml:1046
#, no-c-format
msgid ""
"<emphasis role=\"bold\">(n)</emphasis> and <emphasis role=\"bold\">(o)</"
"emphasis> are not valid <varname>MULTIPOLYGON</varname>s. <emphasis role="
"\"bold\">(p)</emphasis>, however, is valid."
msgstr ""
"<emphasis role=\"bold\">(n)</emphasis> e <emphasis role=\"bold\">(o)</"
"emphasis> não são válidos <varname>MULTIPOLYGON</varname>s. <emphasis role="
"\"bold\">(p)</emphasis>, entretanto, é válido."

#. Tag: para
#: using_postgis_dataman.xml:1055
#, no-c-format
msgid ""
"Most of the functions implemented by the GEOS library rely on the assumption "
"that your geometries are valid as specified by the OpenGIS Simple Feature "
"Specification. To check simplicity or validity of geometries you can use the "
"<link linkend=\"ST_IsSimple\">ST_IsSimple()</link> and <link linkend="
"\"ST_IsValid\">ST_IsValid()</link>"
msgstr ""
"A maioria das funções implementadas pela biblioteca GEOS confiam na "
"suposição de que suas geometrias são válidas como especificados pela OpenGIS "
"Simple Feature Specification. Para verificar a simplicidade ou validade de "
"geometrias, você pode usar a <link linkend=\"ST_IsSimple\">ST_IsSimple()</"
"link> e <link linkend=\"ST_IsValid\">ST_IsValid()</link>"

#. Tag: programlisting
#: using_postgis_dataman.xml:1061
#, no-c-format
msgid ""
"-- Typically, it doesn't make sense to check\n"
"-- for validity on linear features since it will always return TRUE.\n"
"-- But in this example, PostGIS extends the definition of the OGC IsValid\n"
"-- by returning false if a LineString has less than 2 *distinct* vertices.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"
msgstr ""
"-- Typically, it doesn't make sense to check\n"
"-- for validity on linear features since it will always return TRUE.\n"
"-- But in this example, PostGIS extends the definition of the OGC IsValid\n"
"-- by returning false if a LineString has less than 2 *distinct* vertices.\n"
"gisdb=# SELECT\n"
"   ST_IsValid('LINESTRING(0 0, 1 1)'),\n"
"   ST_IsValid('LINESTRING(0 0, 0 0, 0 0)');\n"
"\n"
" st_isvalid | st_isvalid\n"
"------------+-----------\n"
"      t     |     f"

#. Tag: para
#: using_postgis_dataman.xml:1063
#, no-c-format
msgid ""
"By default, PostGIS does not apply this validity check on geometry input, "
"because testing for validity needs lots of CPU time for complex geometries, "
"especially polygons. If you do not trust your data sources, you can manually "
"enforce such a check to your tables by adding a check constraint:"
msgstr ""
"Por padrão, o PostGIS não aplica essa verificação de validade na geometria "
"de entrada, porque testar a validade requer muito tempo da CPU para "
"geometrias complexas, especialmente polígonos. Se você não confia nas fontes "
"dos seus dados, você pode executar uma verificação nas suas tabelas "
"adicionando uma restrição de verificação: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1069
#, no-c-format
msgid ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"
msgstr ""
"ALTER TABLE mytable\n"
"  ADD CONSTRAINT geometry_valid_check\n"
"        CHECK (ST_IsValid(the_geom));"

#. Tag: para
#: using_postgis_dataman.xml:1071
#, no-c-format
msgid ""
"If you encounter any strange error messages such as \"GEOS Intersection() "
"threw an error!\" when calling PostGIS functions with valid input "
"geometries, you likely found an error in either PostGIS or one of the "
"libraries it uses, and you should contact the PostGIS developers. The same "
"is true if a PostGIS function returns an invalid geometry for valid input."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1079
#, no-c-format
msgid ""
"Strictly compliant OGC geometries cannot have Z or M values. The <link "
"linkend=\"ST_IsValid\">ST_IsValid()</link> function won't consider higher "
"dimensioned geometries invalid! Invocations of <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> will add a constraint "
"checking geometry dimensions, so it is enough to specify 2 there."
msgstr ""
"Estritamente condescendentes geometrias OGC não podem ter valores Z ou M. A "
"função <link linkend=\"ST_IsValid\">ST_IsValid()</link> não irá considerar "
"geometrias com dimensões maiores inválidas! Invocações de <link linkend="
"\"AddGeometryColumn\">AddGeometryColumn()</link> irão adicionar uma "
"restrição verificando dimensões de geometrias, então é suficiente "
"especificar 2 lá. "

#. Tag: title
#: using_postgis_dataman.xml:1089
#, fuzzy, no-c-format
msgid "Loading Spatial Data"
msgstr "Carregando dados GIS (Vector)"

#. Tag: para
#: using_postgis_dataman.xml:1091
#, fuzzy, no-c-format
msgid ""
"Once you have created a spatial table, you are ready to upload spatial data "
"to the database. There are two built-in ways to get spatial data into a "
"PostGIS/PostgreSQL database: using formatted SQL statements or using the "
"Shapefile loader."
msgstr ""
"Uma vez que tenha criado uma tabela espacial, você está pronto para "
"atualizar os dados GIS no banco de dados. No momento, existe duas formas de "
"colocar os dados no banco de dados PostGIS/PostgreSQL: usando as declarações "
"SQL ou usando o shape file loader/dumper."

#. Tag: title
#: using_postgis_dataman.xml:1097
#, fuzzy, no-c-format
msgid "Using SQL to Load Data"
msgstr "Usando SQL para recuperar dados"

#. Tag: para
#: using_postgis_dataman.xml:1099
#, fuzzy, no-c-format
msgid ""
"If spatial data can be converted to a text representation (as either WKT or "
"WKB), then using SQL might be the easiest way to get data into PostGIS. Data "
"can be bulk-loaded into PostGIS/PostgreSQL by loading a text file of SQL "
"<code>INSERT</code> statements using the <code>psql</code> SQL utility."
msgstr ""
"Se você puder converter seus dados para uma representação de texto, então "
"usar SQL formatado pode ser mais fácil de colocar seus dados no PostGIS. "
"Como com o Oracle e outros banco de dados SQL, dados só podem ser carregados "
"em volume canalizando um grande arquivo de texto cheio de declarações SQL "
"\"INSERT\" dentro do monitor SQL. "

#. Tag: para
#: using_postgis_dataman.xml:1104
#, fuzzy, no-c-format
msgid ""
"A SQL load file (<filename>roads.sql</filename> for example) might look like "
"this:"
msgstr ""
"Um arquivo de atualização de dados (<filename>roads.sql</filename> por "
"exemplo) deve se parecer com:"

#. Tag: programlisting
#: using_postgis_dataman.xml:1107
#, no-c-format
msgid ""
"BEGIN;\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (1,'LINESTRING(191232 243118,191108 243242)','Jeff Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (2,'LINESTRING(189141 244158,189265 244817)','Geordie Rd');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (3,'LINESTRING(192783 228138,192612 229814)','Paul St');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (4,'LINESTRING(189412 252431,189631 259122)','Graeme Ave');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (5,'LINESTRING(190131 224148,190871 228134)','Phil Tce');\n"
"INSERT INTO roads (road_id, roads_geom, road_name)\n"
"  VALUES (6,'LINESTRING(198231 263418,198213 268322)','Dave Cres');\n"
"COMMIT;"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1109
#, fuzzy, no-c-format
msgid "The SQL file can be loaded into PostgreSQL using <code>psql</code>:"
msgstr ""
"O arquivo de dados pode ser canalizado para PostgreSQL facilmente usando o "
"\"psql\" SQL  monitor terminal: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1111
#, no-c-format
msgid "psql -d [database] -f roads.sql"
msgstr "psql -d [database] -f roads.sql"

#. Tag: title
#: using_postgis_dataman.xml:1115
#, fuzzy, no-c-format
msgid "Using the Shapefile Loader"
msgstr "shp2pgsql: Using the ESRI Shapefile Loader"

#. Tag: para
#: using_postgis_dataman.xml:1117
#, fuzzy, no-c-format
msgid ""
"The <filename>shp2pgsql</filename> data loader converts Shapefiles into SQL "
"suitable for insertion into a PostGIS/PostgreSQL database either in geometry "
"or geography format. The loader has several operating modes selected by "
"command line flags."
msgstr ""
"O carregador de dados  <filename>shp2pgsql</filename> converte ESRI Shape "
"files em SQL adequado para inserção dentro de um banco de dados PostGIS/"
"PostgreSQL, seja em formato de geometria ou geografia. O carregador possui "
"vários modos de operação distinguidos pelas linhas de bandeiras de comando: "

#. Tag: para
#: using_postgis_dataman.xml:1122
#, fuzzy, no-c-format
msgid ""
"There is also a <filename>shp2pgsql-gui</filename> graphical interface with "
"most of the options as the command-line loader. This may be easier to use "
"for one-off non-scripted loading or if you are new to PostGIS. It can also "
"be configured as a plugin to PgAdminIII."
msgstr ""
"Juntamente com o comando carregador shp2pgsql, existe uma interface "
"<filename>shp2pgsql-gui</filename> gráfica com a maioria das opções como o "
"carregador, mas pode ser mais fácil de usar para um carregamento único non-"
"scripted ou se você é novo no PostGIS. Pode ser configurado como um plugin "
"do PgAdminIII."

#. Tag: term
#: using_postgis_dataman.xml:1130
#, no-c-format
msgid "(c|a|d|p) These are mutually exclusive options:"
msgstr "(c|a|d|p) Essas são opções mutualmente exclusivas: "

#. Tag: term
#: using_postgis_dataman.xml:1135
#, no-c-format
msgid "<term>-c</term>"
msgstr "<term>-c</term>"

#. Tag: para
#: using_postgis_dataman.xml:1137
#, fuzzy, no-c-format
msgid ""
"Creates a new table and populates it from the Shapefile. <emphasis>This is "
"the default mode.</emphasis>"
msgstr ""
"Cria uma tabela nova e popula do shapefile. <emphasis>Este é o modo padrão.</"
"emphasis>"

#. Tag: term
#: using_postgis_dataman.xml:1145
#, no-c-format
msgid "<term>-a</term>"
msgstr "<term>-a</term>"

#. Tag: para
#: using_postgis_dataman.xml:1147
#, fuzzy, no-c-format
msgid ""
"Appends data from the Shapefile into the database table. Note that to use "
"this option to load multiple files, the files must have the same attributes "
"and same data types."
msgstr ""
"Anexa dados do shapefile dentro do banco de dados da tabela. Note que para "
"usar esta opção para carregar vários arquivos, eles devem ter os mesmos "
"atributos e tipos de dados. "

#. Tag: term
#: using_postgis_dataman.xml:1156
#, no-c-format
msgid "<term>-d</term>"
msgstr "<term>-d</term>"

#. Tag: para
#: using_postgis_dataman.xml:1158
#, fuzzy, no-c-format
msgid ""
"Drops the database table before creating a new table with the data in the "
"Shapefile."
msgstr ""
"Derruba a tabela do banco de dados, criando uma nova tabela com os dados do "
"shapefile."

#. Tag: term
#: using_postgis_dataman.xml:1165
#, no-c-format
msgid "<term>-p</term>"
msgstr "<term>-p</term>"

#. Tag: para
#: using_postgis_dataman.xml:1167
#, no-c-format
msgid ""
"Only produces the table creation SQL code, without adding any actual data. "
"This can be used if you need to completely separate the table creation and "
"data loading steps."
msgstr ""
"Produz somente a criação da tabela do código SQL, sem adicionar nenhum dado "
"de fato. Isto pode ser usado se você precisar separar completamente a tabela "
"de criação e os passos de carregamento de dados. "

#. Tag: term
#: using_postgis_dataman.xml:1180
#, no-c-format
msgid "<term>-?</term>"
msgstr "<term>-?</term>"

#. Tag: para
#: using_postgis_dataman.xml:1182
#, no-c-format
msgid "Display help screen."
msgstr "Exibir tela de ajuda. "

#. Tag: term
#: using_postgis_dataman.xml:1189
#, no-c-format
msgid "<term>-D</term>"
msgstr "<term>-D</term>"

#. Tag: para
#: using_postgis_dataman.xml:1191
#, no-c-format
msgid ""
"Use the PostgreSQL \"dump\" format for the output data. This can be combined "
"with -a, -c and -d. It is much faster to load than the default \"insert\" "
"SQL format. Use this for very large data sets."
msgstr ""
"Use o formato PostgreSQL \"dump\" para os dados de saída. Pode ser combinado "
"com -a, -c e -d. É muito mais rápido para carregar que o formato padrão "
"\"insert\" SQL. Use isto para dados muito grandes. "

#. Tag: term
#: using_postgis_dataman.xml:1200
#, fuzzy, no-c-format
msgid "-s [&lt;FROM_SRID&gt;:]&lt;SRID&gt;"
msgstr "-s [&lt;FROM_SRID%gt;:]&lt;SRID&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1202
#, fuzzy, no-c-format
msgid ""
"Creates and populates the geometry tables with the specified SRID. "
"Optionally specifies that the input shapefile uses the given FROM_SRID, in "
"which case the geometries will be reprojected to the target SRID."
msgstr ""
"Cria e popula as tabelas de geometria com o SRID específico. Especifica, "
"opcionalmente, que o shapefile de entrada usa o FROM_SRID dado, caso em que "
"as geometrias serão reprojetadas para o SRID alvo. FROM_SRID não pode ser "
"especificado com -D. "

#. Tag: term
#: using_postgis_dataman.xml:1212
#, no-c-format
msgid "<term>-k</term>"
msgstr "<term>-k</term>"

#. Tag: para
#: using_postgis_dataman.xml:1214
#, no-c-format
msgid ""
"Keep identifiers' case (column, schema and attributes). Note that attributes "
"in Shapefile are all UPPERCASE."
msgstr ""
"Mantém identificadores (coluna, esquema e atributos). Note que os atributos "
"no shapefile estão todos em CAIXAALTA."

#. Tag: term
#: using_postgis_dataman.xml:1222
#, no-c-format
msgid "<term>-i</term>"
msgstr "<term>-i</term>"

#. Tag: para
#: using_postgis_dataman.xml:1224
#, no-c-format
msgid ""
"Coerce all integers to standard 32-bit integers, do not create 64-bit "
"bigints, even if the DBF header signature appears to warrant it."
msgstr ""
"Coage todos os inteiros para 32-bit integers padrão, não cria 64-bit "
"bigints, mesmo se a assinatura  DBF parecer justificar ele. "

#. Tag: term
#: using_postgis_dataman.xml:1232
#, no-c-format
msgid "<term>-I</term>"
msgstr "<term>-I</term>"

#. Tag: para
#: using_postgis_dataman.xml:1234
#, no-c-format
msgid "Create a GiST index on the geometry column."
msgstr "Cria um índice GiST na coluna geométrica."

#. Tag: term
#: using_postgis_dataman.xml:1241
#, no-c-format
msgid "<term>-m</term>"
msgstr "<term>-m</term>"

#. Tag: para
#: using_postgis_dataman.xml:1243
#, no-c-format
msgid ""
"-m <filename>a_file_name</filename> Specify a file containing a set of "
"mappings of (long) column names to 10 character DBF column names. The "
"content of the file is one or more lines of two names separated by white "
"space and no trailing or leading space. For example:"
msgstr ""
"-m <filename>a_file_name</filename> Especifica um arquivo contendo um "
"conjunto de mapas de nomes (longos) de colunas para nomes de colunas DBF com "
"10 caracteres. O conteúdo deste arquivo é uma ou mais linhas de dois nomes "
"separados por um espaço branco e seguindo ou liderando espaço. Por exemplo: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1248
#, no-c-format
msgid ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"
msgstr ""
"COLUMNNAME DBFFIELD1\n"
"AVERYLONGCOLUMNNAME DBFFIELD2"

#. Tag: term
#: using_postgis_dataman.xml:1254
#, no-c-format
msgid "<term>-S</term>"
msgstr "<term>-S</term>"

#. Tag: para
#: using_postgis_dataman.xml:1256
#, no-c-format
msgid ""
"Generate simple geometries instead of MULTI geometries. Will only succeed if "
"all the geometries are actually single (I.E. a MULTIPOLYGON with a single "
"shell, or or a MULTIPOINT with a single vertex)."
msgstr ""
"Gera geometrias simples em vez de MULTI geometrias. Só irá ter sucesso se "
"todas as geometrias forem de fato únicas (ex.: um MULTIPOLÍGONO com uma "
"única shell, ou um MULTIPONTO com um único vértice)."

#. Tag: term
#: using_postgis_dataman.xml:1265
#, no-c-format
msgid "-t &lt;dimensionality&gt;"
msgstr "-t &lt;dimensionality&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1267
#, no-c-format
msgid ""
"Force the output geometry to have the specified dimensionality. Use the "
"following strings to indicate the dimensionality: 2D, 3DZ, 3DM, 4D."
msgstr ""
"Força a geometria de saída a ter dimensionalidade especificada. Use as "
"strings seguintes para indicar a dimensionalidade: 2D, 3DZ, 3DM, 4D."

#. Tag: para
#: using_postgis_dataman.xml:1271
#, no-c-format
msgid ""
"If the input has fewer dimensions that specified, the output will have those "
"dimensions filled in with zeroes. If the input has more dimensions that "
"specified, the unwanted dimensions will be stripped."
msgstr ""
"Se a entrada tiver poucas dimensões especificadas, a saída terá essas "
"dimensões cheias com zeros. Se a entrada tiver mais dimensões especificadas, "
"as que indesejadas serão tiradas. "

#. Tag: term
#: using_postgis_dataman.xml:1280
#, no-c-format
msgid "<term>-w</term>"
msgstr "<term>-w</term>"

#. Tag: para
#: using_postgis_dataman.xml:1282
#, no-c-format
msgid ""
"Output WKT format, instead of WKB. Note that this can introduce coordinate "
"drifts due to loss of precision."
msgstr ""
"Gera o formato WKT em vez do WKB. Note que isto pode introduzir impulsos de "
"coordenadas para perda de precisão. "

#. Tag: term
#: using_postgis_dataman.xml:1290
#, no-c-format
msgid "<term>-e</term>"
msgstr "<term>-e</term>"

#. Tag: para
#: using_postgis_dataman.xml:1292
#, no-c-format
msgid ""
"Execute each statement on its own, without using a transaction. This allows "
"loading of the majority of good data when there are some bad geometries that "
"generate errors. Note that this cannot be used with the -D flag as the \"dump"
"\" format always uses a transaction."
msgstr ""
"Execute cada declaração por si mesma, sem usar uma transação. Isto permite "
"carregar a maioria dos dados bons quando existem geometrias ruins que geram "
"erros. Note que não pode ser usado com a bandeira -D como o formato \"dump\" "
"sempre usa a transação. "

#. Tag: term
#: using_postgis_dataman.xml:1302
#, no-c-format
msgid "-W &lt;encoding&gt;"
msgstr "-W &lt;encoding&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1304
#, no-c-format
msgid ""
"Specify encoding of the input data (dbf file). When used, all attributes of "
"the dbf are converted from the specified encoding to UTF8. The resulting SQL "
"output will contain a <code>SET CLIENT_ENCODING to UTF8</code> command, so "
"that the backend will be able to reconvert from UTF8 to whatever encoding "
"the database is configured to use internally."
msgstr ""
"Especifica codificação dos dados de entrada (arquivo dbf). Quando usado, "
"todos os atributos do dbf são convertidos da codificação especificada para "
"UTF8. A saída SQL resultante conterá um comando <code>SET CLIENT_ENCODING to "
"UTF8</code>, então o backend será capaz de reconverter do UTF8 para qualquer "
"codificação que o banco de dados estiver configurado para usar "
"internamente.  "

#. Tag: term
#: using_postgis_dataman.xml:1314
#, no-c-format
msgid "-N &lt;policy&gt;"
msgstr "-N &lt;policy&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1316
#, no-c-format
msgid "NULL geometries handling policy (insert*,skip,abort)"
msgstr "Políticas para lidar com geometrias NULAS (insert*,skip,abort)"

#. Tag: term
#: using_postgis_dataman.xml:1322
#, no-c-format
msgid "<term>-n</term>"
msgstr "<term>-n</term>"

#. Tag: para
#: using_postgis_dataman.xml:1324
#, no-c-format
msgid ""
"-n Only import DBF file. If your data has no corresponding shapefile, it "
"will automatically switch to this mode and load just the dbf. So setting "
"this flag is only needed if you have a full shapefile set, and you only want "
"the attribute data and no geometry."
msgstr ""
"-n Só importa arquivo DBF. Se seus dados não possuem shapefile "
"correspondente, ele irá trocar automaticamente para este modo e carregar só "
"o dbf. Então, só é necessário configurar esta bandeira se você tiver um "
"shapefile completo, e se quiser os dados atributos e nenhuma geometria. "

#. Tag: term
#: using_postgis_dataman.xml:1332
#, no-c-format
msgid "<term>-G</term>"
msgstr "<term>-G</term>"

#. Tag: para
#: using_postgis_dataman.xml:1334
#, no-c-format
msgid ""
"Use geography type instead of geometry (requires lon/lat data) in WGS84 long "
"lat (SRID=4326)"
msgstr ""
"Use geografia em vez de geometria (requer dados long/lat) em WGS84 long lat "
"(SRID=4326)"

#. Tag: term
#: using_postgis_dataman.xml:1340
#, no-c-format
msgid "-T &lt;tablespace&gt;"
msgstr "-T &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1342
#, no-c-format
msgid ""
"Specify the tablespace for the new table. Indexes will still use the default "
"tablespace unless the -X parameter is also used. The PostgreSQL "
"documentation has a good description on when to use custom tablespaces."
msgstr ""
"Especifica o espaço para a nova tabela. Os índices continuarão usando espaço "
"padrão a menos que o parâmetro -X também seja usado. A documentação "
"PostgreSQL tem uma boa descrição quando usa espaços personalizados. "

#. Tag: term
#: using_postgis_dataman.xml:1350
#, no-c-format
msgid "-X &lt;tablespace&gt;"
msgstr "-X &lt;tablespace&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1352
#, no-c-format
msgid ""
"Specify the tablespace for the new table's indexes. This applies to the "
"primary key index, and the GIST spatial index if -I is also used."
msgstr ""
"Especifica o espaço para os novos índices da tabela. Isto se aplica ao "
"primeiro índice chave, e o índice GIST espacial, se -I também for usado. "

#. Tag: para
#: using_postgis_dataman.xml:1360
#, fuzzy, no-c-format
msgid ""
"An example session using the loader to create an input file and loading it "
"might look like this:"
msgstr ""
"Uma seção exemplo usando o carregador para criar um arquivo de entrada e "
"atualizando ele pode parecer com: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1365
#, no-c-format
msgid ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"
msgstr ""
"# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; "
"roads.sql\n"
"# psql -d roadsdb -f roads.sql"

#. Tag: para
#: using_postgis_dataman.xml:1367
#, fuzzy, no-c-format
msgid "A conversion and load can be done in one step using UNIX pipes:"
msgstr ""
"Uma conversão e um upload podem ser feitos em apenas um passo usando "
"encadeamento UNIX: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1371
#, no-c-format
msgid "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"
msgstr "# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb"

#. Tag: title
#: using_postgis_dataman.xml:1376
#, fuzzy, no-c-format
msgid "Extracting Spatial Data"
msgstr "Criando uma Tabela Espacial "

#. Tag: para
#: using_postgis_dataman.xml:1378
#, fuzzy, no-c-format
msgid ""
"Spatial data can be extracted from the database using either SQL or the "
"Shapefile dumper. The section on SQL presents some of the functions "
"available to do comparisons and queries on spatial tables."
msgstr ""
"Os dados podem ser extraídos do banco da dados usando o SQL ou o Shape file "
"loader/dumper. Na seção do SQL discutiremos alguns dos operadores "
"disponíveis para comparações e consultas em tabelas espaciais. "

#. Tag: title
#: using_postgis_dataman.xml:1384
#, fuzzy, no-c-format
msgid "Using SQL to Extract Data"
msgstr "Usando SQL para recuperar dados"

#. Tag: para
#: using_postgis_dataman.xml:1386
#, fuzzy, no-c-format
msgid ""
"The most straightforward way of extracting spatial data out of the database "
"is to use a SQL <code>SELECT</code> query to define the data set to be "
"extracted and dump the resulting columns into a parsable text file:"
msgstr ""
"O mais simples significa extrair os dados do banco de dados, é usar uma "
"consulta SQL para reduzir o número de RELATOS e COLUNAS retornados e "
"abandonar as colunas resultantes dentro de um arquivo de texto analisável: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1391
#, no-c-format
msgid ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"
msgstr ""
"db=# SELECT road_id, ST_AsText(road_geom) AS geom, road_name FROM roads;\n"
"\n"
"road_id | geom                                    | road_name\n"
"--------+-----------------------------------------+-----------\n"
"          1 | LINESTRING(191232 243118,191108 243242) | Jeff Rd\n"
"          2 | LINESTRING(189141 244158,189265 244817) | Geordie Rd\n"
"          3 | LINESTRING(192783 228138,192612 229814) | Paul St\n"
"          4 | LINESTRING(189412 252431,189631 259122) | Graeme Ave\n"
"          5 | LINESTRING(190131 224148,190871 228134) | Phil Tce\n"
"          6 | LINESTRING(198231 263418,198213 268322) | Dave Cres\n"
"          7 | LINESTRING(218421 284121,224123 241231) | Chris Way\n"
"(6 rows)"

#. Tag: para
#: using_postgis_dataman.xml:1393
#, fuzzy, no-c-format
msgid ""
"There will be times when some kind of restriction is necessary to cut down "
"the number of records returned. In the case of attribute-based restrictions, "
"use the same SQL syntax as used with a non-spatial table. In the case of "
"spatial restrictions, the following functions are useful:"
msgstr ""
"Entretanto, às vezes algum tipo de restrição será necessária para cortar o "
"número de campos retornados. No caso de restrições baseadas em atributos, só "
"use a mesma sintaxe SQL como normal com uma tabela não espacial. No caso de "
"restrições espaciais, os operadores seguintes são úteis/disponíveis: "

#. Tag: term
#: using_postgis_dataman.xml:1401
#, no-c-format
msgid "ST_Intersects"
msgstr "ST_Intersects"

#. Tag: para
#: using_postgis_dataman.xml:1404
#, no-c-format
msgid "This function tells whether two geometries share any space."
msgstr ""

#. Tag: term
#: using_postgis_dataman.xml:1409
#, no-c-format
msgid "<term>=</term>"
msgstr "<term>=</term>"

#. Tag: para
#: using_postgis_dataman.xml:1412
#, no-c-format
msgid ""
"This tests whether two geometries are geometrically identical. For example, "
"if 'POLYGON((0 0,1 1,1 0,0 0))' is the same as 'POLYGON((0 0,1 1,1 0,0 "
"0))' (it is)."
msgstr ""
"Isto testa se duas geometrias são geometricamente iguais. Por exemplo, se "
"'POLYGON((0 0,1 1,1 0,0 0))' é o mesmo que  'POLYGON((0 0,1 1,1 0,0 0))' (é)."

#. Tag: para
#: using_postgis_dataman.xml:1420
#, no-c-format
msgid ""
"Next, you can use these operators in queries. Note that when specifying "
"geometries and boxes on the SQL command line, you must explicitly turn the "
"string representations into geometries function. The 312 is a fictitious "
"spatial reference system that matches our data. So, for example:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1426
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"  FROM roads\n"
"  WHERE roads_geom='SRID=312;LINESTRING(191232 243118,191108 243242)'::"
"geometry;"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1428
#, no-c-format
msgid ""
"The above query would return the single record from the \"ROADS_GEOM\" table "
"in which the geometry was equal to that value."
msgstr ""
"A consulta acima retornaria um único relato da tabela \"ROADS_GEOM\"na qual "
"a geometria era igual ao valor. "

#. Tag: para
#: using_postgis_dataman.xml:1431
#, no-c-format
msgid ""
"To check whether some of the roads passes in the area defined by a polygon:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1433
#, no-c-format
msgid ""
"SELECT road_id, road_name\n"
"FROM roads\n"
"WHERE ST_Intersects(roads_geom, 'SRID=312;POLYGON((...))');"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1437
#, no-c-format
msgid ""
"The most common spatial query will probably be a \"frame-based\" query, used "
"by client software, like data browsers and web mappers, to grab a \"map frame"
"\" worth of data for display."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1440
#, no-c-format
msgid ""
"When using the \"&amp;&amp;\" operator, you can specify either a BOX3D as "
"the comparison feature or a GEOMETRY. When you specify a GEOMETRY, however, "
"its bounding box will be used for the comparison."
msgstr ""
"Usando o operador \"&amp;&amp;\" , você pode especificar uma CAIXA3D como "
"uma caracetrística de comparação ou uma GEOMETRIA. Entretanto, quando você "
"especifica uma GEOMETRIA, a caixa delimitadora dela será usada para a "
"comparação. "

#. Tag: para
#: using_postgis_dataman.xml:1444
#, no-c-format
msgid "Using a \"BOX3D\" object for the frame, such a query looks like this:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1446
#, no-c-format
msgid ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"
msgstr ""
"SELECT ST_AsText(roads_geom) AS geom\n"
"FROM roads\n"
"WHERE\n"
"  roads_geom &amp;&amp; ST_MakeEnvelope(191232, 243117,191232, 243119,312);"

#. Tag: para
#: using_postgis_dataman.xml:1448
#, no-c-format
msgid ""
"Note the use of the SRID 312, to specify the projection of the envelope."
msgstr "Observe o uso do SRID 312, para especificar a projeção do envelope. "

#. Tag: title
#: using_postgis_dataman.xml:1454
#, fuzzy, no-c-format
msgid "Using the Shapefile Dumper"
msgstr "Usando o Dumper"

#. Tag: para
#: using_postgis_dataman.xml:1456
#, fuzzy, no-c-format
msgid ""
"The <filename>pgsql2shp</filename> table dumper connects to the database and "
"converts a table (possibly defined by a query) into a shape file. The basic "
"syntax is:"
msgstr ""
"A tabela dumper <filename>pgsql2shp</filename> conecta diretamente ao banco "
"de dados e converte uma tabela (possivelmente definida por uma consulta) em "
"um shapefile. A sintaxe básica é: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1460
#, no-c-format
msgid ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"
msgstr ""
"pgsql2shp [&lt;options&gt;] &lt;database&gt; [&lt;schema&gt;.]&lt;table&gt;"

#. Tag: programlisting
#: using_postgis_dataman.xml:1462
#, no-c-format
msgid "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"
msgstr "pgsql2shp [&lt;options&gt;] &lt;database&gt; &lt;query&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1464
#, no-c-format
msgid "The commandline options are:"
msgstr "As opções da commandline são:"

#. Tag: term
#: using_postgis_dataman.xml:1468
#, no-c-format
msgid "-f &lt;filename&gt;"
msgstr "-f &lt;filename&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1471
#, no-c-format
msgid "Write the output to a particular filename."
msgstr "Atribui a saída a um filename específico. "

#. Tag: term
#: using_postgis_dataman.xml:1476
#, no-c-format
msgid "-h &lt;host&gt;"
msgstr "-h &lt;host&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1479
#, no-c-format
msgid "The database host to connect to."
msgstr "O hospedeiro do banco de dados para se conectar. "

#. Tag: term
#: using_postgis_dataman.xml:1484
#, no-c-format
msgid "-p &lt;port&gt;"
msgstr "-p &lt;port&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1487
#, no-c-format
msgid "The port to connect to on the database host."
msgstr "A porta para conectar no hospedeiro do banco de dados."

#. Tag: term
#: using_postgis_dataman.xml:1492
#, no-c-format
msgid "-P &lt;password&gt;"
msgstr "-P &lt;password&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1495
#, no-c-format
msgid "The password to use when connecting to the database."
msgstr "A senha para usar quando conectar ao banco de dados. "

#. Tag: term
#: using_postgis_dataman.xml:1500
#, no-c-format
msgid "-u &lt;user&gt;"
msgstr "-u &lt;user&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1503
#, no-c-format
msgid "The username to use when connecting to the database."
msgstr "O nome de usuário para usar quando conectado ao banco de dados. "

#. Tag: term
#: using_postgis_dataman.xml:1508
#, no-c-format
msgid "-g &lt;geometry column&gt;"
msgstr "-g &lt;geometry column&gt;"

#. Tag: para
#: using_postgis_dataman.xml:1511
#, no-c-format
msgid ""
"In the case of tables with multiple geometry columns, the geometry column to "
"use when writing the shape file."
msgstr ""
"No caso de tabelas com várias colunas geométricas, a coluna para usar quando "
"atribuindo o shapefile. "

#. Tag: term
#: using_postgis_dataman.xml:1517
#, no-c-format
msgid "<term>-b</term>"
msgstr "<term>-b</term>"

#. Tag: para
#: using_postgis_dataman.xml:1520
#, no-c-format
msgid ""
"Use a binary cursor. This will make the operation faster, but will not work "
"if any NON-geometry attribute in the table lacks a cast to text."
msgstr ""
"Use um cursor binário. Isto tornará a operação mais rápida, mas não "
"funcionará se qualquer atributo NÃO-geométrico na tabela necessitar de um "
"cast para o texto. "

#. Tag: term
#: using_postgis_dataman.xml:1527
#, no-c-format
msgid "<term>-r</term>"
msgstr "<term>-r</term>"

#. Tag: para
#: using_postgis_dataman.xml:1530
#, no-c-format
msgid ""
"Raw mode. Do not drop the <varname>gid</varname> field, or escape column "
"names."
msgstr ""
"Modo cru. Não derruba o campo <varname>gid</varname>, ou escapa o nome das "
"colunas. "

#. Tag: term
#: using_postgis_dataman.xml:1536
#, no-c-format
msgid "-m <varname>filename</varname>"
msgstr "-m <varname>filename</varname>"

#. Tag: para
#: using_postgis_dataman.xml:1538
#, no-c-format
msgid ""
"Remap identifiers to ten character names. The content of the file is lines "
"of two symbols separated by a single white space and no trailing or leading "
"space: VERYLONGSYMBOL SHORTONE ANOTHERVERYLONGSYMBOL SHORTER etc."
msgstr ""
"Remapeia os identificadores para nomes com dez caracteres. O conteúdo do "
"arquivo é linhas de dois símbolos separados por um único espaço branco e "
"nenhum espaço seguindo ou à frente: VERYLONGSYMBOL SHORTONE "
"ANOTHERVERYLONGSYMBOL SHORTER etc."

#. Tag: title
#: using_postgis_dataman.xml:1551
#, fuzzy, no-c-format
msgid "Building Spatial Indexes"
msgstr "Construindo índidces"

#. Tag: para
#: using_postgis_dataman.xml:1553
#, no-c-format
msgid ""
"Indexes make using a spatial database for large data sets possible. Without "
"indexing, a search for features would require a sequential scan of every "
"record in the database. Indexing speeds up searching by organizing the data "
"into a structure which can be quickly traversed to find records."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1559
#, no-c-format
msgid ""
"The B-tree index method commonly used for attribute data is not very useful "
"for spatial data, since it only supports storing and querying data in a "
"single dimension. Data such as geometry which has 2 or more dimensions) "
"requires an index method that supports range query across all the data "
"dimensions. (That said, it is possible to effectively index so-called XY "
"data using a B-tree and explict range searches.) One of the main advantages "
"of PostgreSQL for spatial data handling is that it offers several kinds of "
"indexes which work well for multi-dimensional data: GiST, BRIN and SP-GiST "
"indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1571
#, fuzzy, no-c-format
msgid ""
"<emphasis role=\"bold\">GiST (Generalized Search Tree)</emphasis> indexes "
"break up data into \"things to one side\", \"things which overlap\", "
"\"things which are inside\" and can be used on a wide range of data-types, "
"including GIS data. PostGIS uses an R-Tree index implemented on top of GiST "
"to index spatial data. GiST is the most commonly-used and versatile spatial "
"index method, and offers very good query performance."
msgstr ""
"GiST (Generalized Search Trees) dissolvem dados em \"coisas de um lado\", "
"\"coisas que sobrepõem\", \"coisas que estão dentro\" e pode ser usado em "
"vários tipos de dados, incluindo dados GIS. O PostGIS usa o índice R-Tree "
"implementado no topo do GiST para classificar dados GIS. "

#. Tag: para
#: using_postgis_dataman.xml:1581
#, no-c-format
msgid ""
"<emphasis role=\"bold\">BRIN (Block Range Index)</emphasis> indexes operate "
"by summarizing the spatial extent of ranges of table records. Search is done "
"via a scan of the ranges. BRIN is only appropriate for use for some kinds of "
"data (spatially sorted, with infrequent or no update). But it provides much "
"faster index create time, and much smaller index size."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1591
#, no-c-format
msgid ""
"<emphasis role=\"bold\">SP-GiST (Space-Partitioned Generalized Search Tree)</"
"emphasis> is a generic index method that supports partitioned search trees "
"such as quad-trees, k-d trees, and radix trees (tries)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1598
#, no-c-format
msgid ""
"For more information see the <ulink url=\"https://postgis.net/workshops/"
"postgis-intro/indexing.html\">PostGIS Workshop</ulink>, and the <ulink url="
"\"https://www.postgresql.org/docs/current/indexes.html\">PostgreSQL "
"documentation</ulink>."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1604
#, no-c-format
msgid "GiST Indexes"
msgstr "Índices GiST"

#. Tag: para
#: using_postgis_dataman.xml:1606
#, no-c-format
msgid ""
"GiST stands for \"Generalized Search Tree\" and is a generic form of "
"indexing. In addition to GIS indexing, GiST is used to speed up searches on "
"all kinds of irregular data structures (integer arrays, spectral data, etc) "
"which are not amenable to normal B-Tree indexing."
msgstr ""
"GiST significa \"Árvores de Pesquisa Generalizada\" e é uma forma genérica "
"de classificar. Além disso, ele é usado para acelerar pesquisas em todos os "
"tipos de estruturas de dados irregulares (arranjos inteiros, dados "
"espectrais etc) que não são agradáveis à classificação normal B-Tree. "

#. Tag: para
#: using_postgis_dataman.xml:1611
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data (unless all your searches are "
"based on attributes, in which case you'll want to build a normal index on "
"the attribute fields)."
msgstr ""
"Uma vez que uma tabela de dados GIS excede pouco mais de mil filas, você irá "
"querer construir um índice para acelerar pesquisas espaciais dos dados (a "
"menos que suas pesquisas sejam baseadas em atributos, você vai querer "
"construir um índice normal nos campos de atributo). "

#. Tag: para
#: using_postgis_dataman.xml:1616
#, no-c-format
msgid ""
"The syntax for building a GiST index on a \"geometry\" column is as follows:"
msgstr ""
"A sintaxe para construir um índice GiST em uma coluna \"geométrica\" é a "
"seguinte: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1620
#, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1622
#, no-c-format
msgid ""
"The above syntax will always build a 2D-index. To get the an n-dimensional "
"index for the geometry type, you can create one using this syntax:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1623
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1625
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive exercise. It also "
"blocks write access to your table for the time it creates, so on a "
"production system you may want to do in in a slower CONCURRENTLY-aware way:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1626
#, no-c-format
msgid ""
"CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING GIST "
"( [geometryfield] );"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1628 using_postgis_dataman.xml:1796
#, no-c-format
msgid ""
"After building an index, it is sometimes helpful to force PostgreSQL to "
"collect table statistics, which are used to optimize query plans:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1631 using_postgis_dataman.xml:1799
#, no-c-format
msgid "VACUUM ANALYZE [table_name] [(column_name)];"
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1636
#, no-c-format
msgid "BRIN Indexes"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1638
#, no-c-format
msgid ""
"BRIN stands for \"Block Range Index\". It is an general-purpose <ulink url="
"\"https://www.postgresql.org/docs/current/brin.html\">index method</ulink> "
"introduced in PostgreSQL 9.5. BRIN is a <emphasis>lossy</emphasis> index "
"method, meaning that a a secondary check is required to confirm that a "
"record matches a given search condition (which is the case for all provided "
"spatial indexes). It provides much faster index creation and much smaller "
"index size, with reasonable read performance. Its primary purpose is to "
"support indexing very large tables on columns which have a correlation with "
"their physical location within the table. In addition to spatial indexing, "
"BRIN can speed up searches on various kinds of attribute data structures "
"(integer, arrays etc)."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1652
#, no-c-format
msgid ""
"Once a spatial table exceeds a few thousand rows, you will want to build an "
"index to speed up spatial searches of the data. GiST indexes are very "
"performant as long as their size doesn't exceed the amount of RAM available "
"for the database, and as long as you can afford the index storage size, and "
"the cost of index update on write. Otherwise, for very large tables BRIN "
"index can be considered as an alternative."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1659
#, no-c-format
msgid ""
"A BRIN index stores the bounding box enclosing all the geometries contained "
"in the rows in a contiguous set of table blocks, called a <emphasis>block "
"range</emphasis>. When executing a query using the index the block ranges "
"are scanned to find the ones that intersect the query extent. This is "
"efficient only if the data is physically ordered so that the bounding boxes "
"for block ranges have minimal overlap (and ideally are mutually exclusive). "
"The resulting index is very small in size, but is typically less performant "
"for read than a GiST index over the same data."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1669
#, no-c-format
msgid ""
"Building a BRIN index is much less CPU-intensive than building a GiST index. "
"It's common to find that a BRIN index is ten times faster to build than a "
"GiST index over the same data. And because a BRIN index stores only one "
"bounding box for each range of table blocks, it's common to use up to a "
"thousand times less disk space than a GiST index."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1675
#, no-c-format
msgid ""
"You can choose the number of blocks to summarize in a range. If you decrease "
"this number, the index will be bigger but will probably provide better "
"performance."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1679
#, no-c-format
msgid ""
"For BRIN to be effective, the table data should be stored in a physical "
"order which minimizes the amount of block extent overlap. It may be that the "
"data is already sorted appropriately (for instance, if it is loaded from "
"another dataset that is already sorted in spatial order). Otherwise, this "
"can be accomplished by sorting the data by a one-dimensional spatial key. "
"One way to do this is to create a new table sorted by the geometry values "
"(which in recent PostGIS versions uses an efficient Hilbert curve ordering):"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1688
#, no-c-format
msgid ""
"CREATE TABLE table_sorted AS\n"
"   SELECT * FROM table  ORDER BY geom;"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1690
#, no-c-format
msgid ""
"Alternatively, data can be sorted in-place by using a GeoHash as a "
"(temporary) index, and clustering on that index:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1694
#, no-c-format
msgid ""
"CREATE INDEX idx_temp_geohash ON table\n"
"    USING btree (ST_GeoHash( ST_Transform( geom, 4326 ), 20));\n"
"CLUSTER table USING idx_temp_geohash;"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1697
#, fuzzy, no-c-format
msgid ""
"The syntax for building a BRIN index on a <code>geometry</code> column is:"
msgstr ""
"A sintaxe para construir um índice GiST em uma coluna \"geométrica\" é a "
"seguinte: "

#. Tag: programlisting
#: using_postgis_dataman.xml:1699
#, fuzzy, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geome_col] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1701
#, no-c-format
msgid ""
"The above syntax builds a 2D index. To build a 3D-dimensional index, use "
"this syntax:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1703
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename]\n"
"    USING BRIN ([geome_col] brin_geometry_inclusion_ops_3d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1705
#, no-c-format
msgid "You can also get a 4D-dimensional index using the 4D operator class:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1707
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename]\n"
"    USING BRIN ([geome_col] brin_geometry_inclusion_ops_4d);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1709
#, no-c-format
msgid ""
"The above commands use the default number of blocks in a range, which is "
"128. To specify the number of blocks to summarise in a range, use this syntax"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1712
#, fuzzy, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename]\n"
"    USING BRIN ( [geome_col] ) WITH (pages_per_range = [number]);"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ([geometryfield] "
"gist_geometry_ops_nd);"

#. Tag: para
#: using_postgis_dataman.xml:1714
#, no-c-format
msgid ""
"Keep in mind that a BRIN index only stores one index entry for a large "
"number of rows. If your table stores geometries with a mixed number of "
"dimensions, it's likely that the resulting index will have poor performance. "
"You can avoid this performance penalty by choosing the operator class with "
"the least number of dimensions of the stored geometries"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1722
#, no-c-format
msgid ""
"The <code>geography</code> datatype is supported for BRIN indexing. The "
"syntax for building a BRIN index on a geography column is:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1725
#, fuzzy, no-c-format
msgid "CREATE INDEX [indexname] ON [tablename] USING BRIN ( [geog_col] );"
msgstr ""
"CREATE INDEX [indexname] ON [tablename] USING GIST ( [geometryfield] );"

#. Tag: para
#: using_postgis_dataman.xml:1727
#, no-c-format
msgid ""
"The above syntax builds a 2D-index for geospatial objects on the spheroid."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1729
#, no-c-format
msgid ""
"Currently, only \"inclusion support\" is provided, meaning that just the "
"<varname>&amp;&amp;</varname>, <varname>~</varname> and <varname>@</varname> "
"operators can be used for the 2D cases (for both <code>geometry</code> and "
"<code>geography</code>), and just the <varname>&amp;&amp;&amp;</varname> "
"operator for 3D geometries. There is currently no support for kNN searches."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1736
#, no-c-format
msgid ""
"An important difference between BRIN and other index types is that the "
"database does not maintain the index dynamically. Changes to spatial data in "
"the table are simply appended to the end of the index. This will cause index "
"search performance to degrade over time. The index can be updated by "
"performing a <code>VACUUM</code>, or by using a special function "
"<code>brin_summarize_new_values(regclass)</code>. For this reason BRIN may "
"be most appropriate for use with data that is read-only, or only rarely "
"changing. For more information refer to the <ulink url=\"https://www."
"postgresql.org/docs/current/brin-intro.html#BRIN-OPERATION\">manual</ulink>."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1746
#, no-c-format
msgid "To summarize using BRIN for spatial data:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1750
#, no-c-format
msgid "Index build time is very fast, and index size is very small."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1751
#, no-c-format
msgid "Index query time is slower than GiST, but can still be very acceptable."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1752
#, no-c-format
msgid "Requires table data to be sorted in a spatial ordering."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1753
#, no-c-format
msgid "Requires manual index maintenance."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1754
#, no-c-format
msgid ""
"Most appropriate for very large tables, with low or no overlap (e.g. "
"points), and which are static or change infrequently."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1762
#, no-c-format
msgid "SP-GiST Indexes"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1764
#, no-c-format
msgid ""
"SP-GiST stands for \"Space-Partitioned Generalized Search Tree\" and is a "
"generic form of indexing that supports partitioned search trees, such as "
"quad-trees, k-d trees, and radix trees (tries). The common feature of these "
"data structures is that they repeatedly divide the search space into "
"partitions that need not be of equal size. In addition to GIS indexing, SP-"
"GiST is used to speed up searches on many kinds of data, such as phone "
"routing, ip routing, substring search, etc."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1772
#, no-c-format
msgid ""
"As it is the case for GiST indexes, SP-GiST indexes are lossy, in the sense "
"that they store the bounding box enclosing spatial objects. SP-GiST indexes "
"can be considered as an alternative to GiST indexes. The performance tests "
"reveal that SP-GiST indexes are especially beneficial when there are many "
"overlapping objects, that is, with so-called “spaghetti data”."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1779
#, no-c-format
msgid ""
"Once a GIS data table exceeds a few thousand rows, an SP-GiST index may be "
"used to speed up spatial searches of the data. The syntax for building an SP-"
"GiST index on a \"geometry\" column is as follows:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1783
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING SPGIST ( [geometryfield] );"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1785
#, no-c-format
msgid ""
"The above syntax will build a 2-dimensional index. A 3-dimensional index for "
"the geometry type can be created using the 3D operator class:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1788
#, no-c-format
msgid ""
"CREATE INDEX [indexname] ON [tablename] USING SPGIST ([geometryfield] "
"spgist_geometry_ops_3d);"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1790
#, no-c-format
msgid ""
"Building a spatial index is a computationally intensive operation. It also "
"blocks write access to your table for the time it creates, so on a "
"production system you may want to do in in a slower CONCURRENTLY-aware way:"
msgstr ""

#. Tag: programlisting
#: using_postgis_dataman.xml:1794
#, no-c-format
msgid ""
"CREATE INDEX CONCURRENTLY [indexname] ON [tablename] USING SPGIST "
"( [geometryfield] );"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1801
#, no-c-format
msgid ""
"An SP-GiST index can accelerate queries involving the following operators:"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1803
#, no-c-format
msgid ""
"&lt;&lt;, &amp;&lt;, &amp;&gt;, &gt;&gt;, &lt;&lt;|, &amp;&lt;|, |&amp;&gt;, "
"|&gt;&gt;, &amp;&amp;, @&gt;, &lt;@, and ~=, for 2-dimensional indexes,"
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1804
#, no-c-format
msgid "&amp;/&amp;, ~==, @&gt;&gt;, and &lt;&lt;@, for 3-dimensional indexes."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1806
#, no-c-format
msgid "There is no support for kNN searches at the moment."
msgstr ""

#. Tag: title
#: using_postgis_dataman.xml:1809
#, fuzzy, no-c-format
msgid "Tuning Index Usage"
msgstr "Construindo índidces"

#. Tag: para
#: using_postgis_dataman.xml:1811
#, no-c-format
msgid ""
"Ordinarily, indexes invisibly speed up data access: once an index is built, "
"the PostgreSQL query planner automatically decides when to use it to improve "
"query performance. But there are some situations where the planner does not "
"choose to use existing indexes, so queries end up using slow sequential "
"scans instead of a spatial index."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1817
#, fuzzy, no-c-format
msgid ""
"If you find your spatial indexes are not being used, there are a few things "
"you can do:"
msgstr ""
"Se você achar que seus índices não estão sendo usados (ou seus atributos) há "
"algumas coisas que pode fazer: "

#. Tag: para
#: using_postgis_dataman.xml:1822
#, no-c-format
msgid ""
"Examine the query plan and check your query actually computes the thing you "
"need. An erroneous JOIN, either forgotten or to the wrong table, can "
"unexpectedly retrieve table records multiple times. To get the query plan, "
"execute with <code>EXPLAIN</code> in front of the query."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1829
#, no-c-format
msgid ""
"Make sure statistics are gathered about the number and distributions of "
"values in a table, to provide the query planner with better information to "
"make decisions around index usage. <command>VACUUM ANALYZE</command> will "
"compute both."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1834
#, no-c-format
msgid ""
"You should regularly vacuum your databases anyways. Many PostgreSQL DBAs run "
"<command>VACUUM</command> as an off-peak cron job on a regular basis."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1839
#, no-c-format
msgid ""
"If vacuuming does not help, you can temporarily force the planner to use the "
"index information by using the command <command>SET ENABLE_SEQSCAN TO OFF;</"
"command>. This way you can check whether the planner is at all able to "
"generate an index-accelerated query plan for your query. You should only use "
"this command for debugging; generally speaking, the planner knows better "
"than you do about when to use indexes. Once you have run your query, do not "
"forget to run <command>SET ENABLE_SEQSCAN TO ON;</command> so that the "
"planner will operate normally for other queries."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1851
#, no-c-format
msgid ""
"If <command>SET ENABLE_SEQSCAN TO OFF;</command> helps your query to run "
"faster, your Postgres is likely not tuned for your hardware. If you find the "
"planner wrong about the cost of sequential versus index scans try reducing "
"the value of <varname>RANDOM_PAGE_COST</varname> in <code>postgresql.conf</"
"code>, or use <command>SET RANDOM_PAGE_COST TO 1.1;</command>. The default "
"value for <varname>RANDOM_PAGE_COST</varname> is 4.0. Try setting it to 1.1 "
"(for SSD) or 2.0 (for fast magnetic disks). Decreasing the value makes the "
"planner more likely to use index scans."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1862
#, no-c-format
msgid ""
"If <command>SET ENABLE_SEQSCAN TO OFF;</command> does not help your query, "
"the query may be using a SQL construct that the Postgres planner is not yet "
"able to optimize. It may be possible to rewrite the query in a way that the "
"planner is able to handle. For example, a subquery with an inline SELECT may "
"not produce an efficient plan, but could possibly be rewritten using a "
"LATERAL JOIN."
msgstr ""

#. Tag: para
#: using_postgis_dataman.xml:1871
#, no-c-format
msgid ""
"For more information see the Postgres manual section on <ulink url=\"https://"
"www.postgresql.org/docs/current/runtime-config-query.html\">Query Planning</"
"ulink>."
msgstr ""

#~ msgid "Using PostGIS: Data Management and Queries"
#~ msgstr "Usando o PostGIS: Gerenciamento de dados e consultas"

#~ msgid "Using OpenGIS Standards"
#~ msgstr "Usando os Padrões OpenGIS"

#~ msgid ""
#~ "There are two OpenGIS meta-data tables: <varname>SPATIAL_REF_SYS</"
#~ "varname> and <varname>GEOMETRY_COLUMNS</varname>. The "
#~ "<varname>SPATIAL_REF_SYS</varname> table holds the numeric IDs and "
#~ "textual descriptions of coordinate systems used in the spatial database."
#~ msgstr ""
#~ "Existem duas tabelas de metadados OpenGIS: <varname>SPATIAL_REF_SYS</"
#~ "varname> e <varname>GEOMETRY_COLUMNS</varname>. A tabela "
#~ "<varname>SPATIAL_REF_SYS</varname> detém as IDs numéricas e descrições "
#~ "textuais de sistemas coordenados usadas no banco de dados espacial."

#~ msgid ""
#~ "The spatial_ref_sys table is a PostGIS included and OGC compliant "
#~ "database table that lists over 3000 known <ulink url=\"http://www."
#~ "sharpgis.net/post/2007/05/Spatial-references2c-coordinate-systems2c-"
#~ "projections2c-datums2c-ellipsoids-e28093-confusing.aspx\">spatial "
#~ "reference systems</ulink> and details needed to transform/reproject "
#~ "between them."
#~ msgstr ""
#~ "A tabela spatial_ref_sys está incluída no POstGIS e uma tabela do banco "
#~ "de dados OGC dependente que lista mais de 3000 <ulink url=\"http://www."
#~ "sharpgis.net/post/2007/05/Spatial-references2c-coordinate-systems2c-"
#~ "projections2c-datums2c-ellipsoids-e28093-confusing.aspx\">spatial "
#~ "reference systems</ulink> conhecidas e detalhes necessários para "
#~ "transformar/reprojetar entre eles. "

#~ msgid ""
#~ "For details on determining which UTM zone to use for your area of "
#~ "interest, check out the <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
#~ "UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper "
#~ "function</ulink>."
#~ msgstr ""
#~ "Para maiores detalhes na determinação de qual zona UTM usar para sua área "
#~ "de interesse, veja <ulink url=\"http://trac.osgeo.org/postgis/wiki/"
#~ "UsersWikiplpgsqlfunctionsDistance\">utmzone PostGIS plpgsql helper "
#~ "function</ulink>."

#~ msgid "The <varname>SPATIAL_REF_SYS</varname> columns are as follows:"
#~ msgstr "As colunas <varname>SPATIAL_REF_SYS</varname> estão como segue:"

#~ msgid "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"
#~ msgstr "<ulink url=\"http://en.wikipedia.org/wiki/SRID\">SRID</ulink>"

#~ msgid "AUTH_NAME"
#~ msgstr "AUTH_NAME"

#~ msgid "AUTH_SRID"
#~ msgstr "AUTH_SRID"

#~ msgid "SRTEXT"
#~ msgstr "SRTEXT"

#~ msgid "PROJ4TEXT"
#~ msgstr "PROJ4TEXT"

#~ msgid "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"
#~ msgstr "F_TABLE_CATALOG, F_TABLE_SCHEMA, F_TABLE_NAME"

#~ msgid "F_GEOMETRY_COLUMN"
#~ msgstr "F_GEOMETRY_COLUMN"

#~ msgid "COORD_DIMENSION"
#~ msgstr "COORD_DIMENSION"

#~ msgid "<term>SRID</term>"
#~ msgstr "<term>SRID</term>"

#~ msgid "TYPE"
#~ msgstr "TYPE"

#~ msgid "Ensuring OpenGIS compliancy of geometries"
#~ msgstr "Assegurando a confirmação de geometrias OpenGIS"

#~ msgid "Dimensionally Extended 9 Intersection Model (DE-9IM)"
#~ msgstr "Dimensionalidade estendida 9 Modelo de Interseção (DE-9IM) "

#~ msgid ""
#~ "For example, consider a linear dataset representing a road network. It "
#~ "may be the task of a GIS analyst to identify all road segments that cross "
#~ "each other, not at a point, but on a line, perhaps invalidating some "
#~ "business rule. In this case, <xref linkend=\"ST_Crosses\"/> does not "
#~ "adequately provide the necessary spatial filter since, for linear "
#~ "features, it returns <varname>true</varname> only where they cross at a "
#~ "point."
#~ msgstr ""
#~ "Considere um dataset linear representando uma rede de ruas. Pode ser a "
#~ "tarefa de um analista GIS identificar todos os segmentos de ruas que "
#~ "cruzam outras, não em um ponto, mas em uma linha, talvez invalidando "
#~ "alguma regra de negócio. Neste caso, a <xref linkend=\"ST_Crosses\"/> não "
#~ "fornece adequadamente o filtro espacial necessário já que, para "
#~ "características lineares, ela retorna <varname>true</varname> só onde "
#~ "elas cruzam em um ponto. "

#~ msgid ""
#~ "One two-step solution might be to first perform the actual intersection "
#~ "(<xref linkend=\"ST_Intersection\"/>) of pairs of road segments that "
#~ "spatially intersect (<xref linkend=\"ST_Intersects\"/>), and then compare "
#~ "the intersection's <xref linkend=\"ST_GeometryType\"/> with "
#~ "'<varname>LINESTRING</varname>' (properly dealing with cases that return "
#~ "<varname>GEOMETRYCOLLECTION</varname>s of <varname>[MULTI]POINT</"
#~ "varname>s, <varname>[MULTI]LINESTRING</varname>s, etc.)."
#~ msgstr ""
#~ "Uma solução de dois passos pode ser primeiro representar a verdadeira "
#~ "interseção (<xref linkend=\"ST_Intersection\"/>) de pares de segmentos de "
#~ "ruas que se intersectam espacialmente (<xref linkend=\"ST_Intersects\"/"
#~ ">), e comparar as <xref linkend=\"ST_GeometryType\"/> das intersecções "
#~ "com a '<varname>LINESTRING</varname>' (lidando propriamente com casos que "
#~ "retornam <varname>GEOMETRYCOLLECTION</varname>s de <varname>[MULTI]POINT</"
#~ "varname>s, <varname>[MULTI]LINESTRING</varname>s, etc.)."

#~ msgid "A more elegant / faster solution may indeed be desirable."
#~ msgstr "Uma solução mais elegante/rápida pode ser de fato desejável. "

#~ msgid ""
#~ "A second [theoretical] example may be that of a GIS analyst trying to "
#~ "locate all wharfs or docks that intersect a lake's boundary on a line and "
#~ "where only one end of the wharf is up on shore. In other words, where a "
#~ "wharf is within, but not completely within a lake, intersecting the "
#~ "boundary of a lake on a line, and where the wharf's endpoints are both "
#~ "completely within and on the boundary of the lake. The analyst may need "
#~ "to use a combination of spatial predicates to isolate the sought after "
#~ "features:"
#~ msgstr ""
#~ "Um segundo exemplo [teórico] pode ser aquele de um analista GIS tentando "
#~ "localizar todos os píeres ou docas que intersectam as margens de um lago "
#~ "em um linha e onde somente um fim do píer está em terra. Em outras "
#~ "palavras, onde um píer está, mas não completamente, dentro de um lago, e "
#~ "onde os pontos finais do píer estão completamente dentro e nas margens do "
#~ "lago. O analista pode precisar usar uma combinação de predicados "
#~ "espaciais para isolar o as características procuradas: "

#~ msgid "(lake, wharf) = TRUE"
#~ msgstr "(lake, wharf) = TRUE"

#~ msgid "(lake, wharf) = FALSE"
#~ msgstr "(lake, wharf) = FALSE"

#~ msgid "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"
#~ msgstr "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"

#~ msgid ""
#~ "(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
#~ "linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/"
#~ ">(lake)))) = 1"
#~ msgstr ""
#~ "(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
#~ "linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/"
#~ ">(lake)))) = 1"

#~ msgid "... (needless to say, this could get quite complicated)"
#~ msgstr ""
#~ "... (desnecessário dizer, isto poderia se tornar um pouco complicado)"

#~ msgid ""
#~ "So enters the Dimensionally Extended 9 Intersection Model, or DE-9IM for "
#~ "short."
#~ msgstr ""
#~ "Então entre a Dimensionalidade estendida 9 Modelo de Interseção ou DE-9IM "
#~ "para abreviação. "

#~ msgid "Theory"
#~ msgstr "Teoria"

#~ msgid ""
#~ "According to the <ulink url=\"http://www.opengeospatial.org/standards/sfs"
#~ "\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, "
#~ "\"the basic approach to comparing two geometries is to make pair-wise "
#~ "tests of the intersections between the Interiors, Boundaries and "
#~ "Exteriors of the two geometries and to classify the relationship between "
#~ "the two geometries based on the entries in the resulting 'intersection' "
#~ "matrix.\""
#~ msgstr ""
#~ "De acordo com  <ulink url=\"http://www.opengeospatial.org/standards/sfs"
#~ "\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, "
#~ "\"a abordagem básica para comparar duas geometrias é fazer testes par-"
#~ "wise das interseções entre os interiores, limites e exteriores das duas "
#~ "geometrias e classificar a relação entre as duas geometrias baseada nas "
#~ "entradas e na matriz de \"interseção\" resultante.\""

#~ msgid "<glossterm>Boundary</glossterm>"
#~ msgstr "<glossterm>Boundary</glossterm>"

#~ msgid ""
#~ "The boundary of a geometry is the set of geometries of the next lower "
#~ "dimension. For <varname>POINT</varname>s, which have a dimension of 0, "
#~ "the boundary is the empty set. The boundary of a <varname>LINESTRING</"
#~ "varname> are the two endpoints. For <varname>POLYGON</varname>s, the "
#~ "boundary is the linework that make up the exterior and interior rings."
#~ msgstr ""
#~ "O limite de uma geometria é o conjunto de geometrias da próxima menor "
#~ "dimensão. Para  <varname>POINT</varname>s, os quais têm uma dimensão 0, o "
#~ "limite é o conjunto vazio. O limite de uma <varname>LINESTRING</varname> "
#~ "são os dois pontos finais. Para <varname>POLYGON</varname>s, o limite é a "
#~ "linework que faz os anéis interiores e exteriores. "

#~ msgid "<glossterm>Interior</glossterm>"
#~ msgstr "<glossterm>Interior</glossterm>"

#~ msgid ""
#~ "The interior of a geometry are those points of a geometry that are left "
#~ "when the boundary is removed. For <varname>POINT</varname>s, the interior "
#~ "is the <varname>POINT</varname> itself. The interior of a "
#~ "<varname>LINESTRING</varname> are the set of real points between the "
#~ "endpoints. For <varname>POLYGON</varname>s, the interior is the areal "
#~ "surface inside the polygon."
#~ msgstr ""
#~ "O interior de uma geometria são aqueles pontos deixados quando um limite "
#~ "é removido. Para <varname>POLYGON</varname>s, o interior é o pŕoprio "
#~ "<varname>POLYGON</varname>. O interior de uma <varname>LINESTRING</"
#~ "varname> são o conjunto de pontos reais entre os pontos finais. Para "
#~ "<varname>POLYGON</varname>s, o interior é a superfície areal dentro do "
#~ "polígono. "

#~ msgid "<glossterm>Exterior</glossterm>"
#~ msgstr "<glossterm>Exterior</glossterm>"

#~ msgid ""
#~ "The exterior of a geometry is the universe, an areal surface, not on the "
#~ "interior or boundary of the geometry."
#~ msgstr ""
#~ "O exterior de uma geometria é o universo, uma superfícies areal, não no "
#~ "interior ou limite da geometria. "

#~ msgid ""
#~ "Given geometry <emphasis>a</emphasis>, where the <emphasis>I(a)</"
#~ "emphasis>, <emphasis>B(a)</emphasis>, and <emphasis>E(a)</emphasis> are "
#~ "the <emphasis>Interior</emphasis>, <emphasis>Boundary</emphasis>, and "
#~ "<emphasis>Exterior</emphasis> of a, the mathematical representation of "
#~ "the matrix is:"
#~ msgstr ""
#~ "Dada a geometria <emphasis>a</emphasis>, onde o <emphasis>I(a)</"
#~ "emphasis>, <emphasis>B(a)</emphasis>, and <emphasis>E(a)</emphasis> são "
#~ "<emphasis>Interior</emphasis>, <emphasis>Boundary</emphasis>, e "
#~ "<emphasis>Exterior</emphasis> de a, a representação matemática da matriz "
#~ "é: "

#~ msgid "<emphasis role=\"bold\">Interior</emphasis>"
#~ msgstr "<emphasis role=\"bold\">Interior</emphasis>"

#~ msgid "<emphasis role=\"bold\">Boundary</emphasis>"
#~ msgstr "<emphasis role=\"bold\">Boundary</emphasis>"

#~ msgid "<emphasis role=\"bold\">Exterior</emphasis>"
#~ msgstr "<emphasis role=\"bold\">Exterior</emphasis>"

#~ msgid "dim( I(a) ∩ I(b) )"
#~ msgstr "dim( I(a) ∩ I(b) )"

#~ msgid "dim( I(a) ∩ B(b) )"
#~ msgstr "dim( I(a) ∩ B(b) )"

#~ msgid "dim( I(a) ∩ E(b) )"
#~ msgstr "dim( I(a) ∩ E(b) )"

#~ msgid "dim( B(a) ∩ I(b) )"
#~ msgstr "dim( B(a) ∩ I(b) )"

#~ msgid "dim( B(a) ∩ B(b) )"
#~ msgstr "dim( B(a) ∩ B(b) )"

#~ msgid "dim( B(a) ∩ E(b) )"
#~ msgstr "dim( B(a) ∩ E(b) )"

#~ msgid "dim( E(a) ∩ I(b) )"
#~ msgstr "dim( E(a) ∩ I(b) )"

#~ msgid "dim( E(a) ∩ B(b) )"
#~ msgstr "dim( E(a) ∩ B(b) )"

#~ msgid "dim( E(a) ∩ E(b) )"
#~ msgstr "dim( E(a) ∩ E(b) )"

#~ msgid ""
#~ "Where <emphasis>dim(a)</emphasis> is the dimension of <emphasis>a</"
#~ "emphasis> as specified by <xref linkend=\"ST_Dimension\"/> but has the "
#~ "domain of <literal>{0,1,2,T,F,*}</literal>"
#~ msgstr ""
#~ "Onde<emphasis>dim(a)</emphasis> é a dimensão de <emphasis>a</emphasis> "
#~ "como especificado em <xref linkend=\"ST_Dimension\"/> mas tem o domínio "
#~ "de <literal>{0,1,2,T,F,*}</literal>"

#~ msgid "<literal>0</literal> =&gt; point"
#~ msgstr "<literal>0</literal> =&gt; point"

#~ msgid "<literal>1</literal> =&gt; line"
#~ msgstr "<literal>1</literal> =&gt; line"

#~ msgid "<literal>2</literal> =&gt; area"
#~ msgstr "<literal>2</literal> =&gt; area"

#~ msgid "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"
#~ msgstr "<literal>T</literal> =&gt; <literal>{0,1,2}</literal>"

#~ msgid "<literal>F</literal> =&gt; empty set"
#~ msgstr "<literal>F</literal> =&gt; empty set"

#~ msgid "<literal>*</literal> =&gt; don't care"
#~ msgstr "<literal>*</literal> =&gt; don't care"

#~ msgid "Visually, for two overlapping polygonal geometries, this looks like:"
#~ msgstr ""
#~ "Visualmente, para dois polígonos que se sobrepõem, isto se parece com: "

#~ msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"
#~ msgstr ""
#~ "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">2</emphasis>"

#~ msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"
#~ msgstr ""
#~ "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">1</emphasis>"

#~ msgid "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"
#~ msgstr ""
#~ "<emphasis>dim(...) = </emphasis><emphasis role=\"bold\">0</emphasis>"

#~ msgid ""
#~ "Read from left to right and from top to bottom, the dimensional matrix is "
#~ "represented, '<emphasis role=\"bold\">212101212</emphasis>'."
#~ msgstr ""
#~ "Leia da esquerda para a direita e de cima para baixo, a matriz "
#~ "dimensional é representada, '<emphasis role=\"bold\">212101212</"
#~ "emphasis>'. "

#~ msgid ""
#~ "A relate matrix that would therefore represent our first example of two "
#~ "lines that intersect on a line would be: '<emphasis role=\"bold"
#~ "\">1*1***1**</emphasis>'"
#~ msgstr ""
#~ "Uma matriz conta que iria portanto representar nosso primeiro exemplo de "
#~ "duas linhas que intersectam em uma linha, seria: '<emphasis role=\"bold"
#~ "\">1*1***1**</emphasis>'"

#~ msgid ""
#~ "-- Identify road segments that cross on a line\n"
#~ "SELECT a.id\n"
#~ "FROM roads a, roads b\n"
#~ "WHERE a.id != b.id\n"
#~ "AND a.geom &amp;&amp; b.geom\n"
#~ "AND ST_Relate(a.geom, b.geom, '1*1***1**');"
#~ msgstr ""
#~ "-- Identify road segments that cross on a line\n"
#~ "SELECT a.id\n"
#~ "FROM roads a, roads b\n"
#~ "WHERE a.id != b.id\n"
#~ "AND a.geom &amp;&amp; b.geom\n"
#~ "AND ST_Relate(a.geom, b.geom, '1*1***1**');"

#~ msgid ""
#~ "A relate matrix that represents the second example of wharfs partly on "
#~ "the lake's shoreline would be '<emphasis role=\"bold\">102101FF2</"
#~ "emphasis>'"
#~ msgstr ""
#~ "Uma matriz conta que representa o segundo exemplo de cais parcialmente na "
#~ "margem do lago seria '<emphasis role=\"bold\">102101FF2</emphasis>' "

#~ msgid ""
#~ "-- Identify wharfs partly on a lake's shoreline\n"
#~ "SELECT a.lake_id, b.wharf_id\n"
#~ "FROM lakes a, wharfs b\n"
#~ "WHERE a.geom &amp;&amp; b.geom\n"
#~ "AND ST_Relate(a.geom, b.geom, '102101FF2');"
#~ msgstr ""
#~ "-- Identify wharfs partly on a lake's shoreline\n"
#~ "SELECT a.lake_id, b.wharf_id\n"
#~ "FROM lakes a, wharfs b\n"
#~ "WHERE a.geom &amp;&amp; b.geom\n"
#~ "AND ST_Relate(a.geom, b.geom, '102101FF2');"

#~ msgid "For more information or reading, see:"
#~ msgstr "Para maiores informações ou leituras, veja:"

#~ msgid ""
#~ "<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
#~ "Features Implementation Specification for SQL</ulink> (version 1.1, "
#~ "section 2.1.13.2)"
#~ msgstr ""
#~ "<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
#~ "Features Implementation Specification for SQL</ulink> (version 1.1, "
#~ "section 2.1.13.2)"

#~ msgid "Dimensionally Extended Nine-Intersection Model (DE-9IM)"
#~ msgstr "Dimensionalidade Estendida Modelo de Interseção-Nove (DE-9IM) "

#~ msgid "GeoTools: Point Set Theory and the DE-9IM Matrix"
#~ msgstr "FerramentasGeo: Teoria de Ponto e a Matriz DE-9IM"

#~ msgid "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"
#~ msgstr "<emphasis>Encyclopedia of GIS</emphasis> By Hui Xiong"

#~ msgid "Loading Data Using SQL"
#~ msgstr "Carregando Dados Usando SQL"

#~ msgid "Retrieving GIS Data"
#~ msgstr "Recuperando dados GIS"

#~ msgid "Using Indexes"
#~ msgstr "Usando Índices"

#~ msgid "Complex Queries"
#~ msgstr "Consultas Complexas"

#~ msgid "Taking Advantage of Indexes"
#~ msgstr "Tirando vantagem dos índices"

#~ msgid ""
#~ "When constructing a query it is important to remember that only the "
#~ "bounding-box-based operators such as &amp;&amp; can take advantage of the "
#~ "GiST spatial index. Functions such as <varname>ST_Distance()</varname> "
#~ "cannot use the index to optimize their operation. For example, the "
#~ "following query would be quite slow on a large table:"
#~ msgstr ""
#~ "Ao construir uma consulta é importante lembrar que somente os operadores "
#~ "baseados na caixa delimitadora como &amp;&amp; podem tirar vantagem do "
#~ "índice GiST. Funções como <varname>ST_Distance()</varname> não podem usar "
#~ "o índice para otimizar sua operação. Por exemplo, a consulta a seguir "
#~ "seria devagar em uma tabela grande: "

#~ msgid "Examples of Spatial SQL"
#~ msgstr "Exemplos de SQL espacial"

#~ msgid ""
#~ "The examples in this section will make use of two tables, a table of "
#~ "linear roads, and a table of polygonal municipality boundaries. The table "
#~ "definitions for the <varname>bc_roads</varname> table is:"
#~ msgstr ""
#~ "Os exemplos desta seção farão uso de duas tabelas, uma tabela de ruas "
#~ "lineares e uma de limites de municípios poligonais. As definições para a "
#~ "tabela <varname>bc_roads</varname> são:"

#~ msgid ""
#~ "Column      | Type              | Description\n"
#~ "------------+-------------------+-------------------\n"
#~ "gid         | integer           | Unique ID\n"
#~ "name        | character varying | Road Name\n"
#~ "the_geom    | geometry          | Location Geometry (Linestring)"
#~ msgstr ""
#~ "Column      | Type              | Description\n"
#~ "------------+-------------------+-------------------\n"
#~ "gid         | integer           | Unique ID\n"
#~ "name        | character varying | Road Name\n"
#~ "the_geom    | geometry          | Location Geometry (Linestring)"

#~ msgid ""
#~ "The table definition for the <varname>bc_municipality</varname> table is:"
#~ msgstr "A definição para a tabela <varname>bc_municipality</varname> é:"

#~ msgid ""
#~ "Column     | Type              | Description\n"
#~ "-----------+-------------------+-------------------\n"
#~ "gid        | integer           | Unique ID\n"
#~ "code       | integer           | Unique ID\n"
#~ "name       | character varying | City / Town Name\n"
#~ "the_geom   | geometry          | Location Geometry (Polygon)"
#~ msgstr ""
#~ "Column     | Type              | Description\n"
#~ "-----------+-------------------+-------------------\n"
#~ "gid        | integer           | Unique ID\n"
#~ "code       | integer           | Unique ID\n"
#~ "name       | character varying | City / Town Name\n"
#~ "the_geom   | geometry          | Location Geometry (Polygon)"

#~ msgid "What is the total length of all roads, expressed in kilometers?"
#~ msgstr ""
#~ "Qual é o comprimento total de todas as ruas, expressado em quilômetros?  "

#~ msgid "You can answer this question with a very simple piece of SQL:"
#~ msgstr "Você pode responder esta questão com um pedaço simples de SQL: "

#~ msgid ""
#~ "SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
#~ "\n"
#~ "km_roads\n"
#~ "------------------\n"
#~ "70842.1243039643\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT sum(ST_Length(the_geom))/1000 AS km_roads FROM bc_roads;\n"
#~ "\n"
#~ "km_roads\n"
#~ "------------------\n"
#~ "70842.1243039643\n"
#~ "(1 row)"

#~ msgid "How large is the city of Prince George, in hectares?"
#~ msgstr "Quão grande é a cidade de Prince George em hectares? "

#~ msgid ""
#~ "This query combines an attribute condition (on the municipality name) "
#~ "with a spatial calculation (of the area):"
#~ msgstr ""
#~ "Esta consulta combina um atributo condição (no nome do município) com um "
#~ "cálculo espacial (da área):"

#~ msgid ""
#~ "SELECT\n"
#~ "  ST_Area(the_geom)/10000 AS hectares\n"
#~ "FROM bc_municipality\n"
#~ "WHERE name = 'PRINCE GEORGE';\n"
#~ "\n"
#~ "hectares\n"
#~ "------------------\n"
#~ "32657.9103824927\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT\n"
#~ "  ST_Area(the_geom)/10000 AS hectares\n"
#~ "FROM bc_municipality\n"
#~ "WHERE name = 'PRINCE GEORGE';\n"
#~ "\n"
#~ "hectares\n"
#~ "------------------\n"
#~ "32657.9103824927\n"
#~ "(1 row)"

#~ msgid "What is the largest municipality in the province, by area?"
#~ msgstr "Qual é o maior município na província, por área? "

#~ msgid ""
#~ "This query brings a spatial measurement into the query condition. There "
#~ "are several ways of approaching this problem, but the most efficient is "
#~ "below:"
#~ msgstr ""
#~ "Esta consulta traz uma media espacial dentro da consulta condição. "
#~ "Existem várias maneiras de abordar este problema, mas o mais eficiente "
#~ "está abaixo:"

#~ msgid ""
#~ "SELECT\n"
#~ "  name,\n"
#~ "  ST_Area(the_geom)/10000 AS hectares\n"
#~ "FROM\n"
#~ "  bc_municipality\n"
#~ "ORDER BY hectares DESC\n"
#~ "LIMIT 1;\n"
#~ "\n"
#~ "name           | hectares\n"
#~ "---------------+-----------------\n"
#~ "TUMBLER RIDGE  | 155020.02556131\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT\n"
#~ "  name,\n"
#~ "  ST_Area(the_geom)/10000 AS hectares\n"
#~ "FROM\n"
#~ "  bc_municipality\n"
#~ "ORDER BY hectares DESC\n"
#~ "LIMIT 1;\n"
#~ "\n"
#~ "name           | hectares\n"
#~ "---------------+-----------------\n"
#~ "TUMBLER RIDGE  | 155020.02556131\n"
#~ "(1 row)"

#~ msgid ""
#~ "Note that in order to answer this query we have to calculate the area of "
#~ "every polygon. If we were doing this a lot it would make sense to add an "
#~ "area column to the table that we could separately index for performance. "
#~ "By ordering the results in a descending direction, and them using the "
#~ "PostgreSQL \"LIMIT\" command we can easily pick off the largest value "
#~ "without using an aggregate function like max()."
#~ msgstr ""
#~ "Note que para responder esta pesquisa, tivemos que calcular a área de "
#~ "cada polígono. Se estivéssemos acostumados a fazer isto, faria sentido "
#~ "adicionar uma coluna área à tabela que poderíamos classificar "
#~ "separadamente para apresentação. Pedindo os resultados em uma direção "
#~ "descendente, e usando o comando PostgreSQL \"LIMITE\" podemos escolher o "
#~ "maior valor sem usar uma função agregada como max().  "

#~ msgid ""
#~ "What is the length of roads fully contained within each municipality?"
#~ msgstr ""
#~ "Qual é o comprimento de ruas completamente contidas dentro de cada "
#~ "município?"

#~ msgid ""
#~ "This is an example of a \"spatial join\", because we are bringing "
#~ "together data from two tables (doing a join) but using a spatial "
#~ "interaction condition (\"contained\") as the join condition rather than "
#~ "the usual relational approach of joining on a common key:"
#~ msgstr ""
#~ "Este é um exemplo de uma \"união espacial\", porque estamos unindo dados "
#~ "de duas tabelas (fazendo uma união), mas usando a condição de interação "
#~ "espacial (\"contida\") como a condição de união em vez da maneira usual "
#~ "de unir a uma chave comum: "

#~ msgid ""
#~ "This query takes a while, because every road in the table is summarized "
#~ "into the final result (about 250K roads for our particular example "
#~ "table). For smaller overlays (several thousand records on several "
#~ "hundred) the response can be very fast."
#~ msgstr ""
#~ "Esta consulta leva alguns instantes, pois cada rua na tabela está "
#~ "resumida no resultado final (por volta de 250K ruas para nossa tabela "
#~ "exemplo). Para coberturas menores (vários milhares de relatos em muitas "
#~ "centenas) a resposta pode ser bem rápida. "

#~ msgid ""
#~ "Create a new table with all the roads within the city of Prince George."
#~ msgstr ""
#~ "Criar uma nova tabela como todas as ruas dentro da cidade de Prince "
#~ "George. "

#~ msgid ""
#~ "This is an example of an \"overlay\", which takes in two tables and "
#~ "outputs a new table that consists of spatially clipped or cut resultants. "
#~ "Unlike the \"spatial join\" demonstrated above, this query actually "
#~ "creates new geometries. An overlay is like a turbo-charged spatial join, "
#~ "and is useful for more exact analysis work:"
#~ msgstr ""
#~ "Este é um exemplo de uma \"cobertura\", que pega duas tabelas e gera uma "
#~ "nova tabela que consiste de resultantes cortadas. Diferente da \"união "
#~ "espacial\" demonstrada acima, esta consulta realmente cria novas "
#~ "geometrias. Uma cobertura é como uma união espacial turbo carregada, e é "
#~ "útil para trabalhos de análise mais exatos:"

#~ msgid "What is the length in kilometers of \"Douglas St\" in Victoria?"
#~ msgstr "Qual é o tamanho em quilômetros da \"Douglas St\" em Victoria?"

#~ msgid "What is the largest municipality polygon that has a hole?"
#~ msgstr "Qual é o maior município poligonal que tem um buraco?"

#~ msgid ""
#~ "SELECT gid, name, ST_Area(the_geom) AS area\n"
#~ "FROM bc_municipality\n"
#~ "WHERE ST_NRings(the_geom) &gt; 1\n"
#~ "ORDER BY area DESC LIMIT 1;\n"
#~ "\n"
#~ "gid  | name         | area\n"
#~ "-----+--------------+------------------\n"
#~ "12   | SPALLUMCHEEN | 257374619.430216\n"
#~ "(1 row)"
#~ msgstr ""
#~ "SELECT gid, name, ST_Area(the_geom) AS area\n"
#~ "FROM bc_municipality\n"
#~ "WHERE ST_NRings(the_geom) &gt; 1\n"
#~ "ORDER BY area DESC LIMIT 1;\n"
#~ "\n"
#~ "gid  | name         | area\n"
#~ "-----+--------------+------------------\n"
#~ "12   | SPALLUMCHEEN | 257374619.430216\n"
#~ "(1 row)"
