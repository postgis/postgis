# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: https://bugs.kde.org\n"
"POT-Creation-Date: 2023-07-15 01:29+0000\n"
"PO-Revision-Date: 2023-08-29 14:16+0000\n"
"Last-Translator: 左晨威 <zuocw@highgo.com>\n"
"Language-Team: Chinese <https://weblate.osgeo.org/projects/postgis/using_postgis_queryxml/"
"zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.16.4\n"

#. Tag: title
#: using_postgis_query.xml:3
#, no-c-format
msgid "Spatial Queries"
msgstr "空间查询"

#. Tag: para
#: using_postgis_query.xml:5
#, no-c-format
msgid ""
"The <emphasis>raison d'etre</emphasis> of spatial databases is to perform "
"queries inside the database which would ordinarily require desktop GIS "
"functionality. Using PostGIS effectively requires knowing what spatial "
"functions are available, how to use them in queries, and ensuring that "
"appropriate indexes are in place to provide good performance."
msgstr "空间数据库<emphasis>存在的理由</emphasis>是在数据库内执行查询，这通常需要桌面 GIS 功能。"
"有效使用 PostGIS 需要了解哪些空间函数可用、如何在查询中使用它们，并确保适当的索引以提供良好的性能。"

#. Tag: title
#: using_postgis_query.xml:14
#, no-c-format
msgid "Determining Spatial Relationships"
msgstr "空间关系的确定"

#. Tag: para
#: using_postgis_query.xml:16
#, no-c-format
msgid ""
"Spatial relationships indicate how two geometries interact with one another. "
"They are a fundamental capability for querying geometry."
msgstr "空间关系显示两个几何图形如何相互关联。用于查询几何的基本功能。"

#. Tag: title
#: using_postgis_query.xml:21
#, no-c-format
msgid "Dimensionally Extended 9-Intersection Model"
msgstr "维度扩展9相交模型（Dimensionally Extended 9-Intersection Model）"

#. Tag: para
#: using_postgis_query.xml:23
#, no-c-format
msgid ""
"According to the <ulink url=\"http://www.opengeospatial.org/standards/"
"sfs\">OpenGIS Simple Features Implementation Specification for SQL</ulink>, "
"\"the basic approach to comparing two geometries is to make pair-wise tests "
"of the intersections between the Interiors, Boundaries and Exteriors of the "
"two geometries and to classify the relationship between the two geometries "
"based on the entries in the resulting 'intersection' matrix.\""
msgstr "根据<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS SQL简单特征实现规范</ulink>，"
"“比较两个几何图形的基本方法是对两个几何图形的内部、边界和外部之间的相交进行交集测试，并根据'交集矩阵'的元素对两个几何之间的关系进行分类。”"

#. Tag: para
#: using_postgis_query.xml:32
#, no-c-format
msgid ""
"In the theory of point-set topology, the points in a geometry embedded in 2-"
"dimensional space are categorized into three sets:"
msgstr "在点集拓扑理论中，嵌入二维空间的几何中的点被分为三个集合："

#. Tag: glossterm
#: using_postgis_query.xml:38
#, no-c-format
msgid "<glossterm>Boundary</glossterm>"
msgstr "<glossterm>边界</glossterm>"

#. Tag: para
#: using_postgis_query.xml:41
#, no-c-format
msgid ""
"The boundary of a geometry is the set of geometries of the next lower "
"dimension. For <varname>POINT</varname>s, which have a dimension of 0, the "
"boundary is the empty set. The boundary of a <varname>LINESTRING</varname> "
"is the two endpoints. For <varname>POLYGON</varname>s, the boundary is the "
"linework of the exterior and interior rings."
msgstr "几何的边界是下一个较低维度的几何的集合。 对于维数为 0 的 <varname>POINT</varname>s，"
"边界是空集。<varname>LINESTRING</varname>的边界是两个端点。 对于<varname>POLYGON</varname>s，边界是外环和内环的线条。"

#. Tag: glossterm
#: using_postgis_query.xml:52
#, no-c-format
msgid "<glossterm>Interior</glossterm>"
msgstr "<glossterm>内部</glossterm>"

#. Tag: para
#: using_postgis_query.xml:55
#, no-c-format
msgid ""
"The interior of a geometry are those points of a geometry that are not in "
"the boundary. For <varname>POINT</varname>s, the interior is the point "
"itself. The interior of a <varname>LINESTRING</varname> is the set of points "
"between the endpoints. For <varname>POLYGON</varname>s, the interior is the "
"areal surface inside the polygon."
msgstr "几何图形的内部是几何图形中不在边界内的那些点。对于<varname>POINT</varname>s来说，内部就是点本身。"
"<varname>LINESTRING</varname>的内部是端点之间的点集。 对于<varname>POLYGON</varname>s，内部是多边形内的面。"

#. Tag: glossterm
#: using_postgis_query.xml:66
#, no-c-format
msgid "<glossterm>Exterior</glossterm>"
msgstr "<glossterm>外部</glossterm>"

#. Tag: para
#: using_postgis_query.xml:69
#, no-c-format
msgid ""
"The exterior of a geometry is the rest of the space in which the geometry is "
"embedded; in other words, all points not in the interior or on the boundary "
"of the geometry. It is a 2-dimensional non-closed surface."
msgstr "几何体的外部是几何体嵌入的空间的其余部分；换句话说，所有不在几何内部或边界上的点。 它是一个二维非封闭曲面。"

#. Tag: para
#: using_postgis_query.xml:78
#, no-c-format
msgid ""
"The <ulink url=\"http://en.wikipedia.org/wiki/DE-9IM\">Dimensionally "
"Extended 9-Intersection Model</ulink> (DE-9IM) describes the spatial "
"relationship between two geometries by specifying the dimensions of the 9 "
"intersections between the above sets for each geometry. The intersection "
"dimensions can be formally represented in a 3x3 <emphasis "
"role=\"bold\">intersection matrix</emphasis>."
msgstr "The <ulink url=\"http://en.wikipedia.org/wiki/DE-9IM\">Dimensionally "
"Extended 9-Intersection Model</ulink> (DE-9IM)通过指定每个几何图形的上述集合之间"
"的 9 个相交的维度来描述两个几何图形之间的空间关系。交集维度可以正式表示为 3x3 <emphasis "
"role=\"bold\">交集矩阵</emphasis>。" 

#. Tag: para
#: using_postgis_query.xml:85
#, no-c-format
msgid ""
"For a geometry <emphasis>g</emphasis> the <emphasis>Interior</emphasis>, "
"<emphasis>Boundary</emphasis>, and <emphasis>Exterior</emphasis> are denoted "
"using the notation <emphasis>I(g)</emphasis>, <emphasis>B(g)</emphasis>, and "
"<emphasis>E(g)</emphasis>. Also, <emphasis>dim(s)</emphasis> denotes the "
"dimension of a set <emphasis>s</emphasis> with the domain of <literal>{0,1,2,"
"F}</literal>:"
msgstr "对于几何图形<emphasis>g</emphasis>，<emphasis>内部</emphasis>、<emphasis>边界</emphasis>和<emphasis>外部</emphasis>"
"使用符号<emphasis>I(g)</emphasis>、<emphasis>B(g)</emphasis>和<emphasis>E(g)</emphasis>表示。 此外，<emphasis>dim(s)</emphasis> 表示域为 <literal>{0,1,2,"
"F}</literal>的集合<emphasis>s</emphasis> ："

#. Tag: para
#: using_postgis_query.xml:97
#, no-c-format
msgid "<literal>0</literal> =&gt; point"
msgstr "<literal>0</literal> =&gt; 点集合"

#. Tag: para
#: using_postgis_query.xml:101
#, no-c-format
msgid "<literal>1</literal> =&gt; line"
msgstr "<literal>1</literal> =&gt; 线集合"

#. Tag: para
#: using_postgis_query.xml:105
#, no-c-format
msgid "<literal>2</literal> =&gt; area"
msgstr "<literal>2</literal> =&gt; 面集合"

#. Tag: para
#: using_postgis_query.xml:109
#, no-c-format
msgid "<literal>F</literal> =&gt; empty set"
msgstr "<literal>F</literal> =&gt;空集合"

#. Tag: para
#: using_postgis_query.xml:114
#, no-c-format
msgid ""
"Using this notation, the intersection matrix for two geometries <emphasis>a</"
"emphasis> and <emphasis>b</emphasis> is:"
msgstr "使用此表示法，两个几何<emphasis>a</emphasis>和<emphasis>b</emphasis>的交集矩阵为："

#. Tag: emphasis
#: using_postgis_query.xml:123 using_postgis_query.xml:131
#: using_postgis_query.xml:182 using_postgis_query.xml:195
#, no-c-format
msgid "<emphasis role=\"bold\">Interior</emphasis>"
msgstr "<emphasis role=\"bold\">内部（Interior）</emphasis>"

#. Tag: emphasis
#: using_postgis_query.xml:124 using_postgis_query.xml:137
#: using_postgis_query.xml:185 using_postgis_query.xml:218
#, no-c-format
msgid "<emphasis role=\"bold\">Boundary</emphasis>"
msgstr "<emphasis role=\"bold\">边界（Boundary）</emphasis>"

#. Tag: emphasis
#: using_postgis_query.xml:125 using_postgis_query.xml:143
#: using_postgis_query.xml:188 using_postgis_query.xml:241
#, no-c-format
msgid "<emphasis role=\"bold\">Exterior</emphasis>"
msgstr "<emphasis role=\"bold\">外部（Exterior）</emphasis>"

#. Tag: emphasis
#: using_postgis_query.xml:132
#, no-c-format
msgid "dim( I(a) ∩ I(b) )"
msgstr "dim( I(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_query.xml:133
#, no-c-format
msgid "dim( I(a) ∩ B(b) )"
msgstr "dim( I(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_query.xml:134
#, no-c-format
msgid "dim( I(a) ∩ E(b) )"
msgstr "dim( I(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_query.xml:138
#, no-c-format
msgid "dim( B(a) ∩ I(b) )"
msgstr "dim( B(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_query.xml:139
#, no-c-format
msgid "dim( B(a) ∩ B(b) )"
msgstr "dim( B(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_query.xml:140
#, no-c-format
msgid "dim( B(a) ∩ E(b) )"
msgstr "dim( B(a) ∩ E(b) )"

#. Tag: emphasis
#: using_postgis_query.xml:144
#, no-c-format
msgid "dim( E(a) ∩ I(b) )"
msgstr "dim( E(a) ∩ I(b) )"

#. Tag: emphasis
#: using_postgis_query.xml:145
#, no-c-format
msgid "dim( E(a) ∩ B(b) )"
msgstr "dim( E(a) ∩ B(b) )"

#. Tag: emphasis
#: using_postgis_query.xml:146
#, no-c-format
msgid "dim( E(a) ∩ E(b) )"
msgstr "dim( E(a) ∩ E(b) )"

#. Tag: para
#: using_postgis_query.xml:153
#, no-c-format
msgid "Visually, for two overlapping polygonal geometries, this looks like:"
msgstr "从视觉上看，对于两个重叠的多边形几何图形，如下所示："

#. Tag: para
#: using_postgis_query.xml:199
#, no-c-format
msgid ""
"<emphasis>dim( I(a) ∩ I(b) ) = </emphasis><emphasis role=\"bold\">2</"
"emphasis>"
msgstr ""
"<emphasis>dim( I(a) ∩ I(b) ) = </emphasis><emphasis role=\"bold\">2</"
"emphasis>"
#. Tag: para
#: using_postgis_query.xml:205
#, no-c-format
msgid ""
"<emphasis>dim( I(a) ∩ B(b) = </emphasis><emphasis role=\"bold\">1</emphasis>"
msgstr ""
"<emphasis>dim( I(a) ∩ B(b) = </emphasis><emphasis role=\"bold\">1</emphasis>"
#. Tag: para
#: using_postgis_query.xml:211
#, no-c-format
msgid ""
"<emphasis>dim( I(a) ∩ E(b) ) = </emphasis><emphasis role=\"bold\">2</"
"emphasis>"
msgstr ""
"<emphasis>dim( I(a) ∩ E(b) ) = </emphasis><emphasis role=\"bold\">2</"
"emphasis>"
#. Tag: para
#: using_postgis_query.xml:222
#, no-c-format
msgid ""
"<emphasis>dim( B(a) ∩ I(b) ) = </emphasis><emphasis role=\"bold\">1</"
"emphasis>"
msgstr ""
"<emphasis>dim( B(a) ∩ I(b) ) = </emphasis><emphasis role=\"bold\">1</"
"emphasis>"
#. Tag: para
#: using_postgis_query.xml:228
#, no-c-format
msgid ""
"<emphasis>dim( B(a) ∩ B(b) ) = </emphasis><emphasis role=\"bold\">0</"
"emphasis>"
msgstr ""
"<emphasis>dim( B(a) ∩ B(b) ) = </emphasis><emphasis role=\"bold\">0</"
"emphasis>"
#. Tag: para
#: using_postgis_query.xml:234
#, no-c-format
msgid ""
"<emphasis>dim( B(a) ∩ E(b) ) = </emphasis><emphasis role=\"bold\">1</"
"emphasis>"
msgstr ""
"<emphasis>dim( B(a) ∩ E(b) ) = </emphasis><emphasis role=\"bold\">1</"
"emphasis>"
#. Tag: para
#: using_postgis_query.xml:245
#, no-c-format
msgid ""
"<emphasis>dim( E(a) ∩ I(b) ) = </emphasis><emphasis role=\"bold\">2</"
"emphasis>"
msgstr ""
"<emphasis>dim( E(a) ∩ I(b) ) = </emphasis><emphasis role=\"bold\">2</"
"emphasis>"
#. Tag: para
#: using_postgis_query.xml:251
#, no-c-format
msgid ""
"<emphasis>dim( E(a) ∩ B(b) ) = </emphasis><emphasis role=\"bold\">1</"
"emphasis>"
msgstr ""
"<emphasis>dim( E(a) ∩ B(b) ) = </emphasis><emphasis role=\"bold\">1</"
"emphasis>"
#. Tag: para
#: using_postgis_query.xml:257
#, no-c-format
msgid ""
"<emphasis>dim( E(a) ∩ E(b) = </emphasis><emphasis role=\"bold\">2</emphasis>"
msgstr ""
"<emphasis>dim( E(a) ∩ E(b) = </emphasis><emphasis role=\"bold\">2</emphasis>"
#. Tag: para
#: using_postgis_query.xml:269
#, no-c-format
msgid ""
"Reading from left to right and top to bottom, the intersection matrix is "
"represented as the text string '<emphasis role=\"bold\">212101212</"
"emphasis>'."
msgstr "从左到右，从上到下阅读。交集矩阵的字符串表示形式为“<emphasis role=\"bold\">212101212</"
"emphasis>”。"

#. Tag: para
#: using_postgis_query.xml:272
#, no-c-format
msgid "For more information, refer to:"
msgstr "欲了解更多信息，请访问："

#. Tag: para
#: using_postgis_query.xml:276
#, no-c-format
msgid ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">OpenGIS Simple "
"Features Implementation Specification for SQL</ulink> (version 1.1, section "
"2.1.13.2)"
msgstr ""
"<ulink url=\"http://www.opengeospatial.org/standards/sfs\">适用于 SQL 的 OpenGIS 简单功能实现规范</ulink> (1.1版本, 第 2.1.13.2 节)。"
#. Tag: ulink
#: using_postgis_query.xml:281
#, no-c-format
msgid "Wikipedia: Dimensionally Extended Nine-Intersection Model (DE-9IM)"
msgstr "维基百科：维度扩展九交集模型 （DE-9IM）"

#. Tag: ulink
#: using_postgis_query.xml:285
#, no-c-format
msgid "GeoTools: Point Set Theory and the DE-9IM Matrix"
msgstr "地理工具：点集理论和DE-9IM矩阵"

#. Tag: title
#: using_postgis_query.xml:292
#, no-c-format
msgid "Named Spatial Relationships"
msgstr "命名空间关系"

#. Tag: para
#: using_postgis_query.xml:294
#, no-c-format
msgid ""
"To make it easy to determine common spatial relationships, the OGC SFS "
"defines a set of <emphasis>named spatial relationship predicates</emphasis>. "
"PostGIS provides these as the functions <xref linkend=\"ST_Contains\"/>, "
"<xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Disjoint\"/>, <xref "
"linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Intersects\"/>, <xref "
"linkend=\"ST_Overlaps\"/>, <xref linkend=\"ST_Touches\"/>, <xref "
"linkend=\"ST_Within\"/>. It also defines the non-standard relationship "
"predicates <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, "
"and <xref linkend=\"ST_ContainsProperly\"/>."
msgstr "为了便于确定常见的空间关系，OGC SFS 定义了一组<emphasis>命名空间关系谓词</emphasis>。"
"PostGIS 将这些功能提供为函数 <xref linkend=\"ST_Contains\"/>, <xref linkend=\"ST_Crosses\"/>, <xref linkend=\"ST_Disjoint\"/>, <xref "
"linkend=\"ST_Equals\"/>, <xref linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref linkend=\"ST_Touches\"/>, <xref "
"linkend=\"ST_Within\"/>。 它还定义了非标准关系谓词 <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_CoveredBy\"/>, "
"和<xref linkend=\"ST_ContainsProperly\"/>。"

#. Tag: para
#: using_postgis_query.xml:305
#, no-c-format
msgid ""
"Spatial predicates are usually used as conditions in SQL <code>WHERE</code> "
"or <code>JOIN</code> clauses. The named spatial predicates automatically use "
"a spatial index if one is available, so there is no need to use the bounding "
"box operator <code>&amp;&amp;</code> as well. For example:"
msgstr "空间谓词通常用作 SQL <code>WHERE</code>或<code>JOIN</code>子句中的条件。"
"如果空间索引可用，命名空间谓词会自动使用空间索引，因此无需使用边界框运算符<code>&amp;&amp;</code>。例如："

#. Tag: para
#: using_postgis_query.xml:313
#, no-c-format
msgid ""
"For more details and illustrations, see the <ulink url=\"https://postgis.net/"
"workshops/postgis-intro/spatial_relationships.html\">PostGIS Workshop.</"
"ulink>"
msgstr "有关更多详细信息和插图，请参阅<ulink url=\"https://postgis.net/"
"workshops/postgis-intro/spatial_relationships.html\">PostGIS Workshop.</"
"ulink>。"

#. Tag: title
#: using_postgis_query.xml:319
#, no-c-format
msgid "General Spatial Relationships"
msgstr "一般空间关系"

#. Tag: para
#: using_postgis_query.xml:321
#, no-c-format
msgid ""
"In some cases the named spatial relationships are insufficient to provide a "
"desired spatial filter condition."
msgstr "在某些情况下，指定的空间关系不足以提供所需的空间过滤条件。"

#. Tag: para
#: using_postgis_query.xml:331
#, no-c-format
msgid ""
"For example, consider a linear dataset representing a road network. It may "
"be required to identify all road segments that cross each other, not at a "
"point, but in a line (perhaps to validate some business rule). In this case "
"<xref linkend=\"ST_Crosses\"/> does not provide the necessary spatial "
"filter, since for linear features it returns <varname>true</varname> only "
"where they cross at a point."
msgstr "例如，考虑表示道路网络的线性数据集。 可能需要识别所有相互交叉的路段，不是在一个点，"
"而是在一条线上（也许是为了验证某些业务规则）。 在这种情况下，<xref linkend=\"ST_Crosses\"/>"
"不提供必要的空间过滤器，因为对于线性要素，它仅在它们在某个点交叉的地方返回<varname>true</varname>。"

#. Tag: para
#: using_postgis_query.xml:339
#, no-c-format
msgid ""
"A two-step solution would be to first compute the actual intersection (<xref "
"linkend=\"ST_Intersection\"/>) of pairs of road lines that spatially "
"intersect (<xref linkend=\"ST_Intersects\"/>), and then check if the "
"intersection's <xref linkend=\"ST_GeometryType\"/> is '<varname>LINESTRING</"
"varname>' (properly dealing with cases that return "
"<varname>GEOMETRYCOLLECTION</varname>s of <varname>[MULTI]POINT</varname>s, "
"<varname>[MULTI]LINESTRING</varname>s, etc.)."
msgstr "两步解决方案是首先计算空间相交 (<xref linkend=\"ST_Intersection\"/>)"
"的道路线对的实际交叉点 (<xref linkend=\"ST_Intersects\"/>)，然后检查交叉点的 "
"<xref linkend=\"ST_GeometryType\"/> 是否为“<varname>LINESTRING</varname>”"
"（正确处理返回 <varname>GEOMETRYCOLLECTION</varname>s、<varname>[MULTI]POINT</varname>s、<varname>[MULTI]LINESTRING</varname>s等情况）。"

#. Tag: para
#: using_postgis_query.xml:348
#, no-c-format
msgid "Clearly, a simpler and faster solution is desirable."
msgstr "显然，更简单、更快捷的解决方案更可取。"

#. Tag: para
#: using_postgis_query.xml:360
#, no-c-format
msgid ""
"A second example is locating wharves that intersect a lake's boundary on a "
"line and where one end of the wharf is up on shore. In other words, where a "
"wharf is within but not completely contained by a lake, intersects the "
"boundary of a lake on a line, and where exactly one of the wharf's endpoints "
"is within or on the boundary of the lake. It is possible to use a "
"combination of spatial predicates to find the required features:"
msgstr "第二个例子是定位与湖泊边界相交的码头，并且码头的一端位于岸上。"
"换句话说，如果码头位于湖泊内但未完全被湖泊包围，则与湖泊边界相交于一条线，"
"并且码头的端点之一恰好位于湖泊边界内或湖泊边界上。 可以使用空间谓词的组合来查找所需的特征："

#. Tag: para
#: using_postgis_query.xml:371
#, no-c-format
msgid "(lake, wharf) = TRUE"
msgstr "(lake, wharf) = TRUE"

#. Tag: para
#: using_postgis_query.xml:375
#, no-c-format
msgid "(lake, wharf) = FALSE"
msgstr "(lake, wharf) = FALSE"

#. Tag: para
#: using_postgis_query.xml:379
#, no-c-format
msgid "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"
msgstr "(<xref linkend=\"ST_Intersection\"/>(wharf, lake)) = 'LINESTRING'"

#. Tag: para
#: using_postgis_query.xml:384
#, no-c-format
msgid ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"
msgstr ""
"(<xref linkend=\"ST_Multi\"/>(<xref linkend=\"ST_Intersection\"/>(<xref "
"linkend=\"ST_Boundary\"/>(wharf), <xref linkend=\"ST_Boundary\"/>(lake)))) = "
"1"
#. Tag: para
#: using_postgis_query.xml:387
#, no-c-format
msgid "... but needless to say, this is quite complicated."
msgstr "... 不用说，这非常复杂。"

#. Tag: para
#: using_postgis_query.xml:395
#, no-c-format
msgid ""
"These requirements can be met by computing the full DE-9IM intersection "
"matrix. PostGIS provides the <xref linkend=\"ST_Relate\"/> function to do "
"this:"
msgstr "这些要求可以通过计算完整的 DE-9IM 交集矩阵来满足。PostGIS 提供了<xref linkend=\"ST_Relate\"/> 函数来执行此操作："

#. Tag: para
#: using_postgis_query.xml:402
#, no-c-format
msgid ""
"To test a particular spatial relationship, an <emphasis "
"role=\"bold\">intersection matrix pattern</emphasis> is used. This is the "
"matrix representation augmented with the additional symbols <literal>{T,*}</"
"literal>:"
msgstr "为了测试特定的空间关系，使用<emphasis role=\"bold\">相交矩阵模式</emphasis>。"
"这是用附加符号<literal>{T,*}</literal>增强的矩阵表示："

#. Tag: para
#: using_postgis_query.xml:410
#, no-c-format
msgid ""
"<literal>T</literal> =&gt; intersection dimension is non-empty; i.e. is in "
"<literal>{0,1,2}</literal>"
msgstr ""
"<literal>T</literal> =&gt; 表示交集的维度不为空;即<literal>{0,1,2}</literal>"
#. Tag: para
#: using_postgis_query.xml:415
#, no-c-format
msgid "<literal>*</literal> =&gt; don't care"
msgstr "<literal>*</literal> =&gt; 任何东西"

#. Tag: para
#: using_postgis_query.xml:419
#, no-c-format
msgid ""
"Using intersection matrix patterns, specific spatial relationships can be "
"evaluated in a more succinct way. The <xref linkend=\"ST_Relate\"/> and the "
"<xref linkend=\"ST_RelateMatch\"/> functions can be used to test "
"intersection matrix patterns. For the first example above, the intersection "
"matrix pattern specifying two lines intersecting in a line is '<emphasis "
"role=\"bold\">1*1***1**</emphasis>':"
msgstr "使用交叉矩阵模式，可以以更简洁的方式评估特定的空间关系。<xref linkend=\"ST_Relate\"/>"
"和<xref linkend=\"ST_RelateMatch\"/> 函数可用于测试相交矩阵模式。 对于上面的第一个示例，"
"指定两条线相交的交集矩阵模式为<emphasis role=\"bold\">1*1***1**</emphasis>'："

#. Tag: para
#: using_postgis_query.xml:429
#, no-c-format
msgid ""
"For the second example, the intersection matrix pattern specifying a line "
"partly inside and partly outside a polygon is '<emphasis "
"role=\"bold\">102101FF2</emphasis>':"
msgstr "这是第二个示例。当线部分位于多边形内部和外部时，相交矩阵模式为<emphasis role=\"bold\">102101FF2</emphasis>。"

#. Tag: title
#: using_postgis_query.xml:439
#, no-c-format
msgid "Using Spatial Indexes"
msgstr "使用空间索引"

#. Tag: para
#: using_postgis_query.xml:441
#, no-c-format
msgid ""
"When constructing queries using spatial conditions, for best performance it "
"is important to ensure that a spatial index is used, if one exists (see "
"<xref linkend=\"build-indexes\"/>). To do this, a spatial operator or index-"
"aware function must be used in a <code>WHERE</code> or <code>ON</code> "
"clause of the query."
msgstr "使用空间条件构建查询时，为了获得最佳性能，确保使用空间索引（如果存在）非常重要（请参阅<xref linkend=\"build-indexes\"/>）。"
"为此，必须在查询的<code>WHERE</code>或<code>ON</code>子句中使用空间运算符或索引感知函数。"

#. Tag: para
#: using_postgis_query.xml:447
#, no-c-format
msgid ""
"Spatial operators include the bounding box operators (of which the most "
"commonly used is <xref linkend=\"geometry_overlaps\"/>; see <xref "
"linkend=\"operators-bbox\"/> for the full list) and the distance operators "
"used in nearest-neighbor queries (the most common being <xref "
"linkend=\"geometry_distance_knn\"/>; see <xref linkend=\"operators-"
"distance\"/> for the full list.)"
msgstr "空间运算符包括边界框运算符（其中最常用的是<xref linkend=\"geometry_overlaps\"/>; 有关完整列表，请参见<xref "
"linkend=\"operators-bbox\"/>）以及最近邻查询中使用的距离运算符（最常见的是<xref linkend=\"geometry_distance_knn\"/>;"
" 有关完整列表，请参见 <xref linkend=\"operators-distance\"/>)。"

#. Tag: para
#: using_postgis_query.xml:455
#, no-c-format
msgid ""
"Index-aware functions automatically add a bounding box operator to the "
"spatial condition. Index-aware functions include the named spatial "
"relationship predicates <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref "
"linkend=\"ST_Covers\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref "
"linkend=\"ST_Touches\"/>, <xref linkend=\"ST_Within\"/>, <xref "
"linkend=\"ST_Within\"/>, and <xref linkend=\"ST_3DIntersects\"/>, and the "
"distance predicates <xref linkend=\"ST_DWithin\"/>, <xref "
"linkend=\"ST_DFullyWithin\"/>, <xref linkend=\"ST_3DDFullyWithin\"/>, and "
"<xref linkend=\"ST_3DDWithin\"/> .)"
msgstr "索引感知函数会自动将边界框运算符添加到空间条件中。 索引感知函数包括命名空间关系谓词  <xref linkend=\"ST_Contains\"/>, <xref "
"linkend=\"ST_ContainsProperly\"/>, <xref linkend=\"ST_CoveredBy\"/>, <xref linkend=\"ST_Covers\"/>, <xref linkend=\"ST_Crosses\"/>, <xref "
"linkend=\"ST_Intersects\"/>, <xref linkend=\"ST_Overlaps\"/>, <xref linkend=\"ST_Touches\"/>, <xref linkend=\"ST_Within\"/>, <xref "
"linkend=\"ST_Within\"/>, 和<xref linkend=\"ST_3DIntersects\"/> 以及距离谓词<xref linkend=\"ST_DWithin\"/>, <xref linkend=\"ST_DFullyWithin\"/>, <xref linkend=\"ST_3DDFullyWithin\"/>, 和 "
"<xref linkend=\"ST_3DDWithin\"/>。）"

#. Tag: para
#: using_postgis_query.xml:476
#, no-c-format
msgid ""
"Functions such as <xref linkend=\"ST_Distance\"/> do <emphasis>not</"
"emphasis> use indexes to optimize their operation. For example, the "
"following query would be quite slow on a large table:"
msgstr " <xref linkend=\"ST_Distance\"/> 等函数<emphasis>不</emphasis>使用索引来优化其操作。例如，以下查询在大型表上会非常慢："

#. Tag: para
#: using_postgis_query.xml:483
#, no-c-format
msgid ""
"This query selects all the geometries in <code>geom_table</code> which are "
"within 100 units of the point (100000, 200000). It will be slow because it "
"is calculating the distance between each point in the table and the "
"specified point, ie. one <varname>ST_Distance()</varname> calculation is "
"computed for <emphasis role=\"bold\">every</emphasis> row in the table."
msgstr "此查询选择<code>geom_table</code>中距离 (100000, 200000)该点100个单位以内的所有几何图形。"
"它会很慢，因为它正在计算表中每个点与指定点之间的距离，即为表中的 <emphasis role=\"bold\">每一</emphasis>行计算一个<varname>ST_Distance()</varname>。"

#. Tag: para
#: using_postgis_query.xml:489
#, no-c-format
msgid ""
"The number of rows processed can be reduced substantially by using the index-"
"aware function <xref linkend=\"ST_DWithin\"/>:"
msgstr "通过使用索引感知函数<xref linkend=\"ST_DWithin\"/> 可以大大减少处理的行数："

#. Tag: para
#: using_postgis_query.xml:495
#, no-c-format
msgid ""
"This query selects the same geometries, but it does it in a more efficient "
"way. This is enabled by <varname>ST_DWithin()</varname> using the "
"<varname>&amp;&amp;</varname> operator internally on an expanded bounding "
"box of the query geometry. If there is a spatial index on <code>geom</code>, "
"the query planner will recognize that it can use the index to reduce the "
"number of rows scanned before calculating the distance. The spatial index "
"allows retrieving only records with geometries whose bounding boxes overlap "
"the expanded extent and hence which <emphasis>might</emphasis> be within the "
"required distance. The actual distance is then computed to confirm whether "
"to include the record in the result set."
msgstr "此查询选择相同的几何图形，但采用更有效的方法。 通过使用<varname>ST_DWithin()</varname>"
"带有查询几何图形的放大边界框的<varname>&amp;&amp;</varname>运算符，可以在内部实现。 "
"如果<code>geom</code>存在空间索引，则查询规划器知道该索引可用于在计算距离之前减少感兴趣的行数。"
"空间索引允许您仅搜索与边界框扩展范围重叠的几何，从而搜索 <emphasis>可能</emphasis>位于所需距离内的几何。 "
"然后执行实际距离计算以查看结果集中的记录是否包括在内。"

#. Tag: para
#: using_postgis_query.xml:509
#, no-c-format
msgid ""
"For more information and examples see the <ulink url=\"https://postgis.net/"
"workshops/postgis-intro/indexing.html\">PostGIS Workshop</ulink>."
msgstr "有关详细信息和示例，请参阅<ulink url=\"https://postgis.net/"
"workshops/postgis-intro/indexing.html\">PostGIS Workshop</ulink>。"

#. Tag: title
#: using_postgis_query.xml:516
#, no-c-format
msgid "Examples of Spatial SQL"
msgstr "空间SQL示例"

#. Tag: para
#: using_postgis_query.xml:518
#, no-c-format
msgid ""
"The examples in this section make use of a table of linear roads, and a "
"table of polygonal municipality boundaries. The definition of the "
"<varname>bc_roads</varname> table is:"
msgstr "本节中的示例使用线性道路表和多边形城市边界表。<varname>bc_roads</varname> 表的定义是："

#. Tag: para
#: using_postgis_query.xml:524
#, no-c-format
msgid "The definition of the <varname>bc_municipality</varname> table is:"
msgstr "<varname>bc_municipality</varname>表定义如下："

#. Tag: para
#: using_postgis_query.xml:532
#, no-c-format
msgid "What is the total length of all roads, expressed in kilometers?"
msgstr "道路的总长度是多少公里？"

#. Tag: para
#: using_postgis_query.xml:537
#, no-c-format
msgid "You can answer this question with a very simple piece of SQL:"
msgstr "这个问题可以用非常简单的SQL来回答，例如："

#. Tag: para
#: using_postgis_query.xml:546
#, no-c-format
msgid "How large is the city of Prince George, in hectares?"
msgstr "乔治王子城有多大（以公顷为单位）？"

#. Tag: para
#: using_postgis_query.xml:550
#, no-c-format
msgid ""
"This query combines an attribute condition (on the municipality name) with a "
"spatial calculation (of the polygon area):"
msgstr "此查询将空间计算（面面积）与属性条件（自治市名称）结合使用。"

#. Tag: para
#: using_postgis_query.xml:560
#, no-c-format
msgid "What is the largest municipality in the province, by area?"
msgstr "按面积计算，该省最大的直辖市是哪个？"

#. Tag: para
#: using_postgis_query.xml:565
#, no-c-format
msgid ""
"This query uses a spatial measurement as an ordering value. There are "
"several ways of approaching this problem, but the most efficient is below:"
msgstr "此查询使用空间测量作为排序值。 有多种方法可以解决此问题，但最有效的方法如下："

#. Tag: para
#: using_postgis_query.xml:571
#, no-c-format
msgid ""
"Note that in order to answer this query we have to calculate the area of "
"every polygon. If we were doing this a lot it would make sense to add an "
"area column to the table that could be indexed for performance. By ordering "
"the results in a descending direction, and them using the PostgreSQL "
"\"LIMIT\" command we can easily select just the largest value without using "
"an aggregate function like MAX()."
msgstr "请注意，为了回答这个查询，我们必须计算每个多边形的面积。 如果我们经常这样做，"
"那么向表中添加一个区域列是有意义的，可以为性能建立索引。 通过按降序对结果进行排序，"
"并使用 PostgreSQL“LIMIT”命令，我们可以轻松地仅选择最大值，而无需使用 MAX() 等聚合函数"

#. Tag: para
#: using_postgis_query.xml:583
#, no-c-format
msgid "What is the length of roads fully contained within each municipality?"
msgstr "每个城市包含的道路总长度是多少？"

#. Tag: para
#: using_postgis_query.xml:588
#, no-c-format
msgid ""
"This is an example of a \"spatial join\", which brings together data from "
"two tables (with a join) using a spatial interaction (\"contained\") as the "
"join condition (rather than the usual relational approach of joining on a "
"common key):"
msgstr "这是“空间联接”的示例，它使用空间交互（“包含”）作为联接条件（而不是在公共键上联接的通常关系方法）"
"将来自两个表（带有联接）的数据汇集在一起 :"

#. Tag: para
#: using_postgis_query.xml:596
#, no-c-format
msgid ""
"This query takes a while, because every road in the table is summarized into "
"the final result (about 250K roads for the example table). For smaller "
"datsets (several thousand records on several hundred) the response can be "
"very fast."
msgstr "此查询需要一段时间，因为表中的每条道路都会汇总到最终结果中（示例表中大约有 250K 条道路）。 对于较小的数据集（数百条记录中的数千条），响应可能非常快。"

#. Tag: para
#: using_postgis_query.xml:605
#, no-c-format
msgid "Create a new table with all the roads within the city of Prince George."
msgstr "创建一个包含乔治王子市内所有道路的新表。"

#. Tag: para
#: using_postgis_query.xml:610
#, no-c-format
msgid ""
"This is an example of an \"overlay\", which takes in two tables and outputs "
"a new table that consists of spatially clipped or cut resultants. Unlike the "
"\"spatial join\" demonstrated above, this query creates new geometries. An "
"overlay is like a turbo-charged spatial join, and is useful for more exact "
"analysis work:"
msgstr "	
这是“覆盖”的一个示例。 也就是说，我们取两个表并输出一个由空间切割结果组成的新表。 "
"与上面显示的“空间连接”不同，此查询实际上会生成新的几何图形。 "
"生成的叠加就像涡轮增压的空间耦合，对于更精确的分析工作非常有用。"

#. Tag: para
#: using_postgis_query.xml:623
#, no-c-format
msgid "What is the length in kilometers of \"Douglas St\" in Victoria?"
msgstr "维多利亚州的“道格拉斯街”有多长（公里）？"

#. Tag: para
#: using_postgis_query.xml:634
#, no-c-format
msgid "What is the largest municipality polygon that has a hole?"
msgstr "哪个市政面的孔洞最大？"

