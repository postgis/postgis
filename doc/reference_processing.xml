<?xml version="1.0" encoding="UTF-8"?>
    <sect1 id="Geometry_Processing">
    <sect1info>
        <abstract>
        <para>These functions compute geometric constructions,
        or alter geometry size or shape.
        </para>
        </abstract>
    </sect1info>

    <title>Geometry Processing</title>

        <refentry id="ST_Buffer">
            <refnamediv>
                <refname>ST_Buffer</refname>

                <refpurpose>
Computes a geometry covering all points within a given distance from a geometry.
            </refpurpose>
            </refnamediv>

            <refsynopsisdiv>
                <funcsynopsis>

                  <funcprototype>
                    <funcdef>geometry <function>ST_Buffer</function></funcdef>
                    <paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
                    <paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
                    <paramdef choice="opt"><type>text </type> <parameter>buffer_style_parameters = ''</parameter></paramdef>
                  </funcprototype>

                  <funcprototype>
                    <funcdef>geometry <function>ST_Buffer</function></funcdef>
                    <paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
                    <paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
                    <paramdef><type>integer </type> <parameter>num_seg_quarter_circle</parameter></paramdef>
                  </funcprototype>

                  <funcprototype>
                    <funcdef>geography <function>ST_Buffer</function></funcdef>
                    <paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
                    <paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
                    <paramdef choice="opt"><type>text </type> <parameter>buffer_style_parameters</parameter></paramdef>
                  </funcprototype>

                  <funcprototype>
                    <funcdef>geography <function>ST_Buffer</function></funcdef>
                    <paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
                    <paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
                    <paramdef><type>integer </type> <parameter>num_seg_quarter_circle</parameter></paramdef>
                  </funcprototype>

                </funcsynopsis>
            </refsynopsisdiv>

              <refsection>
                <title>Description</title>

                <para>Computes a a POLYGON or MULTIPOLYGON that represents all points whose distance
            from a geometry/geography is less than or equal to a given distance.
            A negative distance shrinks the geometry rather than expanding it.
            A negative distance may shrink a polygon completely, in which case POLYGON EMPTY is returned.
            For points and lines negative distances always return empty results.
            </para>
            <para>For geometry, the distance is specified in the units of the
            Spatial Reference System of the geometry.
            For geography, the distance is specified in meters.</para>

            <para>The optional third parameter controls the buffer accuracy and style.
The accuracy of circular arcs in the buffer is specified as the number of line segments
used to approximate a quarter circle (default is 8).
The buffer style can be specifed by
providing a list of blank-separated key=value pairs as follows:
<itemizedlist>
<listitem>
<para>'quad_segs=#' : number of line segments used to approximate a quarter circle (default is 8).</para>
</listitem>
<listitem>
<para>'endcap=round|flat|square' : endcap style (defaults to "round"). 'butt' is accepted as a synonym for 'flat'.</para>
</listitem>
<listitem>
<para>'join=round|mitre|bevel' : join style (defaults to "round"). 'miter' is accepted as a synonym for 'mitre'.</para>
</listitem>
<listitem>
<para>'mitre_limit=#.#' : mitre ratio limit (only affects mitered join style). 'miter_limit' is accepted as a synonym for 'mitre_limit'.</para>
</listitem>
<listitem>
<para>'side=both|left|right' : 'left' or 'right' performs a single-sided buffer on the geometry, with the buffered side relative to the direction of the line.
This is only applicable to LINESTRING geometry and does not affect POINT or POLYGON geometries. By default end caps are square.</para>
</listitem>
</itemizedlist>
                </para>

            <note><para>For geography, this is a wrapper around the geometry implementation.
            It determines a planar spatial reference system that best fits the bounding box of the geography object
            (trying UTM, Lambert Azimuthal Equal Area (LAEA) North/South pole, and finally Mercator ).
            The buffer is computed in the planar space, and then transformed back to WGS84.
            This may not produce the desired behavior if the input object is much larger than a UTM zone or crosses the dateline
            </para></note>

            <note><para>Buffer output is always a valid polygonal geometry.
            Buffer can handle invalid inputs,
            so buffering by distance 0 is sometimes used as a way of repairing invalid polygons.
            <xref linkend="ST_MakeValid" /> can also be used for this purpose.
            </para></note>

            <note><para>Buffering is sometimes used to perform a within-distance search.
            For this use case it is more efficient to use <xref linkend="ST_DWithin" />.</para></note>

            <note><para>This function ignores the Z dimension.
It always gives a 2D result even when used on a 3D geometry.</para></note>

                <para>Enhanced: 2.5.0 - ST_Buffer geometry support was enhanced to allow for side buffering specification <code>side=both|left|right</code>.</para>
                <para>Availability: 1.5 - ST_Buffer was enhanced to support different endcaps and join types. These are useful for example to convert road linestrings
                    into polygon roads with flat or square edges instead of rounded edges. Thin wrapper for geography was added.
                </para>

                <para>Performed by the GEOS module.</para>
                <para>&sfs_compliant; s2.1.1.3</para>
                <para>&sqlmm_compliant; SQL-MM 3: 5.1.17</para>

            </refsection>

              <refsection>
                <title>Examples</title>

                <informaltable>
                  <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer01.png" />
                              </imageobject>
                              <caption><para>quad_segs=8 (default)</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText('POINT(100 90)'),
 50, 'quad_segs=8');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer02.png" />
                              </imageobject>
                              <caption><para>quad_segs=2 (lame)</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText('POINT(100 90)'),
 50, 'quad_segs=2');
                </programlisting>
                        </para></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer03.png" />
                              </imageobject>
                              <caption><para>endcap=round join=round (default)</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=round join=round');
                </programlisting>
                         </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer04.png" />
                              </imageobject>
                              <caption><para>endcap=square</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=square join=round');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer05.png" />
                              </imageobject>
                              <caption><para>endcap=flat</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=flat join=round');
                </programlisting>
                          </para></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer07.png" />
                              </imageobject>
                              <caption><para>join=bevel</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=bevel');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer06.png" />
                              </imageobject>
                              <caption><para>join=mitre mitre_limit=5.0 (default mitre limit)</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=mitre mitre_limit=5.0');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer08.png" />
                              </imageobject>
                              <caption><para>join=mitre mitre_limit=1</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=mitre mitre_limit=1.0');
                </programlisting>
                          </para></entry>
                      </row>
                        <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer09.png" />
                              </imageobject>
                              <caption><para>side=left</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'side=left');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer10.png" />
                              </imageobject>
                              <caption><para>side=right</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'side=right');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer11.png" />
                              </imageobject>
                              <caption><para>side=left join=mitre</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'side=left join=mitre');
                </programlisting>
                          </para></entry>
                      </row>
                        <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer12.png" />
                              </imageobject>
                              <caption><para>right-hand-winding, polygon boundary side=left</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
ST_ForceRHR(
ST_Boundary(
 ST_GeomFromText(
'POLYGON ((50 50, 50 150, 150 150, 150 50, 50 50))'))),
 ), 20, 'side=left');
                </programlisting>
                          </para></entry>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer13.png" />
                              </imageobject>
                              <caption><para>right-hand-winding, polygon boundary side=right</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
ST_ForceRHR(
ST_Boundary(
 ST_GeomFromText(
'POLYGON ((50 50, 50 150, 150 150, 150 50, 50 50))'))
), 20,'side=right')
                </programlisting>
                </para></entry>
                </row>
                    </tbody>
                  </tgroup>
            </informaltable>

<programlisting>--A buffered point approximates a circle
-- A buffered point forcing approximation of (see diagram)
-- 2 points per quarter circle is poly with 8 sides (see diagram)
SELECT ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As promisingcircle_pcount,
ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50, 2)) As lamecircle_pcount;

promisingcircle_pcount | lamecircle_pcount
------------------------+-------------------
             33 |                9

--A lighter but lamer circle
-- only 2 points per quarter circle is an octagon
--Below is a 100 meter octagon
-- Note coordinates are in NAD 83 long lat which we transform
to Mass state plane meter and then buffer to get measurements in meters;
SELECT ST_AsText(ST_Buffer(
ST_Transform(
ST_SetSRID(ST_Point(-71.063526, 42.35785),4269), 26986)
,100,2)) As octagon;
----------------------
POLYGON((236057.59057465 900908.759918696,236028.301252769 900838.049240578,235
957.59057465 900808.759918696,235886.879896532 900838.049240578,235857.59057465
900908.759918696,235886.879896532 900979.470596815,235957.59057465 901008.759918
696,236028.301252769 900979.470596815,236057.59057465 900908.759918696))
        </programlisting>
              </refsection>

              <refsection>
                <title>See Also</title>

                <para><xref linkend="ST_Collect" />, <xref linkend="ST_DWithin" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_Transform" />, <xref linkend="ST_Union" />, <xref linkend="ST_MakeValid" /></para>
              </refsection>
        </refentry>

        <refentry id="ST_BuildArea">
          <refnamediv>
            <refname>ST_BuildArea</refname>

            <refpurpose>Creates a polygonal geometry formed by the linework of a geometry.</refpurpose>
          </refnamediv>

          <refsynopsisdiv>
            <funcsynopsis>
              <funcprototype>
                <funcdef>geometry <function>ST_BuildArea</function></funcdef>
                <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
              </funcprototype>
            </funcsynopsis>
          </refsynopsisdiv>

          <refsection>
            <title>Description</title>

            <para>Creates an areal geometry formed by the constituent linework
            of the input geometry.
            The input can be LINESTRINGS, MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS, and GeometryCollections.
            The result is a Polygon or MultiPolygon, depending on input.
            If the input linework does not form polygons, NULL is returned.
            </para>
            <para>This function assumes all inner geometries represent holes</para>

            <note>
                <para>Input linework must be correctly noded for this function to work properly</para>
            </note>

            <para>Availability: 1.1.0</para>
          </refsection>

          <refsection>
            <title>Examples</title>
            <informaltable>
                  <tgroup cols="1">
                    <tbody>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buildarea01.png" />
                              </imageobject>
                              <caption><para>These will create a donut</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>--using polygons
SELECT ST_BuildArea(ST_Collect(smallc,bigc))
FROM (SELECT
    ST_Buffer(
      ST_GeomFromText('POINT(100 90)'), 25) As smallc,
    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As bigc) As foo;
                </programlisting>

                <programlisting>--using linestrings
SELECT ST_BuildArea(ST_Collect(smallc,bigc))
FROM (SELECT
    ST_ExteriorRing(ST_Buffer(
      ST_GeomFromText('POINT(100 90)'), 25)) As smallc,
    ST_ExteriorRing(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As bigc) As foo;</programlisting>
                          </para></entry>
                    </row>
                    </tbody>
                  </tgroup>
            </informaltable>
          </refsection>

          <refsection>
            <title>See Also</title>

            <para>
            <xref linkend="ST_Node" />,
            <xref linkend="ST_MakePolygon" />,
            <xref linkend="ST_MakeValid" />,
            <xref linkend="ST_BdPolyFromText" />,
            <xref linkend="ST_BdMPolyFromText" /> (wrappers to
            this function with standard OGC interface)</para>
          </refsection>
    </refentry>

  <refentry id="ST_Centroid">
    <refnamediv>
      <refname>ST_Centroid</refname>

      <refpurpose>Returns the geometric center of a geometry.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <funcsynopsis>
          <funcprototype>
          <funcdef>geometry <function>ST_Centroid</function></funcdef>

          <paramdef><type>geometry </type>
          <parameter>g1</parameter></paramdef>
        </funcprototype>
            <funcprototype>
                <funcdef>geography <function>ST_Centroid</function></funcdef>

                <paramdef><type>geography </type>
                <parameter>g1</parameter></paramdef>
                <paramdef choice="opt"><type>boolean </type>
                <parameter>use_spheroid=true</parameter></paramdef>
    </funcprototype>

      </funcsynopsis>
    </refsynopsisdiv>

    <refsection>
      <title>Description</title>

      <para>Computes a point which is the geometric center of mass of a geometry.
      For [<varname>MULTI</varname>]<varname>POINT</varname>s,
      the centroid is the arithmetic mean of the input coordinates.
      For [<varname>MULTI</varname>]<varname>LINESTRING</varname>s,
      the centroid is computed using the weighted length of each line segment.
      For [<varname>MULTI</varname>]<varname>POLYGON</varname>s,
      the centroid is computed in terms of area.
      If an empty geometry is supplied, an empty <varname>GEOMETRYCOLLECTION</varname> is returned.
      If <varname>NULL</varname> is supplied, <varname>NULL</varname> is returned.
      If <varname>CIRCULARSTRING</varname> or <varname>COMPOUNDCURVE</varname>
      are supplied, they are converted to linestring with CurveToLine first,
      then same than for  <varname>LINESTRING</varname>
      </para>
      <para>For mixed-dimension input, the result is equal to the centroid of the component
      Geometries of highest dimension (since the lower-dimension geometries
      contribute zero "weight" to the centroid).</para>
      <para>Note that for polygonal geometries the centroid does not necessarily
      lie in the interior of the polygon.  For example, see the diagram below
      of the centroid of a C-shaped polygon.
      To construct a point guaranteed to lie in the interior
      of a polygon use <xref linkend="ST_PointOnSurface" />.
      </para>

      <para>New in 2.3.0 : supports <varname>CIRCULARSTRING</varname> and <varname>COMPOUNDCURVE</varname> (using CurveToLine)</para>

      <para>Availability: 2.4.0 support for geography was introduced.</para>

      <para>&sfs_compliant;</para>
      <para>&sqlmm_compliant; SQL-MM 3: 8.1.4, 9.5.5</para>
    </refsection>

    <refsection>
      <title>Examples</title>

      <para>In the following illustrations the green dot is
      the centroid of the source geometry.</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_centroid01.png" />
                    </imageobject>

                    <caption><para>Centroid of a
                    <varname>MULTIPOINT</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>

              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_centroid02.png" />
                    </imageobject>

                    <caption><para>Centroid of a
                    <varname>LINESTRING</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>
            </row>

            <row>
              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_centroid03.png" />
                    </imageobject>

                    <caption><para>Centroid of a
                    <varname>POLYGON</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>

              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_centroid04.png" />
                    </imageobject>

                    <caption><para>Centroid of a
                    <varname>GEOMETRYCOLLECTION</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <programlisting>SELECT ST_AsText(ST_Centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, 0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'));
                st_astext
------------------------------------------
 POINT(2.30769230769231 3.30769230769231)
(1 row)

SELECT ST_AsText(ST_centroid(g))
FROM  ST_GeomFromText('CIRCULARSTRING(0 2, -1 1,0 0, 0.5 0, 1 0, 2 1, 1 2, 0.5 2, 0 2)')  AS g ;
------------------------------------------
POINT(0.5 1)


SELECT ST_AsText(ST_centroid(g))
FROM  ST_GeomFromText('COMPOUNDCURVE(CIRCULARSTRING(0 2, -1 1,0 0),(0 0, 0.5 0, 1 0),CIRCULARSTRING( 1 0, 2 1, 1 2),(1 2, 0.5 2, 0 2))' ) AS g;
------------------------------------------
POINT(0.5 1)

</programlisting>
    </refsection>

    <refsection>
      <title>See Also</title>

      <para><xref linkend="ST_PointOnSurface" />, <xref linkend="ST_GeometricMedian" /></para>
    </refsection>
  </refentry>

    <refentry id="ST_ConcaveHull">
      <refnamediv>
        <refname>ST_ConcaveHull</refname>
        <refpurpose>Computes a possibly concave geometry that encloses all input geometry vertices</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
         <funcprototype>
            <funcdef>geometry <function>ST_ConcaveHull</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
            <paramdef><type>float </type> <parameter>target_percent</parameter></paramdef>
            <paramdef choice="opt"><type>boolean </type> <parameter>allow_holes = false</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
            <para>A concave hull of a geometry represents a possibly concave
        geometry that encloses the input geometry.
        The result is a single polygon, line or point.
        It will not contain holes unless the optional <varname>allow_holes</varname> argument is specified as true.
        </para>

        <para>One can think of a concave hull as a geometry obtained by "shrink-wrapping" a set of geometries.
        This is different to the convex hull, which is more like wrapping a rubber band around the geometries.
        It is slower to compute than the convex hull but generally has a smaller area
        and represents a more natural boundary for the input geometry.</para>

        <para>The <varname>target_percent</varname> is the percentage of area of the convex hull the solution tries to approach.
        A target_percent of 1 gives the same result as the convex hull.  A target_percent
        between 0 and 0.99 produces a result that should have a smaller area than the convex hull.
        </para>

        <note><para>The smaller the target percent, the longer it takes to process the concave hull, and the more likely to run into topological exceptions. Also the more
            floating points and number of points you accrue.  First try 0.99 which does a single pass, is usually very fast, sometimes as fast as computing the convex hull, and usually gives much better than 99% of shrink since it almost always overshoots.
            Second hope of 0.98 is slower, others get slower usually quadratically.
            To reduce precision and float points, use <xref linkend="ST_SimplifyPreserveTopology" /> or <xref linkend="ST_SnapToGrid" /> after ST_ConcaveHull. ST_SnapToGrid is a bit faster, but
            could result in invalid geometries whereas ST_SimplifyPreserveTopology almost always preserves the validity of the geometry.</para></note>

       <para>This is not an aggregate function.
        To compute the concave hull of a set of geometries, use with <xref linkend="ST_Collect" />
        or <xref linkend="ST_Union" />
        (e.g. <code>ST_ConcaveHull(ST_Collect(somepointfield), 0.80)</code>.</para>

        <note><para>For use with sets of points or linestrings use <code>ST_Collect</code>.
        Use <code>ST_Union</code> for polygons, since it may fail with invalid geometries.</para></note>

        <para>More real world examples and brief explanation of the technique are shown <ulink
        url="http://www.bostongis.com/postgis_concavehull.snippet">http://www.bostongis.com/postgis_concavehull.snippet</ulink></para>

        <para>Also check out Simon Greener's article on demonstrating ConcaveHull introduced in Oracle 11G R2. <ulink
        url="http://www.spatialdbadvisor.com/oracle_spatial_tips_tricks/172/concave-hull-geometries-in-oracle-11gr2">http://www.spatialdbadvisor.com/oracle_spatial_tips_tricks/172/concave-hull-geometries-in-oracle-11gr2</ulink>.
        The solution we get at 0.75 target percent of convex hull is similar to the shape Simon gets with  Oracle SDO_CONCAVEHULL_BOUNDARY.</para>

        <para>Performed by the GEOS module</para>

        <para>Availability: 2.0.0</para>
      </refsection>

      <refsection>
        <title>Examples</title>
<programlisting>
--Get estimate of infected area based on point observations
SELECT d.disease_type,
    ST_ConcaveHull(ST_Collect(d.pnt_geom), 0.99) As geom
    FROM disease_obs As d
    GROUP BY d.disease_type;
</programlisting>
            <informaltable>
                  <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_concavehull03.png" />
                              </imageobject>
                              <caption><para>ST_ConcaveHull of 2 polygons encased in target 100% shrink concave hull</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
-- geometries overlaid with concavehull
-- at target 100% shrink (this is the same as convex hull - since no shrink)
SELECT
    ST_ConcaveHull(
        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
            50 60, 125 100, 175 150))'),
        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
        ), 1)
     As convexhull;
                </programlisting>
                          </para></entry>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_concavehull02.png" />
                              </imageobject>
                              <caption><para>-- geometries overlaid with concavehull
                                at target 90% of convex hull area</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
-- geometries overlaid with concavehull at target 90% shrink
SELECT
    ST_ConcaveHull(
        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
            50 60, 125 100, 175 150))'),
        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
        ), 0.9)
     As target_90;
                </programlisting>
                        </para></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_concavehull04.png" />
                              </imageobject>
                              <caption><para>L Shape points overlaid with convex hull</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
-- this produces a table of 42 points that form an L shape
SELECT (ST_DumpPoints(ST_GeomFromText(
'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,
150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,
14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,
6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,
14 94,14 74,14 54,14 34,14 14)'))).geom
    INTO TABLE l_shape;

SELECT ST_ConvexHull(ST_Collect(geom))
FROM l_shape;
                </programlisting>
                          </para></entry>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_concavehull05.png" />
                              </imageobject>
                              <caption><para>ST_ConcaveHull of L points at target 99% of convex hull</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_ConcaveHull(ST_Collect(geom), 0.99)
    FROM l_shape;
                </programlisting>
                          </para></entry>
        </row>
        <row>
            <entry><para><informalfigure>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="images/st_concavehull06.png" />
                  </imageobject>
                  <caption><para>Concave Hull of L points at target 80% convex hull area</para></caption>
                </mediaobject>
              </informalfigure>
    <programlisting>
    -- Concave Hull L shape points
    -- at target 80% of convexhull
    SELECT ST_ConcaveHull(ST_Collect(geom), 0.80)
    FROM l_shape;
    </programlisting>
            </para>
            </entry>
            <entry><para>
                <informalfigure>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="images/st_concavehull07.png" />
                  </imageobject>
                  <caption><para>multilinestring overlaid with Convex hull</para></caption>
                </mediaobject>
              </informalfigure>
                <informalfigure>
                <mediaobject>
                  <imageobject>
                    <imagedata fileref="images/st_concavehull08.png" />
                  </imageobject>
                  <caption><para>multilinestring with overlaid with Concave hull
                  of linestrings at 99% target -- first hop</para></caption>
                </mediaobject>
              </informalfigure>
    <programlisting>
SELECT ST_ConcaveHull(ST_GeomFromText('MULTILINESTRING((106 164,30 112,74 70,82 112,130 94,
    130 62,122 40,156 32,162 76,172 88),
(132 178,134 148,128 136,96 128,132 108,150 130,
170 142,174 110,156 96,158 90,158 88),
(22 64,66 28,94 38,94 68,114 76,112 30,
132 10,168 18,178 34,186 52,184 74,190 100,
190 122,182 148,178 170,176 184,156 164,146 178,
132 186,92 182,56 158,36 150,62 150,76 128,88 118))'),0.99)
    </programlisting>
            </para>
            </entry>
        </row>
        </tbody>
    </tgroup>
</informaltable>
      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_ConvexHull" />, <xref linkend="ST_SimplifyPreserveTopology" />, <xref linkend="ST_SnapToGrid" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_ConvexHull">
      <refnamediv>
        <refname>ST_ConvexHull</refname>
        <refpurpose>Computes the convex hull of a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_ConvexHull</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
            <para>Computes the convex hull of a geometry.
        The convex hull is the smallest convex
        geometry that encloses all geometries in the input.</para>

        <para>One can think of the convex hull as the geometry obtained by wrapping an rubber
            band around a set of geometries.  This is different from a concave hull
            which is analogous to "shrink-wrapping" the geometries.
            A convex hull is often used to
            determine an affected area based on a set of point observations.</para>

        <para>In the general case the convex hull is a Polygon.
        The convex hull of two or more collinear points is a two-point LineString.
        The convex hull of one or more identical points is a Point.</para>

        <para>This is not an aggregate function.
        To compute the convex hull of a set of geometries, use <xref linkend="ST_Collect" />
        to aggregate them into a geometry collection
        (e.g. <code>ST_ConvexHull(ST_Collect(geom))</code>.</para>

        <para>Performed by the GEOS module</para>

        <para>&sfs_compliant; s2.1.1.3</para>
        <para>&sqlmm_compliant; SQL-MM 3: 5.1.16</para>
        <para>&Z_support;</para>
      </refsection>

      <refsection>
        <title>Examples</title>

<para>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_convexhull01.png" />
        </imageobject>
        <caption><para>Convex Hull of a MultiLinestring and a MultiPoint</para></caption>
      </mediaobject>
    </informalfigure>
    <programlisting>
SELECT ST_AsText(ST_ConvexHull(
    ST_Collect(
        ST_GeomFromText('MULTILINESTRING((100 190,10 8),(150 10, 20 30))'),
            ST_GeomFromText('MULTIPOINT(50 5, 150 30, 50 10, 10 10)')
            )) );
---st_astext--
POLYGON((50 5,10 8,10 10,100 190,150 30,150 10,50 5))
    </programlisting>
</para>

<para>Using with ST_Collect to compute the convex hulls of geometry sets.</para>

<programlisting>
--Get estimate of infected area based on point observations
SELECT d.disease_type,
    ST_ConvexHull(ST_Collect(d.geom)) As geom
    FROM disease_obs As d
    GROUP BY d.disease_type;
</programlisting>

      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_ConcaveHull" />, <xref linkend="ST_MinimumBoundingCircle" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_DelaunayTriangles">
        <refnamediv>
            <refname>ST_DelaunayTriangles</refname>

            <refpurpose>
Returns the Delaunay triangulation of the vertices of a geometry.
            </refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>
              <funcprototype>
                <funcdef>geometry <function>ST_DelaunayTriangles</function></funcdef>
                <paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
                <paramdef><type>float </type> <parameter>tolerance</parameter></paramdef>
                <paramdef><type>int4 </type> <parameter>flags</parameter></paramdef>
              </funcprototype>
            </funcsynopsis>
        </refsynopsisdiv>

          <refsection>
            <title>Description</title>

            <para>
Return the <ulink
url="http://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay
triangulation</ulink> of the vertices of the input geometry.
Output is a COLLECTION of polygons (for flags=0) or a MULTILINESTRING
(for flags=1) or TIN (for flags=2).  The tolerance, if any, is used to snap input vertices
together.
            </para>
            <para>Performed by the GEOS module.</para>
            <para>Availability: 2.1.0</para>
            <para>&Z_support;</para>
            <para>&T_support;</para>

        </refsection>
              <refsection>
        <title>2D Examples</title>
            <informaltable>
                  <tgroup cols="1">
                    <tbody>
                     <row><entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_delaunaytriangles01.png" />
                              </imageobject>
                              <caption><para>Original polygons</para></caption>
                            </mediaobject>
                          </informalfigure></para>
<programlisting>-- our original geometry --
    ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
            50 60, 125 100, 175 150))'),
        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
        )</programlisting></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_delaunaytriangles03.png" />
                              </imageobject>
                              <caption><para>ST_DelaunayTriangles of 2 polygons: delaunay triangle polygons each triangle themed in different color</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
-- geometries overlaid multilinestring triangles
SELECT
    ST_DelaunayTriangles(
        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
            50 60, 125 100, 175 150))'),
        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
        ))
     As  dtriag;
                </programlisting>
                          </para></entry></row>
                <row><entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_delaunaytriangles02.png" />
                              </imageobject>
                              <caption><para>-- delaunay triangles as multilinestring</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>SELECT
    ST_DelaunayTriangles(
        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
            50 60, 125 100, 175 150))'),
        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
        ),0.001,1)
     As  dtriag;</programlisting>
                        </para></entry>
                </row>
                <row><entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_delaunaytriangles04.png" />
                              </imageobject>
                              <caption><para>-- delaunay triangles of 45 points as 55 triangle polygons</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>-- this produces a table of 42 points that form an L shape
SELECT (ST_DumpPoints(ST_GeomFromText(
'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,
150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,
14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,
6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,
14 94,14 74,14 54,14 34,14 14)'))).geom
    INTO TABLE l_shape;
-- output as individual polygon triangles
SELECT ST_AsText((ST_Dump(geom)).geom) As wkt
FROM ( SELECT ST_DelaunayTriangles(ST_Collect(geom)) As geom
FROM l_shape) As foo;

---wkt ---
POLYGON((6 194,6 190,14 194,6 194))
POLYGON((14 194,6 190,14 174,14 194))
POLYGON((14 194,14 174,154 14,14 194))
POLYGON((154 14,14 174,14 154,154 14))
POLYGON((154 14,14 154,150 14,154 14))
POLYGON((154 14,150 14,154 6,154 14))
:
:
</programlisting>
                        </para></entry>
             </row>

        </tbody>
    </tgroup>
</informaltable>
      </refsection>
      <refsection>
            <title>3D Examples</title>
            <programlisting>-- 3D multipoint --
SELECT ST_AsText(ST_DelaunayTriangles(ST_GeomFromText(
'MULTIPOINT Z(14 14 10,
150 14 100,34 6 25, 20 10 150)'))) As wkt;

-----wkt----
GEOMETRYCOLLECTION Z (POLYGON Z ((14 14 10,20 10 150,34 6 25,14 14 10))
 ,POLYGON Z ((14 14 10,34 6 25,150 14 100,14 14 10)))</programlisting>
        </refsection>
        <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_ConstrainedDelaunayTriangles" />, <xref linkend="ST_ConcaveHull" />, <xref linkend="ST_Dump" />, <xref linkend="ST_Tesselate" />
            </para>
        </refsection>
    </refentry>

    <refentry id="ST_FilterByM">
      <refnamediv>
        <refname>ST_FilterByM</refname>
        <refpurpose>Removes vertices based on their M value</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_FilterByM</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
            <paramdef><type>double precision</type> <parameter>min</parameter></paramdef>
            <paramdef><type>double precision</type> <parameter>max = null</parameter></paramdef>
            <paramdef><type>boolean</type> <parameter>returnM = false</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Filters out vertex points based on their M-value. Returns a geometry with only
            vertex points that have a M-value larger or equal to the min value and smaller or equal to
            the max value. If max-value argument is left out only min value is considered. If fourth argument is left out the m-value
            will not be in the resulting geometry. If resulting geometry have too few vertex points left for its geometry type an empty
            geometry will be returned. In a geometry collection
            geometries without enough points will just be left out silently.</para>
        <para>This function is mainly intended to be used in conjunction with ST_SetEffectiveArea. ST_EffectiveArea sets the effective area
            of a vertex in its m-value. With ST_FilterByM it then is possible to get a simplified version of the geometry without any calculations, just by filtering</para>

        <note><para>There is a difference in what ST_SimplifyVW returns when not enough points meet the criteria compared to ST_FilterByM.
                ST_SimplifyVW returns the geometry with enough points while ST_FilterByM returns an empty geometry</para></note>
        <note><para>Note that the returned geometry might be invalid</para></note>
        <note><para>This function returns all dimensions, including the Z and M values</para></note>
        <para>Availability: 2.5.0</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>A linestring is filtered</para>
                <programlisting>
SELECT ST_AsText(ST_FilterByM(geom,30)) simplified
FROM (SELECT  ST_SetEffectiveArea('LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry) geom) As foo;
-result
         simplified
----------------------------
 LINESTRING(5 2,7 25,10 10)
                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_SetEffectiveArea" />, <xref linkend="ST_SimplifyVW" /></para>
          </refsection>
    </refentry>

    <refentry id="ST_GeneratePoints">
      <refnamediv>
        <refname>ST_GeneratePoints</refname>

        <refpurpose>Generates random points contained in a Polygon or MultiPolygon.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_GeneratePoints</function></funcdef>
            <paramdef>
                <parameter>g</parameter>
                <type>geometry</type>
            </paramdef>
            <paramdef>
                <parameter>npoints</parameter>
                <type>integer</type>
            </paramdef>
          </funcprototype>
          <funcprototype>
            <funcdef>geometry <function>ST_GeneratePoints</function></funcdef>
            <paramdef> <type>geometry</type> <parameter>g</parameter> </paramdef>
            <paramdef> <type>integer</type> <parameter>npoints</parameter> </paramdef>
            <paramdef> <type>integer</type> <parameter>seed</parameter> </paramdef>
          </funcprototype>

        </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
        <title>Description</title>

        <para>
            ST_GeneratePoints generates a given number of pseudo-random points
            which lie within the input area.
            The optional <code>seed</code> is used to regenerate a deterministic sequence of points,
            and must be greater than zero.
        </para>

        <para>Availability: 2.3.0</para>
        <para>Enhanced: 3.0.0, added seed parameter</para>
        </refsection>

        <refsection>
            <title>Examples</title>

            <informaltable>
              <tgroup cols="2">
                <tbody>
                  <row>
                    <entry>
                        <para><informalfigure>
                        <mediaobject>
                          <imageobject>
                            <imagedata fileref="images/st_generatepoints01.png" />
                          </imageobject>
                          <caption><para>Original Polygon</para></caption>
                        </mediaobject>
                        </informalfigure>
                        </para>
                    </entry>

                    <entry><para><informalfigure>
                        <mediaobject>
                          <imageobject>
                            <imagedata fileref="images/st_generatepoints02.png" />
                          </imageobject>
                          <caption><para>Generated 12 Points overlaid on top of original polygon using a random seed value 1996</para></caption>
                        </mediaobject>
                      </informalfigure>
                        <programlisting>SELECT ST_GeneratePoints(geom, 12, 1996)
FROM (
    SELECT ST_Buffer(
        ST_GeomFromText(
        'LINESTRING(50 50,150 150,150 50)'),
        10, 'endcap=round join=round') AS geom
) AS s;</programlisting>
                    </para></entry>
                  </row>
            </tbody>
            </tgroup>
        </informaltable>
        </refsection>
    </refentry>

    <refentry id="ST_GeometricMedian">
      <refnamediv>
          <refname>
              ST_GeometricMedian
          </refname>

        <refpurpose>
            Returns the geometric median of a MultiPoint.
        </refpurpose>
      </refnamediv>

    <refsynopsisdiv>
      <funcsynopsis>
        <funcprototype>
            <funcdef>geometry <function>ST_GeometricMedian</function> </funcdef>

            <paramdef> <type>geometry</type> <parameter>geom</parameter></paramdef>
            <paramdef choice="opt"><type>float8</type> <parameter>tolerance = NULL</parameter></paramdef>
            <paramdef choice="opt"><type>int</type> <parameter>max_iter = 10000</parameter></paramdef>
            <paramdef choice="opt"><type>boolean</type> <parameter>fail_if_not_converged = false</parameter></paramdef>

        </funcprototype>
      </funcsynopsis>
    </refsynopsisdiv>

    <refsection>
      <title>Description</title>

    <para>
          Computes the approximate geometric median of a MultiPoint geometry
          using the Weiszfeld algorithm.
          The geometric median is the point minimizing the sum of distances to the input points.
          It provides a centrality measure
          that is less sensitive to outlier points than the centroid (center of mass).
    </para>
    <para>
          The algorithm iterates until the distance change between
          successive iterations is less than the supplied <varname>tolerance</varname>
          parameter.  If this condition has not been met after <varname>max_iterations</varname>
          iterations, the function produces an error and exits,
          unless <varname>fail_if_not_converged</varname> is set to <code>false</code> (the default).
    </para>
    <para>
          If a <varname>tolerance</varname> argument is not provided, the tolerance value
          is calculated based on the extent of the input geometry.
    </para>
    <para>
          If present, the input point M values are interpreted as their relative weights.
    </para>
    <para>Availability: 2.3.0</para>
    <para>Enhanced: 2.5.0 Added support for M as weight of points.</para>
    <para>&Z_support;</para>
    <para>&M_support;</para>
    </refsection>
    <refsection>
      <title>Examples</title>
      <para>
          <informalfigure>
              <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/st_geometricmedian01.png" />
                    </imageobject>

                    <caption>
                        <para>
                        Comparison of the centroid (turquoise point) and geometric
                        median (red point) of a four-point MultiPoint (yellow points).
                        </para>
                    </caption>
              </mediaobject>
        </informalfigure>
      </para>
      <programlisting>
WITH test AS (
SELECT 'MULTIPOINT((0 0), (1 1), (2 2), (200 200))'::geometry geom)
SELECT
  ST_AsText(ST_Centroid(geom)) centroid,
  ST_AsText(ST_GeometricMedian(geom)) median
FROM test;
      centroid      |                 median
--------------------+----------------------------------------
 POINT(50.75 50.75) | POINT(1.9761550281255 1.9761550281255)
(1 row)
      </programlisting>
    </refsection>

    <refsection>
      <title>See Also</title>

      <para><xref linkend="ST_Centroid"/></para>
    </refsection>

    </refentry>

	<refentry id="ST_LineMerge">
		<refnamediv>
			<refname>ST_LineMerge</refname>

			<refpurpose>Return the lines formed by sewing together
			a MultiLineString.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_LineMerge</function></funcdef>
				<paramdef><type>geometry </type> <parameter>amultilinestring</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns a LineString or MultiLineString formed by joining together
			the constituent line work of a MultiLineString.
            Lines are joined at their endpoints at 2-way intersections.
            Lines are not joined across intersections of 3-way or greater degree.
            </para>

			<note><para>Only use with MultiLineString/LineStrings. If you pass a Polygon or GeometryCollection into this function, it
			returns an empty GeometryCollection</para></note>
			<para>Performed by the GEOS module.</para>
			<para>Availability: 1.1.0</para>
			<warning><para>This function will strip the M dimension.</para></warning>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText(ST_LineMerge(
'MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45 -33,-46 -32))'
		));
st_astext
--------------------------------------------------------------------------------------------------
LINESTRING(-29 -27,-30 -29.7,-36 -31,-45 -33,-46 -32)
</programlisting>
<para>If merging is not possible due to non-touching lines,
the original MultiLineString is returned.</para>
<programlisting>
SELECT ST_AsText(ST_LineMerge(
'MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45.2 -33.2,-46 -32))'
));
st_astext
----------------
MULTILINESTRING((-45.2 -33.2,-46 -32),(-29 -27,-30 -29.7,-36 -31,-45 -33))
</programlisting>
<para>Example showing Z-dimension handling.</para>
<programlisting>
SELECT ST_AsText(ST_LineMerge(
      'MULTILINESTRING((-29 -27 11,-30 -29.7 10,-36 -31 5,-45 -33 6), (-29 -27 12,-30 -29.7 5), (-45 -33 1,-46 -32 11))'
        ));
st_astext
--------------------------------------------------------------------------------------------------
LINESTRING Z (-30 -29.7 5,-29 -27 11,-30 -29.7 10,-36 -31 5,-45 -33 1,-46 -32 11)
</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Segmentize" />, <xref linkend="ST_LineSubstring" /></para>
		</refsection>
	</refentry>

    <refentry id="ST_MaximumInscribedCircle">
      <refnamediv>
        <refname>ST_MaximumInscribedCircle</refname>
        <refpurpose>Computes the largest circle that is fully contained within a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>(geometry, geometry, double precision) <function>ST_MaximumInscribedCircle</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Finds the largest circle that is fully contained within a geometry.
        Returns a record with the center point of the circle,
        a point on the geometry that is nearest to the center, and the radius of the circle. </para>

        <para>For polygonal inputs, the circle is inscribed within the external ring, using the internal rings as boundaries.
        For linear and point inputs, the circle is inscribed within the convex hull of the input, using the input as further boundaries.</para>

        <para>Availability: 3.1.0 - requires GEOS &gt;= 3.9.0.</para>

      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_MinimumBoundingCircle" /></para>
      </refsection>

      <refsection>
        <title>Examples</title>
<programlisting>SELECT radius, ST_AsText(center) AS center, ST_AsText(nearest) AS nearest
    FROM ST_MaximumInscribedCircle('POLYGON ((50 50, 150 50, 150 150, 50 150, 50 50))')

 radius |     center     |    nearest
--------+----------------+---------------
     50 | POINT(100 100) | POINT(100 50)</programlisting>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_maximuminscribedcircle01.png" />
        </imageobject>
        <caption><para>Maximum inscribed circle of a triangle polygon. Center, nearest point, and radius are returned.</para></caption>
      </mediaobject>
    </informalfigure>

    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_maximuminscribedcircle02.png" />
        </imageobject>
        <caption><para>Maximum inscribed circle of a multi-linestring. Center, nearest point, and radius are returned.</para></caption>
      </mediaobject>
    </informalfigure>

      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingRadius" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_MinimumBoundingCircle">
      <refnamediv>
        <refname>ST_MinimumBoundingCircle</refname>
        <refpurpose>Returns the smallest circle polygon that contains a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_MinimumBoundingCircle</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
            <paramdef choice="opt"><type>integer </type> <parameter>num_segs_per_qt_circ=48</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
            <para>Returns the smallest circle polygon that contains a geometry. </para>
            <note><para>The circle is approximated by a polygon with a default of 48 segments per quarter circle.  Because the polygon is an approximation of the minimum bounding circle, some points in the input geometry may not be contained within the polygon.  The approximation can be improved by increasing the number of segments, with little performance penalty.  For applications where a polygonal approximation is not suitable, ST_MinimumBoundingRadius may be used.</para></note>

            <para>It is often used with MULTI and Geometry Collections.
        Although it is not an aggregate - you can use it in conjunction
        with ST_Collect to get the minimum bounding circle of a set of geometries.
        ST_MinimumBoundingCircle(ST_Collect(somepointfield)).</para>

        <para>The ratio of the area of a polygon divided by the area of its Minimum Bounding Circle is often referred to as the Roeck test.</para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 1.4.0</para>

      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingRadius" /></para>
      </refsection>

      <refsection>
        <title>Examples</title>
<programlisting>SELECT d.disease_type,
    ST_MinimumBoundingCircle(ST_Collect(d.geom)) As geom
    FROM disease_obs As d
    GROUP BY d.disease_type;
</programlisting>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_minimumboundingcircle01.png" />
        </imageobject>
        <caption><para>Minimum bounding circle of a point and linestring.  Using 8 segs to approximate a quarter circle</para></caption>
      </mediaobject>
    </informalfigure>
<programlisting>
SELECT ST_AsText(ST_MinimumBoundingCircle(
        ST_Collect(
            ST_GeomFromText('LINESTRING(55 75,125 150)'),
                ST_Point(20, 80)), 8
                )) As wktmbc;
wktmbc
-----------
POLYGON((135.59714732062 115,134.384753327498 102.690357210921,130.79416296937 90.8537670908995,124.963360620072 79.9451031602111,117.116420743937 70.3835792560632,107.554896839789 62.5366393799277,96.6462329091006 56.70583703063,84.8096427890789 53.115246672502,72.5000000000001 51.9028526793802,60.1903572109213 53.1152466725019,48.3537670908996 56.7058370306299,37.4451031602112 62.5366393799276,27.8835792560632 70.383579256063,20.0366393799278 79.9451031602109,14.20583703063 90.8537670908993,10.615246672502 102.690357210921,9.40285267938019 115,10.6152466725019 127.309642789079,14.2058370306299 139.1462329091,20.0366393799275 150.054896839789,27.883579256063 159.616420743937,
37.4451031602108 167.463360620072,48.3537670908992 173.29416296937,60.190357210921 176.884753327498,
72.4999999999998 178.09714732062,84.8096427890786 176.884753327498,96.6462329091003 173.29416296937,107.554896839789 167.463360620072,
117.116420743937 159.616420743937,124.963360620072 150.054896839789,130.79416296937 139.146232909101,134.384753327498 127.309642789079,135.59714732062 115))
                </programlisting>
      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingRadius" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_MinimumBoundingRadius">
    <refnamediv>
        <refname>ST_MinimumBoundingRadius</refname>
        <refpurpose>Returns the center point and radius of the smallest circle that contains a geometry.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
        <funcsynopsis>
            <funcprototype>
                <funcdef>(geometry, double precision) <function>ST_MinimumBoundingRadius</function></funcdef>
                <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
    </refsynopsisdiv>

    <refsection>
        <title>Description</title>
        <para>Returns a record containing the center point and radius of the smallest circle that contains a geometry.</para>
        <para>Use in conjunction with <xref linkend="ST_Collect"/> to get the minimum bounding circle of a set of geometries.</para>
        <para>Availability - 2.3.0</para>
    </refsection>

      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingCircle" /></para>
      </refsection>

      <refsection>
        <title>Examples</title>
<programlisting>SELECT ST_AsText(center), radius FROM ST_MinimumBoundingRadius('POLYGON((26426 65078,26531 65242,26075 65136,26096 65427,26426 65078))');

                st_astext                 |      radius
------------------------------------------+------------------
 POINT(26284.8418027133 65267.1145090825) | 247.436045591407
</programlisting>
      </refsection>

    </refentry>

    <refentry id="ST_OrientedEnvelope">
        <refnamediv>
            <refname>ST_OrientedEnvelope</refname>
            <refpurpose>Returns a minimum-area rectangle containing a geometry.</refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>geometry <function>ST_OrientedEnvelope</function></funcdef>
                    <paramdef>
                        <type>geometry</type>
                        <parameter>geom</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>
            <para>
                Returns the minimum-area rotated rectangle enclosing a geometry.
                Note that more than one such rectangle may exist.
                May return a Point or LineString in the case of degenerate inputs.
            </para>
            <para>
                Availability: 2.5.0
            </para>
        </refsection>

        <refsection>
            <title>See Also</title>
            <para>
                <xref linkend="ST_Envelope" />
                <xref linkend="ST_MinimumBoundingCircle" />
            </para>
        </refsection>

        <refsection>
            <title>Examples</title>
            <programlisting>
                SELECT ST_AsText(ST_OrientedEnvelope('MULTIPOINT ((0 0), (-1 -1), (3 2))'));

                st_astext
                ------------------------------------------------
                POLYGON((3 2,2.88 2.16,-1.12 -0.84,-1 -1,3 2))
            </programlisting>

    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_orientedenvelope01.png" />
        </imageobject>
        <caption><para>Oriented envelope of a point and linestring.</para></caption>
      </mediaobject>
    </informalfigure>
<programlisting>
SELECT ST_AsText(ST_OrientedEnvelope(
        ST_Collect(
            ST_GeomFromText('LINESTRING(55 75,125 150)'),
                ST_Point(20, 80))
                )) As wktenv;
wktenv
-----------
POLYGON((19.9999999999997 79.9999999999999,33.0769230769229 60.3846153846152,138.076923076924 130.384615384616,125.000000000001 150.000000000001,19.9999999999997 79.9999999999999))
</programlisting>

        </refsection>
    </refentry>

    <refentry id="ST_OffsetCurve">
        <refnamediv>
            <refname>ST_OffsetCurve</refname>

            <refpurpose>
Returns an offset line at a given distance and side from an input line.
        </refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>

                <funcprototype>
                <funcdef>geometry <function>ST_OffsetCurve</function></funcdef>
                <paramdef><type>geometry </type> <parameter>line</parameter></paramdef>
                <paramdef><type>float </type> <parameter>signed_distance</parameter></paramdef>
                <paramdef choice="opt"><type>text </type> <parameter>style_parameters=''</parameter></paramdef>
                </funcprototype>

            </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>

            <para>
Return an offset line at a given distance and side from an input line.
All points of the returned geometries are not further than the given
distance from the input geometry.
Useful for computing parallel lines about a center line.
            </para>

            <para>
For positive distance the offset is on the left side of the input line
and retains the same direction. For a negative distance it is on the right
side and in the opposite direction.
            </para>
            <para>
Units of distance are measured in units of the spatial reference system.
            </para>
            <para>
Note that output may be a MULTILINESTRING or EMPTY for some jigsaw-shaped input geometries.
            </para>
            <para>
The optional third parameter allows specifying a list of blank-separated
key=value pairs to tweak operations as follows:
<itemizedlist>
<listitem>
<para>'quad_segs=#' : number of segments used to approximate a quarter circle (defaults to 8).</para>
</listitem>
<listitem>
<para>'join=round|mitre|bevel' : join style (defaults to "round"). 'miter' is also accepted as a synonym for 'mitre'.</para>
</listitem>
<listitem>
<para>'mitre_limit=#.#' : mitre ratio limit (only affects mitred join style). 'miter_limit' is also accepted as a synonym for 'mitre_limit'.</para>
</listitem>
</itemizedlist>
                </para>

            <para>Performed by the GEOS module.</para>
            <para>Availability: 2.0</para>
            <para>Enhanced: 2.5 - added support for GEOMETRYCOLLECTION and MULTILINESTRING</para>

            <note><para>This function ignores the Z dimension.
It always gives a 2D result even when used on a 3D geometry.</para></note>

            </refsection>

            <refsection>
            <title>Examples</title>
<para>Compute an open buffer around roads</para>
                <programlisting>
SELECT ST_Union(
 ST_OffsetCurve(f.geom,  f.width/2, 'quad_segs=4 join=round'),
 ST_OffsetCurve(f.geom, -f.width/2, 'quad_segs=4 join=round')
) as track
FROM someroadstable;

                </programlisting>
                <informaltable>
                  <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve01.png" />
                              </imageobject>
                              <caption><para>15, 'quad_segs=4 join=round' original line
and its offset 15 units.</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)'),
    15, 'quad_segs=4 join=round'));
--output --
LINESTRING(164 1,18 1,12.2597485145237 2.1418070123307,
    7.39339828220179 5.39339828220179,
    5.39339828220179 7.39339828220179,
    2.14180701233067 12.2597485145237,1 18,1 195)
                </programlisting>
                          </para></entry>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve02.png" />
                              </imageobject>
                              <caption><para>-15, 'quad_segs=4 join=round' original line
                                and its offset -15 units </para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_OffsetCurve(geom,
    -15, 'quad_segs=4 join=round')) As notsocurvy
    FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)') As geom;
-- notsocurvy --
LINESTRING(31 195,31 31,164 31)
                </programlisting>
                        </para></entry>
                      </row>
                     <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve05.png" />
                              </imageobject>
                              <caption><para>double-offset to get more curvy, note the first reverses direction, so -30 + 15 = -15</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_OffsetCurve(geom,
    -30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')) As morecurvy
    FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)') As geom;
-- morecurvy --
LINESTRING(164 31,46 31,40.2597485145236 32.1418070123307,
35.3933982822018 35.3933982822018,
32.1418070123307 40.2597485145237,31 46,31 195)
                </programlisting>
                        </para></entry>
<entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve06.png" />
                              </imageobject>
                              <caption><para>double-offset to get more curvy,combined with regular offset 15 to get parallel lines.  Overlaid with original.</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>SELECT ST_AsText(ST_Collect(
    ST_OffsetCurve(geom, 15, 'quad_segs=4 join=round'),
    ST_OffsetCurve(ST_OffsetCurve(geom,
    -30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')
    )
) As parallel_curves
    FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)') As geom;
-- parallel curves  --
MULTILINESTRING((164 1,18 1,12.2597485145237 2.1418070123307,
7.39339828220179 5.39339828220179,5.39339828220179 7.39339828220179,
2.14180701233067 12.2597485145237,1 18,1 195),
(164 31,46 31,40.2597485145236 32.1418070123307,35.3933982822018 35.3933982822018,
32.1418070123307 40.2597485145237,31 46,31 195))
                </programlisting>
                        </para></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve03.png" />
                              </imageobject>
                              <caption><para>15, 'quad_segs=4 join=bevel' shown with original line</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)'),
        15, 'quad_segs=4 join=bevel'));
-- output --
LINESTRING(164 1,18 1,7.39339828220179 5.39339828220179,
    5.39339828220179 7.39339828220179,1 18,1 195)
                </programlisting>
                         </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve04.png" />
                              </imageobject>
                              <caption><para>15,-15 collected, join=mitre mitre_limit=2.1</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_Collect(
    ST_OffsetCurve(geom, 15, 'quad_segs=4 join=mitre mitre_limit=2.2'),
    ST_OffsetCurve(geom, -15, 'quad_segs=4 join=mitre mitre_limit=2.2')
    ) )
    FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)') As geom;
-- output --
MULTILINESTRING((164 1,11.7867965644036 1,1 11.7867965644036,1 195),
    (31 195,31 31,164 31))
                </programlisting>
                          </para></entry>
                      </row>
                    </tbody>
                  </tgroup>
            </informaltable>

            </refsection>

              <refsection>
                <title>See Also</title>
                <para><xref linkend="ST_Buffer" /></para>
              </refsection>
    </refentry>

    <refentry id="ST_PointOnSurface">
      <refnamediv>
        <refname>ST_PointOnSurface</refname>
        <refpurpose>Computes a point guaranteed to lie in a polygon, or on a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_PointOnSurface</function></funcdef>

            <paramdef><type>geometry </type>
            <parameter>g1</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>Returns a <varname>POINT</varname> which is guaranteed to lie in the interior of a surface
        (POLYGON, MULTIPOLYGON, and CURVED POLYGON).
        In PostGIS this function also works on line and point geometries.
        </para>

        <para>&sfs_compliant; s3.2.14.2 // s3.2.18.2</para>
        <para>&sqlmm_compliant; SQL-MM 3: 8.1.5, 9.5.6.
         The specifications define ST_PointOnSurface for surface geometries only.
         PostGIS extends the function to support all common geometry types.
         Other databases (Oracle, DB2, ArcSDE) seem to support this function only for surfaces.
         SQL Server 2008 supports all common geometry types.</para>
        <para>&Z_support;</para>
      </refsection>

      <refsection>
        <title>Examples</title>

        <programlisting>SELECT ST_AsText(ST_PointOnSurface('POINT(0 5)'::geometry));
 st_astext
------------
 POINT(0 5)

SELECT ST_AsText(ST_PointOnSurface('LINESTRING(0 5, 0 10)'::geometry));
 st_astext
------------
 POINT(0 5)

SELECT ST_AsText(ST_PointOnSurface('POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))'::geometry));
   st_astext
----------------
 POINT(2.5 2.5)

SELECT ST_AsEWKT(ST_PointOnSurface(ST_GeomFromEWKT('LINESTRING(0 5 1, 0 0 1, 0 10 2)')));
   st_asewkt
----------------
 POINT(0 0 1)
</programlisting>
      </refsection>

      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Centroid" />, <xref linkend="ST_MaximumInscribedCircle" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_Polygonize">
        <refnamediv>
            <refname>ST_Polygonize</refname>

            <refpurpose>Computes a collection of polygons formed from the linework of a set of geometries.
            </refpurpose>
        </refnamediv>

        <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_Polygonize</function></funcdef>
            <paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
          </funcprototype>

          <funcprototype>
            <funcdef>geometry <function>ST_Polygonize</function></funcdef>
            <paramdef><type>geometry[]</type> <parameter>geom_array</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>

            <para>Creates a GeometryCollection containing the
            polygons formed by the constituent linework of a set of geometries.
            Input linework must be correctly noded for this function to work properly.</para>

            <note>
                <para>
                To ensure input is fully noded use <xref linkend="ST_Node" /> on the input geometry
                before polygonizing.
                </para>
            </note>

            <note>
                <para>GeometryCollections are often difficult to deal with with third party tools.
                Use <xref linkend="ST_Dump" /> to convert the polygonize result
                into separate polygons.</para>
            </note>
            <para>Performed by the GEOS module.</para>

            <para>Availability: 1.0.0RC1</para>
        </refsection>

        <refsection>
        <title>Examples: Polygonizing single linestrings</title>
         <programlisting>
SELECT ST_AsEWKT(ST_Polygonize(geom_4269)) As geomtextrep
FROM (SELECT geom_4269 FROM ma.suffolk_edges ORDER BY tlid LIMIT 45) As foo;

geomtextrep
-------------------------------------
 SRID=4269;GEOMETRYCOLLECTION(POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,-71.040878 42.285678)),
 POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358,-71.171794 42.354971,-71.170511 42.354855,
 -71.17112 42.354238,-71.17166 42.353675)))
(1 row)

--Use ST_Dump to dump out the polygonize geoms into individual polygons
SELECT ST_AsEWKT((ST_Dump(foofoo.polycoll)).geom) As geomtextrep
FROM (SELECT ST_Polygonize(geom_4269) As polycoll
    FROM (SELECT geom_4269 FROM ma.suffolk_edges
        ORDER BY tlid LIMIT 45) As foo) As foofoo;

geomtextrep
------------------------
 SRID=4269;POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,
-71.040878 42.285678))
 SRID=4269;POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358
,-71.171794 42.354971,-71.170511 42.354855,-71.17112 42.354238,-71.17166 42.353675))
(2 rows)

              </programlisting>
        </refsection>

        <refsection>
            <title>See Also</title>
            <para>
            <xref linkend="ST_Node" />,
            <xref linkend="ST_Dump" />
            </para>
        </refsection>
    </refentry>

    <refentry id="ST_ReducePrecision">
      <refnamediv>
        <refname>ST_ReducePrecision</refname>

        <refpurpose>Returns a valid geometry with points rounded to a grid tolerance.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_ReducePrecision</function></funcdef>

            <paramdef><type>geometry </type>
            <parameter>g</parameter></paramdef>
            <paramdef><type>float8 </type>
            <parameter>gridsize</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>Returns a valid geometry with all points rounded to the provided grid tolerance, and features below the tolerance removed.</para>

        <para>Unlike <xref linkend="ST_SnapToGrid" /> the returned geometry will be valid, with no ring self-intersections or collapsed components.</para>

		<para>
        Precision reduction can be used to:
        <itemizedlist>
            <listitem><para>
            match coordinate precision to the data accuracy
            </para></listitem>
            <listitem><para>
            reduce the number of coordinates needed to represent a geometry
            </para></listitem>
            <listitem><para>
            ensure valid geometry output to formats which use lower precision
            (e.g. text formats such as WKT, GeoJSON or KML
            when the number of output decimal places is limited).
            </para></listitem>
            <listitem><para>
            export valid geometry to systems which use lower or limited precision
            (e.g. SDE, Oracle tolerance value)
            </para></listitem>
        </itemizedlist>
		</para>

        <para>Availability: 3.1.0 - requires GEOS &gt;= 3.9.0. </para>
      </refsection>

      <refsection>
        <title>Examples</title>

        <programlisting>SELECT ST_AsText(ST_ReducePrecision('POINT(1.412 19.323)', 0.1));
    st_astext
-----------------
 POINT(1.4 19.3)

SELECT ST_AsText(ST_ReducePrecision('POINT(1.412 19.323)', 1.0));
  st_astext
-------------
 POINT(1 19)

SELECT ST_AsText(ST_ReducePrecision('POINT(1.412 19.323)', 10));
  st_astext
-------------
 POINT(0 20)
</programlisting>

<para>Precision reduction can reduce number of vertices</para>
<programlisting>SELECT ST_AsText(ST_ReducePrecision('LINESTRING (10 10, 19.6 30.1, 20 30, 20.3 30, 40 40)', 1));
  st_astext
-------------
 LINESTRING (10 10, 20 30, 40 40)
</programlisting>

<para>Precision reduction splits polygons if needed to ensure validity</para>
<programlisting>SELECT ST_AsText(ST_ReducePrecision('POLYGON ((10 10, 60 60.1, 70 30, 40 40, 50 10, 10 10))', 10));
  st_astext
-------------
 MULTIPOLYGON (((60 60, 70 30, 40 40, 60 60)), ((40 40, 50 10, 10 10, 40 40)))
</programlisting>
      </refsection>

      <refsection>
        <title>See Also</title>

        <para><xref linkend="ST_SnapToGrid" />, <xref linkend="ST_Simplify" />, <xref linkend="ST_SimplifyVW" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_SharedPaths">
      <refnamediv>
        <refname>ST_SharedPaths</refname>
        <refpurpose>Returns a collection containing paths shared by the two input linestrings/multilinestrings.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_SharedPaths</function></funcdef>
            <paramdef><type>geometry</type> <parameter>lineal1</parameter></paramdef>
            <paramdef><type>geometry</type> <parameter>lineal2</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Returns a collection containing paths shared by the two input geometries.
            Those going in the same direction are in the first element of the collection, those going in the opposite direction are in the second element.
            The paths themselves are given in the direction of the first geometry.
        </para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 2.0.0</para>
      </refsection>
      <refsection>
        <title>Examples: Finding shared paths</title>
        <informaltable>
          <tgroup cols="1">
            <tbody>
              <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_sharedpaths01.png" />
                      </imageobject>
                      <caption><para>A multilinestring and a linestring</para></caption>
                    </mediaobject>
                  </informalfigure></para>
               </entry>
              </row>
              <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_sharedpaths02.png" />
                      </imageobject>
                      <caption><para>The shared path of multilinestring and linestring overlaid with original geometries.</para></caption>
                    </mediaobject>
                  </informalfigure>
                  <programlisting>
 SELECT ST_AsText(
  ST_SharedPaths(
    ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),
       (51 150,101 150,76 175,51 150))'),
    ST_GeomFromText('LINESTRING(151 100,126 156.25,126 125,90 161, 76 175)')
    )
  ) As wkt

                                wkt
-------------------------------------------------------------
GEOMETRYCOLLECTION(MULTILINESTRING((126 156.25,126 125),
 (101 150,90 161),(90 161,76 175)),MULTILINESTRING EMPTY)
              </programlisting>
            </para>
            </entry>
        </row>
        <row>
            <entry><para>
                  <programlisting>
-- same example but linestring orientation flipped
SELECT ST_AsText(
  ST_SharedPaths(
   ST_GeomFromText('LINESTRING(76 175,90 161,126 125,126 156.25,151 100)'),
   ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),
       (51 150,101 150,76 175,51 150))')
    )
  ) As wkt

                                wkt
-------------------------------------------------------------
GEOMETRYCOLLECTION(MULTILINESTRING EMPTY,
MULTILINESTRING((76 175,90 161),(90 161,101 150),(126 125,126 156.25)))
              </programlisting>
            </para>
            </entry>
        </row>
    </tbody>
    </tgroup>
</informaltable>
     </refsection>
      <refsection>
        <title>See Also</title>
    <para>
        <xref linkend="ST_Dump" />,
        <xref linkend="ST_GeometryN" />,
        <xref linkend="ST_NumGeometries" />
    </para>
      </refsection>
    </refentry>

    <refentry id="ST_Simplify">
      <refnamediv>
        <refname>ST_Simplify</refname>
        <refpurpose>Returns a simplified version of a geometry, using
                the Douglas-Peucker algorithm.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_Simplify</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
            <paramdef><type>boolean</type> <parameter>preserveCollapsed</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Returns a "simplified" version of the given geometry using
                the Douglas-Peucker algorithm. Will actually do something only with
                (multi)lines and (multi)polygons but you can safely call it with
                any kind of geometry. Since simplification occurs on a
                object-by-object basis you can also feed a GeometryCollection to
                this function.</para>

    <para>The "preserve collapsed" flag will retain objects that would otherwise
      be too small given the tolerance. For example, a 1m long line simplified with a 10m
      tolerance. If the preserve flag is given, the line will not disappear. This flag
      is useful for rendering engines, to avoid having large numbers of very
      small objects disappear from a map leaving surprising gaps.</para>

        <note><para>Note that returned geometry might lose its
                simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
        <note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>

        <para>Availability: 1.2.2</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>A circle simplified too much becomes a triangle, medium an octagon, </para>
                <programlisting>SELECT ST_Npoints(geom) AS np_before,
       ST_NPoints(ST_Simplify(geom,0.1)) AS np01_notbadcircle,
       ST_NPoints(ST_Simplify(geom,0.5)) AS np05_notquitecircle,
       ST_NPoints(ST_Simplify(geom,1)) AS np1_octagon,
       ST_NPoints(ST_Simplify(geom,10)) AS np10_triangle,
       (ST_Simplify(geom,100) is null) AS  np100_geometrygoesaway
  FROM
    (SELECT ST_Buffer('POINT(1 3)', 10,12) As geom) AS foo;

 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_triangle | np100_geometrygoesaway
-----------+-------------------+---------------------+-------------+---------------+------------------------
        49 |                33 |                  17 |           9 |             4 | t
      </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_IsSimple" />, <xref linkend="ST_SimplifyPreserveTopology" />, Topology <xref linkend="TP_ST_Simplify"/></para>
          </refsection>
    </refentry>

    <refentry id="ST_SimplifyPreserveTopology">
      <refnamediv>
        <refname>ST_SimplifyPreserveTopology</refname>
        <refpurpose>Returns a simplified and valid version of a geometry, using
            the Douglas-Peucker algorithm.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_SimplifyPreserveTopology</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Returns a "simplified" version of the given geometry using
            the Douglas-Peucker algorithm. Will avoid creating derived
            geometries (polygons in particular) that are invalid. Will actually do something only with
                (multi)lines and (multi)polygons but you can safely call it with
                any kind of geometry. Since simplification occurs on a
                object-by-object basis you can also feed a GeometryCollection to
                this function.</para>

        <para>Performed by the GEOS module.</para>
        <para>Availability: 1.3.3</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>Same example as Simplify, but we see Preserve Topology prevents oversimplification.  The circle can at most become a square.</para>
                <programlisting>
SELECT ST_Npoints(geom) As np_before, ST_NPoints(ST_SimplifyPreserveTopology(geom,0.1)) As np01_notbadcircle, ST_NPoints(ST_SimplifyPreserveTopology(geom,0.5)) As np05_notquitecircle,
ST_NPoints(ST_SimplifyPreserveTopology(geom,1)) As np1_octagon, ST_NPoints(ST_SimplifyPreserveTopology(geom,10)) As np10_square,
ST_NPoints(ST_SimplifyPreserveTopology(geom,100)) As  np100_stillsquare
FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As geom) As foo;

--result--
 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_square | np100_stillsquare
-----------+-------------------+---------------------+-------------+---------------+-------------------
        49 |                33 |                  17 |           9 |             5 |                 5
                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_Simplify" /></para>
          </refsection>
    </refentry>

    <refentry id="ST_SimplifyVW">
      <refnamediv>
        <refname>ST_SimplifyVW</refname>
        <refpurpose>Returns a simplified version of a geometry, using the Visvalingam-Whyatt algorithm</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_SimplifyVW</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para> Returns a "simplified" version of the given geometry using the Visvalingam-Whyatt algorithm.
        Will actually do something only with (multi)lines and (multi)polygons but you can safely call it with any kind of geometry.
        Since simplification occurs on a object-by-object basis you can also feed a GeometryCollection to this function.</para>

        <note><para>Note that returned geometry might lose its
                simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
        <note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>
        <note><para>This function handles 3D and the third dimension will affect the result.</para></note>
        <para>Availability: 2.2.0</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>A LineString is simplified with a minimum area threshold of 30.</para>
                <programlisting>

select ST_AsText(ST_SimplifyVW(geom,30)) simplified
FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As foo;
-result
 simplified
------------------------------
LINESTRING(5 2,7 25,10 10)

                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_SetEffectiveArea" />, <xref linkend="ST_Simplify" />, <xref linkend="ST_SimplifyPreserveTopology" />, Topology <xref linkend="TP_ST_Simplify"/></para>
          </refsection>
    </refentry>

    <refentry id="ST_ChaikinSmoothing">
      <refnamediv>
        <refname>ST_ChaikinSmoothing</refname>
        <refpurpose>Returns a smoothed version of a geometry, using the Chaikin algorithm</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_ChaikinSmoothing</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
            <paramdef><type>integer</type> <parameter>nIterations = 1</parameter></paramdef>
            <paramdef><type>boolean</type> <parameter>preserveEndPoints = false</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para> Returns a "smoothed" version of the given geometry using the Chaikin algorithm.
        See <ulink url="http://www.idav.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html">Chaikins-Algorithm</ulink> for an explanation of the process.
        For each iteration the number of vertex points will double.
        The function puts new vertex points at 1/4 of the line before and after each point and removes the original point.
        To reduce the number of points use one of the simplification functions on the result.
        The new points gets interpolated values for all included dimensions, also z and m.</para>
        <para>Second argument, number of iterations is limited to max 5 iterations</para>
        <para>Note third argument is only valid for polygons, and will be ignored for linestrings</para>
        <para>This function handles 3D and the third dimension will affect the result.</para>
        <note><para>Note that returned geometry will get more points than the original.
                To reduce the number of points again use one of the simplification functions on the result.
                (see <xref linkend="ST_Simplify" /> and <xref linkend="ST_SimplifyVW" />)</para></note>
        <para>Availability: 2.5.0</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>A triangle is smoothed</para>
                <programlisting>
select ST_AsText(ST_ChaikinSmoothing(geom)) smoothed
FROM (SELECT  'POLYGON((0 0, 8 8, 0 16, 0 0))'::geometry geom) As foo;
┌───────────────────────────────────────────┐
│                 smoothed                  │
├───────────────────────────────────────────┤
│ POLYGON((2 2,6 6,6 10,2 14,0 12,0 4,2 2)) │
└───────────────────────────────────────────┘
                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_Simplify" />, <xref linkend="ST_SimplifyVW" /></para>
          </refsection>
    </refentry>

    <refentry id="ST_SetEffectiveArea">
      <refnamediv>
        <refname>ST_SetEffectiveArea</refname>
        <refpurpose>
            Sets the effective area for each vertex, using the Visvalingam-Whyatt algorithm.
        </refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_SetEffectiveArea</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>float</type> <parameter>threshold = 0</parameter></paramdef>
            <paramdef><type>integer</type> <parameter>set_area = 1</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>
            Sets the effective area for each vertex, using the Visvalingam-Whyatt algorithm.
            The effective area is stored as the M-value of the vertex.
            If the optional "theshold" parameter is used, a simplified geometry will be returned, containing only vertices with an effective area
            greater than or equal to the threshold value.
            </para><para>
            This function can be used for server-side simplification when a threshold is specified.  Another option is to use a threshold value of zero.
            In this case, the full geometry will be returned with effective areas as M-values, which can be used by the client to simplify very quickly.
            </para><para>
            Will actually do something only with
            (multi)lines and (multi)polygons but you can safely call it with
            any kind of geometry. Since simplification occurs on a
            object-by-object basis you can also feed a GeometryCollection to
            this function.
            </para>


        <note><para>Note that returned geometry might lose its
                simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
        <note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>
        <note><para>The output geometry will lose all previous information in the M-values</para></note>
        <note><para>This function handles 3D and the third dimension will affect the effective area</para></note>
        <para>Availability: 2.2.0</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>
                Calculating the effective area of a LineString.  Because we use a threshold value of zero, all vertices in the input geometry are returned.
            </para>
                <programlisting>

select ST_AsText(ST_SetEffectiveArea(geom)) all_pts, ST_AsText(ST_SetEffectiveArea(geom,30) ) thrshld_30
FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As foo;
-result
 all_pts | thrshld_30
-----------+-------------------+
LINESTRING M (5 2 3.40282346638529e+38,3 8 29,6 20 1.5,7 25 49.5,10 10 3.40282346638529e+38) | LINESTRING M (5 2 3.40282346638529e+38,7 25 49.5,10 10 3.40282346638529e+38)

                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_SimplifyVW" /></para>
          </refsection>
    </refentry>

    <refentry id="ST_VoronoiLines">
      <refnamediv>
        <refname>ST_VoronoiLines</refname>

        <refpurpose>Returns the boundaries of the Voronoi diagram of the vertices of a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_VoronoiLines</function></funcdef>
            <paramdef>
                <parameter>g1</parameter>
                <type>geometry</type>
            </paramdef>
            <paramdef choice="opt">
                <parameter>tolerance</parameter>
                <type>float8</type>
            </paramdef>
            <paramdef choice="opt">
                <parameter>extend_to</parameter>
                <type>geometry</type>
            </paramdef>
          </funcprototype>

        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>
            ST_VoronoiLines computes a two-dimensional <ulink url="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</ulink> from the vertices of
            the supplied geometry and returns the boundaries between cells in that diagram as a MultiLineString.
            Returns null if input geometry is null. Returns an empty geometry collection if the input geometry contains only one vertex. Returns an empty geometry collection if the extend_to envelope has zero area.
        </para>
        <para>
            Optional parameters:
            <itemizedlist>
                <listitem>
                    <para> 'tolerance' : The distance within which vertices will be considered equivalent.  Robustness of the algorithm can be improved by supplying a nonzero tolerance distance.  (default = 0.0)</para>
                </listitem>
                <listitem>
                    <para>'extend_to' : If a geometry is supplied as the "extend_to" parameter, the diagram will be extended to cover the envelope of the "extend_to" geometry, unless
                        that envelope is smaller than the default envelope (default = NULL, default envelope is boundingbox of input geometry extended by about 50% in each direction).</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 2.3.0</para>
      </refsection>

      <!-- Examples -->
      <refsection>
        <title>Examples</title>
        <informaltable>
          <tgroup cols="1">
            <tbody>
             <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_voronoi03.png" />
                      </imageobject>
                      <caption><para>Voronoi lines with tolerance of 30 units</para></caption>
                    </mediaobject>
                  </informalfigure>
                    <programlisting>SELECT ST_VoronoiLines(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g</programlisting>
<screen> -- ST_AsText output
MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 -45.7142857142858,36.8181818181818 92.2727272727273))
</screen>
                </para></entry>
              </row>
        </tbody>
        </tgroup>
        </informaltable>

      </refsection>

      <!-- Optionally add a "See Also" section -->
      <refsection>
        <title>See Also</title>

        <para>
            <xref linkend="ST_DelaunayTriangles" />,
            <xref linkend="ST_VoronoiPolygons" />,
            <xref linkend="ST_Collect" />
        </para>
      </refsection>
    </refentry>

    <refentry id="ST_VoronoiPolygons">
      <refnamediv>
        <refname>ST_VoronoiPolygons</refname>

        <refpurpose>Returns the cells of the Voronoi diagram of the vertices of a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_VoronoiPolygons</function></funcdef>
            <paramdef>
                <parameter>g1</parameter>
                <type>geometry</type>
            </paramdef>
            <paramdef choice="opt">
                <parameter>tolerance</parameter>
                <type>float8</type>
            </paramdef>
            <paramdef choice="opt">
                <parameter>extend_to</parameter>
                <type>geometry</type>
            </paramdef>
          </funcprototype>

        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>
            ST_VoronoiPolygons computes a two-dimensional <ulink url="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</ulink> from the vertices of
            the supplied geometry.  The result is a GeometryCollection of Polygons that covers an envelope larger than the extent of the input vertices.
            Returns null if input geometry is null. Returns an empty geometry collection if the input geometry contains only one vertex. Returns an empty geometry collection if the extend_to envelope has zero area.
        </para>

        <para>
            Optional parameters:
            <itemizedlist>
                <listitem>
                    <para> 'tolerance' : The distance within which vertices will be considered equivalent.  Robustness of the algorithm can be improved by supplying a nonzero tolerance distance.  (default = 0.0)</para>
                </listitem>
                <listitem>
                    <para>'extend_to' : If a geometry is supplied as the "extend_to" parameter, the diagram will be extended to cover the envelope of the "extend_to" geometry, unless
                        that envelope is smaller than the default envelope (default = NULL, default envelope is boundingbox of input geometry extended by about 50% in each direction).
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 2.3.0</para>
      </refsection>

      <!-- Examples -->
      <refsection>
        <title>Examples</title>
        <informaltable>
          <tgroup cols="1">
            <tbody>
              <row>
                <entry>
                    <para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_voronoi01.png" />
                      </imageobject>
                      <caption><para>Points overlaid on top of Voronoi diagram</para></caption>
                    </mediaobject>
                    </informalfigure>
                    <programlisting>SELECT
    ST_VoronoiPolygons(geom) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g;</programlisting>
<screen> -- ST_AsText output
GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 43.3333333333333)),
POLYGON((55 -90,-110 -90,-110 43.3333333333333,36.8181818181818 92.2727272727273,55 79.2857142857143,55 -90)),
POLYGON((230 47.5,230 -20.7142857142857,55 79.2857142857143,36.8181818181818 92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 -20.7142857142857,230 -90,55 -90,55 79.2857142857143,230 -20.7142857142857)),
POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 270)))
</screen>
                    </para>
                </entry>
            </row>
            <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_voronoi02.png" />
                      </imageobject>
                      <caption><para>Voronoi with tolerance of 30 units</para></caption>
                    </mediaobject>
                  </informalfigure>
                    <programlisting>SELECT ST_VoronoiPolygons(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g;</programlisting>
<screen> -- ST_AsText output
GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 43.3333333333333)),
POLYGON((230 47.5,230 -45.7142857142858,36.8181818181818 92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 -45.7142857142858,230 -90,-110 -90,-110 43.3333333333333,36.8181818181818 92.2727272727273,230 -45.7142857142858)),
POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 270)))
</screen>
                </para></entry>
              </row>
             <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_voronoi03.png" />
                      </imageobject>
                      <caption><para>Voronoi with tolerance of 30 units as MultiLineString</para></caption>
                    </mediaobject>
                  </informalfigure>
                    <programlisting>SELECT ST_VoronoiLines(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g</programlisting>
<screen> -- ST_AsText output
MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 -45.7142857142858,36.8181818181818 92.2727272727273))
</screen>
                </para></entry>
              </row>
        </tbody>
        </tgroup>
        </informaltable>

      </refsection>

      <!-- Optionally add a "See Also" section -->
      <refsection>
        <title>See Also</title>

        <para>
            <xref linkend="ST_DelaunayTriangles" />,
            <xref linkend="ST_VoronoiLines" />,
            <xref linkend="ST_Collect" />
        </para>
      </refsection>
    </refentry>
</sect1>
