<?xml version="1.0" encoding="UTF-8"?>
    <sect1 id="Geometry_Processing">
    <sect1info>
        <abstract>
        <para>These functions compute geometric constructions,
        or alter geometry size or shape.
        </para>
        </abstract>
    </sect1info>

    <title>Geometry Processing</title>

        <refentry id="ST_Buffer">
            <refnamediv>
                <refname>ST_Buffer</refname>

                <refpurpose>
Computes a geometry covering all points within a given distance from a geometry.
            </refpurpose>
            </refnamediv>

            <refsynopsisdiv>
                <funcsynopsis>

                  <funcprototype>
                    <funcdef>geometry <function>ST_Buffer</function></funcdef>
                    <paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
                    <paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
                    <paramdef choice="opt"><type>text </type> <parameter>buffer_style_parameters = ''</parameter></paramdef>
                  </funcprototype>

                  <funcprototype>
                    <funcdef>geometry <function>ST_Buffer</function></funcdef>
                    <paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
                    <paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
                    <paramdef><type>integer </type> <parameter>num_seg_quarter_circle</parameter></paramdef>
                  </funcprototype>

                  <funcprototype>
                    <funcdef>geography <function>ST_Buffer</function></funcdef>
                    <paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
                    <paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
                    <paramdef choice="opt"><type>text </type> <parameter>buffer_style_parameters</parameter></paramdef>
                  </funcprototype>

                  <funcprototype>
                    <funcdef>geography <function>ST_Buffer</function></funcdef>
                    <paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
                    <paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
                    <paramdef><type>integer </type> <parameter>num_seg_quarter_circle</parameter></paramdef>
                  </funcprototype>

                </funcsynopsis>
            </refsynopsisdiv>

              <refsection>
                <title>Description</title>

                <para>Computes a POLYGON or MULTIPOLYGON that represents all points whose distance
            from a geometry/geography is less than or equal to a given distance.
            A negative distance shrinks the geometry rather than expanding it.
            A negative distance may shrink a polygon completely, in which case POLYGON EMPTY is returned.
            For points and lines negative distances always return empty results.
            </para>
            <para>For geometry, the distance is specified in the units of the
            Spatial Reference System of the geometry.
            For geography, the distance is specified in meters.</para>

            <para>The optional third parameter controls the buffer accuracy and style.
The accuracy of circular arcs in the buffer is specified as the number of line segments
used to approximate a quarter circle (default is 8).
The buffer style can be specifed by
providing a list of blank-separated key=value pairs as follows:
<itemizedlist>
<listitem>
<para>'quad_segs=#' : number of line segments used to approximate a quarter circle (default is 8).</para>
</listitem>
<listitem>
<para>'endcap=round|flat|square' : endcap style (defaults to "round"). 'butt' is accepted as a synonym for 'flat'.</para>
</listitem>
<listitem>
<para>'join=round|mitre|bevel' : join style (defaults to "round"). 'miter' is accepted as a synonym for 'mitre'.</para>
</listitem>
<listitem>
<para>'mitre_limit=#.#' : mitre ratio limit (only affects mitered join style). 'miter_limit' is accepted as a synonym for 'mitre_limit'.</para>
</listitem>
<listitem>
<para>'side=both|left|right' : 'left' or 'right' performs a single-sided buffer on the geometry, with the buffered side relative to the direction of the line.
This is only applicable to LINESTRING geometry and does not affect POINT or POLYGON geometries. By default end caps are square.</para>
</listitem>
</itemizedlist>
                </para>

            <note><para>For geography, this is a wrapper around the geometry implementation.
            It determines a planar spatial reference system that best fits the bounding box of the geography object
            (trying UTM, Lambert Azimuthal Equal Area (LAEA) North/South pole, and finally Mercator ).
            The buffer is computed in the planar space, and then transformed back to WGS84.
            This may not produce the desired behavior if the input object is much larger than a UTM zone or crosses the dateline
            </para></note>

            <note><para>Buffer output is always a valid polygonal geometry.
            Buffer can handle invalid inputs,
            so buffering by distance 0 is sometimes used as a way of repairing invalid polygons.
            <xref linkend="ST_MakeValid" /> can also be used for this purpose.
            </para></note>

            <note><para>Buffering is sometimes used to perform a within-distance search.
            For this use case it is more efficient to use <xref linkend="ST_DWithin" />.</para></note>

            <note><para>This function ignores the Z dimension.
It always gives a 2D result even when used on a 3D geometry.</para></note>

                <para>Enhanced: 2.5.0 - ST_Buffer geometry support was enhanced to allow for side buffering specification <code>side=both|left|right</code>.</para>
                <para>Availability: 1.5 - ST_Buffer was enhanced to support different endcaps and join types. These are useful for example to convert road linestrings
                    into polygon roads with flat or square edges instead of rounded edges. Thin wrapper for geography was added.
                </para>

                <para>Performed by the GEOS module.</para>
                <para>&sfs_compliant; s2.1.1.3</para>
                <para>&sqlmm_compliant; SQL-MM IEC 13249-3: 5.1.30</para>
            </refsection>

              <refsection>
                <title>Examples</title>

                <informaltable>
                  <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer01.png" />
                              </imageobject>
                              <caption><para>quad_segs=8 (default)</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText('POINT(100 90)'),
 50, 'quad_segs=8');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer02.png" />
                              </imageobject>
                              <caption><para>quad_segs=2 (lame)</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText('POINT(100 90)'),
 50, 'quad_segs=2');
                </programlisting>
                        </para></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer03.png" />
                              </imageobject>
                              <caption><para>endcap=round join=round (default)</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=round join=round');
                </programlisting>
                         </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer04.png" />
                              </imageobject>
                              <caption><para>endcap=square</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=square join=round');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer05.png" />
                              </imageobject>
                              <caption><para>endcap=flat</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=flat join=round');
                </programlisting>
                          </para></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer07.png" />
                              </imageobject>
                              <caption><para>join=bevel</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=bevel');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer06.png" />
                              </imageobject>
                              <caption><para>join=mitre mitre_limit=5.0 (default mitre limit)</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=mitre mitre_limit=5.0');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer08.png" />
                              </imageobject>
                              <caption><para>join=mitre mitre_limit=1</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=mitre mitre_limit=1.0');
                </programlisting>
                          </para></entry>
                      </row>
                        <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer09.png" />
                              </imageobject>
                              <caption><para>side=left</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'side=left');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer10.png" />
                              </imageobject>
                              <caption><para>side=right</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'side=right');
                </programlisting>
                          </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer11.png" />
                              </imageobject>
                              <caption><para>side=left join=mitre</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'side=left join=mitre');
                </programlisting>
                          </para></entry>
                      </row>
                        <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer12.png" />
                              </imageobject>
                              <caption><para>right-hand-winding, polygon boundary side=left</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
ST_ForceRHR(
ST_Boundary(
 ST_GeomFromText(
'POLYGON ((50 50, 50 150, 150 150, 150 50, 50 50))'))),
 ), 20, 'side=left');
                </programlisting>
                          </para></entry>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buffer13.png" />
                              </imageobject>
                              <caption><para>right-hand-winding, polygon boundary side=right</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_Buffer(
ST_ForceRHR(
ST_Boundary(
 ST_GeomFromText(
'POLYGON ((50 50, 50 150, 150 150, 150 50, 50 50))'))
), 20,'side=right')
                </programlisting>
                </para></entry>
                </row>
                    </tbody>
                  </tgroup>
            </informaltable>

<programlisting>--A buffered point approximates a circle
-- A buffered point forcing approximation of (see diagram)
-- 2 points per quarter circle is poly with 8 sides (see diagram)
SELECT ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As promisingcircle_pcount,
ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50, 2)) As lamecircle_pcount;

promisingcircle_pcount | lamecircle_pcount
------------------------+-------------------
             33 |                9

--A lighter but lamer circle
-- only 2 points per quarter circle is an octagon
--Below is a 100 meter octagon
-- Note coordinates are in NAD 83 long lat which we transform
to Mass state plane meter and then buffer to get measurements in meters;
SELECT ST_AsText(ST_Buffer(
ST_Transform(
ST_SetSRID(ST_Point(-71.063526, 42.35785),4269), 26986)
,100,2)) As octagon;
----------------------
POLYGON((236057.59057465 900908.759918696,236028.301252769 900838.049240578,235
957.59057465 900808.759918696,235886.879896532 900838.049240578,235857.59057465
900908.759918696,235886.879896532 900979.470596815,235957.59057465 901008.759918
696,236028.301252769 900979.470596815,236057.59057465 900908.759918696))
        </programlisting>
              </refsection>

              <refsection>
                <title>See Also</title>

                <para><xref linkend="ST_Collect" />, <xref linkend="ST_DWithin" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_Transform" />, <xref linkend="ST_Union" />, <xref linkend="ST_MakeValid" /></para>
              </refsection>
        </refentry>

        <refentry id="ST_BuildArea">
          <refnamediv>
            <refname>ST_BuildArea</refname>

            <refpurpose>Creates a polygonal geometry formed by the linework of a geometry.</refpurpose>
          </refnamediv>

          <refsynopsisdiv>
            <funcsynopsis>
              <funcprototype>
                <funcdef>geometry <function>ST_BuildArea</function></funcdef>
                <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
              </funcprototype>
            </funcsynopsis>
          </refsynopsisdiv>

          <refsection>
            <title>Description</title>

            <para>Creates an areal geometry formed by the constituent linework
            of the input geometry.
            The input can be LINESTRINGS, MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS, and GeometryCollections.
            The result is a Polygon or MultiPolygon, depending on input.
            If the input linework does not form polygons, NULL is returned.
            </para>
            <para>This function assumes all inner geometries represent holes</para>

            <note>
                <para>Input linework must be correctly noded for this function to work properly</para>
            </note>

            <para>Availability: 1.1.0</para>
          </refsection>

          <refsection>
            <title>Examples</title>
            <informaltable>
                  <tgroup cols="1">
                    <tbody>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_buildarea01.png" />
                              </imageobject>
                              <caption><para>These will create a donut</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>--using polygons
SELECT ST_BuildArea(ST_Collect(smallc,bigc))
FROM (SELECT
    ST_Buffer(
      ST_GeomFromText('POINT(100 90)'), 25) As smallc,
    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As bigc) As foo;
                </programlisting>

                <programlisting>--using linestrings
SELECT ST_BuildArea(ST_Collect(smallc,bigc))
FROM (SELECT
    ST_ExteriorRing(ST_Buffer(
      ST_GeomFromText('POINT(100 90)'), 25)) As smallc,
    ST_ExteriorRing(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As bigc) As foo;</programlisting>
                          </para></entry>
                    </row>
                    </tbody>
                  </tgroup>
            </informaltable>
          </refsection>

          <refsection>
            <title>See Also</title>

            <para>
            <xref linkend="ST_Node" />,
            <xref linkend="ST_MakePolygon" />,
            <xref linkend="ST_MakeValid" />,
            <xref linkend="ST_BdPolyFromText" />,
            <xref linkend="ST_BdMPolyFromText" /> (wrappers to
            this function with standard OGC interface)</para>
          </refsection>
    </refentry>

  <refentry id="ST_Centroid">
    <refnamediv>
      <refname>ST_Centroid</refname>

      <refpurpose>Returns the geometric center of a geometry.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
      <funcsynopsis>
          <funcprototype>
          <funcdef>geometry <function>ST_Centroid</function></funcdef>

          <paramdef><type>geometry </type>
          <parameter>g1</parameter></paramdef>
        </funcprototype>
            <funcprototype>
                <funcdef>geography <function>ST_Centroid</function></funcdef>

                <paramdef><type>geography </type>
                <parameter>g1</parameter></paramdef>
                <paramdef choice="opt"><type>boolean </type>
                <parameter>use_spheroid=true</parameter></paramdef>
    </funcprototype>

      </funcsynopsis>
    </refsynopsisdiv>

    <refsection>
      <title>Description</title>

      <para>Computes a point which is the geometric center of mass of a geometry.
      For [<varname>MULTI</varname>]<varname>POINT</varname>s,
      the centroid is the arithmetic mean of the input coordinates.
      For [<varname>MULTI</varname>]<varname>LINESTRING</varname>s,
      the centroid is computed using the weighted length of each line segment.
      For [<varname>MULTI</varname>]<varname>POLYGON</varname>s,
      the centroid is computed in terms of area.
      If an empty geometry is supplied, an empty <varname>GEOMETRYCOLLECTION</varname> is returned.
      If <varname>NULL</varname> is supplied, <varname>NULL</varname> is returned.
      If <varname>CIRCULARSTRING</varname> or <varname>COMPOUNDCURVE</varname>
      are supplied, they are converted to linestring with CurveToLine first,
      then same than for  <varname>LINESTRING</varname>
      </para>
      <para>For mixed-dimension input, the result is equal to the centroid of the component
      Geometries of highest dimension (since the lower-dimension geometries
      contribute zero "weight" to the centroid).</para>
      <para>Note that for polygonal geometries the centroid does not necessarily
      lie in the interior of the polygon.  For example, see the diagram below
      of the centroid of a C-shaped polygon.
      To construct a point guaranteed to lie in the interior
      of a polygon use <xref linkend="ST_PointOnSurface" />.
      </para>

      <para>New in 2.3.0 : supports <varname>CIRCULARSTRING</varname> and <varname>COMPOUNDCURVE</varname> (using CurveToLine)</para>

      <para>Availability: 2.4.0 support for geography was introduced.</para>

      <para>&sfs_compliant;</para>
      <para>&sqlmm_compliant; SQL-MM 3: 8.1.4, 9.5.5</para>
    </refsection>

    <refsection>
      <title>Examples</title>

      <para>In the following illustrations the red dot is
      the centroid of the source geometry.</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_centroid01.png" />
                    </imageobject>

                    <caption><para>Centroid of a
                    <varname>MULTIPOINT</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>

              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_centroid02.png" />
                    </imageobject>

                    <caption><para>Centroid of a
                    <varname>LINESTRING</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>
            </row>

            <row>
              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_centroid03.png" />
                    </imageobject>

                    <caption><para>Centroid of a
                    <varname>POLYGON</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>

              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_centroid04.png" />
                    </imageobject>

                    <caption><para>Centroid of a
                    <varname>GEOMETRYCOLLECTION</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <programlisting>SELECT ST_AsText(ST_Centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, 0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'));
                st_astext
------------------------------------------
 POINT(2.30769230769231 3.30769230769231)
(1 row)

SELECT ST_AsText(ST_centroid(g))
FROM  ST_GeomFromText('CIRCULARSTRING(0 2, -1 1,0 0, 0.5 0, 1 0, 2 1, 1 2, 0.5 2, 0 2)')  AS g ;
------------------------------------------
POINT(0.5 1)


SELECT ST_AsText(ST_centroid(g))
FROM  ST_GeomFromText('COMPOUNDCURVE(CIRCULARSTRING(0 2, -1 1,0 0),(0 0, 0.5 0, 1 0),CIRCULARSTRING( 1 0, 2 1, 1 2),(1 2, 0.5 2, 0 2))' ) AS g;
------------------------------------------
POINT(0.5 1)

</programlisting>
    </refsection>

    <refsection>
      <title>See Also</title>

      <para><xref linkend="ST_PointOnSurface" />, <xref linkend="ST_GeometricMedian" /></para>
    </refsection>
  </refentry>

    <refentry id="ST_ChaikinSmoothing">
      <refnamediv>
        <refname>ST_ChaikinSmoothing</refname>
        <refpurpose>Returns a smoothed version of a geometry, using the Chaikin algorithm</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_ChaikinSmoothing</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
            <paramdef><type>integer</type> <parameter>nIterations = 1</parameter></paramdef>
            <paramdef><type>boolean</type> <parameter>preserveEndPoints = false</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para> Returns a "smoothed" version of the given geometry using the Chaikin algorithm.
        See <ulink url="http://www.idav.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html">Chaikins-Algorithm</ulink> for an explanation of the process.
        For each iteration the number of vertex points will double.
        The function puts new vertex points at 1/4 of the line before and after each point and removes the original point.
        To reduce the number of points use one of the simplification functions on the result.
        The new points gets interpolated values for all included dimensions, also z and m.</para>
        <para>Second argument, number of iterations is limited to max 5 iterations</para>
        <para>Note third argument is only valid for polygons, and will be ignored for linestrings</para>
        <para>This function handles 3D and the third dimension will affect the result.</para>
        <note><para>Note that returned geometry will get more points than the original.
                To reduce the number of points again use one of the simplification functions on the result.
                (see <xref linkend="ST_Simplify" /> and <xref linkend="ST_SimplifyVW" />)</para></note>
        <para>Availability: 2.5.0</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>A triangle is smoothed</para>
                <programlisting>
select ST_AsText(ST_ChaikinSmoothing(geom)) smoothed
FROM (SELECT  'POLYGON((0 0, 8 8, 0 16, 0 0))'::geometry geom) As foo;
┌───────────────────────────────────────────┐
│                 smoothed                  │
├───────────────────────────────────────────┤
│ POLYGON((2 2,6 6,6 10,2 14,0 12,0 4,2 2)) │
└───────────────────────────────────────────┘
                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_Simplify" />, <xref linkend="ST_SimplifyVW" /></para>
          </refsection>
    </refentry>


    <refentry id="ST_ConcaveHull">
      <refnamediv>
        <refname>ST_ConcaveHull</refname>
        <refpurpose>Computes a possibly concave geometry that encloses all input geometry vertices</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
         <funcprototype>
            <funcdef>geometry <function>ST_ConcaveHull</function></funcdef>
            <paramdef><type>geometry </type> <parameter>param_geom</parameter></paramdef>
            <paramdef><type>float </type> <parameter>param_pctconvex</parameter></paramdef>
            <paramdef choice="opt"><type>boolean </type> <parameter>param_allow_holes = false</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>A concave hull of a geometry is a possibly concave
        geometry that encloses the vertices of the input geometry.
        In the general case the concave hull is a Polygon.
        The polygon will not contain holes unless the optional <varname>param_allow_holes</varname>
        argument is specified as true.
        The concave hull of two or more collinear points is a two-point LineString.
        The concave hull of one or more identical points is a Point.
        </para>

        <para>One can think of a concave hull as "shrink-wrapping" a set of points.
        This is different to the <link linkend="ST_ConvexHull">convex hull</link>,
        which is more like wrapping a rubber band around the points.
        The concave hull generally has a smaller area
        and represents a more natural boundary for the input points.
        Like the convex hull, the vertices of a concave hull are a subset of the input points,
        and all other input points are contained within it.</para>

        <para>The <varname>param_pctconvex</varname> controls the concaveness of the computed hull.
        A value of 1 produces the convex hull.
        A value of 0 produces a hull of maximum concaveness (but still a single polygon).
        Values between 1 and 0 produce hulls of increasing concaveness.
        Choosing a suitable value depends on the nature of the input data,
        but often values between 0.3 and 0.1 produce reasonable results.
        </para>

        <para>Technically, the <varname>param_pctconvex</varname> determines a length as a fraction of the difference between
        the longest and shortest edges in the Delaunay Triangulation of the input points.
        Edges longer than this length are "eroded" from the triangulation.
        The triangles remaining form the concave hull.
        </para>

        <para>For point and linear inputs, the hull will enclose all the points of the inputs. For polygonal inputs, the hull will enclose all the points of the input <emphasis>and also</emphasis> all the areas covered by the input. If you want a point-wise hull of a polygonal input, convert it to points first, using <xref linkend="ST_Points" />.</para>

       <para>This is not an aggregate function.
        To compute the concave hull of a set of geometries use <xref linkend="ST_Collect" />
        (e.g. <code>ST_ConcaveHull( ST_Collect( geom ), 0.80)</code>.</para>

        <para>Availability: 2.0.0</para>
        <para>Enhanced: 3.3.0, GEOS native implementation enabled for GEOS 3.11+</para>
      </refsection>

      <refsection>
        <title>Examples</title>

<para>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_concavehull01.png" />
        </imageobject>
        <caption><para>Concave Hull of a MultiPoint</para></caption>
      </mediaobject>
    </informalfigure>
    <programlisting>
SELECT ST_AsText( ST_ConcaveHull(
        'MULTIPOINT ((10 72), (53 76), (56 66), (63 58), (71 51), (81 48), (91 46), (101 45), (111 46), (121 47), (131 50), (140 55), (145 64), (144 74), (135 80), (125 83), (115 85), (105 87), (95 89), (85 91), (75 93), (65 95), (55 98), (45 102), (37 107), (29 114), (22 122), (19 132), (18 142), (21 151), (27 160), (35 167), (44 172), (54 175), (64 178), (74 180), (84 181), (94 181), (104 181), (114 181), (124 181), (134 179), (144 177), (153 173), (162 168), (171 162), (177 154), (182 145), (184 135), (139 132), (136 142), (128 149), (119 153), (109 155), (99 155), (89 155), (79 153), (69 150), (61 144), (63 134), (72 128), (82 125), (92 123), (102 121), (112 119), (122 118), (132 116), (142 113), (151 110), (161 106), (170 102), (178 96), (185 88), (189 78), (190 68), (189 58), (185 49), (179 41), (171 34), (162 29), (153 25), (143 23), (133 21), (123 19), (113 19), (102 19), (92 19), (82 19), (72 21), (62 22), (52 25), (43 29), (33 34), (25 41), (19 49), (14 58), (21 73), (31 74), (42 74), (173 134), (161 134), (150 133), (97 104), (52 117), (157 156), (94 171), (112 106), (169 73), (58 165), (149 40), (70 33), (147 157), (48 153), (140 96), (47 129), (173 55), (144 86), (159 67), (150 146), (38 136), (111 170), (124 94), (26 59), (60 41), (71 162), (41 64), (88 110), (122 34), (151 97), (157 56), (39 146), (88 33), (159 45), (47 56), (138 40), (129 165), (33 48), (106 31), (169 147), (37 122), (71 109), (163 89), (37 156), (82 170), (180 72), (29 142), (46 41), (59 155), (124 106), (157 80), (175 82), (56 50), (62 116), (113 95), (144 167))',
         0.1 ) );
---st_astext--
POLYGON ((18 142, 21 151, 27 160, 35 167, 44 172, 54 175, 64 178, 74 180, 84 181, 94 181, 104 181, 114 181, 124 181, 134 179, 144 177, 153 173, 162 168, 171 162, 177 154, 182 145, 184 135, 173 134, 161 134, 150 133, 139 132, 136 142, 128 149, 119 153, 109 155, 99 155, 89 155, 79 153, 69 150, 61 144, 63 134, 72 128, 82 125, 92 123, 102 121, 112 119, 122 118, 132 116, 142 113, 151 110, 161 106, 170 102, 178 96, 185 88, 189 78, 190 68, 189 58, 185 49, 179 41, 171 34, 162 29, 153 25, 143 23, 133 21, 123 19, 113 19, 102 19, 92 19, 82 19, 72 21, 62 22, 52 25, 43 29, 33 34, 25 41, 19 49, 14 58, 10 72, 21 73, 31 74, 42 74, 53 76, 56 66, 63 58, 71 51, 81 48, 91 46, 101 45, 111 46, 121 47, 131 50, 140 55, 145 64, 144 74, 135 80, 125 83, 115 85, 105 87, 95 89, 85 91, 75 93, 65 95, 55 98, 45 102, 37 107, 29 114, 22 122, 19 132, 18 142))
    </programlisting>
</para>

<para>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_concavehull02.png" />
        </imageobject>
        <caption><para>Concave Hull of a MultiPoint, allowing holes</para></caption>
      </mediaobject>
    </informalfigure>
    <programlisting>
SELECT ST_AsText( ST_ConcaveHull(
        'MULTIPOINT ((132 64), (114 64), (99 64), (81 64), (63 64), (57 49), (52 36), (46 20), (37 20), (26 20), (32 36), (39 55), (43 69), (50 84), (57 100), (63 118), (68 133), (74 149), (81 164), (88 180), (101 180), (112 180), (119 164), (126 149), (132 131), (139 113), (143 100), (150 84), (157 69), (163 51), (168 36), (174 20), (163 20), (150 20), (143 36), (139 49), (132 64), (99 151), (92 138), (88 124), (81 109), (74 93), (70 82), (83 82), (99 82), (112 82), (126 82), (121 96), (114 109), (110 122), (103 138), (99 151), (34 27), (43 31), (48 44), (46 58), (52 73), (63 73), (61 84), (72 71), (90 69), (101 76), (123 71), (141 62), (166 27), (150 33), (159 36), (146 44), (154 53), (152 62), (146 73), (134 76), (143 82), (141 91), (130 98), (126 104), (132 113), (128 127), (117 122), (112 133), (119 144), (108 147), (119 153), (110 171), (103 164), (92 171), (86 160), (88 142), (79 140), (72 124), (83 131), (79 118), (68 113), (63 102), (68 93), (35 45))',
         0.15, true ) );
---st_astext--
POLYGON ((43 69, 50 84, 57 100, 63 118, 68 133, 74 149, 81 164, 88 180, 101 180, 112 180, 119 164, 126 149, 132 131, 139 113, 143 100, 150 84, 157 69, 163 51, 168 36, 174 20, 163 20, 150 20, 143 36, 139 49, 132 64, 114 64, 99 64, 81 64, 63 64, 57 49, 52 36, 46 20, 37 20, 26 20, 32 36, 35 45, 39 55, 43 69), (88 124, 81 109, 74 93, 83 82, 99 82, 112 82, 121 96, 114 109, 110 122, 103 138, 92 138, 88 124))
    </programlisting>
</para>

<para>Using with ST_Collect to compute the concave hull of a geometry set.</para>

<programlisting>
-- Compute estimate of infected area based on point observations
SELECT disease_type,
    ST_ConcaveHull( ST_Collect(obs_pnt), 0.3 ) AS geom
  FROM disease_obs
  GROUP BY disease_type;
</programlisting>
      </refsection>

      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_ConvexHull" />, <xref linkend="ST_Collect" />, <xref linkend="ST_AlphaShape" />, <xref linkend="ST_OptimalAlphaShape" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_ConvexHull">
      <refnamediv>
        <refname>ST_ConvexHull</refname>
        <refpurpose>Computes the convex hull of a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_ConvexHull</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
            <para>Computes the convex hull of a geometry.
        The convex hull is the smallest convex
        geometry that encloses all geometries in the input.</para>

        <para>One can think of the convex hull as the geometry obtained by wrapping an rubber
            band around a set of geometries.  This is different from a
            <link linkend="ST_ConcaveHull">concave hull</link>
            which is analogous to "shrink-wrapping" the geometries.
            A convex hull is often used to
            determine an affected area based on a set of point observations.</para>

        <para>In the general case the convex hull is a Polygon.
        The convex hull of two or more collinear points is a two-point LineString.
        The convex hull of one or more identical points is a Point.</para>

        <para>This is not an aggregate function.
        To compute the convex hull of a set of geometries, use <xref linkend="ST_Collect" />
        to aggregate them into a geometry collection
        (e.g. <code>ST_ConvexHull(ST_Collect(geom))</code>.</para>

        <para>Performed by the GEOS module</para>

        <para>&sfs_compliant; s2.1.1.3</para>
        <para>&sqlmm_compliant; SQL-MM IEC 13249-3: 5.1.16</para>
        <para>&Z_support;</para>
      </refsection>

      <refsection>
        <title>Examples</title>

<para>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_convexhull01.png" />
        </imageobject>
        <caption><para>Convex Hull of a MultiLinestring and a MultiPoint</para></caption>
      </mediaobject>
    </informalfigure>
    <programlisting>
SELECT ST_AsText(ST_ConvexHull(
    ST_Collect(
        ST_GeomFromText('MULTILINESTRING((100 190,10 8),(150 10, 20 30))'),
            ST_GeomFromText('MULTIPOINT(50 5, 150 30, 50 10, 10 10)')
            )) );
---st_astext--
POLYGON((50 5,10 8,10 10,100 190,150 30,150 10,50 5))
    </programlisting>
</para>

<para>Using with ST_Collect to compute the convex hulls of geometry sets.</para>

<programlisting>
--Get estimate of infected area based on point observations
SELECT d.disease_type,
    ST_ConvexHull(ST_Collect(d.geom)) As geom
    FROM disease_obs As d
    GROUP BY d.disease_type;
</programlisting>

      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_ConcaveHull" />, <xref linkend="ST_MinimumBoundingCircle" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_DelaunayTriangles">
        <refnamediv>
            <refname>ST_DelaunayTriangles</refname>

            <refpurpose>
Returns the Delaunay triangulation of the vertices of a geometry.
            </refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>
              <funcprototype>
                <funcdef>geometry <function>ST_DelaunayTriangles</function></funcdef>
                <paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
                <paramdef><type>float </type> <parameter>tolerance</parameter></paramdef>
                <paramdef><type>int4 </type> <parameter>flags</parameter></paramdef>
              </funcprototype>
            </funcsynopsis>
        </refsynopsisdiv>

          <refsection>
            <title>Description</title>

            <para>
Return the <ulink
url="http://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay
triangulation</ulink> of the vertices of the input geometry.
Output is a COLLECTION of polygons (for flags=0) or a MULTILINESTRING
(for flags=1) or TIN (for flags=2).  The tolerance, if any, is used to snap input vertices
together.
            </para>
            <para>Performed by the GEOS module.</para>
            <para>Availability: 2.1.0</para>
            <para>&Z_support;</para>
            <para>&T_support;</para>

        </refsection>
              <refsection>
        <title>2D Examples</title>
            <informaltable>
                  <tgroup cols="1">
                    <tbody>
                     <row><entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_delaunaytriangles01.png" />
                              </imageobject>
                              <caption><para>Original polygons</para></caption>
                            </mediaobject>
                          </informalfigure></para>
<programlisting>-- our original geometry --
    ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
            50 60, 125 100, 175 150))'),
        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
        )</programlisting></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_delaunaytriangles03.png" />
                              </imageobject>
                              <caption><para>ST_DelaunayTriangles of 2 polygons: delaunay triangle polygons each triangle themed in different color</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
-- geometries overlaid multilinestring triangles
SELECT
    ST_DelaunayTriangles(
        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
            50 60, 125 100, 175 150))'),
        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
        ))
     As  dtriag;
                </programlisting>
                          </para></entry></row>
                <row><entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_delaunaytriangles02.png" />
                              </imageobject>
                              <caption><para>-- delaunay triangles as multilinestring</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>SELECT
    ST_DelaunayTriangles(
        ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
            50 60, 125 100, 175 150))'),
        ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
        ),0.001,1)
     As  dtriag;</programlisting>
                        </para></entry>
                </row>
                <row><entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_delaunaytriangles04.png" />
                              </imageobject>
                              <caption><para>-- delaunay triangles of 45 points as 55 triangle polygons</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>-- this produces a table of 42 points that form an L shape
SELECT (ST_DumpPoints(ST_GeomFromText(
'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,
150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,
14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,
6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,
14 94,14 74,14 54,14 34,14 14)'))).geom
    INTO TABLE l_shape;
-- output as individual polygon triangles
SELECT ST_AsText((ST_Dump(geom)).geom) As wkt
FROM ( SELECT ST_DelaunayTriangles(ST_Collect(geom)) As geom
FROM l_shape) As foo;

---wkt ---
POLYGON((6 194,6 190,14 194,6 194))
POLYGON((14 194,6 190,14 174,14 194))
POLYGON((14 194,14 174,154 14,14 194))
POLYGON((154 14,14 174,14 154,154 14))
POLYGON((154 14,14 154,150 14,154 14))
POLYGON((154 14,150 14,154 6,154 14))
:
:
</programlisting>
                        </para></entry>
             </row>

        </tbody>
    </tgroup>
</informaltable>
      </refsection>
      <refsection>
            <title>Example 1</title>
            <programlisting>-- 3D multipoint --
SELECT ST_AsText(ST_DelaunayTriangles(ST_GeomFromText(
'MULTIPOINT Z(14 14 10,
150 14 100,34 6 25, 20 10 150)'))) As wkt;

-----wkt----
GEOMETRYCOLLECTION Z (POLYGON Z ((14 14 10,20 10 150,34 6 25,14 14 10))
 ,POLYGON Z ((14 14 10,34 6 25,150 14 100,14 14 10)))</programlisting>
        </refsection>
    </refentry>

    <refentry id="ST_FilterByM">
      <refnamediv>
        <refname>ST_FilterByM</refname>
        <refpurpose>Removes vertices based on their M value</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_FilterByM</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
            <paramdef><type>double precision</type> <parameter>min</parameter></paramdef>
            <paramdef><type>double precision</type> <parameter>max = null</parameter></paramdef>
            <paramdef><type>boolean</type> <parameter>returnM = false</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Filters out vertex points based on their M-value. Returns a geometry with only
            vertex points that have a M-value larger or equal to the min value and smaller or equal to
            the max value. If max-value argument is left out only min value is considered. If fourth argument is left out the m-value
            will not be in the resulting geometry. If resulting geometry have too few vertex points left for its geometry type an empty
            geometry will be returned. In a geometry collection
            geometries without enough points will just be left out silently.</para>
        <para>This function is mainly intended to be used in conjunction with ST_SetEffectiveArea. ST_EffectiveArea sets the effective area
            of a vertex in its m-value. With ST_FilterByM it then is possible to get a simplified version of the geometry without any calculations, just by filtering</para>

        <note><para>There is a difference in what ST_SimplifyVW returns when not enough points meet the criteria compared to ST_FilterByM.
                ST_SimplifyVW returns the geometry with enough points while ST_FilterByM returns an empty geometry</para></note>
        <note><para>Note that the returned geometry might be invalid</para></note>
        <note><para>This function returns all dimensions, including the Z and M values</para></note>
        <para>Availability: 2.5.0</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>A linestring is filtered</para>
                <programlisting>
SELECT ST_AsText(ST_FilterByM(geom,30)) simplified
FROM (SELECT  ST_SetEffectiveArea('LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry) geom) As foo;
-result
         simplified
----------------------------
 LINESTRING(5 2,7 25,10 10)
                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_SetEffectiveArea" />, <xref linkend="ST_SimplifyVW" /></para>
          </refsection>
    </refentry>

    <refentry id="ST_GeneratePoints">
      <refnamediv>
        <refname>ST_GeneratePoints</refname>

        <refpurpose>Generates random points contained in a Polygon or MultiPolygon.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_GeneratePoints</function></funcdef>
            <paramdef>
                <parameter>g</parameter>
                <type>geometry</type>
            </paramdef>
            <paramdef>
                <parameter>npoints</parameter>
                <type>integer</type>
            </paramdef>
          </funcprototype>
          <funcprototype>
            <funcdef>geometry <function>ST_GeneratePoints</function></funcdef>
            <paramdef> <type>geometry</type> <parameter>g</parameter> </paramdef>
            <paramdef> <type>integer</type> <parameter>npoints</parameter> </paramdef>
            <paramdef> <type>integer</type> <parameter>seed</parameter> </paramdef>
          </funcprototype>

        </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
        <title>Description</title>

        <para>
            ST_GeneratePoints generates a given number of pseudo-random points
            which lie within the input area.
            The optional <code>seed</code> is used to regenerate a deterministic sequence of points,
            and must be greater than zero.
        </para>

        <para>Availability: 2.3.0</para>
        <para>Enhanced: 3.0.0, added seed parameter</para>
        </refsection>

        <refsection>
            <title>Examples</title>

<para><informalfigure>
                        <mediaobject>
                          <imageobject>
                            <imagedata fileref="images/st_generatepoints01.png" />
                          </imageobject>
                          <caption><para>Generated 12 Points overlaid on top of original polygon using a random seed value 1996</para></caption>
                        </mediaobject>
                      </informalfigure>
                        <programlisting>SELECT ST_GeneratePoints(geom, 12, 1996)
FROM (
    SELECT ST_Buffer(
        ST_GeomFromText(
        'LINESTRING(50 50,150 150,150 50)'),
        10, 'endcap=round join=round') AS geom
) AS s;</programlisting>
            </para>
        </refsection>
    </refentry>

    <refentry id="ST_GeometricMedian">
      <refnamediv>
          <refname>
              ST_GeometricMedian
          </refname>

        <refpurpose>
            Returns the geometric median of a MultiPoint.
        </refpurpose>
      </refnamediv>

    <refsynopsisdiv>
      <funcsynopsis>
        <funcprototype>
            <funcdef>geometry <function>ST_GeometricMedian</function> </funcdef>

            <paramdef> <type>geometry</type> <parameter>geom</parameter></paramdef>
            <paramdef choice="opt"><type>float8</type> <parameter>tolerance = NULL</parameter></paramdef>
            <paramdef choice="opt"><type>int</type> <parameter>max_iter = 10000</parameter></paramdef>
            <paramdef choice="opt"><type>boolean</type> <parameter>fail_if_not_converged = false</parameter></paramdef>

        </funcprototype>
      </funcsynopsis>
    </refsynopsisdiv>

    <refsection>
      <title>Description</title>

    <para>
          Computes the approximate geometric median of a MultiPoint geometry
          using the Weiszfeld algorithm.
          The geometric median is the point minimizing the sum of distances to the input points.
          It provides a centrality measure
          that is less sensitive to outlier points than the centroid (center of mass).
    </para>
    <para>
          The algorithm iterates until the distance change between
          successive iterations is less than the supplied <varname>tolerance</varname>
          parameter.  If this condition has not been met after <varname>max_iterations</varname>
          iterations, the function produces an error and exits,
          unless <varname>fail_if_not_converged</varname> is set to <code>false</code> (the default).
    </para>
    <para>
          If a <varname>tolerance</varname> argument is not provided, the tolerance value
          is calculated based on the extent of the input geometry.
    </para>
    <para>
          If present, the input point M values are interpreted as their relative weights.
    </para>
    <para>Availability: 2.3.0</para>
    <para>Enhanced: 2.5.0 Added support for M as weight of points.</para>
    <para>&Z_support;</para>
    <para>&M_support;</para>
    </refsection>
    <refsection>
      <title>Examples</title>
      <para>
          <informalfigure>
              <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/st_geometricmedian01.png" />
                    </imageobject>

                    <caption>
                        <para>
                        Comparison of the geometric median (red)
                        and centroid (turquoise) of a MultiPoint.
                        </para>
                    </caption>
              </mediaobject>
        </informalfigure>
      </para>
      <programlisting>
WITH test AS (
SELECT 'MULTIPOINT((10 10), (10 40), (40 10), (190 190))'::geometry geom)
SELECT
  ST_AsText(ST_Centroid(geom)) centroid,
  ST_AsText(ST_GeometricMedian(geom)) median
FROM test;

      centroid      |                 median
--------------------+----------------------------------------
   POINT(62.5 62.5) | POINT(25.01778421249728 25.01778421249728)
(1 row)
      </programlisting>
    </refsection>

    <refsection>
      <title>See Also</title>

      <para><xref linkend="ST_Centroid"/></para>
    </refsection>

    </refentry>

	<refentry id="ST_LineMerge">
		<refnamediv>
			<refname>ST_LineMerge</refname>

			<refpurpose>Return the lines formed by sewing together
			a MultiLineString.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_LineMerge</function></funcdef>
				<paramdef><type>geometry </type> <parameter>amultilinestring</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>geometry <function>ST_LineMerge</function></funcdef>
				<paramdef><type>geometry </type> <parameter>amultilinestring</parameter></paramdef>
				<paramdef><type>boolean </type> <parameter>directed</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns a LineString or MultiLineString formed by joining together
			the line elements of a MultiLineString.
            Lines are joined at their endpoints at 2-way intersections.
            Lines are not joined across intersections of 3-way or greater degree.
            </para>

			<para>If <emphasis role="bold">directed</emphasis> is TRUE, then ST_LineMerge
			will not change point order within LineStrings, so lines with opposite directions
			will not be merged</para>

			<note><para>Only use with MultiLineString/LineStrings. Other geometry types
			return an empty GeometryCollection</para></note>
			<para>Performed by the GEOS module.</para>
			<para>Enhanced: 3.3.0 accept a directed parameter - requires GEOS &gt;= 3.11.0</para>
			<para>Availability: 1.1.0</para>
			<warning><para>This function strips the M dimension.</para></warning>
		</refsection>

		<refsection>
			<title>Examples</title>
      <para>
          <informalfigure>
              <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/st_linemerge01.png" />
                    </imageobject>

                    <caption>
                        <para>Merging lines with different orientation.
                        </para>
                    </caption>
              </mediaobject>
        </informalfigure>
      </para>
			<programlisting>SELECT ST_AsText(ST_LineMerge(
'MULTILINESTRING((10 160, 60 120), (120 140, 60 120), (120 140, 180 120))'
		));
--------------------------------------------
 LINESTRING(10 160,60 120,120 140,180 120)
</programlisting>

      <para>
          <informalfigure>
              <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/st_linemerge02.png" />
                    </imageobject>

                    <caption>
                        <para>Lines are not merged across intersections with degree > 2.
                        </para>
                    </caption>
              </mediaobject>
        </informalfigure>
      </para>
			<programlisting>SELECT ST_AsText(ST_LineMerge(
'MULTILINESTRING((10 160, 60 120), (120 140, 60 120), (120 140, 180 120), (100 180, 120 140))'
		));
--------------------------------------------
 MULTILINESTRING((10 160,60 120,120 140),(100 180,120 140),(120 140,180 120))
</programlisting>

<para>If merging is not possible due to non-touching lines,
the original MultiLineString is returned.</para>
<programlisting>
SELECT ST_AsText(ST_LineMerge(
'MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45.2 -33.2,-46 -32))'
));
----------------
MULTILINESTRING((-45.2 -33.2,-46 -32),(-29 -27,-30 -29.7,-36 -31,-45 -33))
</programlisting>

<para>
	<informalfigure>
		<mediaobject>
			<imageobject>
				<imagedata fileref="images/st_linemerge03.png" />
			</imageobject>
			<caption>
				<para>Lines with opposite directions are not merged if directed = TRUE.</para>
			</caption>
		</mediaobject>
	</informalfigure>
</para>
<programlisting>
SELECT ST_AsText(ST_LineMerge(
'MULTILINESTRING((60 30, 10 70), (120 50, 60 30), (120 50, 180 30))',
TRUE));
-------------------------------------------------------
 MULTILINESTRING((120 50,60 30,10 70),(120 50,180 30))
</programlisting>

<para>Example showing Z-dimension handling.</para>
<programlisting>
SELECT ST_AsText(ST_LineMerge(
      'MULTILINESTRING((-29 -27 11,-30 -29.7 10,-36 -31 5,-45 -33 6), (-29 -27 12,-30 -29.7 5), (-45 -33 1,-46 -32 11))'
        ));
--------------------------------------------------------------------------------------------------
LINESTRING Z (-30 -29.7 5,-29 -27 11,-30 -29.7 10,-36 -31 5,-45 -33 1,-46 -32 11)
</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Segmentize" />, <xref linkend="ST_LineSubstring" /></para>
		</refsection>
	</refentry>

    <refentry id="ST_MaximumInscribedCircle">
      <refnamediv>
        <refname>ST_MaximumInscribedCircle</refname>
        <refpurpose>Computes the largest circle contained within a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>(geometry, geometry, double precision) <function>ST_MaximumInscribedCircle</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Finds the largest circle that is contained within a (multi)polygon,
        or which does not overlap any lines and points.
        Returns a record with fields:
        </para>
        <itemizedlist>
            <listitem><para> <varname>center</varname> - center point of the circle </para></listitem>
            <listitem><para> <varname>nearest</varname> - a point on the geometry nearest to the center </para></listitem>
            <listitem><para> <varname>radius</varname> - radius of the circle </para></listitem>
        </itemizedlist>

        <para>For polygonal inputs, the circle is inscribed within the boundary rings, using the internal rings as boundaries.
        For linear and point inputs, the circle is inscribed within the convex hull of the input,
        using the input lines and points as further boundaries.</para>

        <para>Availability: 3.1.0 - requires GEOS &gt;= 3.9.0.</para>

      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_MinimumBoundingCircle" /></para>
      </refsection>

      <refsection>
        <title>Examples</title>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_maximuminscribedcircle01.png" />
        </imageobject>
        <caption><para>Maximum inscribed circle of a polygon. Center, nearest point, and radius are returned.</para></caption>
      </mediaobject>
    </informalfigure>
<programlisting>SELECT radius, ST_AsText(center) AS center, ST_AsText(nearest) AS nearest
    FROM ST_MaximumInscribedCircle(
        'POLYGON ((40 180, 110 160, 180 180, 180 120, 140 90, 160 40, 80 10, 70 40, 20 50, 40 180),
        (60 140, 50 90, 90 140, 60 140))');

     radius      |           center           |    nearest
-----------------+----------------------------+---------------
 45.165845650018 | POINT(96.953125 76.328125) | POINT(140 90)
</programlisting>

    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_maximuminscribedcircle02.png" />
        </imageobject>
        <caption><para>Maximum inscribed circle of a multi-linestring. Center, nearest point, and radius are returned.</para></caption>
      </mediaobject>
    </informalfigure>

      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_MinimumBoundingRadius" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_MinimumBoundingCircle">
      <refnamediv>
        <refname>ST_MinimumBoundingCircle</refname>
        <refpurpose>Returns the smallest circle polygon that contains a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_MinimumBoundingCircle</function></funcdef>
            <paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
            <paramdef choice="opt"><type>integer </type> <parameter>num_segs_per_qt_circ=48</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
            <para>Returns the smallest circle polygon that contains a geometry. </para>

            <note><para>The bounding circle is approximated by a polygon with a default of 48 segments per quarter circle.
            Because the polygon is an approximation of the minimum bounding circle, some points in the input geometry may not be contained within the polygon.
            The approximation can be improved by increasing the number of segments.
            For applications where an approximation is not suitable <xref linkend="ST_MinimumBoundingRadius" /> may be used.</para></note>

            <para>This function is not an aggregate. It can be used
            with <xref linkend="ST_Collect" /> to get the minimum bounding circle of a set of geometries.</para>

        <para>The ratio of the area of a polygon divided by the area of its Minimum Bounding Circle
        is referred to as the <emphasis>Reock compactness score</emphasis>.</para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 1.4.0</para>

      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingRadius" /></para>
      </refsection>

      <refsection>
        <title>Examples</title>
<programlisting>SELECT d.disease_type,
    ST_MinimumBoundingCircle(ST_Collect(d.geom)) As geom
    FROM disease_obs As d
    GROUP BY d.disease_type;
</programlisting>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_minimumboundingcircle01.png" />
        </imageobject>
        <caption><para>Minimum bounding circle of a point and linestring.  Using 8 segs to approximate a quarter circle</para></caption>
      </mediaobject>
    </informalfigure>
<programlisting>
SELECT ST_AsText(ST_MinimumBoundingCircle(
        ST_Collect(
            ST_GeomFromText('LINESTRING(55 75,125 150)'),
                ST_Point(20, 80)), 8
                )) As wktmbc;
wktmbc
-----------
POLYGON((135.59714732062 115,134.384753327498 102.690357210921,130.79416296937 90.8537670908995,124.963360620072 79.9451031602111,117.116420743937 70.3835792560632,107.554896839789 62.5366393799277,96.6462329091006 56.70583703063,84.8096427890789 53.115246672502,72.5000000000001 51.9028526793802,60.1903572109213 53.1152466725019,48.3537670908996 56.7058370306299,37.4451031602112 62.5366393799276,27.8835792560632 70.383579256063,20.0366393799278 79.9451031602109,14.20583703063 90.8537670908993,10.615246672502 102.690357210921,9.40285267938019 115,10.6152466725019 127.309642789079,14.2058370306299 139.1462329091,20.0366393799275 150.054896839789,27.883579256063 159.616420743937,
37.4451031602108 167.463360620072,48.3537670908992 173.29416296937,60.190357210921 176.884753327498,
72.4999999999998 178.09714732062,84.8096427890786 176.884753327498,96.6462329091003 173.29416296937,107.554896839789 167.463360620072,
117.116420743937 159.616420743937,124.963360620072 150.054896839789,130.79416296937 139.146232909101,134.384753327498 127.309642789079,135.59714732062 115))
                </programlisting>
      </refsection>
      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingRadius" /> </para>
      </refsection>
    </refentry>

    <refentry id="ST_MinimumBoundingRadius">
    <refnamediv>
        <refname>ST_MinimumBoundingRadius</refname>
        <refpurpose>Returns the center point and radius of the smallest circle that contains a geometry.</refpurpose>
    </refnamediv>

    <refsynopsisdiv>
        <funcsynopsis>
            <funcprototype>
                <funcdef>(geometry, double precision) <function>ST_MinimumBoundingRadius</function></funcdef>
                <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
    </refsynopsisdiv>

    <refsection>
        <title>Description</title>
        <para>Computes the center point and radius of the smallest circle that contains a geometry.
        Returns a record with fields:
        </para>
        <itemizedlist>
            <listitem><para> <varname>center</varname> - center point of the circle </para></listitem>
            <listitem><para> <varname>radius</varname> - radius of the circle </para></listitem>
        </itemizedlist>

        <para>Use in conjunction with <xref linkend="ST_Collect"/> to get the minimum bounding circle of a set of geometries.</para>
        <para>Availability - 2.3.0</para>
    </refsection>

      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingCircle" /></para>
      </refsection>

      <refsection>
        <title>Examples</title>
<programlisting>SELECT ST_AsText(center), radius FROM ST_MinimumBoundingRadius('POLYGON((26426 65078,26531 65242,26075 65136,26096 65427,26426 65078))');

                st_astext                 |      radius
------------------------------------------+------------------
 POINT(26284.8418027133 65267.1145090825) | 247.436045591407
</programlisting>
      </refsection>

    </refentry>

    <refentry id="ST_OrientedEnvelope">
        <refnamediv>
            <refname>ST_OrientedEnvelope</refname>
            <refpurpose>Returns a minimum-area rectangle containing a geometry.</refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>geometry <function>ST_OrientedEnvelope</function></funcdef>
                    <paramdef>
                        <type>geometry</type>
                        <parameter>geom</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>
            <para>
                Returns the minimum-area rotated rectangle enclosing a geometry.
                Note that more than one such rectangle may exist.
                May return a Point or LineString in the case of degenerate inputs.
            </para>
            <para>
                Availability: 2.5.0
            </para>
        </refsection>

        <refsection>
            <title>See Also</title>
            <para>
                <xref linkend="ST_Envelope" />
                <xref linkend="ST_MinimumBoundingCircle" />
            </para>
        </refsection>

        <refsection>
            <title>Examples</title>
            <programlisting>
                SELECT ST_AsText(ST_OrientedEnvelope('MULTIPOINT ((0 0), (-1 -1), (3 2))'));

                st_astext
                ------------------------------------------------
                POLYGON((3 2,2.88 2.16,-1.12 -0.84,-1 -1,3 2))
            </programlisting>

    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_orientedenvelope01.png" />
        </imageobject>
        <caption><para>Oriented envelope of a point and linestring.</para></caption>
      </mediaobject>
    </informalfigure>
<programlisting>
SELECT ST_AsText(ST_OrientedEnvelope(
        ST_Collect(
            ST_GeomFromText('LINESTRING(55 75,125 150)'),
                ST_Point(20, 80))
                )) As wktenv;
wktenv
-----------
POLYGON((19.9999999999997 79.9999999999999,33.0769230769229 60.3846153846152,138.076923076924 130.384615384616,125.000000000001 150.000000000001,19.9999999999997 79.9999999999999))
</programlisting>

        </refsection>
    </refentry>

    <refentry id="ST_OffsetCurve">
        <refnamediv>
            <refname>ST_OffsetCurve</refname>

            <refpurpose>
Returns an offset line at a given distance and side from an input line.
        </refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>

                <funcprototype>
                <funcdef>geometry <function>ST_OffsetCurve</function></funcdef>
                <paramdef><type>geometry </type> <parameter>line</parameter></paramdef>
                <paramdef><type>float </type> <parameter>signed_distance</parameter></paramdef>
                <paramdef choice="opt"><type>text </type> <parameter>style_parameters=''</parameter></paramdef>
                </funcprototype>

            </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>

            <para>
Return an offset line at a given distance and side from an input line.
All points of the returned geometries are not further than the given
distance from the input geometry.
Useful for computing parallel lines about a center line.
            </para>

            <para>
For positive distance the offset is on the left side of the input line
and retains the same direction. For a negative distance it is on the right
side and in the opposite direction.
            </para>
            <para>
Units of distance are measured in units of the spatial reference system.
            </para>
            <para>
Note that output may be a MULTILINESTRING or EMPTY for some jigsaw-shaped input geometries.
            </para>
            <para>
The optional third parameter allows specifying a list of blank-separated
key=value pairs to tweak operations as follows:
<itemizedlist>
<listitem>
<para>'quad_segs=#' : number of segments used to approximate a quarter circle (defaults to 8).</para>
</listitem>
<listitem>
<para>'join=round|mitre|bevel' : join style (defaults to "round"). 'miter' is also accepted as a synonym for 'mitre'.</para>
</listitem>
<listitem>
<para>'mitre_limit=#.#' : mitre ratio limit (only affects mitred join style). 'miter_limit' is also accepted as a synonym for 'mitre_limit'.</para>
</listitem>
</itemizedlist>
                </para>

            <para>Performed by the GEOS module.</para>
            <para>Availability: 2.0</para>
            <para>Enhanced: 2.5 - added support for GEOMETRYCOLLECTION and MULTILINESTRING</para>

            <note><para>This function ignores the Z dimension.
It always gives a 2D result even when used on a 3D geometry.</para></note>

            </refsection>

            <refsection>
            <title>Examples</title>
<para>Compute an open buffer around roads</para>
                <programlisting>
SELECT ST_Union(
 ST_OffsetCurve(f.geom,  f.width/2, 'quad_segs=4 join=round'),
 ST_OffsetCurve(f.geom, -f.width/2, 'quad_segs=4 join=round')
) as track
FROM someroadstable;

                </programlisting>
                <informaltable>
                  <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve01.png" />
                              </imageobject>
                              <caption><para>15, 'quad_segs=4 join=round' original line
and its offset 15 units.</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)'),
    15, 'quad_segs=4 join=round'));
--output --
LINESTRING(164 1,18 1,12.2597485145237 2.1418070123307,
    7.39339828220179 5.39339828220179,
    5.39339828220179 7.39339828220179,
    2.14180701233067 12.2597485145237,1 18,1 195)
                </programlisting>
                          </para></entry>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve02.png" />
                              </imageobject>
                              <caption><para>-15, 'quad_segs=4 join=round' original line
                                and its offset -15 units </para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_OffsetCurve(geom,
    -15, 'quad_segs=4 join=round')) As notsocurvy
    FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)') As geom;
-- notsocurvy --
LINESTRING(31 195,31 31,164 31)
                </programlisting>
                        </para></entry>
                      </row>
                     <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve05.png" />
                              </imageobject>
                              <caption><para>double-offset to get more curvy, note the first reverses direction, so -30 + 15 = -15</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_OffsetCurve(geom,
    -30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')) As morecurvy
    FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)') As geom;
-- morecurvy --
LINESTRING(164 31,46 31,40.2597485145236 32.1418070123307,
35.3933982822018 35.3933982822018,
32.1418070123307 40.2597485145237,31 46,31 195)
                </programlisting>
                        </para></entry>
<entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve06.png" />
                              </imageobject>
                              <caption><para>double-offset to get more curvy,combined with regular offset 15 to get parallel lines.  Overlaid with original.</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>SELECT ST_AsText(ST_Collect(
    ST_OffsetCurve(geom, 15, 'quad_segs=4 join=round'),
    ST_OffsetCurve(ST_OffsetCurve(geom,
    -30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')
    )
) As parallel_curves
    FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)') As geom;
-- parallel curves  --
MULTILINESTRING((164 1,18 1,12.2597485145237 2.1418070123307,
7.39339828220179 5.39339828220179,5.39339828220179 7.39339828220179,
2.14180701233067 12.2597485145237,1 18,1 195),
(164 31,46 31,40.2597485145236 32.1418070123307,35.3933982822018 35.3933982822018,
32.1418070123307 40.2597485145237,31 46,31 195))
                </programlisting>
                        </para></entry>
                      </row>
                      <row>
                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve03.png" />
                              </imageobject>
                              <caption><para>15, 'quad_segs=4 join=bevel' shown with original line</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)'),
        15, 'quad_segs=4 join=bevel'));
-- output --
LINESTRING(164 1,18 1,7.39339828220179 5.39339828220179,
    5.39339828220179 7.39339828220179,1 18,1 195)
                </programlisting>
                         </para></entry>

                        <entry><para><informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_offsetcurve04.png" />
                              </imageobject>
                              <caption><para>15,-15 collected, join=mitre mitre_limit=2.1</para></caption>
                            </mediaobject>
                          </informalfigure>
                <programlisting>
SELECT ST_AsText(ST_Collect(
    ST_OffsetCurve(geom, 15, 'quad_segs=4 join=mitre mitre_limit=2.2'),
    ST_OffsetCurve(geom, -15, 'quad_segs=4 join=mitre mitre_limit=2.2')
    ) )
    FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
    44 16,24 16,20 16,18 16,17 17,
    16 18,16 20,16 40,16 60,16 80,16 100,
    16 120,16 140,16 160,16 180,16 195)') As geom;
-- output --
MULTILINESTRING((164 1,11.7867965644036 1,1 11.7867965644036,1 195),
    (31 195,31 31,164 31))
                </programlisting>
                          </para></entry>
                      </row>
                    </tbody>
                  </tgroup>
            </informaltable>

            </refsection>

              <refsection>
                <title>See Also</title>
                <para><xref linkend="ST_Buffer" /></para>
              </refsection>
    </refentry>

    <refentry id="ST_PointOnSurface">
      <refnamediv>
        <refname>ST_PointOnSurface</refname>
        <refpurpose>Computes a point guaranteed to lie in a polygon, or on a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_PointOnSurface</function></funcdef>

            <paramdef><type>geometry </type>
            <parameter>g1</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>Returns a <varname>POINT</varname> which is guaranteed to lie in the interior of a surface
        (POLYGON, MULTIPOLYGON, and CURVED POLYGON).
        In PostGIS this function also works on line and point geometries.
        </para>

        <para>&sfs_compliant; s3.2.14.2 // s3.2.18.2</para>
        <para>&sqlmm_compliant; SQL-MM 3: 8.1.5, 9.5.6.
         The specifications define ST_PointOnSurface for surface geometries only.
         PostGIS extends the function to support all common geometry types.
         Other databases (Oracle, DB2, ArcSDE) seem to support this function only for surfaces.
         SQL Server 2008 supports all common geometry types.</para>
        <para>&Z_support;</para>
      </refsection>

      <refsection>
        <title>Examples</title>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_pointonsurface01.png" />
                    </imageobject>

                    <caption><para>PointOnSurface of a
                    <varname>MULTIPOINT</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>

              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_pointonsurface02.png" />
                    </imageobject>

                    <caption><para>PointOnSurface of a
                    <varname>LINESTRING</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>
            </row>

            <row>
              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_pointonsurface03.png" />
                    </imageobject>

                    <caption><para>PointOnSurface of a
                    <varname>POLYGON</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>

              <entry><para><informalfigure>
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="images/st_pointonsurface04.png" />
                    </imageobject>

                    <caption><para>PointOnSurface of a
                    <varname>GEOMETRYCOLLECTION</varname></para></caption>
                  </mediaobject>
                </informalfigure></para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

        <programlisting>SELECT ST_AsText(ST_PointOnSurface('POINT(0 5)'::geometry));
------------
 POINT(0 5)

SELECT ST_AsText(ST_PointOnSurface('LINESTRING(0 5, 0 10)'::geometry));
------------
 POINT(0 5)

SELECT ST_AsText(ST_PointOnSurface('POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))'::geometry));
----------------
 POINT(2.5 2.5)

SELECT ST_AsEWKT(ST_PointOnSurface(ST_GeomFromEWKT('LINESTRING(0 5 1, 0 0 1, 0 10 2)')));
----------------
 POINT(0 0 1)
</programlisting>

        <para><emphasis role="bold">Example:</emphasis>
        The result of ST_PointOnSurface is guaranteed to lie within polygons,
        whereas the point computed by <xref linkend="ST_Centroid" /> may be outside.
        </para>

        <informalfigure>
            <mediaobject>
                <imageobject>
                <imagedata fileref="images/st_pointonsurface.png" />
                </imageobject>
                <caption><para>Red: point on surface; Green: centroid</para></caption>
            </mediaobject>
            </informalfigure>

<programlisting>
SELECT ST_AsText(ST_PointOnSurface(geom)) AS pt_on_surf,
       ST_AsText(ST_Centroid(geom)) AS centroid
    FROM (SELECT 'POLYGON ((130 120, 120 190, 30 140, 50 20, 190 20,
                      170 100, 90 60, 90 130, 130 120))'::geometry AS geom) AS t;

   pt_on_surf    |                  centroid
-----------------+---------------------------------------------
 POINT(62.5 110) | POINT(100.18264840182648 85.11415525114155)
</programlisting>
      </refsection>

      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_Centroid" />, <xref linkend="ST_MaximumInscribedCircle" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_Polygonize">
        <refnamediv>
            <refname>ST_Polygonize</refname>

            <refpurpose>Computes a collection of polygons formed from the linework of a set of geometries.
            </refpurpose>
        </refnamediv>

        <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_Polygonize</function></funcdef>
            <paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
          </funcprototype>

          <funcprototype>
            <funcdef>geometry <function>ST_Polygonize</function></funcdef>
            <paramdef><type>geometry[]</type> <parameter>geom_array</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>

            <para>Creates a GeometryCollection containing the
            polygons formed by the constituent linework of a set of geometries.
            Input linework must be correctly noded for this function to work properly.</para>

            <note>
                <para>
                To ensure input is fully noded use <xref linkend="ST_Node" /> on the input geometry
                before polygonizing.
                </para>
            </note>

            <note>
                <para>GeometryCollections are often difficult to deal with with third party tools.
                Use <xref linkend="ST_Dump" /> to convert the polygonize result
                into separate polygons.</para>
            </note>
            <para>Performed by the GEOS module.</para>

            <para>Availability: 1.0.0RC1</para>
        </refsection>

        <refsection>
        <title>Examples: Polygonizing single linestrings</title>
         <programlisting>
SELECT ST_AsEWKT(ST_Polygonize(geom_4269)) As geomtextrep
FROM (SELECT geom_4269 FROM ma.suffolk_edges ORDER BY tlid LIMIT 45) As foo;

geomtextrep
-------------------------------------
 SRID=4269;GEOMETRYCOLLECTION(POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,-71.040878 42.285678)),
 POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358,-71.171794 42.354971,-71.170511 42.354855,
 -71.17112 42.354238,-71.17166 42.353675)))
(1 row)

--Use ST_Dump to dump out the polygonize geoms into individual polygons
SELECT ST_AsEWKT((ST_Dump(foofoo.polycoll)).geom) As geomtextrep
FROM (SELECT ST_Polygonize(geom_4269) As polycoll
    FROM (SELECT geom_4269 FROM ma.suffolk_edges
        ORDER BY tlid LIMIT 45) As foo) As foofoo;

geomtextrep
------------------------
 SRID=4269;POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,
-71.040878 42.285678))
 SRID=4269;POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358
,-71.171794 42.354971,-71.170511 42.354855,-71.17112 42.354238,-71.17166 42.353675))
(2 rows)

              </programlisting>
        </refsection>

        <refsection>
            <title>See Also</title>
            <para>
            <xref linkend="ST_Node" />,
            <xref linkend="ST_Dump" />
            </para>
        </refsection>
    </refentry>

    <refentry id="ST_ReducePrecision">
      <refnamediv>
        <refname>ST_ReducePrecision</refname>

        <refpurpose>Returns a valid geometry with points rounded to a grid tolerance.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_ReducePrecision</function></funcdef>

            <paramdef><type>geometry </type>
            <parameter>g</parameter></paramdef>
            <paramdef><type>float8 </type>
            <parameter>gridsize</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>Returns a valid geometry with all points rounded to the provided grid tolerance, and features below the tolerance removed.</para>

        <para>Unlike <xref linkend="ST_SnapToGrid" /> the returned geometry will be valid, with no ring self-intersections or collapsed components.</para>

		<para>
        Precision reduction can be used to:
        <itemizedlist>
            <listitem><para>
            match coordinate precision to the data accuracy
            </para></listitem>
            <listitem><para>
            reduce the number of coordinates needed to represent a geometry
            </para></listitem>
            <listitem><para>
            ensure valid geometry output to formats which use lower precision
            (e.g. text formats such as WKT, GeoJSON or KML
            when the number of output decimal places is limited).
            </para></listitem>
            <listitem><para>
            export valid geometry to systems which use lower or limited precision
            (e.g. SDE, Oracle tolerance value)
            </para></listitem>
        </itemizedlist>
		</para>

        <para>Availability: 3.1.0 - requires GEOS &gt;= 3.9.0. </para>
      </refsection>

      <refsection>
        <title>Examples</title>

        <programlisting>SELECT ST_AsText(ST_ReducePrecision('POINT(1.412 19.323)', 0.1));
    st_astext
-----------------
 POINT(1.4 19.3)

SELECT ST_AsText(ST_ReducePrecision('POINT(1.412 19.323)', 1.0));
  st_astext
-------------
 POINT(1 19)

SELECT ST_AsText(ST_ReducePrecision('POINT(1.412 19.323)', 10));
  st_astext
-------------
 POINT(0 20)
</programlisting>

<para>Precision reduction can reduce number of vertices</para>
<programlisting>SELECT ST_AsText(ST_ReducePrecision('LINESTRING (10 10, 19.6 30.1, 20 30, 20.3 30, 40 40)', 1));
  st_astext
-------------
 LINESTRING (10 10, 20 30, 40 40)
</programlisting>

<para>Precision reduction splits polygons if needed to ensure validity</para>
<programlisting>SELECT ST_AsText(ST_ReducePrecision('POLYGON ((10 10, 60 60.1, 70 30, 40 40, 50 10, 10 10))', 10));
  st_astext
-------------
 MULTIPOLYGON (((60 60, 70 30, 40 40, 60 60)), ((40 40, 50 10, 10 10, 40 40)))
</programlisting>
      </refsection>

      <refsection>
        <title>See Also</title>

        <para><xref linkend="ST_SnapToGrid" />, <xref linkend="ST_Simplify" />, <xref linkend="ST_SimplifyVW" /></para>
      </refsection>
    </refentry>

    <refentry id="ST_SharedPaths">
      <refnamediv>
        <refname>ST_SharedPaths</refname>
        <refpurpose>Returns a collection containing paths shared by the two input linestrings/multilinestrings.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_SharedPaths</function></funcdef>
            <paramdef><type>geometry</type> <parameter>lineal1</parameter></paramdef>
            <paramdef><type>geometry</type> <parameter>lineal2</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Returns a collection containing paths shared by the two input geometries.
            Those going in the same direction are in the first element of the collection, those going in the opposite direction are in the second element.
            The paths themselves are given in the direction of the first geometry.
        </para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 2.0.0</para>
      </refsection>
      <refsection>
        <title>Examples: Finding shared paths</title>
        <informaltable>
          <tgroup cols="1">
            <tbody>
              <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_sharedpaths01.png" />
                      </imageobject>
                      <caption><para>A multilinestring and a linestring</para></caption>
                    </mediaobject>
                  </informalfigure></para>
               </entry>
              </row>
              <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_sharedpaths02.png" />
                      </imageobject>
                      <caption><para>The shared path of multilinestring and linestring overlaid with original geometries.</para></caption>
                    </mediaobject>
                  </informalfigure>
                  <programlisting>
 SELECT ST_AsText(
  ST_SharedPaths(
    ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),
       (51 150,101 150,76 175,51 150))'),
    ST_GeomFromText('LINESTRING(151 100,126 156.25,126 125,90 161, 76 175)')
    )
  ) As wkt

                                wkt
-------------------------------------------------------------
GEOMETRYCOLLECTION(MULTILINESTRING((126 156.25,126 125),
 (101 150,90 161),(90 161,76 175)),MULTILINESTRING EMPTY)
              </programlisting>
            </para>
            </entry>
        </row>
        <row>
            <entry><para>
                  <programlisting>
-- same example but linestring orientation flipped
SELECT ST_AsText(
  ST_SharedPaths(
   ST_GeomFromText('LINESTRING(76 175,90 161,126 125,126 156.25,151 100)'),
   ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),
       (51 150,101 150,76 175,51 150))')
    )
  ) As wkt

                                wkt
-------------------------------------------------------------
GEOMETRYCOLLECTION(MULTILINESTRING EMPTY,
MULTILINESTRING((76 175,90 161),(90 161,101 150),(126 125,126 156.25)))
              </programlisting>
            </para>
            </entry>
        </row>
    </tbody>
    </tgroup>
</informaltable>
     </refsection>
      <refsection>
        <title>See Also</title>
    <para>
        <xref linkend="ST_Dump" />,
        <xref linkend="ST_GeometryN" />,
        <xref linkend="ST_NumGeometries" />
    </para>
      </refsection>
    </refentry>

    <refentry id="ST_Simplify">
      <refnamediv>
        <refname>ST_Simplify</refname>
        <refpurpose>Returns a simplified version of a geometry, using
                the Douglas-Peucker algorithm.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_Simplify</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
          </funcprototype>
          <funcprototype>
            <funcdef>geometry <function>ST_Simplify</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
            <paramdef><type>boolean</type> <parameter>preserveCollapsed</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Returns a "simplified" version of the given geometry using
                the Douglas-Peucker algorithm. Will actually do something only with
                (multi)lines and (multi)polygons but you can safely call it with
                any kind of geometry. Since simplification occurs on a
                object-by-object basis you can also feed a GeometryCollection to
                this function.</para>

    <para>The "preserve collapsed" flag will retain objects that would otherwise
      be too small given the tolerance. For example, a 1m long line simplified with a 10m
      tolerance. If <varname>preserveCollapsed</varname> argument is
      specified as true, the line will not disappear.
      This flag is useful for rendering engines, to avoid having large numbers of very
      small objects disappear from a map leaving surprising gaps.</para>

        <note><para>Note that returned geometry might lose its
                simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
        <note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>

        <para>Availability: 1.2.2</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>A circle simplified too much becomes a triangle, medium an octagon, </para>
                <programlisting>SELECT ST_Npoints(geom) AS np_before,
       ST_NPoints(ST_Simplify(geom,0.1)) AS np01_notbadcircle,
       ST_NPoints(ST_Simplify(geom,0.5)) AS np05_notquitecircle,
       ST_NPoints(ST_Simplify(geom,1)) AS np1_octagon,
       ST_NPoints(ST_Simplify(geom,10)) AS np10_triangle,
       (ST_Simplify(geom,100) is null) AS  np100_geometrygoesaway
  FROM
    (SELECT ST_Buffer('POINT(1 3)', 10,12) As geom) AS foo;

 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_triangle | np100_geometrygoesaway
-----------+-------------------+---------------------+-------------+---------------+------------------------
        49 |                33 |                  17 |           9 |             4 | t
      </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para>
    <xref linkend="ST_IsSimple" />,
    <xref linkend="ST_SimplifyPreserveTopology" />,
    <xref linkend="ST_SimplifyVW" />,
    Topology <xref linkend="TP_ST_Simplify"/></para>
          </refsection>
    </refentry>

    <refentry id="ST_SimplifyPreserveTopology">
      <refnamediv>
        <refname>ST_SimplifyPreserveTopology</refname>
        <refpurpose>Returns a simplified and valid version of a geometry, using
            the Douglas-Peucker algorithm.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_SimplifyPreserveTopology</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Returns a "simplified" version of the given geometry using
            the Douglas-Peucker algorithm. Will avoid creating derived
            geometries (polygons in particular) that are invalid. Will actually do something only with
                (multi)lines and (multi)polygons but you can safely call it with
                any kind of geometry. Since simplification occurs on a
                object-by-object basis you can also feed a GeometryCollection to
                this function.</para>

        <para>Performed by the GEOS module.</para>
        <para>Availability: 1.3.3</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>Same example as Simplify, but we see Preserve Topology prevents oversimplification.  The circle can at most become a square.</para>
                <programlisting>
SELECT ST_Npoints(geom) As np_before, ST_NPoints(ST_SimplifyPreserveTopology(geom,0.1)) As np01_notbadcircle, ST_NPoints(ST_SimplifyPreserveTopology(geom,0.5)) As np05_notquitecircle,
ST_NPoints(ST_SimplifyPreserveTopology(geom,1)) As np1_octagon, ST_NPoints(ST_SimplifyPreserveTopology(geom,10)) As np10_square,
ST_NPoints(ST_SimplifyPreserveTopology(geom,100)) As  np100_stillsquare
FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As geom) As foo;

--result--
 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_square | np100_stillsquare
-----------+-------------------+---------------------+-------------+---------------+-------------------
        49 |                33 |                  17 |           9 |             5 |                 5
                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_Simplify" /></para>
          </refsection>
    </refentry>


    <refentry id="ST_SimplifyPolygonHull">
      <refnamediv>
        <refname>ST_SimplifyPolygonHull</refname>
        <refpurpose>Computes a simplifed topology-preserving outer or inner hull of a polygonal geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
         <funcprototype>
            <funcdef>geometry <function>ST_SimplifyPolygonHull</function></funcdef>
            <paramdef><type>geometry </type> <parameter>param_geom</parameter></paramdef>
            <paramdef><type>float </type> <parameter>vertex_fraction</parameter></paramdef>
            <paramdef choice="opt"><type>boolean </type> <parameter>is_outer = true</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>Computes a simplified topology-preserving outer or inner hull of a polygonal geometry.
        An outer hull completely covers the input geometry.
        An inner hull is completely covered by the input geometry.
        The result is a polygonal geometry formed by a subset of the input vertices.
        MultiPolygons and holes are handled and produce a result with the same structure as the input.
        </para>

        <para>The reduction in vertex count is controlled by the <varname>vertex_fraction</varname> parameter,
        which is a number in the range 0 to 1.
        Lower values produce simpler results, with smaller vertex count and less concaveness.
        For both outer and inner hulls a vertex fraction of 1.0 produces the orginal geometry.
        For outer hulls a value of 0.0 produces the convex hull (for a single polygon);
        for inner hulls it produces a triangle.</para>

        <para>
        The simplification process operates by progressively removing concave corners that contain the least amount of area, until the vertex count target is reached.
        It prevents edges from crossing, so the result is always a valid polygonal geometry.
        </para>

        <para>To get better results with geometries that contain relatively long line segments, it might be necessary to "segmentize" the input, as shown below.</para>

        <para>Performed by the GEOS module.</para>
    	<para>Availability: 3.3.0 - requires GEOS &gt;= 3.11.0 </para>

      </refsection>
      <refsection>
        <title>Examples</title>

    <para>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_simplifypolygonhull02.png" />
        </imageobject>
        <caption><para>Outer hull of a Polygon</para></caption>
      </mediaobject>
    </informalfigure>
    <programlisting>SELECT ST_SimplifyPolygonHull(
  'POLYGON ((131 158, 136 163, 161 165, 173 156, 179 148, 169 140, 186 144, 190 137, 185 131, 174 128, 174 124, 166 119, 158 121, 158 115, 165 107, 161 97, 166 88, 166 79, 158 57, 145 57, 112 53, 111 47, 93 43, 90 48, 88 40, 80 39, 68 32, 51 33, 40 31, 39 34, 49 38, 34 38, 25 34, 28 39, 36 40, 44 46, 24 41, 17 41, 14 46, 19 50, 33 54, 21 55, 13 52, 11 57, 22 60, 34 59, 41 68, 75 72, 62 77, 56 70, 46 72, 31 69, 46 76, 52 82, 47 84, 56 90, 66 90, 64 94, 56 91, 33 97, 36 100, 23 100, 22 107, 29 106, 31 112, 46 116, 36 118, 28 131, 53 132, 59 127, 62 131, 76 130, 80 135, 89 137, 87 143, 73 145, 80 150, 88 150, 85 157, 99 162, 116 158, 115 165, 123 165, 122 170, 134 164, 131 158))',
    0.3);
</programlisting>
    </para>

    <para>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_simplifypolygonhull03.png" />
        </imageobject>
        <caption><para>Inner hull of a Polygon</para></caption>
      </mediaobject>
    </informalfigure>
    <programlisting>SELECT ST_SimplifyPolygonHull(
  'POLYGON ((131 158, 136 163, 161 165, 173 156, 179 148, 169 140, 186 144, 190 137, 185 131, 174 128, 174 124, 166 119, 158 121, 158 115, 165 107, 161 97, 166 88, 166 79, 158 57, 145 57, 112 53, 111 47, 93 43, 90 48, 88 40, 80 39, 68 32, 51 33, 40 31, 39 34, 49 38, 34 38, 25 34, 28 39, 36 40, 44 46, 24 41, 17 41, 14 46, 19 50, 33 54, 21 55, 13 52, 11 57, 22 60, 34 59, 41 68, 75 72, 62 77, 56 70, 46 72, 31 69, 46 76, 52 82, 47 84, 56 90, 66 90, 64 94, 56 91, 33 97, 36 100, 23 100, 22 107, 29 106, 31 112, 46 116, 36 118, 28 131, 53 132, 59 127, 62 131, 76 130, 80 135, 89 137, 87 143, 73 145, 80 150, 88 150, 85 157, 99 162, 116 158, 115 165, 123 165, 122 170, 134 164, 131 158))',
    0.3, false);
</programlisting>
    </para>

    <para>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/st_simplifypolygonhull01.png" />
        </imageobject>
        <caption><para>Outer hull simplification of a MultiPolygon, with segmentization</para></caption>
      </mediaobject>
    </informalfigure>
    <programlisting>SELECT ST_SimplifyPolygonHull(
  ST_Segmentize(ST_Letters('xt'), 2.0),
    0.1);
</programlisting>
    </para>

      </refsection>

      <refsection>
        <title>See Also</title>
        <para><xref linkend="ST_ConvexHull" />, <xref linkend="ST_SimplifyVW" />, <xref linkend="ST_ConcaveHull" />, <xref linkend="ST_Segmentize" /></para>
      </refsection>
    </refentry>


    <refentry id="ST_SimplifyVW">
      <refnamediv>
        <refname>ST_SimplifyVW</refname>
        <refpurpose>Returns a simplified version of a geometry, using the Visvalingam-Whyatt algorithm</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_SimplifyVW</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para> Returns a "simplified" version of the given geometry using the Visvalingam-Whyatt algorithm.
        Will actually do something only with (multi)lines and (multi)polygons but you can safely call it with any kind of geometry.
        Since simplification occurs on a object-by-object basis you can also feed a GeometryCollection to this function.</para>

        <note><para>Note that returned geometry might lose its
                simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
        <note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>
        <note><para>This function handles 3D and the third dimension will affect the result.</para></note>
        <para>Availability: 2.2.0</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>A LineString is simplified with a minimum area threshold of 30.</para>
                <programlisting>

select ST_AsText(ST_SimplifyVW(geom,30)) simplified
FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As foo;
-result
 simplified
------------------------------
LINESTRING(5 2,7 25,10 10)

                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_SetEffectiveArea" />, <xref linkend="ST_Simplify" />, <xref linkend="ST_SimplifyPreserveTopology" />, Topology <xref linkend="TP_ST_Simplify"/></para>
          </refsection>
    </refentry>

    <refentry id="ST_SetEffectiveArea">
      <refnamediv>
        <refname>ST_SetEffectiveArea</refname>
        <refpurpose>
            Sets the effective area for each vertex, using the Visvalingam-Whyatt algorithm.
        </refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_SetEffectiveArea</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
            <paramdef><type>float</type> <parameter>threshold = 0</parameter></paramdef>
            <paramdef><type>integer</type> <parameter>set_area = 1</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>
            Sets the effective area for each vertex, using the Visvalingam-Whyatt algorithm.
            The effective area is stored as the M-value of the vertex.
            If the optional "theshold" parameter is used, a simplified geometry will be returned, containing only vertices with an effective area
            greater than or equal to the threshold value.
            </para><para>
            This function can be used for server-side simplification when a threshold is specified.  Another option is to use a threshold value of zero.
            In this case, the full geometry will be returned with effective areas as M-values, which can be used by the client to simplify very quickly.
            </para><para>
            Will actually do something only with
            (multi)lines and (multi)polygons but you can safely call it with
            any kind of geometry. Since simplification occurs on a
            object-by-object basis you can also feed a GeometryCollection to
            this function.
            </para>


        <note><para>Note that returned geometry might lose its
                simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
        <note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>
        <note><para>The output geometry will lose all previous information in the M-values</para></note>
        <note><para>This function handles 3D and the third dimension will affect the effective area</para></note>
        <para>Availability: 2.2.0</para>
      </refsection>

          <refsection>
            <title>Examples</title>
            <para>
                Calculating the effective area of a LineString.  Because we use a threshold value of zero, all vertices in the input geometry are returned.
            </para>
                <programlisting>

select ST_AsText(ST_SetEffectiveArea(geom)) all_pts, ST_AsText(ST_SetEffectiveArea(geom,30) ) thrshld_30
FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As foo;
-result
 all_pts | thrshld_30
-----------+-------------------+
LINESTRING M (5 2 3.40282346638529e+38,3 8 29,6 20 1.5,7 25 49.5,10 10 3.40282346638529e+38) | LINESTRING M (5 2 3.40282346638529e+38,7 25 49.5,10 10 3.40282346638529e+38)

                </programlisting>
          </refsection>
          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_SimplifyVW" /></para>
          </refsection>
    </refentry>

    <refentry id="ST_TriangulatePolygon">
      <refnamediv>
        <refname>ST_TriangulatePolygon</refname>
        <refpurpose>Computes the constrained Delaunay triangulation of polygons</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_TriangulatePolygon</function></funcdef>
            <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>Computes the constrained Delaunay triangulation of polygons.
        Holes and Multipolygons are supported.
        </para>
        <para>
        The "constrained Delaunay triangulation" of a polygon is a set of triangles formed from the vertices of the polygon,
        and covering it exactly, with the maximum total interior angle over all possible triangulations.
        It provides the "best quality" triangulation of the polygon.</para>

        <para>Availability: 3.3.0 - requires GEOS &gt;= 3.11.0</para>
      </refsection>

          <refsection>
            <title>Example</title>
            <para>Triangulation of a square.</para>
                <programlisting>
SELECT ST_AsText(
    ST_TriangulatePolygon('POLYGON((0 0, 0 1, 1 1, 1 0, 0 0))'));

                                 st_astext
---------------------------------------------------------------------------
 GEOMETRYCOLLECTION(POLYGON((0 0,0 1,1 1,0 0)),POLYGON((1 1,1 0,0 0,1 1)))
                </programlisting>
          </refsection>
      <refsection>
            <title>Example</title>
            <para>Triangulation of the letter P.</para>
            <programlisting>SELECT ST_AsText(ST_TriangulatePolygon(
    'POLYGON ((26 17, 31 19, 34 21, 37 24, 38 29, 39 43, 39 161, 38 172, 36 176, 34 179, 30 181, 25 183, 10 185, 10 190, 100 190, 121 189, 139 187, 154 182, 167 177, 177 169, 184 161, 189 152, 190 141, 188 128, 186 123, 184 117, 180 113, 176 108, 170 104, 164 101, 151 96, 136 92, 119 89, 100 89, 86 89, 73 89, 73 39, 74 32, 75 27, 77 23, 79 20, 83 18, 89 17, 106 15, 106 10, 10 10, 10 15, 26 17), (152 147, 151 152, 149 157, 146 162, 142 166, 137 169, 132 172, 126 175, 118 177, 109 179, 99 180, 89 180, 80 179, 76 178, 74 176, 73 171, 73 100, 85 99, 91 99, 102 99, 112 100, 121 102, 128 104, 134 107, 139 110, 143 114, 147 118, 149 123, 151 128, 153 141, 152 147))'
    ));
</programlisting>
            <informalfigure>
            <mediaobject>
            <imageobject>
            <imagedata fileref="images/st_triangulatepolygon01.png" />
            </imageobject>
            <caption><para>Polygon Triangulation</para></caption>
            </mediaobject>
            </informalfigure>
        </refsection>

          <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_DelaunayTriangles" />, <xref linkend="ST_ConstrainedDelaunayTriangles" />, <xref linkend="ST_Tesselate" /></para>
          </refsection>
    </refentry>

    <refentry id="ST_VoronoiLines">
      <refnamediv>
        <refname>ST_VoronoiLines</refname>

        <refpurpose>Returns the boundaries of the Voronoi diagram of the vertices of a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_VoronoiLines</function></funcdef>
            <paramdef>
                <parameter>g1</parameter>
                <type>geometry</type>
            </paramdef>
            <paramdef choice="opt">
                <parameter>tolerance</parameter>
                <type>float8</type>
            </paramdef>
            <paramdef choice="opt">
                <parameter>extend_to</parameter>
                <type>geometry</type>
            </paramdef>
          </funcprototype>

        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
        <para>
            ST_VoronoiLines computes a two-dimensional <ulink url="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</ulink> from the vertices of
            the supplied geometry and returns the boundaries between cells in that diagram as a MultiLineString.
            Returns null if input geometry is null. Returns an empty geometry collection if the input geometry contains only one vertex. Returns an empty geometry collection if the extend_to envelope has zero area.
        </para>
        <para>
            Optional parameters:
            <itemizedlist>
                <listitem>
                    <para> 'tolerance' : The distance within which vertices will be considered equivalent.  Robustness of the algorithm can be improved by supplying a nonzero tolerance distance.  (default = 0.0)</para>
                </listitem>
                <listitem>
                    <para>'extend_to' : If a geometry is supplied as the "extend_to" parameter, the diagram will be extended to cover the envelope of the "extend_to" geometry, unless
                        that envelope is smaller than the default envelope (default = NULL, default envelope is boundingbox of input geometry extended by about 50% in each direction).</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 2.3.0</para>
      </refsection>

      <!-- Examples -->
      <refsection>
        <title>Examples</title>
        <informaltable>
          <tgroup cols="1">
            <tbody>
             <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_voronoi03.png" />
                      </imageobject>
                      <caption><para>Voronoi lines with tolerance of 30 units</para></caption>
                    </mediaobject>
                  </informalfigure>
                    <programlisting>SELECT ST_VoronoiLines(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g</programlisting>
<screen> -- ST_AsText output
MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 -45.7142857142858,36.8181818181818 92.2727272727273))
</screen>
                </para></entry>
              </row>
        </tbody>
        </tgroup>
        </informaltable>

      </refsection>

      <!-- Optionally add a "See Also" section -->
      <refsection>
        <title>See Also</title>

        <para>
            <xref linkend="ST_DelaunayTriangles" />,
            <xref linkend="ST_VoronoiPolygons" />,
            <xref linkend="ST_Collect" />
        </para>
      </refsection>
    </refentry>

    <refentry id="ST_VoronoiPolygons">
      <refnamediv>
        <refname>ST_VoronoiPolygons</refname>

        <refpurpose>Returns the cells of the Voronoi diagram of the vertices of a geometry.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_VoronoiPolygons</function></funcdef>
            <paramdef>
                <parameter>g1</parameter>
                <type>geometry</type>
            </paramdef>
            <paramdef choice="opt">
                <parameter>tolerance</parameter>
                <type>float8</type>
            </paramdef>
            <paramdef choice="opt">
                <parameter>extend_to</parameter>
                <type>geometry</type>
            </paramdef>
          </funcprototype>

        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>

        <para>
            ST_VoronoiPolygons computes a two-dimensional <ulink url="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</ulink> from the vertices of
            the supplied geometry.  The result is a GeometryCollection of Polygons that covers an envelope larger than the extent of the input vertices.
            Returns null if input geometry is null. Returns an empty geometry collection if the input geometry contains only one vertex. Returns an empty geometry collection if the extend_to envelope has zero area.
        </para>

        <para>
            Optional parameters:
            <itemizedlist>
                <listitem>
                    <para> 'tolerance' : The distance within which vertices will be considered equivalent.  Robustness of the algorithm can be improved by supplying a nonzero tolerance distance.  (default = 0.0)</para>
                </listitem>
                <listitem>
                    <para>'extend_to' : If a geometry is supplied as the "extend_to" parameter, the diagram will be extended to cover the envelope of the "extend_to" geometry, unless
                        that envelope is smaller than the default envelope (default = NULL, default envelope is boundingbox of input geometry extended by about 50% in each direction).
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>Performed by the GEOS module.</para>
        <para>Availability: 2.3.0</para>
      </refsection>

      <!-- Examples -->
      <refsection>
        <title>Examples</title>
        <informaltable>
          <tgroup cols="1">
            <tbody>
              <row>
                <entry>
                    <para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_voronoi01.png" />
                      </imageobject>
                      <caption><para>Points overlaid on top of Voronoi diagram</para></caption>
                    </mediaobject>
                    </informalfigure>
                    <programlisting>SELECT
    ST_VoronoiPolygons(geom) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g;</programlisting>
<screen> -- ST_AsText output
GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 43.3333333333333)),
POLYGON((55 -90,-110 -90,-110 43.3333333333333,36.8181818181818 92.2727272727273,55 79.2857142857143,55 -90)),
POLYGON((230 47.5,230 -20.7142857142857,55 79.2857142857143,36.8181818181818 92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 -20.7142857142857,230 -90,55 -90,55 79.2857142857143,230 -20.7142857142857)),
POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 270)))
</screen>
                    </para>
                </entry>
            </row>
            <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_voronoi02.png" />
                      </imageobject>
                      <caption><para>Voronoi with tolerance of 30 units</para></caption>
                    </mediaobject>
                  </informalfigure>
                    <programlisting>SELECT ST_VoronoiPolygons(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g;</programlisting>
<screen> -- ST_AsText output
GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 43.3333333333333)),
POLYGON((230 47.5,230 -45.7142857142858,36.8181818181818 92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 -45.7142857142858,230 -90,-110 -90,-110 43.3333333333333,36.8181818181818 92.2727272727273,230 -45.7142857142858)),
POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 270)))
</screen>
                </para></entry>
              </row>
             <row>
                <entry><para><informalfigure>
                    <mediaobject>
                      <imageobject>
                        <imagedata fileref="images/st_voronoi03.png" />
                      </imageobject>
                      <caption><para>Voronoi with tolerance of 30 units as MultiLineString</para></caption>
                    </mediaobject>
                  </informalfigure>
                    <programlisting>SELECT ST_VoronoiLines(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g</programlisting>
<screen> -- ST_AsText output
MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 -45.7142857142858,36.8181818181818 92.2727272727273))
</screen>
                </para></entry>
              </row>
        </tbody>
        </tgroup>
        </informaltable>

      </refsection>

      <!-- Optionally add a "See Also" section -->
      <refsection>
        <title>See Also</title>

        <para>
            <xref linkend="ST_DelaunayTriangles" />,
            <xref linkend="ST_VoronoiLines" />,
            <xref linkend="ST_Collect" />
        </para>
      </refsection>
    </refentry>
</sect1>
