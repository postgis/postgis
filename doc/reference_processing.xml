<?xml version="1.0" encoding="UTF-8"?>
	<sect1 id="Geometry_Processing">
		<title>Geometry Processing</title>
		<refentry id="ST_Buffer">
			<refnamediv>
				<refname>ST_Buffer</refname>

				<refpurpose>
(T)
Returns a geometry covering all points within a given distance
from the input geometry.
			</refpurpose>
			</refnamediv>

			<refsynopsisdiv>
				<funcsynopsis>

				  <funcprototype>
					<funcdef>geometry <function>ST_Buffer</function></funcdef>
					<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
					<paramdef choice="opt"><type>text </type> <parameter>buffer_style_parameters=''</parameter></paramdef>
				  </funcprototype>

				  <funcprototype>
					<funcdef>geometry <function>ST_Buffer</function></funcdef>
					<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
					<paramdef><type>integer </type> <parameter>num_seg_quarter_circle</parameter></paramdef>
				  </funcprototype>

				  <funcprototype>
					<funcdef>geography <function>ST_Buffer</function></funcdef>
					<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
					<paramdef choice="opt"><type>text </type> <parameter>buffer_style_parameters</parameter></paramdef>
				  </funcprototype>

				  <funcprototype>
					<funcdef>geography <function>ST_Buffer</function></funcdef>
					<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
					<paramdef><type>integer </type> <parameter>num_seg_quarter_circle</parameter></paramdef>
				  </funcprototype>

				</funcsynopsis>
			</refsynopsisdiv>

			  <refsection>
				<title>Description</title>

				<para>Returns a geometry/geography that represents all points whose distance
			from this Geometry/geography is less than or equal to distance. </para>
			<para>Geometry: Calculations
			are in the Spatial Reference System of the geometry. Introduced in 1.5 support for
			different end cap and mitre settings to control shape.</para>
			<note><para>Negative radii: For polygons, a negative radius can be used, which will shrink the polygon rather than expanding it.</para></note>
				<note><para>Geography: For geography this is really a thin wrapper around the geometry implementation. It first determines the best SRID that
					fits the bounding box of the geography object (favoring UTM, Lambert Azimuthal Equal Area (LAEA) north/south pole, and falling back on mercator in worst case scenario) and then buffers in that planar spatial ref and retransforms back to WGS84 geography.</para></note>
			<warning><para>
			For geography this may not behave as expected if object is sufficiently large that it falls between two UTM zones or crosses the dateline</para></warning>
				<para>Enhanced: 2.5.0 - ST_Buffer geometry support was enhanced to allow for side buffering specification <code>side=both|left|right</code>.</para>
				<para>Availability: 1.5 - ST_Buffer was enhanced to support different endcaps and join types. These are useful for example to convert road linestrings
					into polygon roads with flat or square edges instead of rounded edges. Thin wrapper for geography was added.
				</para>
				<para>
The optional third parameter (currently only applies to geometry) can either specify number of segments used to approximate a quarter circle (integer case, defaults to 8) or a list of blank-separated key=value pairs (string case) to tweak operations as follows:
<itemizedlist>
<listitem>
<para>'quad_segs=#' : number of segments used to approximate a quarter circle (defaults to 8).</para>
</listitem>
<listitem>
<para>'endcap=round|flat|square' : endcap style (defaults to "round"). 'butt' is also accepted as a synonym for 'flat'.</para>
</listitem>
<listitem>
<para>'join=round|mitre|bevel' : join style (defaults to "round"). 'miter' is also accepted as a synonym for 'mitre'.</para>
</listitem>
<listitem>
<para>'mitre_limit=#.#' : mitre ratio limit (only affects mitered join style). 'miter_limit' is also accepted as a synonym for 'mitre_limit'.</para>
</listitem>
<listitem>
<para>'side=both|left|right' : 'left' or 'right' performs a single-sided buffer on the geometry, with the buffered side relative to the direction of the line.
This is only really relevant to LINESTRING geometry and does not affect POINT or POLYGON geometries. By default end caps are square.</para>
</listitem>
</itemizedlist>
				</para>

				<para>Units of radius are measured in units of the spatial reference system.</para>
				<para>The inputs can be POINTS, MULTIPOINTS, LINESTRINGS, MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS, and GeometryCollections.</para>
				<note><para>This function ignores the third dimension (z) and will always give a 2-d buffer even when presented with a 3d-geometry.</para></note>

				<para>Performed by the GEOS module.</para>
				<para>&sfs_compliant; s2.1.1.3</para>
				<para>&sqlmm_compliant; SQL-MM 3: 5.1.17</para>

				<note><para>People often make the mistake of using this function to try to do radius searches.  Creating a
					buffer to a radius search is slow and pointless.  Use <xref linkend="ST_DWithin" /> instead.</para></note>
			</refsection>

			  <refsection>
				<title>Examples</title>

				<informaltable>
				  <tgroup cols="2">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer01.png" />
							  </imageobject>
							  <caption><para>quad_segs=8 (default)</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText('POINT(100 90)'),
 50, 'quad_segs=8');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer02.png" />
							  </imageobject>
							  <caption><para>quad_segs=2 (lame)</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText('POINT(100 90)'),
 50, 'quad_segs=2');
				</programlisting>
						</para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer03.png" />
							  </imageobject>
							  <caption><para>endcap=round join=round (default)</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=round join=round');
				</programlisting>
						 </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer04.png" />
							  </imageobject>
							  <caption><para>endcap=square</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=square join=round');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer05.png" />
							  </imageobject>
							  <caption><para>endcap=flat</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=flat join=round');
				</programlisting>
						  </para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer07.png" />
							  </imageobject>
							  <caption><para>join=bevel</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=bevel');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer06.png" />
							  </imageobject>
							  <caption><para>join=mitre mitre_limit=5.0 (default mitre limit)</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=mitre mitre_limit=5.0');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer08.png" />
							  </imageobject>
							  <caption><para>join=mitre mitre_limit=1</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=mitre mitre_limit=1.0');
				</programlisting>
						  </para></entry>
					  </row>
						<row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer09.png" />
							  </imageobject>
							  <caption><para>side=left</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'side=left');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer10.png" />
							  </imageobject>
							  <caption><para>side=right</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'side=right');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer11.png" />
							  </imageobject>
							  <caption><para>side=left join=mitre</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'side=left join=mitre');
				</programlisting>
						  </para></entry>
					  </row>
						<row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer12.png" />
							  </imageobject>
							  <caption><para>right-hand-winding, polygon boundary side=left</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
ST_ForceRHR(
ST_Boundary(
 ST_GeomFromText(
'POLYGON ((50 50, 50 150, 150 150, 150 50, 50 50))'))),
 ), 20, 'side=left');
				</programlisting>
						  </para></entry>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer13.png" />
							  </imageobject>
							  <caption><para>right-hand-winding, polygon boundary side=right</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
ST_ForceRHR(
ST_Boundary(
 ST_GeomFromText(
'POLYGON ((50 50, 50 150, 150 150, 150 50, 50 50))'))
), 20,'side=right')
				</programlisting>
				</para></entry>
				</row>
					</tbody>
				  </tgroup>
			</informaltable>

<programlisting>--A buffered point approximates a circle
-- A buffered point forcing approximation of (see diagram)
-- 2 points per quarter circle is poly with 8 sides (see diagram)
SELECT ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As promisingcircle_pcount,
ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50, 2)) As lamecircle_pcount;

promisingcircle_pcount | lamecircle_pcount
------------------------+-------------------
			 33 |                9

--A lighter but lamer circle
-- only 2 points per quarter circle is an octagon
--Below is a 100 meter octagon
-- Note coordinates are in NAD 83 long lat which we transform
to Mass state plane meter and then buffer to get measurements in meters;
SELECT ST_AsText(ST_Buffer(
ST_Transform(
ST_SetSRID(ST_MakePoint(-71.063526, 42.35785),4269), 26986)
,100,2)) As octagon;
----------------------
POLYGON((236057.59057465 900908.759918696,236028.301252769 900838.049240578,235
957.59057465 900808.759918696,235886.879896532 900838.049240578,235857.59057465
900908.759918696,235886.879896532 900979.470596815,235957.59057465 901008.759918
696,236028.301252769 900979.470596815,236057.59057465 900908.759918696))
		</programlisting>
			  </refsection>

			  <refsection>
				<title>See Also</title>

				<para><xref linkend="ST_Collect" />, <xref linkend="ST_DWithin" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_Transform" />, <xref linkend="ST_Union" /></para>
			  </refsection>
		</refentry>

		<refentry id="ST_BuildArea">
		  <refnamediv>
			<refname>ST_BuildArea</refname>

			<refpurpose>Creates an areal geometry formed by the constituent linework
			of given geometry</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_BuildArea</function></funcdef>
				<paramdef><type>geometry </type> <parameter>A</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Creates an areal geometry formed by the constituent linework
			of given geometry. The return type can be a Polygon or
			MultiPolygon, depending on input. If the input lineworks do not
			form polygons NULL is returned.  The inputs can be LINESTRINGS, MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS, and GeometryCollections.
			</para>
			<para>This function will assume all inner geometries represent holes</para>

			<note>
				<para>Input linework must be correctly noded for this function to work properly</para>
			</note>

			<para>Availability: 1.1.0</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
			<informaltable>
				  <tgroup cols="1">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buildarea01.png" />
							  </imageobject>
							  <caption><para>This will create a donut</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_BuildArea(ST_Collect(smallc,bigc))
FROM (SELECT
	ST_Buffer(
	  ST_GeomFromText('POINT(100 90)'), 25) As smallc,
	ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As bigc) As foo;
				</programlisting>
						  </para></entry>
					</row>
					<row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buildarea02.png" />
							  </imageobject>
							  <caption><para>This will create a gaping hole inside the circle with prongs sticking out</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_BuildArea(ST_Collect(line,circle))
FROM (SELECT
	ST_Buffer(
		ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)),
				5)  As line,
	ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

--this creates the same gaping hole
--but using linestrings instead of polygons
SELECT ST_BuildArea(
	ST_Collect(ST_ExteriorRing(line),ST_ExteriorRing(circle))
	)
FROM (SELECT ST_Buffer(
	ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190))
		,5)  As line,
	ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

				</programlisting>
						</para></entry>
					  </row>
					</tbody>
				  </tgroup>
			</informaltable>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para>
			<xref linkend="ST_Node" />,
			<xref linkend="ST_MakePolygon" />,
			<xref linkend="ST_BdPolyFromText" />,
			<xref linkend="ST_BdMPolyFromText" />wrappers to
			this function with standard OGC interface</para>
		  </refsection>
	</refentry>

  <refentry id="ST_Centroid">
	<refnamediv>
	  <refname>ST_Centroid</refname>

	  <refpurpose>Returns the geometric center of a geometry.</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
          <funcprototype>
  		  <funcdef>geometry <function>ST_Centroid</function></funcdef>

  		  <paramdef><type>geometry </type>
  		  <parameter>g1</parameter></paramdef>
  		</funcprototype>
            <funcprototype>
                <funcdef>geography <function>ST_Centroid</function></funcdef>

                <paramdef><type>geography </type>
                <parameter>g1</parameter></paramdef>
                <paramdef choice="opt"><type>boolean </type>
                <parameter>use_spheroid=true</parameter></paramdef>
	</funcprototype>

	  </funcsynopsis>
	</refsynopsisdiv>

	<refsection>
	  <title>Description</title>

	  <para>Computes the geometric center of a geometry, or equivalently,
	  the center of mass of the geometry as a <varname>POINT</varname>. For
	  [<varname>MULTI</varname>]<varname>POINT</varname>s, this is computed
	  as the arithmetic mean of the input coordinates. For
	  [<varname>MULTI</varname>]<varname>LINESTRING</varname>s, this is
	  computed as the weighted length of each line segment. For
	  [<varname>MULTI</varname>]<varname>POLYGON</varname>s, "weight" is
	  thought in terms of area. If an empty geometry is supplied, an empty
	  <varname>GEOMETRYCOLLECTION</varname> is returned. If
	  <varname>NULL</varname> is supplied, <varname>NULL</varname> is
	  returned.
	  If <varname>CIRCULARSTRING</varname> or <varname>COMPOUNDCURVE</varname>
	  are supplied, they are converted to linestring wtih CurveToLine first,
	  then same than for  <varname>LINESTRING</varname>
	  </para>
	  <para>New in 2.3.0 : support <varname>CIRCULARSTRING</varname> and <varname>COMPOUNDCURVE</varname> (using CurveToLine)</para>

      <para>Availability: 2.4.0 support for geography was introduced.</para>

	  <para>The centroid is equal to the centroid of the set of component
	  Geometries of highest dimension (since the lower-dimension geometries
	  contribute zero "weight" to the centroid).</para>

	  <para>&sfs_compliant;</para>
	  <para>&sqlmm_compliant; SQL-MM 3: 8.1.4, 9.5.5</para>
	</refsection>

	<refsection>
	  <title>Examples</title>

	  <para>In each of the following illustrations, the green dot represents
	  the centroid of the source geometry.</para>

	  <informaltable>
		<tgroup cols="2">
		  <tbody>
			<row>
			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_centroid01.png" />
					</imageobject>

					<caption><para>Centroid of a
					<varname>MULTIPOINT</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>

			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_centroid02.png" />
					</imageobject>

					<caption><para>Centroid of a
					<varname>LINESTRING</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>
			</row>

			<row>
			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_centroid03.png" />
					</imageobject>

					<caption><para>Centroid of a
					<varname>POLYGON</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>

			  <entry><para><informalfigure>
				  <mediaobject>
					<imageobject>
					  <imagedata fileref="images/st_centroid04.png" />
					</imageobject>

					<caption><para>Centroid of a
					<varname>GEOMETRYCOLLECTION</varname></para></caption>
				  </mediaobject>
				</informalfigure></para></entry>
			</row>
		  </tbody>
		</tgroup>
	  </informaltable>

	  <programlisting>SELECT ST_AsText(ST_Centroid('MULTIPOINT ( -1 0, -1 2, -1 3, -1 4, -1 7, 0 1, 0 3, 1 1, 2 0, 6 0, 7 8, 9 8, 10 6 )'));
				st_astext
------------------------------------------
 POINT(2.30769230769231 3.30769230769231)
(1 row)

SELECT ST_AsText(ST_centroid(g))
FROM  ST_GeomFromText('CIRCULARSTRING(0 2, -1 1,0 0, 0.5 0, 1 0, 2 1, 1 2, 0.5 2, 0 2)')  AS g ;
------------------------------------------
POINT(0.5 1)


SELECT ST_AsText(ST_centroid(g))
FROM  ST_GeomFromText('COMPOUNDCURVE(CIRCULARSTRING(0 2, -1 1,0 0),(0 0, 0.5 0, 1 0),CIRCULARSTRING( 1 0, 2 1, 1 2),(1 2, 0.5 2, 0 2))' ) AS g;
------------------------------------------
POINT(0.5 1)

</programlisting>
	</refsection>

	<refsection>
	  <title>See Also</title>

	  <para><xref linkend="ST_PointOnSurface" />, <xref linkend="ST_GeometricMedian" /></para>
	</refsection>
  </refentry>

	<refentry id="ST_ClipByBox2D">
	  <refnamediv>
		<refname>ST_ClipByBox2D</refname>
		<refpurpose>Returns the portion of a geometry falling within a rectangle.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>geometry <function>ST_ClipByBox2D</function></funcdef>
				<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
				<paramdef><type>box2d</type> <parameter>box</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
			Clips a geometry by a 2D box in a fast but possibly dirty way.
			The output geometry is not guaranteed to be valid (self-intersections for a polygon may be introduced).
			Topologically invalid input geometries do not result in exceptions being thrown.
		</para>

		<para>Performed by the GEOS module.</para>

		<para>Availability: 2.2.0</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>
			<programlisting>
-- Rely on implicit cast from geometry to box2d for the second parameter
SELECT ST_ClipByBox2D(the_geom, ST_MakeEnvelope(0,0,10,10)) FROM mytab;
      </programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para>
<xref linkend="ST_Intersection" />,
<xref linkend="ST_MakeBox2D" />,
<xref linkend="ST_MakeEnvelope" />
    </para>
	  </refsection>
	</refentry>


	<refentry id="ST_ConcaveHull">
	  <refnamediv>
		<refname>ST_ConcaveHull</refname>
		<refpurpose>The concave hull of a geometry represents a possibly concave
		geometry that encloses all geometries within the set.  You can think of it as shrink wrapping.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		 <funcprototype>
			<funcdef>geometry <function>ST_ConcaveHull</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>target_percent</parameter></paramdef>
			<paramdef choice="opt"><type>boolean </type> <parameter>allow_holes=false</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>The concave hull of a geometry represents a possibly concave
		geometry that encloses all geometries within the set. Defaults to false for allowing polygons with holes.
		The result is never higher than a single polygon.</para>

		<para>The target_percent is the target percent of area of convex hull the PostGIS solution will try to approach before giving up or exiting.
		One can think of the concave hull as the geometry you get by vacuum sealing a set of geometries. The
			target_percent of 1 will give you the same answer as the convex hull.  A target_percent
				between 0 and 0.99 will give you something that should have a smaller area than the convex hull.  This is different from a convex hull which is more like wrapping a rubber band around the set of geometries.</para>

			<para>It is usually used with MULTI and Geometry Collections.
		Although it is not an aggregate - you can use it in conjunction
		with ST_Collect or ST_Union to get the concave hull of a set of points/linestring/polygons
		ST_ConcaveHull(ST_Collect(somepointfield), 0.80).</para>

		<para>It is much slower to compute than convex hull but encloses the geometry better and is also useful for
			image recognition.</para>

		<para>Performed by the GEOS module</para>
		<note><para>Note - If you are using with points, linestrings, or geometry collections use ST_Collect. If you are using with polygons, use ST_Union since
			it may fail with invalid geometries.</para></note>

		<note><para>Note - The smaller you make the target percent, the longer it takes to process the concave hull and more likely to run into topological exceptions. Also the more
			floating points and number of points you accrue.  First try a 0.99 which does a first hop, is usually very fast, sometimes as fast as computing the convex hull, and usually gives much better than 99% of shrink since it almost always overshoots. Second hope of 0.98 it slower, others get slower usually quadratically.
			To reduce precision and float points, use <xref linkend="ST_SimplifyPreserveTopology" /> or <xref linkend="ST_SnapToGrid" /> after ST_ConcaveHull. ST_SnapToGrid is a bit faster, but
				could result in invalid geometries where as ST_SimplifyPreserveTopology almost always preserves the validity of the geometry.</para></note>

		<para>More real world examples and brief explanation of the technique are shown <ulink
		url="http://www.bostongis.com/postgis_concavehull.snippet">http://www.bostongis.com/postgis_concavehull.snippet</ulink></para>

		<para>Also check out Simon Greener's article on demonstrating ConcaveHull introduced in Oracle 11G R2. <ulink
		url="http://www.spatialdbadvisor.com/oracle_spatial_tips_tricks/172/concave-hull-geometries-in-oracle-11gr2">http://www.spatialdbadvisor.com/oracle_spatial_tips_tricks/172/concave-hull-geometries-in-oracle-11gr2</ulink>.
		The solution we get at 0.75 target percent of convex hull is similar to the shape Simon gets with  Oracle SDO_CONCAVEHULL_BOUNDARY.</para>

		<para>Availability: 2.0.0</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
<programlisting>
--Get estimate of infected area based on point observations
SELECT d.disease_type,
	ST_ConcaveHull(ST_Collect(d.pnt_geom), 0.99) As geom
	FROM disease_obs As d
	GROUP BY d.disease_type;
</programlisting>
			<informaltable>
				  <tgroup cols="2">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_concavehull03.png" />
							  </imageobject>
							  <caption><para>ST_ConcaveHull of 2 polygons encased in target 100% shrink concave hull</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
-- geometries overlaid with concavehull
-- at target 100% shrink (this is the same as convex hull - since no shrink)
SELECT
	ST_ConcaveHull(
		ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		), 1)
	 As convexhull;
				</programlisting>
						  </para></entry>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_concavehull02.png" />
							  </imageobject>
							  <caption><para>-- geometries overlaid with concavehull
								at target 90% of convex hull area</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
-- geometries overlaid with concavehull at target 90% shrink
SELECT
	ST_ConcaveHull(
		ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		), 0.9)
	 As target_90;
				</programlisting>
						</para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_concavehull04.png" />
							  </imageobject>
							  <caption><para>L Shape points overlaid with convex hull</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
-- this produces a table of 42 points that form an L shape
SELECT (ST_DumpPoints(ST_GeomFromText(
'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,
150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,
14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,
6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,
14 94,14 74,14 54,14 34,14 14)'))).geom
	INTO TABLE l_shape;

SELECT ST_ConvexHull(ST_Collect(geom))
FROM l_shape;
				</programlisting>
						  </para></entry>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_concavehull05.png" />
							  </imageobject>
							  <caption><para>ST_ConcaveHull of L points at target 99% of convex hull</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_ConcaveHull(ST_Collect(geom), 0.99)
	FROM l_shape;
				</programlisting>
						  </para></entry>
		</row>
		<row>
			<entry><para><informalfigure>
				<mediaobject>
				  <imageobject>
					<imagedata fileref="images/st_concavehull06.png" />
				  </imageobject>
				  <caption><para>Concave Hull of L points at target 80% convex hull area</para></caption>
				</mediaobject>
			  </informalfigure>
	<programlisting>
	-- Concave Hull L shape points
	-- at target 80% of convexhull
	SELECT ST_ConcaveHull(ST_Collect(geom), 0.80)
	FROM l_shape;
	</programlisting>
			</para>
			</entry>
			<entry><para>
				<informalfigure>
				<mediaobject>
				  <imageobject>
					<imagedata fileref="images/st_concavehull07.png" />
				  </imageobject>
				  <caption><para>multilinestring overlaid with Convex hull</para></caption>
				</mediaobject>
			  </informalfigure>
				<informalfigure>
				<mediaobject>
				  <imageobject>
					<imagedata fileref="images/st_concavehull08.png" />
				  </imageobject>
				  <caption><para>multilinestring with overlaid with Concave hull
				  of linestrings at 99% target -- first hop</para></caption>
				</mediaobject>
			  </informalfigure>
	<programlisting>
SELECT ST_ConcaveHull(ST_GeomFromText('MULTILINESTRING((106 164,30 112,74 70,82 112,130 94,
	130 62,122 40,156 32,162 76,172 88),
(132 178,134 148,128 136,96 128,132 108,150 130,
170 142,174 110,156 96,158 90,158 88),
(22 64,66 28,94 38,94 68,114 76,112 30,
132 10,168 18,178 34,186 52,184 74,190 100,
190 122,182 148,178 170,176 184,156 164,146 178,
132 186,92 182,56 158,36 150,62 150,76 128,88 118))'),0.99)
	</programlisting>
			</para>
			</entry>
		</row>
		</tbody>
	</tgroup>
</informaltable>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_ConvexHull" />, <xref linkend="ST_SimplifyPreserveTopology" />, <xref linkend="ST_SnapToGrid" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_ConvexHull">
	  <refnamediv>
		<refname>ST_ConvexHull</refname>
		<refpurpose>Computes the convex hull of a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_ConvexHull</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>Computes the convex hull of a geometry.
		The convex hull is the smallest convex
		geometry that encloses all geometries in the input.</para>

		<para>In the general case the convex hull is a Polygon.
		The convex hull of two or more collinear points is a two-point LineString.
		The convex hull of one or more identical points is a Point.</para>

		<para>It is usually used with Multi* and GeometryCollections.
		It is not an aggregate function.
		To compute the convex hull of a set of geometries,
		use	<xref linkend="ST_Collect" /> to aggregate them.</para>

		<para>One can think of the convex hull as the geometry obtained by wrapping an elastic
			band around a set of geometries.  This is different from a concave hull
			which is analogous to "shrink-wrapping" the geometries.
			A convex hull is often used to
			determine an affected area based on a set of point observations.</para>

		<para>Performed by the GEOS module</para>

		<para>&sfs_compliant; s2.1.1.3</para>
		<para>&sqlmm_compliant; SQL-MM 3: 5.1.16</para>
		<para>&Z_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

<para>
	<informalfigure>
	  <mediaobject>
		<imageobject>
		  <imagedata fileref="images/st_convexhull01.png" />
		</imageobject>
		<caption><para>Convex Hull of a MultiLinestring and a MultiPoint</para></caption>
	  </mediaobject>
	</informalfigure>
	<programlisting>
SELECT ST_AsText(ST_ConvexHull(
	ST_Collect(
		ST_GeomFromText('MULTILINESTRING((100 190,10 8),(150 10, 20 30))'),
			ST_GeomFromText('MULTIPOINT(50 5, 150 30, 50 10, 10 10)')
			)) );
---st_astext--
POLYGON((50 5,10 8,10 10,100 190,150 30,150 10,50 5))
	</programlisting>
</para>

<para>Using with ST_Collect to compute the convex hulls of geometry sets.</para>

<programlisting>
--Get estimate of infected area based on point observations
SELECT d.disease_type,
	ST_ConvexHull(ST_Collect(d.the_geom)) As the_geom
	FROM disease_obs As d
	GROUP BY d.disease_type;
</programlisting>

	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_ConcaveHull" />, <xref linkend="ST_MinimumBoundingCircle" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_CurveToLine">
	  <refnamediv>
		<refname>ST_CurveToLine</refname>

		<refpurpose>Converts a CIRCULARSTRING/CURVEPOLYGON/MULTISURFACE to a LINESTRING/POLYGON/MULTIPOLYGON</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_CurveToLine</function></funcdef>
			<paramdef><type>geometry</type> <parameter>curveGeom</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
			<paramdef choice="opt"><type>integer</type> <parameter>tolerance_type</parameter></paramdef>
			<paramdef choice="opt"><type>integer</type> <parameter>flags</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Converts a CIRCULAR STRING to regular LINESTRING or CURVEPOLYGON to POLYGON or MULTISURFACE to MULTIPOLYGON. Useful for outputting to devices that can't support CIRCULARSTRING geometry types</para>

		<para>Converts a given geometry to a linear geometry.
		Each curved geometry or segment is converted into a linear
approximation using the given `tolerance` and options (32 segments per
quadrant and no options by default).</para>

    <para>
The 'tolerance_type' argument determines interpretation of the
`tolerance` argument. It can take the following values:
      <itemizedlist>
        <listitem>
          <para>0 (default): Tolerance is max segments per quadrant.</para>
        </listitem>
        <listitem>
          <para>1: Tolerance is max-deviation of line from curve, in source units.</para>
        </listitem>
        <listitem>
          <para>2: Tolerance is max-angle, in radians, between generating radii.</para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
The 'flags' argument is a bitfield. 0 by default.
Supported bits are:
      <itemizedlist>
        <listitem>
          <para>1: Symmetric (orientation idependent) output.</para>
        </listitem>
        <listitem>
          <para>2: Retain angle, avoids reducing angles (segment lengths) when producing symmetric output. Has no effect when Symmetric flag is off.</para>
        </listitem>
      </itemizedlist>
    </para>

		<para>Availability: 1.3.0</para>
    <para>Enhanced: 2.4.0 added support for max-deviation and max-angle tolerance, and for symmetric output.</para>
    <para>Enhanced: 3.0.0 implemented a minimum number of segments per linearized arc to prevent topological collapse.</para>

		<para>&sfs_compliant;</para>
		<para>&sqlmm_compliant; SQL-MM 3: 7.1.7</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)')));

--Result --
 LINESTRING(220268 150415,220269.95064912 150416.539364228,220271.823415575 150418.17258804,220273.613787707 150419.895736857,
 220275.317452352 150421.704659462,220276.930305234 150423.594998003,220278.448460847 150425.562198489,
 220279.868261823 150427.60152176,220281.186287736 150429.708054909,220282.399363347 150431.876723113,
 220283.50456625 150434.10230186,220284.499233914 150436.379429536,220285.380970099 150438.702620341,220286.147650624 150441.066277505,
 220286.797428488 150443.464706771,220287.328738321 150445.892130112,220287.740300149 150448.342699654,
 220288.031122486 150450.810511759,220288.200504713 150453.289621251,220288.248038775 150455.77405574,
 220288.173610157 150458.257830005,220287.977398166 150460.734960415,220287.659875492 150463.199479347,
 220287.221807076 150465.64544956,220286.664248262 150468.066978495,220285.988542259 150470.458232479,220285.196316903 150472.81345077,
 220284.289480732 150475.126959442,220283.270218395 150477.39318505,220282.140985384 150479.606668057,
 220280.90450212 150481.762075989,220279.5637474 150483.85421628,220278.12195122 150485.87804878,
 220276.582586992 150487.828697901,220274.949363179 150489.701464356,220273.226214362 150491.491836488,
 220271.417291757 150493.195501133,220269.526953216 150494.808354014,220267.559752731 150496.326509628,
 220265.520429459 150497.746310603,220263.41389631 150499.064336517,220261.245228106 150500.277412127,
 220259.019649359 150501.38261503,220256.742521683 150502.377282695,220254.419330878 150503.259018879,
 220252.055673714 150504.025699404,220249.657244448 150504.675477269,220247.229821107 150505.206787101,
 220244.779251566 150505.61834893,220242.311439461 150505.909171266,220239.832329968 150506.078553494,
 220237.347895479 150506.126087555,220234.864121215 150506.051658938,220232.386990804 150505.855446946,
 220229.922471872 150505.537924272,220227.47650166 150505.099855856,220225.054972724 150504.542297043,
 220222.663718741 150503.86659104,220220.308500449 150503.074365683,
 220217.994991777 150502.167529512,220215.72876617 150501.148267175,
 220213.515283163 150500.019034164,220211.35987523 150498.7825509,
 220209.267734939 150497.441796181,220207.243902439 150496,
 220205.293253319 150494.460635772,220203.420486864 150492.82741196,220201.630114732 150491.104263143,
 220199.926450087 150489.295340538,220198.313597205 150487.405001997,220196.795441592 150485.437801511,
 220195.375640616 150483.39847824,220194.057614703 150481.291945091,220192.844539092 150479.123276887,220191.739336189 150476.89769814,
 220190.744668525 150474.620570464,220189.86293234 150472.297379659,220189.096251815 150469.933722495,
 220188.446473951 150467.535293229,220187.915164118 150465.107869888,220187.50360229 150462.657300346,
 220187.212779953 150460.189488241,220187.043397726 150457.710378749,220186.995863664 150455.22594426,
 220187.070292282 150452.742169995,220187.266504273 150450.265039585,220187.584026947 150447.800520653,
 220188.022095363 150445.35455044,220188.579654177 150442.933021505,220189.25536018 150440.541767521,
 220190.047585536 150438.18654923,220190.954421707 150435.873040558,220191.973684044 150433.60681495,
 220193.102917055 150431.393331943,220194.339400319 150429.237924011,220195.680155039 150427.14578372,220197.12195122 150425.12195122,
 220198.661315447 150423.171302099,220200.29453926 150421.298535644,220202.017688077 150419.508163512,220203.826610682 150417.804498867,
 220205.716949223 150416.191645986,220207.684149708 150414.673490372,220209.72347298 150413.253689397,220211.830006129 150411.935663483,
 220213.998674333 150410.722587873,220216.22425308 150409.61738497,220218.501380756 150408.622717305,220220.824571561 150407.740981121,
 220223.188228725 150406.974300596,220225.586657991 150406.324522731,220227 150406)

--3d example
SELECT ST_AsEWKT(ST_CurveToLine(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)')));
Output
------
 LINESTRING(220268 150415 1,220269.95064912 150416.539364228 1.0181172856673,
 220271.823415575 150418.17258804 1.03623457133459,220273.613787707 150419.895736857 1.05435185700189,....AD INFINITUM ....
	220225.586657991 150406.324522731 1.32611114201132,220227 150406 3)

--use only 2 segments to approximate quarter circle
SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)'),2));
st_astext
------------------------------
 LINESTRING(220268 150415,220287.740300149 150448.342699654,220278.12195122 150485.87804878,
 220244.779251566 150505.61834893,220207.243902439 150496,220187.50360229 150462.657300346,
 220197.12195122 150425.12195122,220227 150406)

-- Ensure approximated line is no further than 20 units away from
-- original curve, and make the result direction-neutral
SELECT ST_AsText(ST_CurveToLine(
 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
	20, -- Tolerance
	1, -- Above is max distance between curve and line
	1  -- Symmetric flag
));
st_astext
-------------------------------------------------------------------------------------------
 LINESTRING(0 0,50 -86.6025403784438,150 -86.6025403784439,200 -1.1331077795296e-13,200 0)


		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_LineToCurve" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_DelaunayTriangles">
		<refnamediv>
			<refname>ST_DelaunayTriangles</refname>

			<refpurpose>
Return a Delaunay triangulation around the given input points.
			</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_DelaunayTriangles</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>float </type> <parameter>tolerance</parameter></paramdef>
				<paramdef><type>int4 </type> <parameter>flags</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>
Return a <ulink
url="http://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay
triangulation</ulink> around the vertices of the input geometry.
Output is a COLLECTION of polygons (for flags=0) or a MULTILINESTRING
(for flags=1) or TIN (for flags=2).  The tolerance, if any, is used to snap input vertices
togheter.
			</para>
			<para>Performed by the GEOS module.</para>
			<para>Availability: 2.1.0</para>
			<para>&Z_support;</para>
			<para>&T_support;</para>

		</refsection>
			  <refsection>
		<title>2D Examples</title>
			<informaltable>
				  <tgroup cols="1">
					<tbody>
					 <row><entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_delaunaytriangles01.png" />
							  </imageobject>
							  <caption><para>Original polygons</para></caption>
							</mediaobject>
						  </informalfigure></para>
<programlisting>-- our original geometry --
	ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		)</programlisting></entry>
				      </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_delaunaytriangles03.png" />
							  </imageobject>
							  <caption><para>ST_DelaunayTriangles of 2 polygons: delaunay triangle polygons each triangle themed in different color</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
-- geometries overlaid multilinestring triangles
SELECT
	ST_DelaunayTriangles(
		ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		))
	 As  dtriag;
				</programlisting>
						  </para></entry></row>
				<row><entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_delaunaytriangles02.png" />
							  </imageobject>
							  <caption><para>-- delaunay triangles as multilinestring</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>SELECT
	ST_DelaunayTriangles(
		ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		),0.001,1)
	 As  dtriag;</programlisting>
						</para></entry>
				</row>
				<row><entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_delaunaytriangles04.png" />
							  </imageobject>
							  <caption><para>-- delaunay triangles of 45 points as 55 triangle polygons</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>-- this produces a table of 42 points that form an L shape
SELECT (ST_DumpPoints(ST_GeomFromText(
'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,
150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,
14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,
6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,
14 94,14 74,14 54,14 34,14 14)'))).geom
	INTO TABLE l_shape;
-- output as individual polygon triangles
SELECT ST_AsText((ST_Dump(geom)).geom) As wkt
FROM ( SELECT ST_DelaunayTriangles(ST_Collect(geom)) As geom
FROM l_shape) As foo;

---wkt ---
POLYGON((6 194,6 190,14 194,6 194))
POLYGON((14 194,6 190,14 174,14 194))
POLYGON((14 194,14 174,154 14,14 194))
POLYGON((154 14,14 174,14 154,154 14))
POLYGON((154 14,14 154,150 14,154 14))
POLYGON((154 14,150 14,154 6,154 14))
:
:
</programlisting>
						</para></entry>
			 </row>

		</tbody>
	</tgroup>
</informaltable>
	  </refsection>
	  <refsection>
			<title>3D Examples</title>
			<programlisting>-- 3D multipoint --
SELECT ST_AsText(ST_DelaunayTriangles(ST_GeomFromText(
'MULTIPOINT Z(14 14 10,
150 14 100,34 6 25, 20 10 150)'))) As wkt;

-----wkt----
GEOMETRYCOLLECTION Z (POLYGON Z ((14 14 10,20 10 150,34 6 25,14 14 10))
 ,POLYGON Z ((14 14 10,34 6 25,150 14 100,14 14 10)))</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_ConstrainedDelaunayTriangles" />, <xref linkend="ST_ConcaveHull" />, <xref linkend="ST_Dump" />, <xref linkend="ST_Tesselate" />
			</para>
		</refsection>
	</refentry>

	<refentry id="ST_Difference">
	  <refnamediv>
		<refname>ST_Difference</refname>

		<refpurpose>Returns a geometry that represents that part of geometry A
			that does not intersect with geometry B.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Difference</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a geometry that represents that part of geometry A
			that does not intersect with geometry B.  One can think of this as GeometryA - ST_Intersection(A,B).  If A is completely contained in B
			then an empty geometry collection is returned.</para>
		<note><para>Order matters. B - A will always return a portion of B</para></note>

		<para>Performed by the GEOS module</para>

		<para>&sfs_compliant; s2.1.1.3</para>
		<para>&sqlmm_compliant; SQL-MM 3: 5.1.20</para>
		<para>&Z_support; However it seems to only consider x y when
		  doing the difference and tacks back on the Z-Index</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
			<informaltable>
			  <tgroup cols="2">
				<tbody>
				  <row>
					<entry>
						<para>
							<informalfigure>
								<mediaobject>
								  <imageobject>
									<imagedata fileref="images/st_symdifference01.png" />
								  </imageobject>
								  <caption><para>The original linestrings shown together. </para></caption>
								</mediaobject>
							</informalfigure>
						</para>
					</entry>

					<entry>
						<para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_difference01.png" />
							  </imageobject>
							  <caption><para>The difference of the two linestrings</para></caption>
							</mediaobject>
						  </informalfigure>
					</para>
				</entry>
				  </row>
		</tbody>
	</tgroup>
</informaltable>
<para>Safe for 2D. This is same geometries as what is shown for st_symdifference</para>
<programlisting>SELECT ST_AsText(
	ST_Difference(
			'LINESTRING(50 100, 50 200)'::geometry,
			'LINESTRING(50 50, 50 150)'::geometry
		)
	);

st_astext
---------
LINESTRING(50 150,50 200)
</programlisting>

<para>When used in 3d doesn't quite do the right thing.</para>
<programlisting>select ST_AsEWKT(
           ST_Difference(
               'MULTIPOINT(-118.58 38.38 5,-118.60 38.329 6,-118.614 38.281 7)' :: geometry,
               'POINT(-118.614 38.281 5)' :: geometry
               )
    );
st_asewkt
---------
MULTIPOINT(-118.6 38.329 6,-118.58 38.38 5)</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_SymDifference" />, <xref linkend="ST_Intersection" />, <xref linkend="ST_Union" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_FlipCoordinates">
	  <refnamediv>
		<refname>ST_FlipCoordinates</refname>
		<refpurpose>Returns a version of the given geometry with
				X and Y axis flipped. Useful for people
				who have built latitude/longitude features
				and need to fix them.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_FlipCoordinates</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a version of the given geometry with X and Y axis flipped.</para>
		<para>Availability: 2.0.0</para>
		<para>&curve_support;</para>
		<para>&Z_support;</para>
		<para>&M_support;</para>
		<para>&P_support;</para>
		<para>&T_support;</para>
	  </refsection>

	  <refsection>
		<title>Example</title>
		<programlisting><![CDATA[
SELECT ST_AsEWKT(ST_FlipCoordinates(GeomFromEWKT('POINT(1 2)')));
 st_asewkt
------------
POINT(2 1)
		 ]]></programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para> <xref linkend="ST_SwapOrdinates" /> </para>
	  </refsection>

	</refentry>

	<refentry id="ST_GeneratePoints">
	  <refnamediv>
		<refname>ST_GeneratePoints</refname>

		<refpurpose>Converts a polygon or multi-polygon into a multi-point composed of randomly location points within the original areas.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_GeneratePoints</function></funcdef>
			<paramdef>
				<parameter>g</parameter>
				<type>geometry</type>
			</paramdef>
			<paramdef>
				<parameter>npoints</parameter>
				<type>integer</type>
			</paramdef>
		  </funcprototype>
		  <funcprototype>
			<funcdef>geometry <function>ST_GeneratePoints</function></funcdef>
			<paramdef>
				<parameter>g</parameter>
				<type>geometry</type>
			</paramdef>
			<paramdef>
				<parameter>npoints</parameter>
				<type>integer</type>
			</paramdef>
			<paramdef>
				<parameter>seed</parameter>
				<type>integer</type>
			</paramdef>
		  </funcprototype>

		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
		<title>Description</title>

		<para>
			ST_GeneratePoints generates pseudo-random points until the requested number are
			found within the input area. The optional seed must be greater than zero,
			and is used to regenerate a deterministic sequence of points.
		</para>

		<para>Availability: 2.3.0</para>
		<para>Enhanced: 3.0.0, added seed parameter</para>
		</refsection>

		<refsection>
			<title>Examples</title>

			<informaltable>
			  <tgroup cols="2">
				<tbody>
				  <row>
					<entry>
						<para><informalfigure>
						<mediaobject>
						  <imageobject>
							<imagedata fileref="images/st_generatepoints01.png" />
						  </imageobject>
						  <caption><para>Original Polygon</para></caption>
						</mediaobject>
						</informalfigure>
						</para>
					</entry>

					<entry><para><informalfigure>
						<mediaobject>
						  <imageobject>
							<imagedata fileref="images/st_generatepoints02.png" />
						  </imageobject>
						  <caption><para>Generated 12 Points overlaid on top of original polygon using a random seed value 1996</para></caption>
						</mediaobject>
					  </informalfigure>
						<programlisting>SELECT ST_GeneratePoints(geom, 12, 1996)
FROM (
	SELECT ST_Buffer(
		ST_GeomFromText(
		'LINESTRING(50 50,150 150,150 50)'),
		10, 'endcap=round join=round') AS geom
) AS s;</programlisting>
					</para></entry>
				  </row>
			</tbody>
			</tgroup>
		</informaltable>
		</refsection>
	</refentry>

	<refentry id="ST_GeometricMedian">
	  <refnamediv>
		  <refname>
			  ST_GeometricMedian
		  </refname>

		<refpurpose>
			Returns the geometric median of a MultiPoint.
		</refpurpose>
	  </refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
		<funcprototype>
			<funcdef>geometry
				<function>
					ST_GeometricMedian
				</function>
			</funcdef>

			<paramdef>
				<type>
					geometry
				</type>
				<parameter>
					g
				</parameter>
			</paramdef>

			<paramdef>
				<type>
					float8
				</type>
				<parameter>
					tolerance
				</parameter>
			</paramdef>

			<paramdef>
				<type>
					int
				</type>
				<parameter>
					max_iter
				</parameter>
			</paramdef>

			<paramdef>
				<type>
					boolean
				</type>
				<parameter>
					fail_if_not_converged
				</parameter>
			</paramdef>

		</funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsection>
	  <title>Description</title>

	<para>
		  Computes the approximate geometric median of a MultiPoint geometry
		  using the Weiszfeld algorithm.  The geometric median provides a
		  centrality measure that is less sensitive to outlier points than
		  the centroid.
	</para>
	<para>
		  The algorithm will iterate until the distance change between
		  successive iterations is less than the supplied <varname>tolerance</varname>
		  parameter.  If this condition has not been met after <varname>max_iterations</varname>
		  iterations, the function will produce an error and exit, unless <varname>fail_if_not_converged</varname>
		  is set to false.
	</para>
	<para>
		  If a <varname>tolerance</varname> value is not provided, a default tolerance value
		  will be calculated based on the extent of the input geometry.
	</para>
	<para>
		  M value of points, if present, is interpreted as their relative weight.
	</para>
	<para>Availability: 2.3.0</para>
	<para>Enhanced: 2.5.0 Added support for M as weight of points.</para>
	<para>&Z_support;</para>
	<para>&M_support;</para>
    </refsection>
    <refsection>
      <title>Examples</title>
	  <para>
		  <informalfigure>
			  <mediaobject>
					<imageobject>
						<imagedata fileref="images/st_geometricmedian01.png" />
					</imageobject>

					<caption>
						<para>
						Comparison of the centroid (turquoise point) and geometric
						median (red point) of a four-point MultiPoint (yellow points).
						</para>
					</caption>
			  </mediaobject>
		</informalfigure>
	  </para>
	  <programlisting>
WITH test AS (
SELECT 'MULTIPOINT((0 0), (1 1), (2 2), (200 200))'::geometry geom)
SELECT
  ST_AsText(ST_Centroid(geom)) centroid,
  ST_AsText(ST_GeometricMedian(geom)) median
FROM test;
      centroid      |                 median
--------------------+----------------------------------------
 POINT(50.75 50.75) | POINT(1.9761550281255 1.9761550281255)
(1 row)
	  </programlisting>
	</refsection>

	<refsection>
	  <title>See Also</title>

	  <para><xref linkend="ST_Centroid"/></para>
	</refsection>

	</refentry>

	<refentry id="ST_Intersection">
		<refnamediv>
			<refname>ST_Intersection</refname>

			<refpurpose>
(T)
Returns a geometry that represents the shared portion of geomA and geomB.
			</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>geometry <function>ST_Intersection</function></funcdef>
					<paramdef>
						<type>geometry</type>
						<parameter>geomA</parameter>
					</paramdef>
					<paramdef>
						<type>geometry</type>
						<parameter>geomB</parameter>
					</paramdef>
				</funcprototype>
				<funcprototype>
					<funcdef>geography <function>ST_Intersection</function></funcdef>
					<paramdef>
						<type>geography</type>
						<parameter>geogA</parameter>
					</paramdef>
					<paramdef>
						<type>geography</type>
						<parameter>geogB</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>
			<para>Returns a geometry that represents the point set
				intersection of the Geometries.</para>

			<para>In other words - that portion of geometry A and geometry B
			that is shared between the two geometries.</para>

			<para>If the geometries do not share any space (are disjoint), then an empty geometry collection
			is returned.</para>
			<para>ST_Intersection in conjunction with ST_Intersects is very useful for clipping geometries such as in bounding box, buffer, region
				queries where you only want to return that portion of a geometry that sits in a country or region of interest.</para>

			<note><para>Geography: For geography this is really a thin wrapper around the geometry implementation. It first determines the best SRID that
					fits the bounding box of the 2 geography objects (if geography objects are within one half zone UTM but not same UTM will pick one of those) (favoring UTM or Lambert Azimuthal Equal Area (LAEA) north/south pole, and falling back on mercator in worst case scenario)  and then intersection in that best fit planar spatial ref and retransforms back to WGS84 geography.</para></note>

	  	<warning><para>This function will drop the M coordinate values if present.</para></warning>

		  <warning><para>If working with 3D geometries, you may want to use SFGCAL based <xref linkend="ST_3DIntersection" /> which does a proper 3D intersection for 3D geometries.  Although this function works with Z-coordinate, it does an averaging of Z-Coordinate.</para></warning>

		  <para>Performed by the GEOS module</para>

		  <para>Availability: 1.5 support for geography data type was introduced.</para>
			<para>Changed: 3.0.0 does not depend on SFCGAL.</para>

		  <para>&sfs_compliant; s2.1.1.3</para>
		  <para>&sqlmm_compliant; SQL-MM 3: 5.1.18</para>
		</refsection>
		<refsection>
		<title>Examples</title>
<programlisting>SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry));
 st_astext
---------------
GEOMETRYCOLLECTION EMPTY

SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::geometry));
 st_astext
---------------
POINT(0 0)</programlisting>
<para>
Clip all lines (trails) by country. Hhere we assume country geom are POLYGON or MULTIPOLYGONS.
NOTE: we are only keeping intersections that result in a LINESTRING or MULTILINESTRING because we don't
care about trails that just share a point. The dump is needed to expand a geometry collection into individual single MULT* parts.
The below is fairly generic and will work for polys, etc. by just changing the where clause.</para>
<programlisting>select clipped.gid, clipped.f_name, clipped_geom
from (
         select trails.gid, trails.f_name,
             (ST_Dump(ST_Intersection(country.geom, trails.geom))).geom clipped_geom
         from country
              inner join trails on ST_Intersects(country.geom, trails.geom)
     ) as clipped
where ST_Dimension(clipped.clipped_geom) = 1;</programlisting>
<para>For polys e.g. polygon landmarks, you can also use the sometimes faster hack that buffering anything by 0.0 except a polygon results in an empty geometry collection.
(So a geometry collection containing polys, lines and points buffered by 0.0 would only leave the polygons and dissolve the collection shell.)</para>
<programlisting>select poly.gid,
    ST_Multi(
        ST_Buffer(
            ST_Intersection(country.geom, poly.geom),
            0.0
        )
    ) clipped_geom
from country
     inner join poly on ST_Intersects(country.geom, poly.geom)
where not ST_IsEmpty(ST_Buffer(ST_Intersection(country.geom, poly.geom), 0.0));</programlisting>
		</refsection>

		<refsection>
		<title>Examples: 2.5Dish</title>
		<para>Note this is not a true intersection, compare to the same example using <xref linkend="ST_3DIntersection" />.</para>
		<programlisting>
select ST_AsText(ST_Intersection(linestring, polygon)) As wkt
from  ST_GeomFromText('LINESTRING Z (2 2 6,1.5 1.5 7,1 1 8,0.5 0.5 8,0 0 10)') AS linestring
 CROSS JOIN ST_GeomFromText('POLYGON((0 0 8, 0 1 8, 1 1 8, 1 0 8, 0 0 8))') AS polygon;

               st_astext
---------------------------------------
 LINESTRING Z (1 1 8,0.5 0.5 8,0 0 10)
		</programlisting>
	  </refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_3DIntersection" />,	<xref linkend="ST_Difference"/>, <xref linkend="ST_Union"/>, <xref linkend="ST_Dimension"/>, <xref linkend="ST_Dump"/>, <xref linkend="ST_Force2D" />, <xref linkend="ST_SymDifference"/>, <xref linkend="ST_Intersects"/>, <xref linkend="ST_Multi"/></para>
		</refsection>
	</refentry>

	<refentry id="ST_LineToCurve">
	  <refnamediv>
		<refname>ST_LineToCurve</refname>

		<refpurpose>Converts a LINESTRING/POLYGON to a CIRCULARSTRING, CURVEPOLYGON</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_LineToCurve</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomANoncircular</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Converts plain LINESTRING/POLYGON to CIRCULAR STRINGs and Curved Polygons.  Note much fewer points are needed to describe the curved equivalent.</para>
		<note><para>If the input LINESTRING/POLYGON is not curved enough to clearly represent a curve, the function will return the same input geometry.</para></note>
		<para>Availability: 1.3.0</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting> -- 2D Example
SELECT ST_AsText(ST_LineToCurve(foo.the_geom)) As curvedastext,ST_AsText(foo.the_geom) As non_curvedastext
	FROM (SELECT ST_Buffer('POINT(1 3)'::geometry, 3) As the_geom) As foo;

curvedatext                                                            non_curvedastext
--------------------------------------------------------------------|-----------------------------------------------------------------
CURVEPOLYGON(CIRCULARSTRING(4 3,3.12132034355964 0.878679656440359, | POLYGON((4 3,3.94235584120969 2.41472903395162,3.77163859753386 1.85194970290473,
1 0,-1.12132034355965 5.12132034355963,4 3))                        |  3.49440883690764 1.33328930094119,3.12132034355964 0.878679656440359,
                                                                    |  2.66671069905881 0.505591163092366,2.14805029709527 0.228361402466141,
                                                                    |  1.58527096604839 0.0576441587903094,1 0,
                                                                    |  0.414729033951621 0.0576441587903077,-0.148050297095264 0.228361402466137,
                                                                    |  -0.666710699058802 0.505591163092361,-1.12132034355964 0.878679656440353,
                                                                    |  -1.49440883690763 1.33328930094119,-1.77163859753386 1.85194970290472
                                                                    |  --ETC-- ,3.94235584120969 3.58527096604839,4 3))

--3D example
SELECT ST_AsText(ST_LineToCurve(geom)) As curved, ST_AsText(geom) AS not_curved
FROM (SELECT ST_Translate(ST_Force3D(ST_Boundary(ST_Buffer(ST_Point(1,3), 2,2))),0,0,3) AS geom) AS foo;

                        curved                        |               not_curved
------------------------------------------------------+---------------------------------------------------------------------
 CIRCULARSTRING Z (3 3 3,-1 2.99999999999999 3,3 3 3) | LINESTRING Z (3 3 3,2.4142135623731 1.58578643762691 3,1 1 3,
                                                      |	-0.414213562373092 1.5857864376269 3,-1 2.99999999999999 3,
                                                      | -0.414213562373101 4.41421356237309 3,
                                                      |	0.999999999999991 5 3,2.41421356237309 4.4142135623731 3,3 3 3)
(1 row)
</programlisting>
	</refsection>



	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_CurveToLine" /></para>
	  </refsection>
	</refentry>

    <refentry id="ST_MakeValid">
      <refnamediv>
        <refname>ST_MakeValid</refname>
        <refpurpose>Attempts to make an invalid geometry valid without losing vertices.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_MakeValid</function></funcdef>
            <paramdef><type>geometry</type> <parameter>input</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
    <para>
    The function attempts to create a valid representation of a given invalid
    geometry without losing any of the input vertices.
    Already-valid geometries are returned without further intervention.
    </para>

    <para>
    Supported inputs are: POINTS, MULTIPOINTS, LINESTRINGS,
    MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS and GEOMETRYCOLLECTIONS
    containing any mix of them.
    </para>

    <para>
    In case of full or partial dimensional collapses, the output geometry
    may be a collection of lower-to-equal dimension geometries or a
    geometry of lower dimension.
    </para>

    <para>
    Single polygons may become multi-geometries in case of self-intersections.
    </para>
		<para>Performed by the GEOS module.</para>

    <para>Availability: 2.0.0</para>
    <para>Enhanced: 2.0.1, speed improvements</para>
    <para>Enhanced: 2.1.0, added support for GEOMETRYCOLLECTION and MULTIPOINT.</para>

    <para>&Z_support;</para>

          </refsection>

          <refsection>
            <title>See Also</title>
            <para>
                <xref linkend="ST_IsValid" />
                <xref linkend="ST_CollectionExtract" />
            </para>
          </refsection>
    </refentry>

	<refentry id="ST_MemUnion">
	  <refnamediv>
		<refname>ST_MemUnion</refname>

		<refpurpose>Same as ST_Union, only memory-friendly (uses less memory
			and more processor time).</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MemUnion</function></funcdef>
			<paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Some useful description here.</para>

		<!-- optionally mention that this function uses indexes if appropriate -->
		<note>
		  <para>Same as ST_Union, only memory-friendly (uses less memory
			and more processor time).  This aggregate function works by unioning the geometries one at a time to previous result as opposed to
			ST_Union aggregate which first creates an array and then unions</para>
		</note>

		<para>&Z_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>See ST_Union</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Union" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MinimumBoundingCircle">
	  <refnamediv>
		<refname>ST_MinimumBoundingCircle</refname>
		<refpurpose>Returns the smallest circle polygon that can fully contain a geometry. Default
		uses 48 segments per quarter circle.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MinimumBoundingCircle</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef choice="opt"><type>integer </type> <parameter>num_segs_per_qt_circ=48</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>Returns the smallest circle polygon that can fully contain a geometry. </para>
			<note><para>The circle is approximated by a polygon with a default of 48 segments per quarter circle.  Because the polygon is an approximation of the minimum bounding circle, some points in the input geometry may not be contained within the polygon.  The approximation can be improved by increasing the number of segments, with little performance penalty.  For applications where a polygonal approximation is not suitable, ST_MinimumBoundingRadius may be used.</para></note>

			<para>It is often used with MULTI and Geometry Collections.
		Although it is not an aggregate - you can use it in conjunction
		with ST_Collect to get the minimum bounding circle of a set of geometries.
		ST_MinimumBoundingCircle(ST_Collect(somepointfield)).</para>

		<para>The ratio of the area of a polygon divided by the area of its Minimum Bounding Circle is often referred to as the Roeck test.</para>
		<para>Performed by the GEOS module.</para>
		<para>Availability: 1.4.0</para>

	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingRadius" /></para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
<programlisting>SELECT d.disease_type,
	ST_MinimumBoundingCircle(ST_Collect(d.the_geom)) As the_geom
	FROM disease_obs As d
	GROUP BY d.disease_type;
</programlisting>
	<informalfigure>
	  <mediaobject>
		<imageobject>
		  <imagedata fileref="images/st_minimumboundingcircle01.png" />
		</imageobject>
		<caption><para>Minimum bounding circle of a point and linestring.  Using 8 segs to approximate a quarter circle</para></caption>
	  </mediaobject>
	</informalfigure>
<programlisting>
SELECT ST_AsText(ST_MinimumBoundingCircle(
		ST_Collect(
			ST_GeomFromText('LINESTRING(55 75,125 150)'),
				ST_Point(20, 80)), 8
				)) As wktmbc;
wktmbc
-----------
POLYGON((135.59714732062 115,134.384753327498 102.690357210921,130.79416296937 90.8537670908995,124.963360620072 79.9451031602111,117.116420743937 70.3835792560632,107.554896839789 62.5366393799277,96.6462329091006 56.70583703063,84.8096427890789 53.115246672502,72.5000000000001 51.9028526793802,60.1903572109213 53.1152466725019,48.3537670908996 56.7058370306299,37.4451031602112 62.5366393799276,27.8835792560632 70.383579256063,20.0366393799278 79.9451031602109,14.20583703063 90.8537670908993,10.615246672502 102.690357210921,9.40285267938019 115,10.6152466725019 127.309642789079,14.2058370306299 139.1462329091,20.0366393799275 150.054896839789,27.883579256063 159.616420743937,
37.4451031602108 167.463360620072,48.3537670908992 173.29416296937,60.190357210921 176.884753327498,
72.4999999999998 178.09714732062,84.8096427890786 176.884753327498,96.6462329091003 173.29416296937,107.554896839789 167.463360620072,
117.116420743937 159.616420743937,124.963360620072 150.054896839789,130.79416296937 139.146232909101,134.384753327498 127.309642789079,135.59714732062 115))
				</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingRadius" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MinimumBoundingRadius">
	<refnamediv>
		<refname>ST_MinimumBoundingRadius</refname>
		<refpurpose>Returns the center point and radius of the smallest circle that can fully contain a geometry.</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>(geometry, double precision) <function>ST_MinimumBoundingRadius</function></funcdef>
				<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	</refsynopsisdiv>

	<refsection>
		<title>Description</title>
		<para>Returns a record containing the center point and radius of the smallest circle that can fully contain a geometry.</para>
		<para>Can be used in conjunction with <xref linkend="ST_Collect"/> to get the minimum bounding circle of a set of geometries.</para>
		<para>Availability - 2.3.0</para>
	</refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingCircle" /></para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
<programlisting>SELECT ST_AsText(center), radius FROM ST_MinimumBoundingRadius('POLYGON((26426 65078,26531 65242,26075 65136,26096 65427,26426 65078))');

                st_astext                 |      radius
------------------------------------------+------------------
 POINT(26284.8418027133 65267.1145090825) | 247.436045591407
</programlisting>
	  </refsection>

	</refentry>

	<refentry id="ST_OrientedEnvelope">
		<refnamediv>
			<refname>ST_OrientedEnvelope</refname>
			<refpurpose>Returns a minimum rotated rectangle enclosing a geometry.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>geometry <function>ST_OrientedEnvelope</function></funcdef>
					<paramdef>
						<type>geometry</type>
						<parameter>geom</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>
			<para>
				Returns a mimimum rotated rectangle enclosing a geometry.
				Note that more than one minimum rotated rectangle may exist.
				May return a Point or LineString in the case of degenerate inputs.
			</para>
			<para>
				Availability: 2.5.0
			</para>
		</refsection>

		<refsection>
			<title>See Also</title>
			<para>
				<xref linkend="ST_Envelope" />
				<xref linkend="ST_MinimumBoundingCircle" />
			</para>
		</refsection>

		<refsection>
			<title>Examples</title>
			<programlisting>
				SELECT ST_AsText(ST_OrientedEnvelope('MULTIPOINT ((0 0), (-1 -1), (3 2))'));

				st_astext
				------------------------------------------------
				POLYGON((3 2,2.88 2.16,-1.12 -0.84,-1 -1,3 2))
			</programlisting>

	<informalfigure>
	  <mediaobject>
		<imageobject>
		  <imagedata fileref="images/st_orientedenvelope01.png" />
		</imageobject>
		<caption><para>Oriented envelope of a point and linestring.</para></caption>
	  </mediaobject>
	</informalfigure>
<programlisting>
SELECT ST_AsText(ST_OrientedEnvelope(
		ST_Collect(
			ST_GeomFromText('LINESTRING(55 75,125 150)'),
				ST_Point(20, 80))
				)) As wktenv;
wktenv
-----------
POLYGON((19.9999999999997 79.9999999999999,33.0769230769229 60.3846153846152,138.076923076924 130.384615384616,125.000000000001 150.000000000001,19.9999999999997 79.9999999999999))
</programlisting>

		</refsection>
	</refentry>

	<refentry id="ST_Polygonize">
		<refnamediv>
			<refname>ST_Polygonize</refname>

			<refpurpose>Aggregate. Creates a GeometryCollection containing possible
			polygons formed from the constituent linework of a set of
			geometries.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Polygonize</function></funcdef>
			<paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_Polygonize</function></funcdef>
			<paramdef><type>geometry[]</type> <parameter>geom_array</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a GeometryCollection containing possible
			polygons formed from the constituent linework of a set of
			geometries.</para>

			<note>
				<para>Geometry Collections are often difficult to deal with with third party tools, so use ST_Polygonize in conjunction with  <xref linkend="ST_Dump" /> to dump the polygons
				out into individual polygons.</para>
			</note>

			<note>
				<para>Input linework must be correctly noded for this function to work properly</para>
			</note>
			<para>Performed by the GEOS module.</para>

			<para>Availability: 1.0.0RC1</para>
		</refsection>

		<refsection>
		<title>Examples: Polygonizing single linestrings</title>
		 <programlisting>
SELECT ST_AsEWKT(ST_Polygonize(the_geom_4269)) As geomtextrep
FROM (SELECT the_geom_4269 FROM ma.suffolk_edges ORDER BY tlid LIMIT 45) As foo;

geomtextrep
-------------------------------------
 SRID=4269;GEOMETRYCOLLECTION(POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,-71.040878 42.285678)),
 POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358,-71.171794 42.354971,-71.170511 42.354855,
 -71.17112 42.354238,-71.17166 42.353675)))
(1 row)

--Use ST_Dump to dump out the polygonize geoms into individual polygons
SELECT ST_AsEWKT((ST_Dump(foofoo.polycoll)).geom) As geomtextrep
FROM (SELECT ST_Polygonize(the_geom_4269) As polycoll
	FROM (SELECT the_geom_4269 FROM ma.suffolk_edges
		ORDER BY tlid LIMIT 45) As foo) As foofoo;

geomtextrep
------------------------
 SRID=4269;POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,
-71.040878 42.285678))
 SRID=4269;POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358
,-71.171794 42.354971,-71.170511 42.354855,-71.17112 42.354238,-71.17166 42.353675))
(2 rows)

			  </programlisting>
		</refsection>

		<refsection>
			<title>See Also</title>
			<para>
			<xref linkend="ST_Node" />,
			<xref linkend="ST_Dump" />
			</para>
		</refsection>
	</refentry>

	<refentry id="ST_Node">
	  <refnamediv>
		<refname>ST_Node</refname>

		<refpurpose>
Node a set of linestrings.
		</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Node</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
Fully node a set of linestrings using the least possible number of nodes
while preserving all of the input ones.
		</para>

		<para>&Z_support;</para>
		<para>Performed by the GEOS module.</para>
		<para>Availability: 2.0.0</para>

		<para>
Changed: 2.4.0 this function uses GEOSNode internally instead of GEOSUnaryUnion.
This may cause the resulting linestrings to have a different order and direction compared to Postgis &lt; 2.4.
		</para>
	  </refsection>
	  <refsection>
		<title>Examples</title>
		<programlisting>
SELECT ST_AsText(
		ST_Node('LINESTRINGZ(0 0 0, 10 10 10, 0 10 5, 10 0 3)'::geometry)
	) As  output;
output
-----------
MULTILINESTRING Z ((0 0 0,5 5 4.5),(5 5 4.5,10 10 10,0 10 5,5 5 4.5),(5 5 4.5,10 0 3))
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
			<xref linkend="ST_UnaryUnion" />
		</para>
	  </refsection>
	</refentry>

			<refentry id="ST_OffsetCurve">
			<refnamediv>
				<refname>ST_OffsetCurve</refname>

				<refpurpose>
Return an offset line at a given distance and side from an input line. Useful for computing parallel lines about a center line
			</refpurpose>
			</refnamediv>

			<refsynopsisdiv>
				<funcsynopsis>

				  <funcprototype>
					<funcdef>geometry <function>ST_OffsetCurve</function></funcdef>
					<paramdef><type>geometry </type> <parameter>line</parameter></paramdef>
					<paramdef><type>float </type> <parameter>signed_distance</parameter></paramdef>
					<paramdef choice="opt"><type>text </type> <parameter>style_parameters=''</parameter></paramdef>
				  </funcprototype>

				</funcsynopsis>
			</refsynopsisdiv>

			  <refsection>
				<title>Description</title>

				<para>
Return an offset line at a given distance and side from an input line.
All points of the returned geometries are not further than the given
distance from the input geometry.
				</para>

				<para>
For positive distance the offset will be at the left side of the input line
and retain the same direction. For a negative distance it'll be at the right
side and in the opposite direction.
				</para>
				<para>
Note that output may be a MULTILINESTRING or EMPTY for some jigsaw-shaped input geometries.
				</para>

				<para>Performed by the GEOS module.</para>
				<para>Availability: 2.0</para>
				<para>Enhanced: 2.5 - added support for GEOMETRYCOLLECTION and MULTILINESTRING</para>

				<para>
The optional third parameter allows specifying a list of blank-separated
key=value pairs to tweak operations as follows:
<itemizedlist>
<listitem>
<para>'quad_segs=#' : number of segments used to approximate a quarter circle (defaults to 8).</para>
</listitem>
<listitem>
<para>'join=round|mitre|bevel' : join style (defaults to "round"). 'miter' is also accepted as a synonym for 'mitre'.</para>
</listitem>
<listitem>
<para>'mitre_limit=#.#' : mitre ratio limit (only affects mitred join style). 'miter_limit' is also accepted as a synonym for 'mitre_limit'.</para>
</listitem>
</itemizedlist>
				</para>

				<para>
Units of distance are measured in units of the spatial reference system.
				</para>

				<para>Performed by the GEOS module.</para>

				<note><para>
This function ignores the third dimension (z) and will always give a
2-d result even when presented with a 3d-geometry.</para></note>

			</refsection>

			<refsection>
			<title>Examples</title>
<para>Compute an open buffer around roads</para>
				<programlisting>
SELECT ST_Union(
 ST_OffsetCurve(f.the_geom,  f.width/2, 'quad_segs=4 join=round'),
 ST_OffsetCurve(f.the_geom, -f.width/2, 'quad_segs=4 join=round')
) as track
FROM someroadstable;

				</programlisting>
				<informaltable>
				  <tgroup cols="2">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve01.png" />
							  </imageobject>
							  <caption><para>15, 'quad_segs=4 join=round' original line
and its offset 15 units.</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)'),
	15, 'quad_segs=4 join=round'));
--output --
LINESTRING(164 1,18 1,12.2597485145237 2.1418070123307,
	7.39339828220179 5.39339828220179,
	5.39339828220179 7.39339828220179,
	2.14180701233067 12.2597485145237,1 18,1 195)
				</programlisting>
						  </para></entry>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve02.png" />
							  </imageobject>
							  <caption><para>-15, 'quad_segs=4 join=round' original line
								and its offset -15 units </para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_OffsetCurve(geom,
	-15, 'quad_segs=4 join=round')) As notsocurvy
	FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)') As geom;
-- notsocurvy --
LINESTRING(31 195,31 31,164 31)
				</programlisting>
						</para></entry>
					  </row>
					 <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve05.png" />
							  </imageobject>
							  <caption><para>double-offset to get more curvy, note the first reverses direction, so -30 + 15 = -15</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_OffsetCurve(geom,
	-30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')) As morecurvy
	FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)') As geom;
-- morecurvy --
LINESTRING(164 31,46 31,40.2597485145236 32.1418070123307,
35.3933982822018 35.3933982822018,
32.1418070123307 40.2597485145237,31 46,31 195)
				</programlisting>
						</para></entry>
<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve06.png" />
							  </imageobject>
							  <caption><para>double-offset to get more curvy,combined with regular offset 15 to get parallel lines.  Overlaid with original.</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>SELECT ST_AsText(ST_Collect(
	ST_OffsetCurve(geom, 15, 'quad_segs=4 join=round'),
	ST_OffsetCurve(ST_OffsetCurve(geom,
	-30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')
	)
) As parallel_curves
	FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)') As geom;
-- parallel curves  --
MULTILINESTRING((164 1,18 1,12.2597485145237 2.1418070123307,
7.39339828220179 5.39339828220179,5.39339828220179 7.39339828220179,
2.14180701233067 12.2597485145237,1 18,1 195),
(164 31,46 31,40.2597485145236 32.1418070123307,35.3933982822018 35.3933982822018,
32.1418070123307 40.2597485145237,31 46,31 195))
				</programlisting>
						</para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve03.png" />
							  </imageobject>
							  <caption><para>15, 'quad_segs=4 join=bevel' shown with original line</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)'),
		15, 'quad_segs=4 join=bevel'));
-- output --
LINESTRING(164 1,18 1,7.39339828220179 5.39339828220179,
	5.39339828220179 7.39339828220179,1 18,1 195)
				</programlisting>
						 </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve04.png" />
							  </imageobject>
							  <caption><para>15,-15 collected, join=mitre mitre_limit=2.1</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_Collect(
	ST_OffsetCurve(geom, 15, 'quad_segs=4 join=mitre mitre_limit=2.2'),
	ST_OffsetCurve(geom, -15, 'quad_segs=4 join=mitre mitre_limit=2.2')
	) )
	FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)') As geom;
-- output --
MULTILINESTRING((164 1,11.7867965644036 1,1 11.7867965644036,1 195),
	(31 195,31 31,164 31))
				</programlisting>
						  </para></entry>
					  </row>
					</tbody>
				  </tgroup>
			</informaltable>

			</refsection>

			  <refsection>
				<title>See Also</title>
				<para><xref linkend="ST_Buffer" /></para>
			  </refsection>
	</refentry>

	<refentry id="ST_PointOnSurface">
	  <refnamediv>
		<refname>ST_PointOnSurface</refname>

		<refpurpose>Returns a <varname>POINT</varname> guaranteed to lie on the surface.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_PointOnSurface</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a <varname>POINT</varname> guaranteed to intersect a surface.</para>

		<para>&sfs_compliant; s3.2.14.2 // s3.2.18.2</para>
		<para>&sqlmm_compliant; SQL-MM 3: 8.1.5, 9.5.6.
		 According to the specs, ST_PointOnSurface works for surface geometries (POLYGONs, MULTIPOLYGONS, CURVED POLYGONS).  So PostGIS seems to be extending what
		 the spec allows here.  Most databases Oracle,DB II, ESRI SDE seem to only support this function for surfaces.  SQL Server 2008 like PostGIS supports for all common geometries.</para>
		<para>&Z_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsText(ST_PointOnSurface('POINT(0 5)'::geometry));
 st_astext
------------
 POINT(0 5)
(1 row)

SELECT ST_AsText(ST_PointOnSurface('LINESTRING(0 5, 0 10)'::geometry));
 st_astext
------------
 POINT(0 5)
(1 row)

SELECT ST_AsText(ST_PointOnSurface('POLYGON((0 0, 0 5, 5 5, 5 0, 0 0))'::geometry));
   st_astext
----------------
 POINT(2.5 2.5)
(1 row)

SELECT ST_AsEWKT(ST_PointOnSurface(ST_GeomFromEWKT('LINESTRING(0 5 1, 0 0 1, 0 10 2)')));
   st_asewkt
----------------
 POINT(0 0 1)
(1 row)
</programlisting>
	  </refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Centroid" />, <xref linkend="ST_PointInsideCircle" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_RemoveRepeatedPoints">
	  <refnamediv>
		<refname>ST_RemoveRepeatedPoints</refname>
		<refpurpose>Returns a version of the given geometry with
				duplicated points removed.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RemoveRepeatedPoints</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
			<paramdef choice="opt"><type>float8</type> <parameter>tolerance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a version of the given geometry with
				duplicated points removed. Will actually do something only with
				(multi)lines, (multi)polygons and multipoints but you can safely call it with
				any kind of geometry. Since simplification occurs on a
				object-by-object basis you can also feed a GeometryCollection to
				this function.</para>
        <para>If the tolerance parameter is provided, vertices within the tolerance
        of one another will be considered the "same" for the purposes of removal.</para>

		<para>Availability: 2.2.0</para>
		<para>&P_support;</para>
		<para>&Z_support;</para>
	  </refsection>

		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Simplify" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_SharedPaths">
	  <refnamediv>
		<refname>ST_SharedPaths</refname>
		<refpurpose>Returns a collection containing paths shared by the two input linestrings/multilinestrings.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SharedPaths</function></funcdef>
			<paramdef><type>geometry</type> <parameter>lineal1</parameter></paramdef>
			<paramdef><type>geometry</type> <parameter>lineal2</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a collection containing paths shared by the two input geometries.
		    Those going in the same direction are in the first element of the collection, those going in the opposite direction are in the second element.
		    The paths themselves are given in the direction of the first geometry.
		</para>
		<para>Performed by the GEOS module.</para>
		<para>Availability: 2.0.0</para>
	  </refsection>
	  <refsection>
		<title>Examples: Finding shared paths</title>
		<informaltable>
		  <tgroup cols="1">
			<tbody>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_sharedpaths01.png" />
					  </imageobject>
					  <caption><para>A multilinestring and a linestring</para></caption>
					</mediaobject>
				  </informalfigure></para>
			   </entry>
			  </row>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_sharedpaths02.png" />
					  </imageobject>
					  <caption><para>The shared path of multilinestring and linestring overlaid with original geometries.</para></caption>
					</mediaobject>
				  </informalfigure>
				  <programlisting>
 SELECT ST_AsText(
  ST_SharedPaths(
    ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),
	   (51 150,101 150,76 175,51 150))'),
	ST_GeomFromText('LINESTRING(151 100,126 156.25,126 125,90 161, 76 175)')
	)
  ) As wkt

                                wkt
-------------------------------------------------------------
GEOMETRYCOLLECTION(MULTILINESTRING((126 156.25,126 125),
 (101 150,90 161),(90 161,76 175)),MULTILINESTRING EMPTY)
			  </programlisting>
			</para>
			</entry>
		</row>
		<row>
			<entry><para>
				  <programlisting>
-- same example but linestring orientation flipped
SELECT ST_AsText(
  ST_SharedPaths(
   ST_GeomFromText('LINESTRING(76 175,90 161,126 125,126 156.25,151 100)'),
   ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),
	   (51 150,101 150,76 175,51 150))')
	)
  ) As wkt

                                wkt
-------------------------------------------------------------
GEOMETRYCOLLECTION(MULTILINESTRING EMPTY,
MULTILINESTRING((76 175,90 161),(90 161,101 150),(126 125,126 156.25)))
			  </programlisting>
			</para>
			</entry>
		</row>
	</tbody>
	</tgroup>
</informaltable>
	 </refsection>
      <refsection>
        <title>See Also</title>
	<para>
		<xref linkend="ST_Dump" />,
		<xref linkend="ST_GeometryN" />,
		<xref linkend="ST_NumGeometries" />
	</para>
      </refsection>
	</refentry>

	<refentry id="ST_Shift_Longitude">
	  <refnamediv>
		<refname>ST_ShiftLongitude</refname>

		<refpurpose>Toggle geometry coordinates between -180..180 and 0..360 ranges.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_ShiftLongitude</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Reads every point/vertex in every component of every feature
			in a geometry, and if the longitude coordinate is &lt;0, adds 360
			to it. The result would be a 0-360 version of the data to be
			plotted in a 180 centric map</para>
		<note><para>This is only useful for data in long lat e.g. 4326 (WGS 84 long lat)</para></note>

		<warning>
			<para>Pre-1.3.4 bug prevented this from working for MULTIPOINT. 1.3.4+ works with MULTIPOINT as well.</para>
    </warning>

		<para>&Z_support;</para>
		<para>Enhanced: 2.0.0 support for Polyhedral surfaces and TIN was introduced.</para>
    <para>NOTE: this function was renamed from "ST_Shift_Longitude" in 2.2.0</para>
		<para>&P_support;</para>
		<para>&T_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>--3d points
SELECT ST_AsEWKT(ST_ShiftLongitude(ST_GeomFromEWKT('SRID=4326;POINT(-118.58 38.38 10)'))) As geomA,
	ST_AsEWKT(ST_ShiftLongitude(ST_GeomFromEWKT('SRID=4326;POINT(241.42 38.38 10)'))) As geomb
geomA							  geomB
----------						  -----------
SRID=4326;POINT(241.42 38.38 10) SRID=4326;POINT(-118.58 38.38 10)

--regular line string
SELECT ST_AsText(ST_ShiftLongitude(ST_GeomFromText('LINESTRING(-118.58 38.38, -118.20 38.45)')))

st_astext
----------
LINESTRING(241.42 38.38,241.8 38.45)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para>
      <xref linkend="ST_WrapX" />
    </para>
	  </refsection>
	</refentry>

	<refentry id="ST_WrapX">
	  <refnamediv>
		<refname>ST_WrapX</refname>

		<refpurpose>Wrap a geometry around an X value.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_WrapX</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
			<paramdef><type>float8 </type> <parameter>wrap</parameter></paramdef>
			<paramdef><type>float8 </type> <parameter>move</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

    <para>
This function splits the input geometries and then moves every resulting
component falling on the right (for negative 'move') or on the left (for
positive 'move') of given 'wrap' line in the direction specified by the
'move' parameter, finally re-unioning the pieces togheter.
    </para>

		<note><para>
This is useful to "recenter" long-lat input to have features
of interest not spawned from one side to the other.
    </para></note>

		<para>Availability: 2.3.0</para>

		<para>&Z_support;</para>
<!-- TODO: check these
		<para>&P_support;</para>
		<para>&T_support;</para>
-->
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
-- Move all components of the given geometries whose bounding box
-- falls completely on the left of x=0 to +360
select ST_WrapX(the_geom, 0, 360);

-- Move all components of the given geometries whose bounding box
-- falls completely on the left of x=-30 to +360
select ST_WrapX(the_geom, -30, 360);
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Shift_Longitude" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Simplify">
	  <refnamediv>
		<refname>ST_Simplify</refname>
		<refpurpose>Returns a "simplified" version of the given geometry using
				the Douglas-Peucker algorithm.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Simplify</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
			<paramdef><type>boolean</type> <parameter>preserveCollapsed</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a "simplified" version of the given geometry using
				the Douglas-Peucker algorithm. Will actually do something only with
				(multi)lines and (multi)polygons but you can safely call it with
				any kind of geometry. Since simplification occurs on a
				object-by-object basis you can also feed a GeometryCollection to
				this function.</para>

    <para>The "preserve collapsed" flag will retain objects that would otherwise
      be too small given the tolerance. For example, a 1m long line simplified with a 10m
      tolerance. If the preserve flag is given, the line will not disappear. This flag
      is useful for rendering engines, to avoid having large numbers of very
      small objects disappear from a map leaving surprising gaps.</para>

		<note><para>Note that returned geometry might lose its
				simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
		<note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>

		<para>Availability: 1.2.2</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>A circle simplified too much becomes a triangle, medium an octagon, </para>
				<programlisting>SELECT ST_Npoints(the_geom) AS np_before,
       ST_NPoints(ST_Simplify(the_geom,0.1)) AS np01_notbadcircle,
       ST_NPoints(ST_Simplify(the_geom,0.5)) AS np05_notquitecircle,
       ST_NPoints(ST_Simplify(the_geom,1)) AS np1_octagon,
       ST_NPoints(ST_Simplify(the_geom,10)) AS np10_triangle,
       (ST_Simplify(the_geom,100) is null) AS  np100_geometrygoesaway
  FROM
    (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) AS foo;

 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_triangle | np100_geometrygoesaway
-----------+-------------------+---------------------+-------------+---------------+------------------------
        49 |                33 |                  17 |           9 |             4 | t
      </programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_IsSimple" />, <xref linkend="ST_SimplifyPreserveTopology" />, Topology <xref linkend="TP_ST_Simplify"/></para>
		  </refsection>
	</refentry>

	<refentry id="ST_SimplifyPreserveTopology">
	  <refnamediv>
		<refname>ST_SimplifyPreserveTopology</refname>
		<refpurpose>Returns a "simplified" version of the given geometry using
			the Douglas-Peucker algorithm. Will avoid creating derived
			geometries (polygons in particular) that are invalid.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SimplifyPreserveTopology</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a "simplified" version of the given geometry using
			the Douglas-Peucker algorithm. Will avoid creating derived
			geometries (polygons in particular) that are invalid. Will actually do something only with
				(multi)lines and (multi)polygons but you can safely call it with
				any kind of geometry. Since simplification occurs on a
				object-by-object basis you can also feed a GeometryCollection to
				this function.</para>

		<para>Performed by the GEOS module.</para>
		<para>Availability: 1.3.3</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>Same example as Simplify, but we see Preserve Topology prevents oversimplification.  The circle can at most become a square.</para>
				<programlisting>
SELECT ST_Npoints(the_geom) As np_before, ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.1)) As np01_notbadcircle, ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.5)) As np05_notquitecircle,
ST_NPoints(ST_SimplifyPreserveTopology(the_geom,1)) As np1_octagon, ST_NPoints(ST_SimplifyPreserveTopology(the_geom,10)) As np10_square,
ST_NPoints(ST_SimplifyPreserveTopology(the_geom,100)) As  np100_stillsquare
FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) As foo;

--result--
 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_square | np100_stillsquare
-----------+-------------------+---------------------+-------------+---------------+-------------------
		49 |                33 |                  17 |           9 |             5 |                 5
				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Simplify" /></para>
		  </refsection>
	</refentry>

    <refentry id="ST_SimplifyVW">
	  <refnamediv>
		<refname>ST_SimplifyVW</refname>
		<refpurpose>Returns a "simplified" version of the given geometry using the Visvalingam-Whyatt algorithm</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SimplifyVW</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para> Returns a "simplified" version of the given geometry using the Visvalingam-Whyatt algorithm.
		Will actually do something only with (multi)lines and (multi)polygons but you can safely call it with any kind of geometry.
		Since simplification occurs on a object-by-object basis you can also feed a GeometryCollection to this function.</para>

		<note><para>Note that returned geometry might lose its
				simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
		<note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>
		<note><para>This function handles 3D and the third dimension will affect the result.</para></note>
		<para>Availability: 2.2.0</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>A LineString is simplified with a minimum area threshold of 30.</para>
				<programlisting>

select ST_AsText(ST_SimplifyVW(geom,30)) simplified
FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As foo;
-result
 simplified
------------------------------
LINESTRING(5 2,7 25,10 10)

				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_SetEffectiveArea" />, <xref linkend="ST_Simplify" />, <xref linkend="ST_SimplifyPreserveTopology" />, Topology <xref linkend="TP_ST_Simplify"/></para>
		  </refsection>
	</refentry>

	<refentry id="ST_ChaikinSmoothing">
	  <refnamediv>
		<refname>ST_ChaikinSmoothing</refname>
		<refpurpose>Returns a "smoothed" version of the given geometry using the Chaikin algorithm</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_ChaikinSmoothing</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
			<paramdef><type>integer</type> <parameter>nIterations = 1</parameter></paramdef>
			<paramdef><type>boolean</type> <parameter>preserveEndPoints = false</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para> Returns a "smoothed" version of the given geometry using the Chaikin algorithm.
        See <ulink url="http://www.idav.ucdavis.edu/education/CAGDNotes/Chaikins-Algorithm/Chaikins-Algorithm.html">Chaikins-Algorithm</ulink> for an explanation of the process.
		For each iteration the number of vertex points will double.
        The function puts new vertex points at 1/4 of the line before and after each point and removes the original point.
        To reduce the number of points use one of the simplification functions on the result.
        The new points gets interpolated values for all included dimensions, also z and m.</para>
		<para>Second argument, number of iterations is limited to max 5 iterations</para>
		<para>Note third argument is only valid for polygons, and will be ignored for linestrings</para>
		<para>This function handles 3D and the third dimension will affect the result.</para>
		<note><para>Note that returned geometry will get more points than the original.
                To reduce the number of points again use one of the simplification functions on the result.
                (see <xref linkend="ST_Simplify" /> and <xref linkend="ST_SimplifyVW" />)</para></note>
		<para>Availability: 2.5.0</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>A triangle is smoothed</para>
				<programlisting>
select ST_AsText(ST_ChaikinSmoothing(geom)) smoothed
FROM (SELECT  'POLYGON((0 0, 8 8, 0 16, 0 0))'::geometry geom) As foo;

                 smoothed                  

 POLYGON((2 2,6 6,6 10,2 14,0 12,0 4,2 2)) 

				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Simplify" />, <xref linkend="ST_SimplifyVW" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_FilterByM">
	  <refnamediv>
		<refname>ST_FilterByM</refname>
		<refpurpose>Filters vertex points based on their m-value</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_FilterByM</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>min</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>max = null</parameter></paramdef>
			<paramdef><type>boolean</type> <parameter>returnM = false</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Filters away vertex points based on their m-value. Returns a geometry with only
			vertex points that have a m-value larger or equal to the min value and smaller or equal to
			the max value. If max-value argument is left out only min value is considered. If fourth argument is left out the m-value
			will not be in the resulting geometry. If resulting geometry have too few vertex points left for its geometry type an empty
			geometry will be returned. In a geometry collection
			geometries without enough points will just be left out silently.</para>
		<para>This function is mainly intended to be used in conjunction with ST_SetEffectiveArea. ST_EffectiveArea sets the effective area
			of a vertex in its m-value. With ST_FilterByM it then is possible to get a simplified version of the geometry without any calculations, just by filtering</para>

		<note><para>There is a difference in what ST_SimplifyVW returns when not enough points meet the criteria compared to ST_FilterByM.
				ST_SimplifyVW returns the geometry with enough points while ST_FilterByM returns an empty geometry</para></note>
		<note><para>Note that the retuned geometry might be invalid</para></note>
		<note><para>This function returns all dimensions, also the z and m-value</para></note>
		<para>Availability: 2.5.0</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>A linestring is filtered</para>
				<programlisting>


SELECT ST_AsText(ST_FilterByM(geom,30)) simplified
FROM (SELECT  ST_SetEffectiveArea('LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry) geom) As foo;
-result
         simplified
----------------------------
 LINESTRING(5 2,7 25,10 10)

				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_SetEffectiveArea" />, <xref linkend="ST_SimplifyVW" /></para>
		  </refsection>
	</refentry>

    <refentry id="ST_SetEffectiveArea">
	  <refnamediv>
		<refname>ST_SetEffectiveArea</refname>
		<refpurpose>
			Sets the effective area for each vertex, storing the value in the M ordinate.  A simplified geometry can then be generated by filtering on the M ordinate.
		</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SetEffectiveArea</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>threshold = 0</parameter></paramdef>
			<paramdef><type>integer</type> <parameter>set_area = 1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>
			Sets the effective area for each vertex, using the Visvalingam-Whyatt algorithm.
			The effective area is stored as the M-value of the vertex.
			If the optional "theshold" parameter is used, a simplified geometry will be returned, containing only vertices with an effective area
            greater than or equal to the threshold value.
			</para><para>
			This function can be used for server-side simplification when a threshold is specified.  Another option is to use a threshold value of zero.
			In this case, the full geometry will be returned with effective areas as M-values, which can be used by the client to simplify very quickly.
			</para><para>
			Will actually do something only with
			(multi)lines and (multi)polygons but you can safely call it with
			any kind of geometry. Since simplification occurs on a
			object-by-object basis you can also feed a GeometryCollection to
			this function.
			</para>


		<note><para>Note that returned geometry might lose its
				simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
		<note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>
		<note><para>The output geometry will lose all previous information in the M-values</para></note>
		<note><para>This function handles 3D and the third dimension will affect the effective area</para></note>
		<para>Availability: 2.2.0</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>
				Calculating the effective area of a LineString.  Because we use a threshold value of zero, all vertices in the input geometry are returned.
			</para>
				<programlisting>

select ST_AsText(ST_SetEffectiveArea(geom)) all_pts, ST_AsText(ST_SetEffectiveArea(geom,30) ) thrshld_30
FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As foo;
-result
 all_pts | thrshld_30
-----------+-------------------+
LINESTRING M (5 2 3.40282346638529e+38,3 8 29,6 20 1.5,7 25 49.5,10 10 3.40282346638529e+38) | LINESTRING M (5 2 3.40282346638529e+38,7 25 49.5,10 10 3.40282346638529e+38)

				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_SimplifyVW" /></para>
		  </refsection>
	</refentry>

    <refentry id="ST_Split">
        <refnamediv>
            <refname>ST_Split</refname>
            <refpurpose>Returns a collection of geometries resulting by splitting a geometry.</refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>
              <funcprototype>
                <funcdef>geometry <function>ST_Split</function></funcdef>
                <paramdef><type>geometry</type> <parameter>input</parameter></paramdef>
                <paramdef><type>geometry</type> <parameter>blade</parameter></paramdef>
              </funcprototype>
            </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>
            <para>
            The function supports splitting a line by (multi)point, (multi)line or (multi)polygon boundary, a (multi)polygon by line. The returned geometry is always a collection.
            </para>

            <para>
            Think of this function as the opposite of ST_Union.
            Theoretically applying ST_Union to the elements of the returned collection
            should always yield the original geometry.
            </para>

            <para>Availability: 2.0.0</para>
            <para>Enhanced: 2.2.0 support for splitting a line by a multiline, a multipoint or (multi)polygon boundary was introduced.</para>
        	<para>Enhanced: 2.5.0 support for splitting a polygon by a multiline was introduced.</para>

            <note><para>To improve the robustness of ST_Split it may be convenient to <xref linkend="ST_Snap"/> the input to the blade in advance using a very low tolerance. Otherwise the internally used coordinate grid may cause tolerance problems, where coordinates of input and blade do not fall onto each other and the input is not being split correctly (see <ulink url="http://trac.osgeo.org/postgis/ticket/2192">#2192</ulink>).</para></note>

            <note><para>
When a (multi)polygon is passed as as the blade, its linear component
(the boundary) is used for cutting the input.
            </para></note>

        </refsection>
        <refsection>
            <title>Examples</title>
            <para>Polygon Cut by Line</para>
            <informaltable>
                <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split01.png" />
                              </imageobject>
                              <caption><para>Before Split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                               </para>
                        </entry>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split02.png" />
                              </imageobject>
                              <caption><para>After split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                              </para>
                        </entry>
                    </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <programlisting>
-- this creates a geometry collection consisting of the 2 halves of the polygon
-- this is similar to the example we demonstrated in ST_BuildArea
SELECT ST_Split(circle, line)
FROM (SELECT
    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,
    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

-- result --
 GEOMETRYCOLLECTION(POLYGON((150 90,149.039264020162 80.2454838991936,146.193976625564 70.8658283817455,..), POLYGON(..)))

-- To convert to individual polygons, you can use ST_Dump or ST_GeometryN
SELECT ST_AsText((ST_Dump(ST_Split(circle, line))).geom) As wkt
FROM (SELECT
    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,
    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

-- result --
wkt
---------------
POLYGON((150 90,149.039264020162 80.2454838991936,..))
POLYGON((60.1371179574584 60.1371179574584,58.4265193848728 62.2214883490198,53.8060233744357 ..))
            </programlisting>
            <para>Multilinestring Cut by point</para>
            <informaltable>
                <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split03.png" />
                              </imageobject>
                              <caption><para>Before Split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                               </para>
                        </entry>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split04.png" />
                              </imageobject>
                              <caption><para>After split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                               </para>
                        </entry>
                    </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <programlisting>
SELECT ST_AsText(ST_Split(mline, pt)) As wktcut
        FROM (SELECT
    ST_GeomFromText('MULTILINESTRING((10 10, 190 190), (15 15, 30 30, 100 90))') As mline,
    ST_Point(30,30) As pt) As foo;

wktcut
------
GEOMETRYCOLLECTION(
    LINESTRING(10 10,30 30),
    LINESTRING(30 30,190 190),
    LINESTRING(15 15,30 30),
    LINESTRING(30 30,100 90)
)
            </programlisting>
        </refsection>
        <refsection>
        <title>See Also</title>
        <para>
<xref linkend="ST_AsText" />,
<xref linkend="ST_BuildArea" />,
<xref linkend="ST_Dump" />,
<xref linkend="ST_GeometryN" />,
<xref linkend="ST_Union" />,
<xref linkend="ST_Subdivide" />
        </para>
        </refsection>
    </refentry>

	<refentry id="ST_SymDifference">
	  <refnamediv>
		<refname>ST_SymDifference</refname>

		<refpurpose>Returns a geometry that represents the portions of A and B
			that do not intersect. It is called a symmetric difference because
			ST_SymDifference(A,B) = ST_SymDifference(B,A).</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SymDifference</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a geometry that represents the portions of A and B
			that do not intersect. It is called a symmetric difference because
			ST_SymDifference(A,B) = ST_SymDifference(B,A). One can think of this as ST_Union(geomA,geomB) - ST_Intersection(A,B).
			</para>

		<para>Performed by the GEOS module</para>
		<para>&sfs_compliant; s2.1.1.3</para>
		<para>&sqlmm_compliant; SQL-MM 3: 5.1.21</para>
		<para>&Z_support; However it seems to only consider x y when
		  doing the difference and tacks back on the Z-Index</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<informaltable>
			  <tgroup cols="2">
				<tbody>
				  <row>
					<entry>
						<para>
							<informalfigure>
								<mediaobject>
								  <imageobject>
									<imagedata fileref="images/st_symdifference01.png" />
								  </imageobject>
								  <caption><para>The original linestrings shown together</para></caption>
								</mediaobject>
							</informalfigure>
						</para>
					</entry>

					<entry>
						<para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_symdifference02.png" />
							  </imageobject>
							  <caption><para>The symmetric difference of the two linestrings</para></caption>
							</mediaobject>
						  </informalfigure>
					</para>
				</entry>
				  </row>
		</tbody>
	</tgroup>
</informaltable>
<programlisting>
--Safe for 2d - symmetric difference of 2 linestrings
SELECT ST_AsText(
	ST_SymDifference(
		ST_GeomFromText('LINESTRING(50 100, 50 200)'),
		ST_GeomFromText('LINESTRING(50 50, 50 150)')
	)
);

st_astext
---------
MULTILINESTRING((50 150,50 200),(50 50,50 100))
</programlisting>

<programlisting>

--When used in 3d doesn't quite do the right thing
SELECT ST_AsEWKT(ST_SymDifference(ST_GeomFromEWKT('LINESTRING(1 2 1, 1 4 2)'),
	ST_GeomFromEWKT('LINESTRING(1 1 3, 1 3 4)')))

st_astext
------------
MULTILINESTRING((1 3 2.75,1 4 2),(1 1 3,1 2 2.25))
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Difference" />, <xref linkend="ST_Intersection" />, <xref linkend="ST_Union" /></para>
	  </refsection>
</refentry>


	<refentry id="ST_Subdivide">
	  <refnamediv>
		<refname>ST_Subdivide</refname>
		<refpurpose>Returns a set of geometry where no geometry in the set has more than the specified number of vertices.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>setof geometry <function>ST_Subdivide</function></funcdef>
				<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
				<paramdef><type>integer</type> <parameter>max_vertices=256</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	</refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
			Divides geometry into parts until a part can be represented using no more than <code>max_vertices</code>.
			Point-in-polygon and other overlay operations are normally faster for indexed subdivided dataset:
			"miss" cases are faster to check as boxes for all parts typically cover smaller area than original geometry box,
			"hit" cases are faster because recheck operates on less points.
			Uses the same envelope clipping as <code>ST_ClipByBox2D</code>.
			<code>max_vertices</code> must be 5 or more, as 5 points are needed to represent a closed box.
		</para>
		<para>Performed by the GEOS module.</para>
		<para>Availability: 2.2.0</para>
		<para>Enhanced: 2.5.0 reuses existing points on polygon split, vertex count is lowered from 8 to 5.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
			<programlisting>-- Subdivide complex geometries in table, in place
with complex_areas_to_subdivide as (
    delete from polygons_table
    where ST_NPoints(geom) > 255
    returning id, column1, column2, column3, geom
)
insert into polygons_table (fid, column1, column2, column3, geom)
    select
        fid, column1, column2, column3,
        ST_Subdivide(geom, 255) as geom
    from complex_areas_to_subdivide;
 </programlisting>

			<programlisting>-- Create a new subdivided table suitable for joining to the original
CREATE TABLE subdivided_geoms AS
SELECT pkey, ST_Subdivide(geom) AS geom
FROM original_geoms;
 </programlisting>

				<informaltable>
				  <tgroup cols="1">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_subdivide01.png" />
							  </imageobject>
							  <caption><para>Subdivide max 10 vertices</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>SELECT row_number() OVER() As rn, ST_AsText(geom) As wkt
FROM ( SELECT ST_SubDivide('POLYGON((132 10,119 23,85 35,68 29,66 28,49 42,32 56,22 64,32 110,40 119,36 150,
57 158,75 171,92 182,114 184,132 186,146 178,176 184,179 162,184 141,190 122,
190 100,185 79,186 56,186 52,178 34,168 18,147 13,132 10))'::geometry,10))  As f(geom);</programlisting>
<screen> rn                                                       wkt

  1  POLYGON((119 23,85 35,68 29,66 28,32 56,22 64,29.8260869565217 100,119 100,119 23))
  2  POLYGON((132 10,119 23,119 56,186 56,186 52,178 34,168 18,147 13,132 10))
  3  POLYGON((119 56,119 100,190 100,185 79,186 56,119 56))
  4  POLYGON((29.8260869565217 100,32 110,40 119,36 150,57 158,75 171,92 182,114 184,114 100,29.8260869565217 100))
  5  POLYGON((114 184,132 186,146 178,176 184,179 162,184 141,190 122,190 100,114 100,114 184))</screen>
						  </para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_subdivide02.png" />
							  </imageobject>
							  <caption><para>Useful in conjunction with ST_Segmentize(geography) to create additional vertices that can then be used for splitting.</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>SELECT ST_AsText(ST_Subdivide(ST_Segmentize('LINESTRING(0 0, 85 85)'::geography,1200000)::geometry,8));</programlisting>
				<screen>
LINESTRING(0 0,0.487578359029357 5.57659056746196,0.984542144675897 11.1527721155093,1.50101059639722 16.7281035483571,1.94532113630331 21.25)
LINESTRING(1.94532113630331 21.25,2.04869538062779 22.3020741387339,2.64204641967673 27.8740533545155,3.29994062412787 33.443216802941,4.04836719489742 39.0084282520239,4.59890468420694 42.5)
LINESTRING(4.59890468420694 42.5,4.92498503922732 44.5680389206321,5.98737409390639 50.1195229244701,7.3290919767674 55.6587646879025,8.79638749938413 60.1969505994924)
LINESTRING(8.79638749938413 60.1969505994924,9.11375579533779 61.1785363177625,11.6558166691368 66.6648504160202,15.642041247655 72.0867690601745,22.8716627200212 77.3609628116894,24.6991785131552 77.8939011989848)
LINESTRING(24.6991785131552 77.8939011989848,39.4046096622744 82.1822848017636,44.7994523421035 82.5156766227011)
LINESTRING(44.7994523421035 82.5156766227011,85 85)</screen>
						  </para></entry>
					  </row>
				</tbody></tgroup></informaltable>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para>
<xref linkend="ST_AsText" />,
<xref linkend="ST_ClipByBox2D" />,
<xref linkend="ST_Segmentize" />,
<xref linkend="ST_Split" />,
<xref linkend="ST_NPoints" />
    </para>
	  </refsection>
	</refentry>

<refentry id="ST_Union">
  <refnamediv>
	<refname>ST_Union</refname>
	<refpurpose>Returns a geometry that represents the point set union of
		the Geometries.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
	<funcsynopsis>
	  <funcprototype>
		<funcdef>geometry <function>ST_Union</function></funcdef>
		<paramdef><type>geometry set</type> <parameter>g1field</parameter></paramdef>
	  </funcprototype>
	  <funcprototype>
		<funcdef>geometry <function>ST_Union</function></funcdef>
		<paramdef><type>geometry</type> <parameter>g1</parameter></paramdef>
		<paramdef><type>geometry</type> <parameter>g2</parameter></paramdef>
	  </funcprototype>
	  <funcprototype>
		<funcdef>geometry <function>ST_Union</function></funcdef>
		<paramdef><type>geometry[]</type> <parameter>g1_array</parameter></paramdef>
	  </funcprototype>
	</funcsynopsis>
  </refsynopsisdiv>

  <refsection>
	<title>Description</title>
	<para> Output type can be a MULTI*, single geometry, or Geometry Collection. Comes in 2 variants.  Variant 1 unions 2 geometries resulting in a new geometry with no intersecting regions.
		Variant 2 is an aggregate function that takes a set of geometries and unions
		them into a single ST_Geometry resulting in no intersecting regions.</para>

	<para>Aggregate version: This function returns a MULTI geometry or NON-MULTI geometry
		from a set of geometries. The ST_Union() function is an "aggregate"
		function in the terminology of PostgreSQL. That means that it
		operates on rows of data, in the same way the SUM() and AVG()
		functions do and like most aggregates, it also ignores NULL geometries.</para>

	<para>Non-Aggregate version: This function returns a geometry being a union of two
		input geometries. Output type can be a MULTI*, NON-MULTI or
		GEOMETRYCOLLECTION. If any are NULL, then NULL is returned.</para>

	<note><para>ST_Collect and ST_Union are often interchangeable.
		ST_Union is in general orders of magnitude slower than ST_Collect
		because it tries to dissolve boundaries and reorder geometries to ensure that a constructed Multi* doesn't
		have intersecting regions.</para></note>

		<para>ST_Union will use the faster Cascaded Union algorithm described in <ulink
		url="http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html">http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html</ulink></para>

	<para>Performed by the GEOS module.</para>
	<para>NOTE: this function was formerly called GeomUnion(), which
		was renamed from "Union" because UNION is an SQL reserved
		word.</para>
	<para>Availability: 1.4.0 - ST_Union was enhanced. ST_Union(geomarray) was introduced and also faster aggregate collection in PostgreSQL.</para>
	<para>Changed: 3.0.0 does not depend on SFCGAL.</para>

	<para>&sfs_compliant; s2.1.1.3</para>
	<note><para>Aggregate version is not explicitly defined in OGC SPEC.</para></note>
	<para>&sqlmm_compliant; SQL-MM 3: 5.1.19
		the z-index (elevation) when polygons are involved.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>Aggregate example</para>
			<programlisting>
SELECT stusps,
  	   ST_Union(f.geom) as singlegeom
FROM sometable f
GROUP BY stusps
			  </programlisting>
		<para>Non-Aggregate example</para>
			<programlisting>
select ST_AsText(ST_Union('POINT(1 2)' :: geometry, 'POINT(-2 3)' :: geometry))

st_astext
----------
MULTIPOINT(-2 3,1 2)

select ST_AsText(ST_Union('POINT(1 2)' :: geometry, 'POINT(1 2)' :: geometry))

st_astext
----------
POINT(1 2)</programlisting>
<para>3D example - sort of supports 3D (and with mixed dimensions!)</para>
<programlisting>select ST_AsEWKT(ST_Union(geom))
from (
         select 'POLYGON((-7 4.2,-7.1 4.2,-7.1 4.3, -7 4.2))'::geometry geom
         union all
         select 'POINT(5 5 5)'::geometry geom
         union all
         select 'POINT(-2 3 1)'::geometry geom
         union all
         select 'LINESTRING(5 5 5, 10 10 10)'::geometry geom
     ) as foo;

st_asewkt
---------
GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 4.2 5,-7.1 4.2 5,-7.1 4.3 5,-7 4.2 5)));
</programlisting>
<para>3d example not mixing dimensions</para>
<programlisting>select ST_AsEWKT(ST_Union(geom))
from (
         select 'POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2, -7 4.2 2))'::geometry geom
         union all
         select 'POINT(5 5 5)'::geometry geom
         union all
         select 'POINT(-2 3 1)'::geometry geom
         union all
         select 'LINESTRING(5 5 5, 10 10 10)'::geometry geom
     ) as foo;

st_asewkt
---------
GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2,-7 4.2 2)))

--Examples using new Array construct
SELECT ST_Union(ARRAY(SELECT the_geom FROM sometable));

SELECT ST_AsText(ST_Union(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 4)'),
			ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As wktunion;

--wktunion---
MULTILINESTRING((3 4,4 5),(1 2,3 4))

			  </programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para>
			<xref linkend="ST_Collect" />,
			<xref linkend="ST_UnaryUnion" />,
			<xref linkend="ST_Intersection" />,
			<xref linkend="ST_Difference" />
			<xref linkend="ST_SymDifference" />
		</para>
	  </refsection>
	</refentry>

	<refentry id="ST_UnaryUnion">
	  <refnamediv>
		<refname>ST_UnaryUnion</refname>

		<refpurpose>Like ST_Union, but working at the geometry component level.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_UnaryUnion</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
		Unlike ST_Union, ST_UnaryUnion does dissolve boundaries
		between components of a multipolygon (invalid)
		and does perform union between the components of a
		geometrycollection.
		Each components of the input geometry is assumed to be
		valid, so you won't get a valid multipolygon out of a
		bow-tie polygon (invalid).
		</para>

		<para>
		You may use this function to node a set of linestrings.
		You may mix ST_UnaryUnion with ST_Collect to fine-tune
		how many geometries at once you want to dissolve to
		be nice on both memory size and CPU time, finding the
		balance between ST_Union and ST_MemUnion.
		</para>

		<para>&Z_support;</para>

		<para>Availability: 2.0.0</para>
	  </refsection>


	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
			<xref linkend="ST_Union" />,
			<xref linkend="ST_MemUnion" />,
			<xref linkend="ST_Collect" />,
			<xref linkend="ST_Node" />
		</para>
	  </refsection>
	</refentry>

	<refentry id="ST_VoronoiLines">
	  <refnamediv>
		<refname>ST_VoronoiLines</refname>

		<refpurpose>Returns the boundaries between the cells of the Voronoi diagram constructed from the vertices of a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_VoronoiLines</function></funcdef>
			<paramdef>
				<parameter>g1</parameter>
				<type>geometry</type>
			</paramdef>
			<paramdef choice="opt">
				<parameter>tolerance</parameter>
				<type>float8</type>
			</paramdef>
			<paramdef choice="opt">
				<parameter>extend_to</parameter>
				<type>geometry</type>
			</paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>
			ST_VoronoiLines computes a two-dimensional <ulink url="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</ulink> from the vertices of
			the supplied geometry and returns the boundaries between cells in that diagram as a MultiLineString.
			Returns null if input geometry is null. Returns an empty geometry collection if the input geometry contains only one vertex. Returns an empty geometry collection if the extend_to envelope has zero area.
		</para>
		<para>
			Optional parameters:
			<itemizedlist>
				<listitem>
					<para> 'tolerance' : The distance within which vertices will be considered equivalent.  Robustness of the algorithm can be improved by supplying a nonzero tolerance distance.  (default = 0.0)</para>
				</listitem>
				<listitem>
					<para>'extend_to' : If a geometry is supplied as the "extend_to" parameter, the diagram will be extended to cover the envelope of the "extend_to" geometry, unless
						that envelope is smaller than the default envelope (default = NULL, default envelope is boundingbox of input geometry extended by about 50% in each direction).</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>Performed by the GEOS module.</para>
		<para>Availability: 2.3.0</para>
	  </refsection>

	  <!-- Examples -->
	  <refsection>
		<title>Examples</title>
		<informaltable>
		  <tgroup cols="1">
			<tbody>
			 <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_voronoi03.png" />
					  </imageobject>
					  <caption><para>Voronoi lines with tolerance of 30 units</para></caption>
					</mediaobject>
				  </informalfigure>
					<programlisting>SELECT ST_VoronoiLines(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g</programlisting>
<screen> -- ST_AsText output
MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 -45.7142857142858,36.8181818181818 92.2727272727273))
</screen>
				</para></entry>
			  </row>
		</tbody>
		</tgroup>
		</informaltable>

	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
			<xref linkend="ST_DelaunayTriangles" />,
			<xref linkend="ST_VoronoiPolygons" />,
			<xref linkend="ST_Collect" />
		</para>
	  </refsection>
	</refentry>

	<refentry id="ST_VoronoiPolygons">
	  <refnamediv>
		<refname>ST_VoronoiPolygons</refname>

		<refpurpose>Returns the cells of the Voronoi diagram constructed from the vertices of a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_VoronoiPolygons</function></funcdef>
			<paramdef>
				<parameter>g1</parameter>
				<type>geometry</type>
			</paramdef>
			<paramdef choice="opt">
				<parameter>tolerance</parameter>
				<type>float8</type>
			</paramdef>
			<paramdef choice="opt">
				<parameter>extend_to</parameter>
				<type>geometry</type>
			</paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
			ST_VoronoiPolygons computes a two-dimensional <ulink url="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</ulink> from the vertices of
			the supplied geometry.  The result is a GeometryCollection of Polygons that covers an envelope larger than the extent of the input vertices.
			Returns null if input geometry is null. Returns an empty geometry collection if the input geometry contains only one vertex. Returns an empty geometry collection if the extend_to envelope has zero area.
		</para>

		<para>
			Optional parameters:
			<itemizedlist>
				<listitem>
					<para> 'tolerance' : The distance within which vertices will be considered equivalent.  Robustness of the algorithm can be improved by supplying a nonzero tolerance distance.  (default = 0.0)</para>
				</listitem>
				<listitem>
					<para>'extend_to' : If a geometry is supplied as the "extend_to" parameter, the diagram will be extended to cover the envelope of the "extend_to" geometry, unless
						that envelope is smaller than the default envelope (default = NULL, default envelope is boundingbox of input geometry extended by about 50% in each direction).
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>Performed by the GEOS module.</para>
		<para>Availability: 2.3.0</para>
	  </refsection>

	  <!-- Examples -->
	  <refsection>
		<title>Examples</title>
		<informaltable>
		  <tgroup cols="1">
			<tbody>
			  <row>
				<entry>
					<para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_voronoi01.png" />
					  </imageobject>
					  <caption><para>Points overlaid on top of Voronoi diagram</para></caption>
					</mediaobject>
					</informalfigure>
					<programlisting>SELECT
	ST_VoronoiPolygons(geom) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g;</programlisting>
<screen> -- ST_AsText output
GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 43.3333333333333)),
POLYGON((55 -90,-110 -90,-110 43.3333333333333,36.8181818181818 92.2727272727273,55 79.2857142857143,55 -90)),
POLYGON((230 47.5,230 -20.7142857142857,55 79.2857142857143,36.8181818181818 92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 -20.7142857142857,230 -90,55 -90,55 79.2857142857143,230 -20.7142857142857)),
POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 270)))
</screen>
					</para>
				</entry>
			</row>
			<row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_voronoi02.png" />
					  </imageobject>
					  <caption><para>Voronoi with tolerance of 30 units</para></caption>
					</mediaobject>
				  </informalfigure>
					<programlisting>SELECT ST_VoronoiPolygons(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g;</programlisting>
<screen> -- ST_AsText output
GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 43.3333333333333)),
POLYGON((230 47.5,230 -45.7142857142858,36.8181818181818 92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 -45.7142857142858,230 -90,-110 -90,-110 43.3333333333333,36.8181818181818 92.2727272727273,230 -45.7142857142858)),
POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 270)))
</screen>
				</para></entry>
			  </row>
			 <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_voronoi03.png" />
					  </imageobject>
					  <caption><para>Voronoi with tolerance of 30 units as MultiLineString</para></caption>
					</mediaobject>
				  </informalfigure>
					<programlisting>SELECT ST_VoronoiLines(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g</programlisting>
<screen> -- ST_AsText output
MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 -45.7142857142858,36.8181818181818 92.2727272727273))
</screen>
				</para></entry>
			  </row>
		</tbody>
		</tgroup>
		</informaltable>

	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
			<xref linkend="ST_DelaunayTriangles" />,
			<xref linkend="ST_VoronoiLines" />,
			<xref linkend="ST_Collect" />
		</para>
	  </refsection>
	</refentry>
</sect1>
