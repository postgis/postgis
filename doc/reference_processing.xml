<?xml version="1.0" encoding="UTF-8"?>
	<sect1 id="Geometry_Processing">
		<title>Geometry Processing</title>
		<refentry id="ST_Buffer">
			<refnamediv>
				<refname>ST_Buffer</refname>

				<refpurpose>
(T)
Returns a geometry covering all points within a given distance
from the input geometry.
			</refpurpose>
			</refnamediv>

			<refsynopsisdiv>
				<funcsynopsis>
				  <funcprototype>
					<funcdef>geometry <function>ST_Buffer</function></funcdef>
					<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
				  </funcprototype>

				  <funcprototype>
					<funcdef>geometry <function>ST_Buffer</function></funcdef>
					<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
					<paramdef><type>integer </type> <parameter>num_seg_quarter_circle</parameter></paramdef>
				  </funcprototype>

				  <funcprototype>
					<funcdef>geometry <function>ST_Buffer</function></funcdef>
					<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
					<paramdef><type>text </type> <parameter>buffer_style_parameters</parameter></paramdef>
				  </funcprototype>

				  <funcprototype>
					<funcdef>geography <function>ST_Buffer</function></funcdef>
					<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer_in_meters</parameter></paramdef>
				  </funcprototype>

              <funcprototype>
					<funcdef>geography <function>ST_Buffer</function></funcdef>
					<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
					<paramdef><type>integer </type> <parameter>num_seg_quarter_circle</parameter></paramdef>
				  </funcprototype>

				  <funcprototype>
					<funcdef>geography <function>ST_Buffer</function></funcdef>
					<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
					<paramdef><type>float </type> <parameter>radius_of_buffer</parameter></paramdef>
					<paramdef><type>text </type> <parameter>buffer_style_parameters</parameter></paramdef>
				  </funcprototype>

				</funcsynopsis>
			</refsynopsisdiv>

			  <refsection>
				<title>Description</title>

				<para>Returns a geometry/geography that represents all points whose distance
			from this Geometry/geography is less than or equal to distance. </para>
			<para>Geometry: Calculations
			are in the Spatial Reference System of the geometry. Introduced in 1.5 support for
			different end cap and mitre settings to control shape.</para>
			<note><para>Negative radii: For polygons, a negative radius can be used, which will shrink the polygon rather than expanding it.</para></note>
				<note><para>Geography: For geography this is really a thin wrapper around the geometry implementation. It first determines the best SRID that
					fits the bounding box of the geography object (favoring UTM, Lambert Azimuthal Equal Area (LAEA) north/south pole, and falling back on mercator in worst case scenario) and then buffers in that planar spatial ref and retransforms back to WGS84 geography.</para></note>
			<para><inlinegraphic fileref="images/warning.png" />
			For geography this may not behave as expected if object is sufficiently large that it falls between two UTM zones or crosses the dateline</para>
				<para>Availability: 1.5 - ST_Buffer was enhanced to support different endcaps and join types. These are useful for example to convert road linestrings
					into polygon roads with flat or square edges instead of rounded edges. Thin wrapper for geography was added. - requires GEOS &gt;= 3.2 to take advantage of advanced geometry functionality.
				</para>
				<para>
The optional third parameter (currently only applies to geometry) can either specify number of segments used to approximate a quarter circle (integer case, defaults to 8) or a list of blank-separated key=value pairs (string case) to tweak operations as follows:
<itemizedlist>
<listitem>
<para>'quad_segs=#' : number of segments used to approximate a quarter circle (defaults to 8).</para>
</listitem>
<listitem>
<para>'endcap=round|flat|square' : endcap style (defaults to "round", needs GEOS-3.2 or higher for a different value). 'butt' is also accepted as a synonym for 'flat'.</para>
</listitem>
<listitem>
<para>'join=round|mitre|bevel' : join style (defaults to "round", needs GEOS-3.2 or higher for a different value). 'miter' is also accepted as a synonym for 'mitre'.</para>
</listitem>
<listitem>
<para>'mitre_limit=#.#' : mitre ratio limit (only affects mitered join style). 'miter_limit' is also accepted as a synonym for 'mitre_limit'.</para>
</listitem>
</itemizedlist>
				</para>

				<para>Units of radius are measured in units of the spatial reference system.</para>
				<para>The inputs can be POINTS, MULTIPOINTS, LINESTRINGS, MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS, and GeometryCollections.</para>
				<note><para>This function ignores the third dimension (z) and will always give a 2-d buffer even when presented with a 3d-geometry.</para></note>

				<para>Performed by the GEOS module.</para>
				<para>&sfs_compliant; s2.1.1.3</para>
				<para>&sqlmm_compliant; SQL-MM 3: 5.1.17</para>

				<note><para>People often make the mistake of using this function to try to do radius searches.  Creating a
					buffer to a radius search is slow and pointless.  Use <xref linkend="ST_DWithin" /> instead.</para></note>
			</refsection>

			  <refsection>
				<title>Examples</title>

				<informaltable>
				  <tgroup cols="2">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer01.png" />
							  </imageobject>
							  <caption><para>quad_segs=8 (default)</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText('POINT(100 90)'),
 50, 'quad_segs=8');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer02.png" />
							  </imageobject>
							  <caption><para>quad_segs=2 (lame)</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText('POINT(100 90)'),
 50, 'quad_segs=2');
				</programlisting>
						</para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer03.png" />
							  </imageobject>
							  <caption><para>endcap=round join=round (default)</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=round join=round');
				</programlisting>
						 </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer04.png" />
							  </imageobject>
							  <caption><para>endcap=square</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=square join=round');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer05.png" />
							  </imageobject>
							  <caption><para>endcap=flat</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'endcap=flat join=round');
				</programlisting>
						  </para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer07.png" />
							  </imageobject>
							  <caption><para>join=bevel</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=bevel');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer06.png" />
							  </imageobject>
							  <caption><para>join=mitre mitre_limit=5.0 (default mitre limit)</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=mitre mitre_limit=5.0');
				</programlisting>
						  </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buffer08.png" />
							  </imageobject>
							  <caption><para>join=mitre mitre_limit=1</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_Buffer(
 ST_GeomFromText(
  'LINESTRING(50 50,150 150,150 50)'
 ), 10, 'join=mitre mitre_limit=1.0');
				</programlisting>
						  </para></entry>
					  </row>
					</tbody>
				  </tgroup>
			</informaltable>

<programlisting>--A buffered point approximates a circle
-- A buffered point forcing approximation of (see diagram)
-- 2 points per quarter circle is poly with 8 sides (see diagram)
SELECT ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50)) As promisingcircle_pcount,
ST_NPoints(ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50, 2)) As lamecircle_pcount;

promisingcircle_pcount | lamecircle_pcount
------------------------+-------------------
			 33 |                9

--A lighter but lamer circle
-- only 2 points per quarter circle is an octagon
--Below is a 100 meter octagon
-- Note coordinates are in NAD 83 long lat which we transform
to Mass state plane meter and then buffer to get measurements in meters;
SELECT ST_AsText(ST_Buffer(
ST_Transform(
ST_SetSRID(ST_MakePoint(-71.063526, 42.35785),4269), 26986)
,100,2)) As octagon;
----------------------
POLYGON((236057.59057465 900908.759918696,236028.301252769 900838.049240578,235
957.59057465 900808.759918696,235886.879896532 900838.049240578,235857.59057465
900908.759918696,235886.879896532 900979.470596815,235957.59057465 901008.759918
696,236028.301252769 900979.470596815,236057.59057465 900908.759918696))
		</programlisting>
			  </refsection>

			  <refsection>
				<title>See Also</title>

				<para><xref linkend="ST_Collect" />, <xref linkend="ST_DWithin" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_Transform" />, <xref linkend="ST_Union" /></para>
			  </refsection>
		</refentry>

		<refentry id="ST_BuildArea">
		  <refnamediv>
			<refname>ST_BuildArea</refname>

			<refpurpose>Creates an areal geometry formed by the constituent linework
			of given geometry</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_BuildArea</function></funcdef>
				<paramdef><type>geometry </type> <parameter>A</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Creates an areal geometry formed by the constituent linework
			of given geometry. The return type can be a Polygon or
			MultiPolygon, depending on input. If the input lineworks do not
			form polygons NULL is returned.  The inputs can be LINESTRINGS, MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS, and GeometryCollections.
			</para>
			<para>This function will assume all inner geometries represent holes</para>

			<note>
				<para>Input linework must be correctly noded for this function to work properly</para>
			</note>

			<para>Availability: 1.1.0 - requires GEOS &gt;= 2.1.0.</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
			<informaltable>
				  <tgroup cols="1">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buildarea01.png" />
							  </imageobject>
							  <caption><para>This will create a donut</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_BuildArea(ST_Collect(smallc,bigc))
FROM (SELECT
	ST_Buffer(
	  ST_GeomFromText('POINT(100 90)'), 25) As smallc,
	ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As bigc) As foo;
				</programlisting>
						  </para></entry>
					</row>
					<row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_buildarea02.png" />
							  </imageobject>
							  <caption><para>This will create a gaping hole inside the circle with prongs sticking out</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_BuildArea(ST_Collect(line,circle))
FROM (SELECT
	ST_Buffer(
		ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)),
				5)  As line,
	ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

--this creates the same gaping hole
--but using linestrings instead of polygons
SELECT ST_BuildArea(
	ST_Collect(ST_ExteriorRing(line),ST_ExteriorRing(circle))
	)
FROM (SELECT ST_Buffer(
	ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190))
		,5)  As line,
	ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

				</programlisting>
						</para></entry>
					  </row>
					</tbody>
				  </tgroup>
			</informaltable>
		  </refsection>

		  <refsection>
			<title>See Also</title>

			<para>
			<xref linkend="ST_Node" />,
			<xref linkend="ST_MakePolygon" />,
			<xref linkend="ST_BdPolyFromText" />,
			<xref linkend="ST_BdMPolyFromText" />wrappers to
			this function with standard OGC interface</para>
		  </refsection>
	</refentry>

	<refentry id="ST_ClipByBox2D">
	  <refnamediv>
		<refname>ST_ClipByBox2D</refname>
		<refpurpose>Returns the portion of a geometry falling within a rectangle.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>geometry <function>ST_ClipByBox2D</function></funcdef>
				<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
				<paramdef><type>box2d</type> <parameter>box</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

    <para>
Clips a geometry by a 2D box in a fast but possibly dirty way. The output
geometry is not guaranteed to be valid (self-intersections for a polygon
may be introduced). Topologically invalid input geometries do not result
in exceptions being thrown.
    </para>

		<para>Performed by the GEOS module.</para>
		<note><para>Requires GEOS 3.5.0+</para></note>

		<para>Availability: 2.2.0 - requires GEOS &gt;= 3.5.0.</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>
			<programlisting>
-- Rely on implicit cast from geometry to box2d for the second parameter
SELECT ST_ClipByBox2D(the_geom, ST_MakeEnvelope(0,0,10,10)) FROM mytab;
      </programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para>
<xref linkend="ST_Intersection" />,
<xref linkend="ST_MakeBox2D" />,
<xref linkend="ST_MakeEnvelope" />
    </para>
	  </refsection>
	</refentry>

	<refentry id="ST_Collect">
	  <refnamediv>
		<refname>ST_Collect</refname>
		<refpurpose>Return a specified ST_Geometry value from a collection of other geometries.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>geometry <function>ST_Collect</function></funcdef>
				<paramdef><type>geometry set</type> <parameter>g1field</parameter></paramdef>
			</funcprototype>
			<funcprototype>
			<funcdef>geometry <function>ST_Collect</function></funcdef>
				<paramdef><type>geometry</type> <parameter>g1</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>g2</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>geometry <function>ST_Collect</function></funcdef>
				<paramdef><type>geometry[]</type> <parameter>g1_array</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para> Output type can be a MULTI* or a
			GEOMETRYCOLLECTION. Comes in 2 variants.  Variant 1 collects 2 geometries. Variant 2 is an aggregate function that takes a set of geometries and collects
			them into a single ST_Geometry.</para>

		<para>Aggregate version: This function returns a GEOMETRYCOLLECTION or a MULTI object
			from a set of geometries. The ST_Collect() function is an "aggregate"
			function in the terminology of PostgreSQL. That means that it
			operates on rows of data, in the same way the SUM() and AVG()
			functions do. For example, "SELECT ST_Collect(GEOM) FROM GEOMTABLE
			GROUP BY ATTRCOLUMN" will return a separate GEOMETRYCOLLECTION for
			each distinct value of ATTRCOLUMN.</para>

		<para>Non-Aggregate version: This function returns a geometry being a collection of two
			input geometries. Output type can be a MULTI* or a
			GEOMETRYCOLLECTION.</para>

		<note><para>ST_Collect and ST_Union are often interchangeable except that ST_Collect will always return a GeometryCollection or MULTI geometry
		and ST_Union may return single geometries when it dissolves boundaries.  ST_Union will also split linestrings at node intersections, whereas ST_Collect
		will never split linestrings and in turn just return as MULTILINESTRING.
			 To prevent ST_Collect from
			returning a Geometry Collection when collecting MULTI geometries,
			one can use the below trick that utilizes <xref linkend="ST_Dump" /> to expand the
			MULTIs out to singles and then regroup them.</para></note>

		<para>Availability: 1.4.0 -  ST_Collect(geomarray) was introduced. ST_Collect was enhanced to handle more geometries faster.</para>
		  <para>&Z_support;</para>
		  <para>&curve_support; This method supports Circular Strings
		    and Curves, but will never return a MULTICURVE or MULTI as one
		    would expect and PostGIS does not currently support those.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>Aggregate example</para>
			<programlisting>SELECT stusps, ST_Collect(f.the_geom) as singlegeom
	 FROM (SELECT stusps, (ST_Dump(the_geom)).geom As the_geom
				FROM
				somestatetable ) As f
GROUP BY stusps</programlisting>
		<para>Non-Aggregate example</para>
			<programlisting>SELECT ST_AsText(ST_Collect(ST_GeomFromText('POINT(1 2)'),
	ST_GeomFromText('POINT(-2 3)') ));

st_astext
----------
MULTIPOINT(1 2,-2 3)

--Collect 2 d points
SELECT ST_AsText(ST_Collect(ST_GeomFromText('POINT(1 2)'),
		ST_GeomFromText('POINT(1 2)') ) );

st_astext
----------
MULTIPOINT(1 2,1 2)

--Collect 3d points
SELECT ST_AsEWKT(ST_Collect(ST_GeomFromEWKT('POINT(1 2 3)'),
		ST_GeomFromEWKT('POINT(1 2 4)') ) );

		st_asewkt
-------------------------
 MULTIPOINT(1 2 3,1 2 4)

 --Example with curves
SELECT ST_AsText(ST_Collect(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)'),
ST_GeomFromText('CIRCULARSTRING(220227 150406,2220227 150407,220227 150406)')));
																st_astext
------------------------------------------------------------------------------------
 GEOMETRYCOLLECTION(CIRCULARSTRING(220268 150415,220227 150505,220227 150406),
 CIRCULARSTRING(220227 150406,2220227 150407,220227 150406))

--New ST_Collect array construct
SELECT ST_Collect(ARRAY(SELECT the_geom FROM sometable));

SELECT ST_AsText(ST_Collect(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 4)'),
			ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As wktcollect;

--wkt collect --
MULTILINESTRING((1 2,3 4),(3 4,4 5))

</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Dump" />, <xref linkend="ST_Union" /></para>
	  </refsection>
	</refentry>


	<refentry id="ST_ConcaveHull">
	  <refnamediv>
		<refname>ST_ConcaveHull</refname>
		<refpurpose>The concave hull of a geometry represents a possibly concave
		geometry that encloses all geometries within the set.  You can think of it as shrink wrapping.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		 <funcprototype>
			<funcdef>geometry <function>ST_ConcaveHull</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>target_percent</parameter></paramdef>
			<paramdef choice="opt"><type>boolean </type> <parameter>allow_holes=false</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>The concave hull of a geometry represents a possibly concave
		geometry that encloses all geometries within the set. Defaults to false for allowing polygons with holes.
		The result is never higher than a single polygon.</para>

		<para>The target_percent is the target percent of area of convex hull the PostGIS solution will try to approach before giving up or exiting.
		One can think of the concave hull as the geometry you get by vacuum sealing a set of geometries. The
			target_percent of 1 will give you the same answer as the convex hull.  A target_percent
				between 0 and 0.99 will give you something that should have a smaller area than the convex hull.  This is different from a convex hull which is more like wrapping a rubber band around the set of geometries.</para>

			<para>It is usually used with MULTI and Geometry Collections.
		Although it is not an aggregate - you can use it in conjunction
		with ST_Collect or ST_Union to get the concave hull of a set of points/linestring/polygons
		ST_ConcaveHull(ST_Collect(somepointfield), 0.80).</para>

		<para>It is much slower to compute than convex hull but encloses the geometry better and is also useful for
			image recognition.</para>

		<para>Performed by the GEOS module</para>
		<note><para>Note - If you are using with points, linestrings, or geometry collections use ST_Collect. If you are using with polygons, use ST_Union since
			it may fail with invalid geometries.</para></note>

		<note><para>Note - The smaller you make the target percent, the longer it takes to process the concave hull and more likely to run into topological exceptions. Also the more
			floating points and number of points you accrue.  First try a 0.99 which does a first hop, is usually very fast, sometimes as fast as computing the convex hull, and usually gives much better than 99% of shrink since it almost always overshoots. Second hope of 0.98 it slower, others get slower usually quadratically.
			To reduce precision and float points, use <xref linkend="ST_SimplifyPreserveTopology" /> or <xref linkend="ST_SnapToGrid" /> after ST_ConcaveHull. ST_SnapToGrid is a bit faster, but
				could result in invalid geometries where as ST_SimplifyPreserveTopology almost always preserves the validity of the geometry.</para></note>

		<para>More real world examples and brief explanation of the technique are shown <ulink
		url="http://www.bostongis.com/postgis_concavehull.snippet">http://www.bostongis.com/postgis_concavehull.snippet</ulink></para>

		<para>Also check out Simon Greener's article on demonstrating ConcaveHull introduced in Oracle 11G R2. <ulink
		url="http://www.spatialdbadvisor.com/oracle_spatial_tips_tricks/172/concave-hull-geometries-in-oracle-11gr2">http://www.spatialdbadvisor.com/oracle_spatial_tips_tricks/172/concave-hull-geometries-in-oracle-11gr2</ulink>.
		The solution we get at 0.75 target percent of convex hull is similar to the shape Simon gets with  Oracle SDO_CONCAVEHULL_BOUNDARY.</para>

		<para>Availability: 2.0.0</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
<programlisting>
--Get estimate of infected area based on point observations
SELECT d.disease_type,
	ST_ConcaveHull(ST_Collect(d.pnt_geom), 0.99) As geom
	FROM disease_obs As d
	GROUP BY d.disease_type;
</programlisting>
			<informaltable>
				  <tgroup cols="2">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_concavehull03.png" />
							  </imageobject>
							  <caption><para>ST_ConcaveHull of 2 polygons encased in target 100% shrink concave hull</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
-- geometries overlaid with concavehull
-- at target 100% shrink (this is the same as convex hull - since no shrink)
SELECT
	ST_ConcaveHull(
		ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		), 1)
	 As convexhull;
				</programlisting>
						  </para></entry>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_concavehull02.png" />
							  </imageobject>
							  <caption><para>-- geometries overlaid with concavehull
								at target 90% of convex hull area</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
-- geometries overlaid with concavehull at target 90% shrink
SELECT
	ST_ConcaveHull(
		ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		), 0.9)
	 As target_90;
				</programlisting>
						</para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_concavehull04.png" />
							  </imageobject>
							  <caption><para>L Shape points overlaid with convex hull</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
-- this produces a table of 42 points that form an L shape
SELECT (ST_DumpPoints(ST_GeomFromText(
'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,
150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,
14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,
6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,
14 94,14 74,14 54,14 34,14 14)'))).geom
	INTO TABLE l_shape;

SELECT ST_ConvexHull(ST_Collect(geom))
FROM l_shape;
				</programlisting>
						  </para></entry>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_concavehull05.png" />
							  </imageobject>
							  <caption><para>ST_ConcaveHull of L points at target 99% of convex hull</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_ConcaveHull(ST_Collect(geom), 0.99)
	FROM l_shape;
				</programlisting>
						  </para></entry>
		</row>
		<row>
			<entry><para><informalfigure>
				<mediaobject>
				  <imageobject>
					<imagedata fileref="images/st_concavehull06.png" />
				  </imageobject>
				  <caption><para>Concave Hull of L points at target 80% convex hull area</para></caption>
				</mediaobject>
			  </informalfigure>
	<programlisting>
	-- Concave Hull L shape points
	-- at target 80% of convexhull
	SELECT ST_ConcaveHull(ST_Collect(geom), 0.80)
	FROM l_shape;
	</programlisting>
			</para>
			</entry>
			<entry><para>
				<informalfigure>
				<mediaobject>
				  <imageobject>
					<imagedata fileref="images/st_concavehull07.png" />
				  </imageobject>
				  <caption><para>multilinestring overlaid with Convex hull</para></caption>
				</mediaobject>
			  </informalfigure>
				<informalfigure>
				<mediaobject>
				  <imageobject>
					<imagedata fileref="images/st_concavehull08.png" />
				  </imageobject>
				  <caption><para>multilinestring with overlaid with Concave hull
				  of linestrings at 99% target -- first hop</para></caption>
				</mediaobject>
			  </informalfigure>
	<programlisting>
SELECT ST_ConcaveHull(ST_GeomFromText('MULTILINESTRING((106 164,30 112,74 70,82 112,130 94,
	130 62,122 40,156 32,162 76,172 88),
(132 178,134 148,128 136,96 128,132 108,150 130,
170 142,174 110,156 96,158 90,158 88),
(22 64,66 28,94 38,94 68,114 76,112 30,
132 10,168 18,178 34,186 52,184 74,190 100,
190 122,182 148,178 170,176 184,156 164,146 178,
132 186,92 182,56 158,36 150,62 150,76 128,88 118))'),0.99)
	</programlisting>
			</para>
			</entry>
		</row>
		</tbody>
	</tgroup>
</informaltable>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_ConvexHull" />, <xref linkend="ST_SimplifyPreserveTopology" />, <xref linkend="ST_SnapToGrid" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_ConvexHull">
	  <refnamediv>
		<refname>ST_ConvexHull</refname>
		<refpurpose>The convex hull of a geometry represents the minimum convex
		geometry that encloses all geometries within the set.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_ConvexHull</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>The convex hull of a geometry represents the minimum convex
		geometry that encloses all geometries within the set.</para>

		<para>One can think of the convex hull as the geometry you get by wrapping an elastic
			band around a set of geometries.  This is different from a concave hull
				which is analogous to shrink-wrapping your geometries.</para>

			<para>It is usually used with MULTI and Geometry Collections.
		Although it is not an aggregate - you can use it in conjunction
		with ST_Collect to get the convex hull of a set of points.
		ST_ConvexHull(ST_Collect(somepointfield)).</para>

		<para>It is often used to
		determine an affected area based on a set of point
		observations.</para>

		<para>Performed by the GEOS module</para>

		<para>&sfs_compliant; s2.1.1.3</para>
		<para>&sqlmm_compliant; SQL-MM 3: 5.1.16</para>
		<para>&Z_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
<programlisting>
--Get estimate of infected area based on point observations
SELECT d.disease_type,
	ST_ConvexHull(ST_Collect(d.the_geom)) As the_geom
	FROM disease_obs As d
	GROUP BY d.disease_type;
</programlisting>

<para>
	<informalfigure>
	  <mediaobject>
		<imageobject>
		  <imagedata fileref="images/st_convexhull01.png" />
		</imageobject>
		<caption><para>Convex Hull of a MultiLinestring and a MultiPoint seen together with the MultiLinestring and MultiPoint</para></caption>
	  </mediaobject>
	</informalfigure>
	<programlisting>
SELECT ST_AsText(ST_ConvexHull(
	ST_Collect(
		ST_GeomFromText('MULTILINESTRING((100 190,10 8),(150 10, 20 30))'),
			ST_GeomFromText('MULTIPOINT(50 5, 150 30, 50 10, 10 10)')
			)) );
---st_astext--
POLYGON((50 5,10 8,10 10,100 190,150 30,150 10,50 5))
	</programlisting>
</para>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_ConcaveHull" />, <xref linkend="ST_MinimumBoundingCircle" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_CurveToLine">
	  <refnamediv>
		<refname>ST_CurveToLine</refname>

		<refpurpose>Converts a CIRCULARSTRING/CURVEPOLYGON to a LINESTRING/POLYGON</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_CurveToLine</function></funcdef>
			<paramdef><type>geometry</type> <parameter>curveGeom</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
			<paramdef choice="opt"><type>integer</type> <parameter>tolerance_type</parameter></paramdef>
			<paramdef choice="opt"><type>integer</type> <parameter>flags</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Converts a CIRCULAR STRING to regular LINESTRING or CURVEPOLYGON to POLYGON. Useful for outputting to devices that can't support CIRCULARSTRING geometry types</para>

		<para>Converts a given geometry to a linear geometry.
		Each curved geometry or segment is converted into a linear
approximation using the given `tolerance` and options (32 segments per
quadrant and no options by default).</para>

    <para>
The 'tolerance_type' argument determines interpretation of the
`tolerance` argument. It can take the following values:
      <itemizedlist>
        <listitem>
          <para>0 (default): Tolerance is max segments per quadrant.</para>
        </listitem>
        <listitem>
          <para>1: Tolerance is max-deviation of line from curve, in source units.</para>
        </listitem>
        <listitem>
          <para>2: Tolerance is max-angle, in radians, between generating radii.</para>
        </listitem>
      </itemizedlist>
    </para>

    <para>
The 'flags' argument is a bitfield. 0 by default.
Supported bits are:
      <itemizedlist>
        <listitem>
          <para>1: Symmetric (orientation idependent) output.</para>
        </listitem>
        <listitem>
          <para>2: Retain angle, avoids reducing angles (segment lengths) when producing symmetric output. Has no effect when Symmetric flag is off.</para>
        </listitem>
      </itemizedlist>
    </para>

		<para>Availability: 1.2.2?</para>
    <para>Enhanced: 2.4.0 added support for max-deviation and max-angle tolerance, and for symmetric output.</para>

		<para>&sfs_compliant;</para>
		<para>&sqlmm_compliant; SQL-MM 3: 7.1.7</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)')));

--Result --
 LINESTRING(220268 150415,220269.95064912 150416.539364228,220271.823415575 150418.17258804,220273.613787707 150419.895736857,
 220275.317452352 150421.704659462,220276.930305234 150423.594998003,220278.448460847 150425.562198489,
 220279.868261823 150427.60152176,220281.186287736 150429.708054909,220282.399363347 150431.876723113,
 220283.50456625 150434.10230186,220284.499233914 150436.379429536,220285.380970099 150438.702620341,220286.147650624 150441.066277505,
 220286.797428488 150443.464706771,220287.328738321 150445.892130112,220287.740300149 150448.342699654,
 220288.031122486 150450.810511759,220288.200504713 150453.289621251,220288.248038775 150455.77405574,
 220288.173610157 150458.257830005,220287.977398166 150460.734960415,220287.659875492 150463.199479347,
 220287.221807076 150465.64544956,220286.664248262 150468.066978495,220285.988542259 150470.458232479,220285.196316903 150472.81345077,
 220284.289480732 150475.126959442,220283.270218395 150477.39318505,220282.140985384 150479.606668057,
 220280.90450212 150481.762075989,220279.5637474 150483.85421628,220278.12195122 150485.87804878,
 220276.582586992 150487.828697901,220274.949363179 150489.701464356,220273.226214362 150491.491836488,
 220271.417291757 150493.195501133,220269.526953216 150494.808354014,220267.559752731 150496.326509628,
 220265.520429459 150497.746310603,220263.41389631 150499.064336517,220261.245228106 150500.277412127,
 220259.019649359 150501.38261503,220256.742521683 150502.377282695,220254.419330878 150503.259018879,
 220252.055673714 150504.025699404,220249.657244448 150504.675477269,220247.229821107 150505.206787101,
 220244.779251566 150505.61834893,220242.311439461 150505.909171266,220239.832329968 150506.078553494,
 220237.347895479 150506.126087555,220234.864121215 150506.051658938,220232.386990804 150505.855446946,
 220229.922471872 150505.537924272,220227.47650166 150505.099855856,220225.054972724 150504.542297043,
 220222.663718741 150503.86659104,220220.308500449 150503.074365683,
 220217.994991777 150502.167529512,220215.72876617 150501.148267175,
 220213.515283163 150500.019034164,220211.35987523 150498.7825509,
 220209.267734939 150497.441796181,220207.243902439 150496,
 220205.293253319 150494.460635772,220203.420486864 150492.82741196,220201.630114732 150491.104263143,
 220199.926450087 150489.295340538,220198.313597205 150487.405001997,220196.795441592 150485.437801511,
 220195.375640616 150483.39847824,220194.057614703 150481.291945091,220192.844539092 150479.123276887,220191.739336189 150476.89769814,
 220190.744668525 150474.620570464,220189.86293234 150472.297379659,220189.096251815 150469.933722495,
 220188.446473951 150467.535293229,220187.915164118 150465.107869888,220187.50360229 150462.657300346,
 220187.212779953 150460.189488241,220187.043397726 150457.710378749,220186.995863664 150455.22594426,
 220187.070292282 150452.742169995,220187.266504273 150450.265039585,220187.584026947 150447.800520653,
 220188.022095363 150445.35455044,220188.579654177 150442.933021505,220189.25536018 150440.541767521,
 220190.047585536 150438.18654923,220190.954421707 150435.873040558,220191.973684044 150433.60681495,
 220193.102917055 150431.393331943,220194.339400319 150429.237924011,220195.680155039 150427.14578372,220197.12195122 150425.12195122,
 220198.661315447 150423.171302099,220200.29453926 150421.298535644,220202.017688077 150419.508163512,220203.826610682 150417.804498867,
 220205.716949223 150416.191645986,220207.684149708 150414.673490372,220209.72347298 150413.253689397,220211.830006129 150411.935663483,
 220213.998674333 150410.722587873,220216.22425308 150409.61738497,220218.501380756 150408.622717305,220220.824571561 150407.740981121,
 220223.188228725 150406.974300596,220225.586657991 150406.324522731,220227 150406)

--3d example
SELECT ST_AsEWKT(ST_CurveToLine(ST_GeomFromEWKT('CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)')));
Output
------
 LINESTRING(220268 150415 1,220269.95064912 150416.539364228 1.0181172856673,
 220271.823415575 150418.17258804 1.03623457133459,220273.613787707 150419.895736857 1.05435185700189,....AD INFINITUM ....
	220225.586657991 150406.324522731 1.32611114201132,220227 150406 3)

--use only 2 segments to approximate quarter circle
SELECT ST_AsText(ST_CurveToLine(ST_GeomFromText('CIRCULARSTRING(220268 150415,220227 150505,220227 150406)'),2));
st_astext
------------------------------
 LINESTRING(220268 150415,220287.740300149 150448.342699654,220278.12195122 150485.87804878,
 220244.779251566 150505.61834893,220207.243902439 150496,220187.50360229 150462.657300346,
 220197.12195122 150425.12195122,220227 150406)

-- Ensure approximated line is no further than 20 units away from
-- original curve, and make the result direction-neutral
SELECT ST_AsText(ST_CurveToLine(
 'CIRCULARSTRING(0 0,100 -100,200 0)'::geometry,
	20, -- Tolerance
	1, -- Above is max distance between curve and line
	1  -- Symmetric flag
));
st_astext
-------------------------------------------------------------------------------------------
 LINESTRING(0 0,50 -86.6025403784438,150 -86.6025403784439,200 -1.1331077795296e-13,200 0)


		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_LineToCurve" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_DelaunayTriangles">
		<refnamediv>
			<refname>ST_DelaunayTriangles</refname>

			<refpurpose>
Return a Delaunay triangulation around the given input points.
			</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_DelaunayTriangles</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>float </type> <parameter>tolerance</parameter></paramdef>
				<paramdef><type>int4 </type> <parameter>flags</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>
Return a <ulink
url="http://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay
triangulation</ulink> around the vertices of the input geometry.
Output is a COLLECTION of polygons (for flags=0) or a MULTILINESTRING
(for flags=1) or TIN (for flags=2).  The tolerance, if any, is used to snap input vertices
togheter.
			</para>

			<para>Availability: 2.1.0 - requires GEOS &gt;= 3.4.0.</para>
			<para>&Z_support;</para>
			<para>&T_support;</para>

		</refsection>
			  <refsection>
		<title>2D Examples</title>
			<informaltable>
				  <tgroup cols="1">
					<tbody>
					 <row><entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_delaunaytriangles01.png" />
							  </imageobject>
							  <caption><para>Original polygons</para></caption>
							</mediaobject>
						  </informalfigure></para>
<programlisting>-- our original geometry --
	ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		)</programlisting></entry>
				      </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_delaunaytriangles03.png" />
							  </imageobject>
							  <caption><para>ST_DelaunayTriangles of 2 polygons: delaunay triangle polygons each triangle themed in different color</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
-- geometries overlaid multilinestring triangles
SELECT
	ST_DelaunayTriangles(
		ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		))
	 As  dtriag;
				</programlisting>
						  </para></entry></row>
				<row><entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_delaunaytriangles02.png" />
							  </imageobject>
							  <caption><para>-- delaunay triangles as multilinestring</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>SELECT
	ST_DelaunayTriangles(
		ST_Union(ST_GeomFromText('POLYGON((175 150, 20 40,
			50 60, 125 100, 175 150))'),
		ST_Buffer(ST_GeomFromText('POINT(110 170)'), 20)
		),0.001,1)
	 As  dtriag;</programlisting>
						</para></entry>
				</row>
				<row><entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_delaunaytriangles04.png" />
							  </imageobject>
							  <caption><para>-- delaunay triangles of 45 points as 55 triangle polygons</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>-- this produces a table of 42 points that form an L shape
SELECT (ST_DumpPoints(ST_GeomFromText(
'MULTIPOINT(14 14,34 14,54 14,74 14,94 14,114 14,134 14,
150 14,154 14,154 6,134 6,114 6,94 6,74 6,54 6,34 6,
14 6,10 6,8 6,7 7,6 8,6 10,6 30,6 50,6 70,6 90,6 110,6 130,
6 150,6 170,6 190,6 194,14 194,14 174,14 154,14 134,14 114,
14 94,14 74,14 54,14 34,14 14)'))).geom
	INTO TABLE l_shape;
-- output as individual polygon triangles
SELECT ST_AsText((ST_Dump(geom)).geom) As wkt
FROM ( SELECT ST_DelaunayTriangles(ST_Collect(geom)) As geom
FROM l_shape) As foo;

---wkt ---
POLYGON((6 194,6 190,14 194,6 194))
POLYGON((14 194,6 190,14 174,14 194))
POLYGON((14 194,14 174,154 14,14 194))
POLYGON((154 14,14 174,14 154,154 14))
POLYGON((154 14,14 154,150 14,154 14))
POLYGON((154 14,150 14,154 6,154 14))
:
:
</programlisting>
						</para></entry>
			 </row>

		</tbody>
	</tgroup>
</informaltable>
	  </refsection>
	  <refsection>
			<title>3D Examples</title>
			<programlisting>-- 3D multipoint --
SELECT ST_AsText(ST_DelaunayTriangles(ST_GeomFromText(
'MULTIPOINT Z(14 14 10,
150 14 100,34 6 25, 20 10 150)'))) As wkt;

-----wkt----
GEOMETRYCOLLECTION Z (POLYGON Z ((14 14 10,20 10 150,34 6 25,14 14 10))
 ,POLYGON Z ((14 14 10,34 6 25,150 14 100,14 14 10)))</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_ConcaveHull" />, <xref linkend="ST_Dump" />
			</para>
		</refsection>
	</refentry>

	<refentry id="ST_Difference">
	  <refnamediv>
		<refname>ST_Difference</refname>

		<refpurpose>Returns a geometry that represents that part of geometry A
			that does not intersect with geometry B.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Difference</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a geometry that represents that part of geometry A
			that does not intersect with geometry B.  One can think of this as GeometryA - ST_Intersection(A,B).  If A is completely contained in B
			then an empty geometry collection is returned.</para>
		<note><para>Note - order matters. B - A will always return a portion of B</para></note>

		<para>Performed by the GEOS module</para>

		<note><para>Do not call with a GeometryCollection as an argument</para></note>

		<para>&sfs_compliant; s2.1.1.3</para>
		<para>&sqlmm_compliant; SQL-MM 3: 5.1.20</para>
		<para>&Z_support; However it seems to only consider x y when
		  doing the difference and tacks back on the Z-Index</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
			<informaltable>
			  <tgroup cols="2">
				<tbody>
				  <row>
					<entry>
						<para>
							<informalfigure>
								<mediaobject>
								  <imageobject>
									<imagedata fileref="images/st_symdifference01.png" />
								  </imageobject>
								  <caption><para>The original linestrings shown together. </para></caption>
								</mediaobject>
							</informalfigure>
						</para>
					</entry>

					<entry>
						<para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_difference01.png" />
							  </imageobject>
							  <caption><para>The difference of the two linestrings</para></caption>
							</mediaobject>
						  </informalfigure>
					</para>
				</entry>
				  </row>
		</tbody>
	</tgroup>
</informaltable>
<programlisting>
--Safe for 2d. This is same geometries as what is shown for st_symdifference
SELECT ST_AsText(
	ST_Difference(
			ST_GeomFromText('LINESTRING(50 100, 50 200)'),
			ST_GeomFromText('LINESTRING(50 50, 50 150)')
		)
	);

st_astext
---------
LINESTRING(50 150,50 200)
</programlisting>

<programlisting>

--When used in 3d doesn't quite do the right thing
SELECT ST_AsEWKT(ST_Difference(ST_GeomFromEWKT('MULTIPOINT(-118.58 38.38 5,-118.60 38.329 6,-118.614 38.281 7)'), ST_GeomFromEWKT('POINT(-118.614 38.281 5)')));
st_asewkt
---------
MULTIPOINT(-118.6 38.329 6,-118.58 38.38 5)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_SymDifference" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Dump">
	  <refnamediv>
		<refname>ST_Dump</refname>
		<refpurpose>Returns a set of geometry_dump (geom,path) rows, that make up a geometry g1.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry_dump[] <function>ST_Dump</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>This is a set-returning function (SRF). It returns a set of
			geometry_dump rows, formed by a geometry (geom) and an array of
			integers (path). When the input geometry is a simple type
			(POINT,LINESTRING,POLYGON) a single record will be returned with
			an empty path array and the input geometry as geom. When the input
			geometry is a collection or multi it will return a record for each
			of the collection components, and the path will express the
			position of the component inside the collection.</para>

			<para>ST_Dump is useful for expanding geometries. It is the
			reverse of a GROUP BY in that it creates new rows. For example it
			can be use to expand MULTIPOLYGONS into POLYGONS.</para>

			<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>
			<para>Availability: PostGIS 1.0.0RC1. Requires PostgreSQL 7.3 or higher.</para>

			<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>



            <para>&curve_support;</para>
            <para>&P_support;</para>
            <para>&T_support;</para>
            <para>&Z_support;</para>
	  </refsection>

	  <refsection>
		<title>Standard Examples</title>
	<programlisting>SELECT sometable.field1, sometable.field1,
      (ST_Dump(sometable.the_geom)).geom AS the_geom
FROM sometable;

-- Break a compound curve into its constituent linestrings and circularstrings
SELECT ST_AsEWKT(a.geom), ST_HasArc(a.geom)
  FROM ( SELECT (ST_Dump(p_geom)).geom AS geom
         FROM (SELECT ST_GeomFromEWKT('COMPOUNDCURVE(CIRCULARSTRING(0 0, 1 1, 1 0),(1 0, 0 1))') AS p_geom) AS b
        ) AS a;
          st_asewkt          | st_hasarc
-----------------------------+----------
 CIRCULARSTRING(0 0,1 1,1 0) | t
 LINESTRING(1 0,0 1)         | f
(2 rows)</programlisting>
</refsection>
<refsection><title>Polyhedral Surfaces, TIN and Triangle Examples</title>
<programlisting>-- Polyhedral surface example
-- Break a Polyhedral surface into its faces
SELECT (a.p_geom).path[1] As path, ST_AsEWKT((a.p_geom).geom) As geom_ewkt
  FROM (SELECT ST_Dump(ST_GeomFromEWKT('POLYHEDRALSURFACE(
((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),
((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),  ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),
((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)),  ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1))
)') ) AS p_geom )  AS a;

 path |                geom_ewkt
------+------------------------------------------
    1 | POLYGON((0 0 0,0 0 1,0 1 1,0 1 0,0 0 0))
    2 | POLYGON((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0))
    3 | POLYGON((0 0 0,1 0 0,1 0 1,0 0 1,0 0 0))
    4 | POLYGON((1 1 0,1 1 1,1 0 1,1 0 0,1 1 0))
    5 | POLYGON((0 1 0,0 1 1,1 1 1,1 1 0,0 1 0))
    6 | POLYGON((0 0 1,1 0 1,1 1 1,0 1 1,0 0 1))</programlisting>

<programlisting>-- TIN --
SELECT (g.gdump).path, ST_AsEWKT((g.gdump).geom) as wkt
  FROM
    (SELECT
       ST_Dump( ST_GeomFromEWKT('TIN (((
                0 0 0,
                0 0 1,
                0 1 0,
                0 0 0
            )), ((
                0 0 0,
                0 1 0,
                1 1 0,
                0 0 0
            ))
            )') ) AS gdump
    ) AS g;
-- result --
 path |                 wkt
------+-------------------------------------
 {1}  | TRIANGLE((0 0 0,0 0 1,0 1 0,0 0 0))
 {2}  | TRIANGLE((0 0 0,0 1 0,1 1 0,0 0 0))
</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="geometry_dump" />, <xref linkend="PostGIS_Geometry_DumpFunctions" />, <xref linkend="ST_Collect" />, <xref linkend="ST_Collect" />, <xref linkend="ST_GeometryN" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_DumpPoints">
		<refnamediv>
			<refname>ST_DumpPoints</refname>
			<refpurpose>Returns a set of geometry_dump (geom,path) rows of all points that make up a geometry.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
				<funcdef>geometry_dump[]<function>ST_DumpPoints</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>
				<para>This set-returning function (SRF) returns a set of <varname>geometry_dump</varname> rows formed
				    by a geometry (<varname>geom</varname>) and an array of integers (<varname>path</varname>).</para>

				<para>The <parameter>geom</parameter> component of <varname>geometry_dump</varname> are
				    all the <varname>POINT</varname>s that make up the supplied geometry</para>

				<para>The <parameter>path</parameter> component of <varname>geometry_dump</varname> (an <varname>integer[]</varname>)
				    is an index reference enumerating the <varname>POINT</varname>s of the supplied geometry.
					For example, if a <varname>LINESTRING</varname> is supplied, a path of <varname>{i}</varname> is
					returned where <varname>i</varname> is the <varname>nth</varname> coordinate in the <varname>LINESTRING</varname>.
					If a <varname>POLYGON</varname> is supplied, a path of <varname>{i,j}</varname> is returned where
					<varname>i</varname> is the ring number (1 is outer; inner rings follow) and <varname>j</varname>
					enumerates the <varname>POINT</varname>s (again 1-based index).
				</para>
				<para>Enhanced: 2.1.0 Faster speed. Reimplemented as native-C.</para>
				<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>
				<para>Availability: 1.5.0</para>
				<para>&curve_support;</para>
				<para>&P_support;</para>
				<para>&T_support;</para>
				<para>&Z_support;</para>
		</refsection>

		<refsection><title>Classic Explode a Table of LineStrings into nodes</title>
			<programlisting>SELECT edge_id, (dp).path[1] As index, ST_AsText((dp).geom) As wktnode
FROM (SELECT 1 As edge_id
	, ST_DumpPoints(ST_GeomFromText('LINESTRING(1 2, 3 4, 10 10)')) AS dp
     UNION ALL
     SELECT 2 As edge_id
	, ST_DumpPoints(ST_GeomFromText('LINESTRING(3 5, 5 6, 9 10)')) AS dp
   ) As foo;
 edge_id | index |    wktnode
---------+-------+--------------
       1 |     1 | POINT(1 2)
       1 |     2 | POINT(3 4)
       1 |     3 | POINT(10 10)
       2 |     1 | POINT(3 5)
       2 |     2 | POINT(5 6)
       2 |     3 | POINT(9 10)</programlisting>
		</refsection>
		<refsection>
			<title>Standard Geometry Examples</title>

			<informalfigure>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/st_dumppoints01.png" />
					</imageobject>
				</mediaobject>
			</informalfigure>

			<programlisting>SELECT path, ST_AsText(geom)
FROM (
  SELECT (ST_DumpPoints(g.geom)).*
  FROM
    (SELECT
       'GEOMETRYCOLLECTION(
          POINT ( 0 1 ),
          LINESTRING ( 0 3, 3 4 ),
          POLYGON (( 2 0, 2 3, 0 2, 2 0 )),
          POLYGON (( 3 0, 3 3, 6 3, 6 0, 3 0 ),
                   ( 5 1, 4 2, 5 2, 5 1 )),
          MULTIPOLYGON (
                  (( 0 5, 0 8, 4 8, 4 5, 0 5 ),
                   ( 1 6, 3 6, 2 7, 1 6 )),
                  (( 5 4, 5 8, 6 7, 5 4 ))
          )
        )'::geometry AS geom
    ) AS g
  ) j;

   path    | st_astext
-----------+------------
 {1,1}     | POINT(0 1)
 {2,1}     | POINT(0 3)
 {2,2}     | POINT(3 4)
 {3,1,1}   | POINT(2 0)
 {3,1,2}   | POINT(2 3)
 {3,1,3}   | POINT(0 2)
 {3,1,4}   | POINT(2 0)
 {4,1,1}   | POINT(3 0)
 {4,1,2}   | POINT(3 3)
 {4,1,3}   | POINT(6 3)
 {4,1,4}   | POINT(6 0)
 {4,1,5}   | POINT(3 0)
 {4,2,1}   | POINT(5 1)
 {4,2,2}   | POINT(4 2)
 {4,2,3}   | POINT(5 2)
 {4,2,4}   | POINT(5 1)
 {5,1,1,1} | POINT(0 5)
 {5,1,1,2} | POINT(0 8)
 {5,1,1,3} | POINT(4 8)
 {5,1,1,4} | POINT(4 5)
 {5,1,1,5} | POINT(0 5)
 {5,1,2,1} | POINT(1 6)
 {5,1,2,2} | POINT(3 6)
 {5,1,2,3} | POINT(2 7)
 {5,1,2,4} | POINT(1 6)
 {5,2,1,1} | POINT(5 4)
 {5,2,1,2} | POINT(5 8)
 {5,2,1,3} | POINT(6 7)
 {5,2,1,4} | POINT(5 4)
(29 rows)</programlisting>
		</refsection>
	<refsection>
			<title>Polyhedral Surfaces, TIN and Triangle Examples</title>
			<programlisting>-- Polyhedral surface cube --
SELECT (g.gdump).path, ST_AsEWKT((g.gdump).geom) as wkt
  FROM
    (SELECT
       ST_DumpPoints(ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),
((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),
((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),
((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )') ) AS gdump
    ) AS g;
-- result --
  path   |     wkt
---------+--------------
 {1,1,1} | POINT(0 0 0)
 {1,1,2} | POINT(0 0 1)
 {1,1,3} | POINT(0 1 1)
 {1,1,4} | POINT(0 1 0)
 {1,1,5} | POINT(0 0 0)
 {2,1,1} | POINT(0 0 0)
 {2,1,2} | POINT(0 1 0)
 {2,1,3} | POINT(1 1 0)
 {2,1,4} | POINT(1 0 0)
 {2,1,5} | POINT(0 0 0)
 {3,1,1} | POINT(0 0 0)
 {3,1,2} | POINT(1 0 0)
 {3,1,3} | POINT(1 0 1)
 {3,1,4} | POINT(0 0 1)
 {3,1,5} | POINT(0 0 0)
 {4,1,1} | POINT(1 1 0)
 {4,1,2} | POINT(1 1 1)
 {4,1,3} | POINT(1 0 1)
 {4,1,4} | POINT(1 0 0)
 {4,1,5} | POINT(1 1 0)
 {5,1,1} | POINT(0 1 0)
 {5,1,2} | POINT(0 1 1)
 {5,1,3} | POINT(1 1 1)
 {5,1,4} | POINT(1 1 0)
 {5,1,5} | POINT(0 1 0)
 {6,1,1} | POINT(0 0 1)
 {6,1,2} | POINT(1 0 1)
 {6,1,3} | POINT(1 1 1)
 {6,1,4} | POINT(0 1 1)
 {6,1,5} | POINT(0 0 1)
(30 rows)</programlisting>
<programlisting>-- Triangle --
SELECT (g.gdump).path, ST_AsText((g.gdump).geom) as wkt
  FROM
    (SELECT
       ST_DumpPoints( ST_GeomFromEWKT('TRIANGLE ((
                0 0,
                0 9,
                9 0,
                0 0
            ))') ) AS gdump
    ) AS g;
-- result --
 path |    wkt
------+------------
 {1}  | POINT(0 0)
 {2}  | POINT(0 9)
 {3}  | POINT(9 0)
 {4}  | POINT(0 0)
</programlisting>
<programlisting>-- TIN --
SELECT (g.gdump).path, ST_AsEWKT((g.gdump).geom) as wkt
  FROM
    (SELECT
       ST_DumpPoints( ST_GeomFromEWKT('TIN (((
                0 0 0,
                0 0 1,
                0 1 0,
                0 0 0
            )), ((
                0 0 0,
                0 1 0,
                1 1 0,
                0 0 0
            ))
            )') ) AS gdump
    ) AS g;
-- result --
  path   |     wkt
---------+--------------
 {1,1,1} | POINT(0 0 0)
 {1,1,2} | POINT(0 0 1)
 {1,1,3} | POINT(0 1 0)
 {1,1,4} | POINT(0 0 0)
 {2,1,1} | POINT(0 0 0)
 {2,1,2} | POINT(0 1 0)
 {2,1,3} | POINT(1 1 0)
 {2,1,4} | POINT(0 0 0)
(8 rows)
</programlisting>
		</refsection>
			<refsection>
			<title>See Also</title>
			<para><xref linkend="geometry_dump" />, <xref linkend="PostGIS_Geometry_DumpFunctions" />, <xref linkend="ST_Dump" />, <xref linkend="ST_DumpRings" /></para>
		</refsection>
	</refentry>
	<refentry id="ST_DumpRings">
	  <refnamediv>
		<refname>ST_DumpRings</refname>

		<refpurpose>Returns a set of <varname>geometry_dump</varname> rows, representing
			the exterior and interior rings of a polygon.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry_dump[] <function>ST_DumpRings</function></funcdef>
			<paramdef><type>geometry </type> <parameter>a_polygon</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>This is a set-returning function (SRF). It returns a set of
			<varname>geometry_dump</varname> rows, defined as an <varname>integer[]</varname>
			and a <varname>geometry</varname>, aliased "path" and "geom" respectively.
			The "path" field holds the polygon ring index containing a single integer: 0 for the shell, >0 for holes.
			The "geom" field contains the corresponding ring as a polygon.</para>

		<para>Availability: PostGIS 1.1.3. Requires PostgreSQL 7.3 or higher.</para>
		<note><para>This only works for POLYGON geometries. It will not work for MULTIPOLYGONS</para></note>
		<para>&Z_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT sometable.field1, sometable.field1,
	  (ST_DumpRings(sometable.the_geom)).geom As the_geom
FROM sometableOfpolys;

SELECT ST_AsEWKT(geom) As the_geom, path
	FROM ST_DumpRings(
		ST_GeomFromEWKT('POLYGON((-8149064 5133092 1,-8149064 5132986 1,-8148996 5132839 1,-8148972 5132767 1,-8148958 5132508 1,-8148941 5132466 1,-8148924 5132394 1,
		-8148903 5132210 1,-8148930 5131967 1,-8148992 5131978 1,-8149237 5132093 1,-8149404 5132211 1,-8149647 5132310 1,-8149757 5132394 1,
		-8150305 5132788 1,-8149064 5133092 1),
		(-8149362 5132394 1,-8149446 5132501 1,-8149548 5132597 1,-8149695 5132675 1,-8149362 5132394 1))')
		)  as foo;
 path |                                            the_geom
----------------------------------------------------------------------------------------------------------------
  {0} | POLYGON((-8149064 5133092 1,-8149064 5132986 1,-8148996 5132839 1,-8148972 5132767 1,-8148958 5132508 1,
	  |          -8148941 5132466 1,-8148924 5132394 1,
	  |          -8148903 5132210 1,-8148930 5131967 1,
	  |          -8148992 5131978 1,-8149237 5132093 1,
	  |          -8149404 5132211 1,-8149647 5132310 1,-8149757 5132394 1,-8150305 5132788 1,-8149064 5133092 1))
  {1} | POLYGON((-8149362 5132394 1,-8149446 5132501 1,
	  |          -8149548 5132597 1,-8149695 5132675 1,-8149362 5132394 1))</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="geometry_dump" />, <xref linkend="PostGIS_Geometry_DumpFunctions" />, <xref linkend="ST_Dump" />, <xref linkend="ST_ExteriorRing" />, <xref linkend="ST_InteriorRingN" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_FlipCoordinates">
	  <refnamediv>
		<refname>ST_FlipCoordinates</refname>
		<refpurpose>Returns a version of the given geometry with
				X and Y axis flipped. Useful for people
				who have built latitude/longitude features
				and need to fix them.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_FlipCoordinates</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a version of the given geometry with X and Y axis flipped.</para>
		<para>Availability: 2.0.0</para>
		<para>&curve_support;</para>
		<para>&Z_support;</para>
		<para>&M_support;</para>
		<para>&P_support;</para>
		<para>&T_support;</para>
	  </refsection>

	  <refsection>
		<title>Example</title>
		<programlisting><![CDATA[
SELECT ST_AsEWKT(ST_FlipCoordinates(GeomFromEWKT('POINT(1 2)')));
 st_asewkt
------------
POINT(2 1)
		 ]]></programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para> <xref linkend="ST_SwapOrdinates" /> </para>
	  </refsection>

	</refentry>

	<refentry id="ST_GeneratePoints">
	  <refnamediv>
		<refname>ST_GeneratePoints</refname>

		<refpurpose>Converts a polygon or multi-polygon into a multi-point composed of randomly location points within the original areas.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_GeneratePoints</function></funcdef>
			<paramdef>
				<parameter>g</parameter>
				<type>geometry</type>
			</paramdef>
			<paramdef>
				<parameter>npoints</parameter>
				<type>numeric</type>
			</paramdef>
		  </funcprototype>

		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
		<title>Description</title>

		<para>
			ST_GeneratePoints generates pseudo-random points until the requested number are
			found within the input area.
		</para>

		<para>Availability: 2.3.0</para>
		</refsection>

		<refsection>
			<title>Examples</title>

			<informaltable>
			  <tgroup cols="2">
				<tbody>
				  <row>
					<entry>
						<para><informalfigure>
						<mediaobject>
						  <imageobject>
							<imagedata fileref="images/st_generatepoints01.png" />
						  </imageobject>
						  <caption><para>Original Polygon</para></caption>
						</mediaobject>
						</informalfigure>
						</para>
					</entry>

					<entry><para><informalfigure>
						<mediaobject>
						  <imageobject>
							<imagedata fileref="images/st_generatepoints02.png" />
						  </imageobject>
						  <caption><para>Generated 12 Points overlaid on top of original polygon</para></caption>
						</mediaobject>
					  </informalfigure>
						<programlisting>SELECT ST_GeneratePoints(
	ST_Buffer(
		ST_GeomFromText(
		'LINESTRING(50 50,150 150,150 50)'
		), 10, 'endcap=round join=round'), 12);</programlisting>
					</para></entry>
				  </row>
			</tbody>
			</tgroup>
		</informaltable>
		</refsection>
	</refentry>


	<refentry id="ST_Intersection">
		<refnamediv>
			<refname>ST_Intersection</refname>

			<refpurpose>
(T)
Returns a geometry that represents the shared portion of geomA and geomB.
			</refpurpose>
		</refnamediv>
		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>geometry <function>ST_Intersection</function></funcdef>
					<paramdef>
						<type>geometry</type>
						<parameter>geomA</parameter>
					</paramdef>
					<paramdef>
						<type>geometry</type>
						<parameter>geomB</parameter>
					</paramdef>
				</funcprototype>
				<funcprototype>
					<funcdef>geography <function>ST_Intersection</function></funcdef>
					<paramdef>
						<type>geography</type>
						<parameter>geogA</parameter>
					</paramdef>
					<paramdef>
						<type>geography</type>
						<parameter>geogB</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>
		<refsection>
			<title>Description</title>
			<para>Returns a geometry that represents the point set
				intersection of the Geometries.</para>

			<para>In other words - that portion of geometry A and geometry B
			that is shared between the two geometries.</para>

			<para>If the geometries do not share any space (are disjoint), then an empty geometry collection
			is returned.</para>
			<para>ST_Intersection in conjunction with ST_Intersects is very useful for clipping geometries such as in bounding box, buffer, region
				queries where you only want to return that portion of a geometry that sits in a country or region of interest.</para>

			<note><para>Geography: For geography this is really a thin wrapper around the geometry implementation. It first determines the best SRID that
					fits the bounding box of the 2 geography objects (if geography objects are within one half zone UTM but not same UTM will pick one of those) (favoring UTM or Lambert Azimuthal Equal Area (LAEA) north/south pole, and falling back on mercator in worst case scenario)  and then intersection in that best fit planar spatial ref and retransforms back to WGS84 geography.</para></note>
		  <important>
			<para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an argument</para>
		  </important>

	  	<warning><para>This function will drop the M coordinate values if present.</para></warning>

		  <warning><para>If working with 3D geometries, you may want to use SFGCAL based <xref linkend="ST_3DIntersection" /> which does a proper 3D intersection for 3D geometries.  Although this function works with Z-coordinate, it does an averaging of Z-Coordinate values when <code>postgis.backend=geos</code>. <code>postgis.backend=sfcgal</code>, it will return a 2D geometry regardless ignoring the Z-Coordinate. Refer to <xref linkend="postgis_backend" /> for details.</para></warning>

		  <para>Performed by the GEOS module</para>
                  <para>&sfcgal_enhanced;</para>

		  <para>Availability: 1.5 support for geography data type was introduced.</para>

		  <para>&sfs_compliant; s2.1.1.3</para>
		  <para>&sqlmm_compliant; SQL-MM 3: 5.1.18</para>
		</refsection>
		<refsection>
		<title>Examples</title>
<programlisting>SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 2 0, 0 2 )'::geometry));
 st_astext
---------------
GEOMETRYCOLLECTION EMPTY
(1 row)
SELECT ST_AsText(ST_Intersection('POINT(0 0)'::geometry, 'LINESTRING ( 0 0, 0 2 )'::geometry));
 st_astext
---------------
POINT(0 0)
(1 row)

---Clip all lines (trails) by country (here we assume country geom are POLYGON or MULTIPOLYGONS)
-- NOTE: we are only keeping intersections that result in a LINESTRING or MULTILINESTRING because we don't
-- care about trails that just share a point
-- the dump is needed to expand a geometry collection into individual single MULT* parts
-- the below is fairly generic and will work for polys, etc. by just changing the where clause
SELECT clipped.gid, clipped.f_name, clipped_geom
FROM (SELECT trails.gid, trails.f_name, (ST_Dump(ST_Intersection(country.the_geom, trails.the_geom))).geom As clipped_geom
FROM country
	INNER JOIN trails
	ON ST_Intersects(country.the_geom, trails.the_geom))  As clipped
	WHERE ST_Dimension(clipped.clipped_geom) = 1 ;

--For polys e.g. polygon landmarks, you can also use the sometimes faster hack that buffering anything by 0.0
-- except a polygon results in an empty geometry collection
--(so a geometry collection containing polys, lines and points)
-- buffered by 0.0 would only leave the polygons and dissolve the collection shell
SELECT poly.gid,  ST_Multi(ST_Buffer(
				ST_Intersection(country.the_geom, poly.the_geom),
				0.0)
				) As clipped_geom
FROM country
	INNER JOIN poly
	ON ST_Intersects(country.the_geom, poly.the_geom)
	WHERE Not ST_IsEmpty(ST_Buffer(ST_Intersection(country.the_geom, poly.the_geom),0.0));
		</programlisting>
		</refsection>

		<refsection>
		<title>Examples: 2.5Dish</title>
		<para>Geos is the default backend if not set. Note this is not a true intersection, compare to the same example using <xref linkend="ST_3DIntersection" />.</para>
		<programlisting>
set postgis.backend=geos;
select ST_AsText(ST_Intersection(linestring, polygon)) As wkt
from  ST_GeomFromText('LINESTRING Z (2 2 6,1.5 1.5 7,1 1 8,0.5 0.5 8,0 0 10)') AS linestring
 CROSS JOIN ST_GeomFromText('POLYGON((0 0 8, 0 1 8, 1 1 8, 1 0 8, 0 0 8))') AS polygon;

               st_astext
---------------------------------------
 LINESTRING Z (1 1 8,0.5 0.5 8,0 0 10)
		</programlisting>

		<para>If your PostGIS is compiled with sfcgal support, have option of using sfcgal, but note if basically cases down both geometries to 2D before doing intersection
		and returns the ST_Force2D equivalent result which is a 2D geometry</para>
		<programlisting>
set postgis.backend=sfcgal;
select ST_AsText(ST_Intersection(linestring, polygon)) As wkt
from  ST_GeomFromText('LINESTRING Z (2 2 6,1.5 1.5 7,1 1 8,0.5 0.5 8,0 0 10)') AS linestring
 CROSS JOIN ST_GeomFromText('POLYGON((0 0 8, 0 1 8, 1 1 8, 1 0 8, 0 0 8))') AS polygon;

                     wkt
----------------------------------------------
 MULTILINESTRING((0.5 0.5,0 0),(1 1,0.5 0.5))
		</programlisting>
	  </refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_3DIntersection" />, <xref linkend="ST_Difference"/>, <xref linkend="ST_Dimension"/>, <xref linkend="ST_Dump"/>, <xref linkend="ST_Force2D" />, <xref linkend="ST_SymDifference"/>, <xref linkend="ST_Intersects"/>, <xref linkend="ST_Multi"/></para>
		</refsection>
	</refentry>

	<refentry id="ST_LineToCurve">
	  <refnamediv>
		<refname>ST_LineToCurve</refname>

		<refpurpose>Converts a LINESTRING/POLYGON to a CIRCULARSTRING, CURVEPOLYGON</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_LineToCurve</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomANoncircular</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Converts plain LINESTRING/POLYGON to CIRCULAR STRINGs and Curved Polygons.  Note much fewer points are needed to describe the curved equivalent.</para>
		<note><para>If the input LINESTRING/POLYGON is not curved enough to clearly represent a curve, the function will return the same input geometry.</para></note>
		<para>Availability: 1.2.2?</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting> -- 2D Example
SELECT ST_AsText(ST_LineToCurve(foo.the_geom)) As curvedastext,ST_AsText(foo.the_geom) As non_curvedastext
	FROM (SELECT ST_Buffer('POINT(1 3)'::geometry, 3) As the_geom) As foo;

curvedatext                                                            non_curvedastext
--------------------------------------------------------------------|-----------------------------------------------------------------
CURVEPOLYGON(CIRCULARSTRING(4 3,3.12132034355964 0.878679656440359, | POLYGON((4 3,3.94235584120969 2.41472903395162,3.77163859753386 1.85194970290473,
1 0,-1.12132034355965 5.12132034355963,4 3))                        |  3.49440883690764 1.33328930094119,3.12132034355964 0.878679656440359,
                                                                    |  2.66671069905881 0.505591163092366,2.14805029709527 0.228361402466141,
                                                                    |  1.58527096604839 0.0576441587903094,1 0,
                                                                    |  0.414729033951621 0.0576441587903077,-0.148050297095264 0.228361402466137,
                                                                    |  -0.666710699058802 0.505591163092361,-1.12132034355964 0.878679656440353,
                                                                    |  -1.49440883690763 1.33328930094119,-1.77163859753386 1.85194970290472
                                                                    |  --ETC-- ,3.94235584120969 3.58527096604839,4 3))

--3D example
SELECT ST_AsText(ST_LineToCurve(geom)) As curved, ST_AsText(geom) AS not_curved
FROM (SELECT ST_Translate(ST_Force3D(ST_Boundary(ST_Buffer(ST_Point(1,3), 2,2))),0,0,3) AS geom) AS foo;

                        curved                        |               not_curved
------------------------------------------------------+---------------------------------------------------------------------
 CIRCULARSTRING Z (3 3 3,-1 2.99999999999999 3,3 3 3) | LINESTRING Z (3 3 3,2.4142135623731 1.58578643762691 3,1 1 3,
                                                      |	-0.414213562373092 1.5857864376269 3,-1 2.99999999999999 3,
                                                      | -0.414213562373101 4.41421356237309 3,
                                                      |	0.999999999999991 5 3,2.41421356237309 4.4142135623731 3,3 3 3)
(1 row)
</programlisting>
	</refsection>



	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_CurveToLine" /></para>
	  </refsection>
	</refentry>

    <refentry id="ST_MakeValid">
      <refnamediv>
        <refname>ST_MakeValid</refname>
        <refpurpose>Attempts to make an invalid geometry valid without losing vertices.</refpurpose>
      </refnamediv>

      <refsynopsisdiv>
        <funcsynopsis>
          <funcprototype>
            <funcdef>geometry <function>ST_MakeValid</function></funcdef>
            <paramdef><type>geometry</type> <parameter>input</parameter></paramdef>
          </funcprototype>
        </funcsynopsis>
      </refsynopsisdiv>

      <refsection>
        <title>Description</title>
    <para>
    The function attempts to create a valid representation of a given invalid
    geometry without losing any of the input vertices.
    Already-valid geometries are returned without further intervention.
    </para>

    <para>
    Supported inputs are: POINTS, MULTIPOINTS, LINESTRINGS,
    MULTILINESTRINGS, POLYGONS, MULTIPOLYGONS and GEOMETRYCOLLECTIONS
    containing any mix of them.
    </para>

    <para>
    In case of full or partial dimensional collapses, the output geometry
    may be a collection of lower-to-equal dimension geometries or a
    geometry of lower dimension.
    </para>

    <para>
    Single polygons may become multi-geometries in case of self-intersections.
    </para>

    <para>Availability: 2.0.0, requires GEOS-3.3.0</para>
    <para>Enhanced: 2.0.1, speed improvements requires GEOS-3.3.4</para>
    <para>Enhanced: 2.1.0 added support for GEOMETRYCOLLECTION and MULTIPOINT.</para>

    <para>&Z_support;</para>

          </refsection>

          <refsection>
            <title>See Also</title>
            <para>
                <xref linkend="ST_IsValid" />
                <xref linkend="ST_CollectionExtract" />
            </para>
          </refsection>
    </refentry>

	<refentry id="ST_MemUnion">
	  <refnamediv>
		<refname>ST_MemUnion</refname>

		<refpurpose>Same as ST_Union, only memory-friendly (uses less memory
			and more processor time).</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MemUnion</function></funcdef>
			<paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Some useful description here.</para>

		<!-- optionally mention that this function uses indexes if appropriate -->
		<note>
		  <para>Same as ST_Union, only memory-friendly (uses less memory
			and more processor time).  This aggregate function works by unioning the geometries one at a time to previous result as opposed to
			ST_Union aggregate which first creates an array and then unions</para>
		</note>

		<para>&Z_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>See ST_Union</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Union" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MinimumBoundingCircle">
	  <refnamediv>
		<refname>ST_MinimumBoundingCircle</refname>
		<refpurpose>Returns the smallest circle polygon that can fully contain a geometry. Default
		uses 48 segments per quarter circle.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MinimumBoundingCircle</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef choice="opt"><type>integer </type> <parameter>num_segs_per_qt_circ=48</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
			<para>Returns the smallest circle polygon that can fully contain a geometry. </para>
			<note><para>The circle is approximated by a polygon with a default of 48 segments per quarter circle.  Because the polygon is an approximation of the minimum bounding circle, some points in the input geometry may not be contained within the polygon.  The approximation can be improved by increasing the number of segments, with little performance penalty.  For applications where a polygonal approximation is not suitable, ST_MinimumBoundingRadius may be used.</para></note>

			<para>It is often used with MULTI and Geometry Collections.
		Although it is not an aggregate - you can use it in conjunction
		with ST_Collect to get the minimum bounding circle of a set of geometries.
		ST_MinimumBoundingCircle(ST_Collect(somepointfield)).</para>

		<para>The ratio of the area of a polygon divided by the area of its Minimum Bounding Circle is often referred to as the Roeck test.</para>

		<para>Availability: 1.4.0 - requires GEOS</para>

	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingRadius" /></para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
<programlisting>SELECT d.disease_type,
	ST_MinimumBoundingCircle(ST_Collect(d.the_geom)) As the_geom
	FROM disease_obs As d
	GROUP BY d.disease_type;
</programlisting>
	<informalfigure>
	  <mediaobject>
		<imageobject>
		  <imagedata fileref="images/st_minimumboundingcircle01.png" />
		</imageobject>
		<caption><para>Minimum bounding circle of a point and linestring.  Using 8 segs to approximate a quarter circle</para></caption>
	  </mediaobject>
	</informalfigure>
<programlisting>
SELECT ST_AsText(ST_MinimumBoundingCircle(
		ST_Collect(
			ST_GeomFromEWKT('LINESTRING(55 75,125 150)'),
				ST_Point(20, 80)), 8
				)) As wktmbc;
wktmbc
-----------
POLYGON((135.59714732062 115,134.384753327498 102.690357210921,130.79416296937 90.8537670908995,124.963360620072 79.9451031602111,117.116420743937 70.3835792560632,107.554896839789 62.5366393799277,96.6462329091006 56.70583703063,84.8096427890789 53.115246672502,72.5000000000001 51.9028526793802,60.1903572109213 53.1152466725019,48.3537670908996 56.7058370306299,37.4451031602112 62.5366393799276,27.8835792560632 70.383579256063,20.0366393799278 79.9451031602109,14.20583703063 90.8537670908993,10.615246672502 102.690357210921,9.40285267938019 115,10.6152466725019 127.309642789079,14.2058370306299 139.1462329091,20.0366393799275 150.054896839789,27.883579256063 159.616420743937,
37.4451031602108 167.463360620072,48.3537670908992 173.29416296937,60.190357210921 176.884753327498,
72.4999999999998 178.09714732062,84.8096427890786 176.884753327498,96.6462329091003 173.29416296937,107.554896839789 167.463360620072,
117.116420743937 159.616420743937,124.963360620072 150.054896839789,130.79416296937 139.146232909101,134.384753327498 127.309642789079,135.59714732062 115))
				</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingRadius" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MinimumBoundingRadius">
	<refnamediv>
		<refname>ST_MinimumBoundingRadius</refname>
		<refpurpose>Returns the center point and radius of the smallest circle that can fully contain a geometry.</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>(geometry, double precision) <function>ST_MinimumBoundingRadius</function></funcdef>
				<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	</refsynopsisdiv>

	<refsection>
		<title>Description</title>
		<para>Returns a record containing the center point and radius of the smallest circle that can fully contain a geometry.</para>
		<para>Can be used in conjunction with <xref linkend="ST_Collect"/> to get the minimum bounding circle of a set of geometries.</para>
		<para>Availability - 2.3.0</para>
	</refsection>

	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Collect" />, <xref linkend="ST_MinimumBoundingCircle" /></para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
<programlisting>SELECT ST_AsText(center), radius FROM ST_MinimumBoundingRadius('POLYGON((26426 65078,26531 65242,26075 65136,26096 65427,26426 65078))');

                st_astext                 |      radius
------------------------------------------+------------------
 POINT(26284.8418027133 65267.1145090825) | 247.436045591407
</programlisting>
	  </refsection>

	</refentry>

	<refentry id="ST_Polygonize">
		<refnamediv>
			<refname>ST_Polygonize</refname>

			<refpurpose>Aggregate. Creates a GeometryCollection containing possible
			polygons formed from the constituent linework of a set of
			geometries.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Polygonize</function></funcdef>
			<paramdef><type>geometry set</type> <parameter>geomfield</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_Polygonize</function></funcdef>
			<paramdef><type>geometry[]</type> <parameter>geom_array</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a GeometryCollection containing possible
			polygons formed from the constituent linework of a set of
			geometries.</para>

			<note>
				<para>Geometry Collections are often difficult to deal with with third party tools, so use ST_Polygonize in conjunction with  <xref linkend="ST_Dump" /> to dump the polygons
				out into individual polygons.</para>
			</note>

			<note>
				<para>Input linework must be correctly noded for this function to work properly</para>
			</note>

			<para>Availability: 1.0.0RC1 - requires GEOS &gt;= 2.1.0.</para>
		</refsection>

		<refsection>
		<title>Examples: Polygonizing single linestrings</title>
		 <programlisting>
SELECT ST_AsEWKT(ST_Polygonize(the_geom_4269)) As geomtextrep
FROM (SELECT the_geom_4269 FROM ma.suffolk_edges ORDER BY tlid LIMIT 45) As foo;

geomtextrep
-------------------------------------
 SRID=4269;GEOMETRYCOLLECTION(POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,-71.040878 42.285678)),
 POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358,-71.171794 42.354971,-71.170511 42.354855,
 -71.17112 42.354238,-71.17166 42.353675)))
(1 row)

--Use ST_Dump to dump out the polygonize geoms into individual polygons
SELECT ST_AsEWKT((ST_Dump(foofoo.polycoll)).geom) As geomtextrep
FROM (SELECT ST_Polygonize(the_geom_4269) As polycoll
	FROM (SELECT the_geom_4269 FROM ma.suffolk_edges
		ORDER BY tlid LIMIT 45) As foo) As foofoo;

geomtextrep
------------------------
 SRID=4269;POLYGON((-71.040878 42.285678,-71.040943 42.2856,-71.04096 42.285752,
-71.040878 42.285678))
 SRID=4269;POLYGON((-71.17166 42.353675,-71.172026 42.354044,-71.17239 42.354358
,-71.171794 42.354971,-71.170511 42.354855,-71.17112 42.354238,-71.17166 42.353675))
(2 rows)

			  </programlisting>
		</refsection>

		<refsection>
			<title>See Also</title>
			<para>
			<xref linkend="ST_Node" />,
			<xref linkend="ST_Dump" />
			</para>
		</refsection>
	</refentry>

	<refentry id="ST_Node">
	  <refnamediv>
		<refname>ST_Node</refname>

		<refpurpose>
Node a set of linestrings.
		</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Node</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
Fully node a set of linestrings using the least possible number of nodes
while preserving all of the input ones.
		</para>

		<para>&Z_support;</para>

		<para>Availability: 2.0.0 - requires GEOS &gt;= 3.3.0.</para>

		<note><para>
Due to a bug in GEOS up to 3.3.1 this function fails to node self-intersecting
lines. This is fixed with GEOS 3.3.2 or higher.
		</para></note>
		<note><para>
Changed: 2.4.0 this function uses GEOSNode internally instead of GEOSUnaryUnion.
This may cause the resulting linestrings to have a different order and direction compared to Postgis &lt; 2.4.
		</para></note>
	  </refsection>
	  <refsection>
		<title>Examples</title>
		<programlisting>
SELECT ST_AsText(
		ST_Node('LINESTRINGZ(0 0 0, 10 10 10, 0 10 5, 10 0 3)'::geometry)
	) As  output;
output
-----------
MULTILINESTRING Z ((0 0 0,5 5 4.5),(5 5 4.5,10 10 10,0 10 5,5 5 4.5),(5 5 4.5,10 0 3))
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
			<xref linkend="ST_UnaryUnion" />
		</para>
	  </refsection>
	</refentry>

			<refentry id="ST_OffsetCurve">
			<refnamediv>
				<refname>ST_OffsetCurve</refname>

				<refpurpose>
Return an offset line at a given distance and side from an input line. Useful for computing parallel lines about a center line
			</refpurpose>
			</refnamediv>

			<refsynopsisdiv>
				<funcsynopsis>

				  <funcprototype>
					<funcdef>geometry <function>ST_OffsetCurve</function></funcdef>
					<paramdef><type>geometry </type> <parameter>line</parameter></paramdef>
					<paramdef><type>float </type> <parameter>signed_distance</parameter></paramdef>
					<paramdef choice="opt"><type>text </type> <parameter>style_parameters=''</parameter></paramdef>
				  </funcprototype>

				</funcsynopsis>
			</refsynopsisdiv>

			  <refsection>
				<title>Description</title>

				<para>
Return an offset line at a given distance and side from an input line.
All points of the returned geometries are not further than the given
distance from the input geometry.
				</para>

				<para>
For positive distance the offset will be at the left side of the input line
and retain the same direction. For a negative distance it'll be at the right
side and in the opposite direction.
				</para>

				<para>
Availability: 2.0 - requires GEOS &gt;= 3.2, improved with GEOS &gt;= 3.3
				</para>

				<para>
The optional third parameter allows specifying a list of blank-separated
key=value pairs to tweak operations as follows:
<itemizedlist>
<listitem>
<para>'quad_segs=#' : number of segments used to approximate a quarter circle (defaults to 8).</para>
</listitem>
<listitem>
<para>'join=round|mitre|bevel' : join style (defaults to "round"). 'miter' is also accepted as a synonym for 'mitre'.</para>
</listitem>
<listitem>
<para>'mitre_limit=#.#' : mitre ratio limit (only affects mitred join style). 'miter_limit' is also accepted as a synonym for 'mitre_limit'.</para>
</listitem>
</itemizedlist>
				</para>

				<para>
Units of distance are measured in units of the spatial reference system.
				</para>

				<para>The inputs can only be LINESTRINGS.</para>

				<para>Performed by the GEOS module.</para>

				<note><para>
This function ignores the third dimension (z) and will always give a
2-d result even when presented with a 3d-geometry.</para></note>

			</refsection>

			<refsection>
			<title>Examples</title>
<para>Compute an open buffer around roads</para>
				<programlisting>
SELECT ST_Union(
 ST_OffsetCurve(f.the_geom,  f.width/2, 'quad_segs=4 join=round'),
 ST_OffsetCurve(f.the_geom, -f.width/2, 'quad_segs=4 join=round')
) as track
FROM someroadstable;

				</programlisting>
				<informaltable>
				  <tgroup cols="2">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve01.png" />
							  </imageobject>
							  <caption><para>15, 'quad_segs=4 join=round' original line
and its offset 15 units.</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)'),
	15, 'quad_segs=4 join=round'));
--output --
LINESTRING(164 1,18 1,12.2597485145237 2.1418070123307,
	7.39339828220179 5.39339828220179,
	5.39339828220179 7.39339828220179,
	2.14180701233067 12.2597485145237,1 18,1 195)
				</programlisting>
						  </para></entry>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve02.png" />
							  </imageobject>
							  <caption><para>-15, 'quad_segs=4 join=round' original line
								and its offset -15 units </para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_OffsetCurve(geom,
	-15, 'quad_segs=4 join=round')) As notsocurvy
	FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)') As geom;
-- notsocurvy --
LINESTRING(31 195,31 31,164 31)
				</programlisting>
						</para></entry>
					  </row>
					 <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve05.png" />
							  </imageobject>
							  <caption><para>double-offset to get more curvy, note the first reverses direction, so -30 + 15 = -15</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_OffsetCurve(geom,
	-30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')) As morecurvy
	FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)') As geom;
-- morecurvy --
LINESTRING(164 31,46 31,40.2597485145236 32.1418070123307,
35.3933982822018 35.3933982822018,
32.1418070123307 40.2597485145237,31 46,31 195)
				</programlisting>
						</para></entry>
<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve06.png" />
							  </imageobject>
							  <caption><para>double-offset to get more curvy,combined with regular offset 15 to get parallel lines.  Overlaid with original.</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>SELECT ST_AsText(ST_Collect(
	ST_OffsetCurve(geom, 15, 'quad_segs=4 join=round'),
	ST_OffsetCurve(ST_OffsetCurve(geom,
	-30, 'quad_segs=4 join=round'), -15, 'quad_segs=4 join=round')
	)
) As parallel_curves
	FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)') As geom;
-- parallel curves  --
MULTILINESTRING((164 1,18 1,12.2597485145237 2.1418070123307,
7.39339828220179 5.39339828220179,5.39339828220179 7.39339828220179,
2.14180701233067 12.2597485145237,1 18,1 195),
(164 31,46 31,40.2597485145236 32.1418070123307,35.3933982822018 35.3933982822018,
32.1418070123307 40.2597485145237,31 46,31 195))
				</programlisting>
						</para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve03.png" />
							  </imageobject>
							  <caption><para>15, 'quad_segs=4 join=bevel' shown with original line</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_OffsetCurve(ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)'),
		15, 'quad_segs=4 join=bevel'));
-- output --
LINESTRING(164 1,18 1,7.39339828220179 5.39339828220179,
	5.39339828220179 7.39339828220179,1 18,1 195)
				</programlisting>
						 </para></entry>

						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_offsetcurve04.png" />
							  </imageobject>
							  <caption><para>15,-15 collected, join=mitre mitre_limit=2.1</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_Collect(
	ST_OffsetCurve(geom, 15, 'quad_segs=4 join=mitre mitre_limit=2.2'),
	ST_OffsetCurve(geom, -15, 'quad_segs=4 join=mitre mitre_limit=2.2')
	) )
	FROM ST_GeomFromText(
'LINESTRING(164 16,144 16,124 16,104 16,84 16,64 16,
	44 16,24 16,20 16,18 16,17 17,
	16 18,16 20,16 40,16 60,16 80,16 100,
	16 120,16 140,16 160,16 180,16 195)') As geom;
-- output --
MULTILINESTRING((164 1,11.7867965644036 1,1 11.7867965644036,1 195),
	(31 195,31 31,164 31))
				</programlisting>
						  </para></entry>
					  </row>
					</tbody>
				  </tgroup>
			</informaltable>

			</refsection>

			  <refsection>
				<title>See Also</title>
				<para><xref linkend="ST_Buffer" /></para>
			  </refsection>
	</refentry>

	<refentry id="ST_RemoveRepeatedPoints">
	  <refnamediv>
		<refname>ST_RemoveRepeatedPoints</refname>
		<refpurpose>Returns a version of the given geometry with
				duplicated points removed.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RemoveRepeatedPoints</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
			<paramdef choice="opt"><type>float8</type> <parameter>tolerance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a version of the given geometry with
				duplicated points removed. Will actually do something only with
				(multi)lines, (multi)polygons and multipoints but you can safely call it with
				any kind of geometry. Since simplification occurs on a
				object-by-object basis you can also feed a GeometryCollection to
				this function.</para>
        <para>If the tolerance parameter is provided, vertices within the tolerance
        of one another will be considered the "same" for the purposes of removal.</para>

		<para>Availability: 2.2.0</para>
		<para>&P_support;</para>
		<para>&Z_support;</para>
	  </refsection>

		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Simplify" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_SharedPaths">
	  <refnamediv>
		<refname>ST_SharedPaths</refname>
		<refpurpose>Returns a collection containing paths shared by the two input linestrings/multilinestrings.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SharedPaths</function></funcdef>
			<paramdef><type>geometry</type> <parameter>lineal1</parameter></paramdef>
			<paramdef><type>geometry</type> <parameter>lineal2</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a collection containing paths shared by the two input geometries.
		    Those going in the same direction are in the first element of the collection, those going in the opposite direction are in the second element.
		    The paths themselves are given in the direction of the first geometry.
		</para>

		<para>Availability: 2.0.0 requires GEOS &gt;= 3.3.0.</para>
	  </refsection>
	  <refsection>
		<title>Examples: Finding shared paths</title>
		<informaltable>
		  <tgroup cols="1">
			<tbody>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_sharedpaths01.png" />
					  </imageobject>
					  <caption><para>A multilinestring and a linestring</para></caption>
					</mediaobject>
				  </informalfigure></para>
			   </entry>
			  </row>
			  <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_sharedpaths02.png" />
					  </imageobject>
					  <caption><para>The shared path of multilinestring and linestring overlaid with original geometries.</para></caption>
					</mediaobject>
				  </informalfigure>
				  <programlisting>
 SELECT ST_AsText(
  ST_SharedPaths(
    ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),
	   (51 150,101 150,76 175,51 150))'),
	ST_GeomFromText('LINESTRING(151 100,126 156.25,126 125,90 161, 76 175)')
	)
  ) As wkt

                                wkt
-------------------------------------------------------------
GEOMETRYCOLLECTION(MULTILINESTRING((126 156.25,126 125),
 (101 150,90 161),(90 161,76 175)),MULTILINESTRING EMPTY)
			  </programlisting>
			</para>
			</entry>
		</row>
		<row>
			<entry><para>
				  <programlisting>
-- same example but linestring orientation flipped
SELECT ST_AsText(
  ST_SharedPaths(
   ST_GeomFromText('LINESTRING(76 175,90 161,126 125,126 156.25,151 100)'),
   ST_GeomFromText('MULTILINESTRING((26 125,26 200,126 200,126 125,26 125),
	   (51 150,101 150,76 175,51 150))')
	)
  ) As wkt

                                wkt
-------------------------------------------------------------
GEOMETRYCOLLECTION(MULTILINESTRING EMPTY,
MULTILINESTRING((76 175,90 161),(90 161,101 150),(126 125,126 156.25)))
			  </programlisting>
			</para>
			</entry>
		</row>
	</tbody>
	</tgroup>
</informaltable>
	 </refsection>
      <refsection>
        <title>See Also</title>
	<para>
		<xref linkend="ST_Dump" />,
		<xref linkend="ST_GeometryN" />,
		<xref linkend="ST_NumGeometries" />
	</para>
      </refsection>
	</refentry>

	<refentry id="ST_Shift_Longitude">
	  <refnamediv>
		<refname>ST_ShiftLongitude</refname>

		<refpurpose>Toggle geometry coordinates between -180..180 and 0..360 ranges.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_ShiftLongitude</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Reads every point/vertex in every component of every feature
			in a geometry, and if the longitude coordinate is &lt;0, adds 360
			to it. The result would be a 0-360 version of the data to be
			plotted in a 180 centric map</para>
		<note><para>This is only useful for data in long lat e.g. 4326 (WGS 84 long lat)</para></note>

		<para><inlinegraphic fileref="images/warning.png" />
			Pre-1.3.4 bug prevented this from working for MULTIPOINT. 1.3.4+ works with MULTIPOINT as well.
		</para>

		<para>&Z_support;</para>
		<para>Enhanced: 2.0.0 support for Polyhedral surfaces and TIN was introduced.</para>
    <para>NOTE: this function was renamed from "ST_Shift_Longitude" in 2.2.0</para>
		<para>&P_support;</para>
		<para>&T_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>--3d points
SELECT ST_AsEWKT(ST_ShiftLongitude(ST_GeomFromEWKT('SRID=4326;POINT(-118.58 38.38 10)'))) As geomA,
	ST_AsEWKT(ST_ShiftLongitude(ST_GeomFromEWKT('SRID=4326;POINT(241.42 38.38 10)'))) As geomb
geomA							  geomB
----------						  -----------
SRID=4326;POINT(241.42 38.38 10) SRID=4326;POINT(-118.58 38.38 10)

--regular line string
SELECT ST_AsText(ST_ShiftLongitude(ST_GeomFromText('LINESTRING(-118.58 38.38, -118.20 38.45)')))

st_astext
----------
LINESTRING(241.42 38.38,241.8 38.45)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para>
      <xref linkend="ST_WrapX" />
    </para>
	  </refsection>
	</refentry>

	<refentry id="ST_WrapX">
	  <refnamediv>
		<refname>ST_WrapX</refname>

		<refpurpose>Wrap a geometry around an X value.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_WrapX</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
			<paramdef><type>float8 </type> <parameter>wrap</parameter></paramdef>
			<paramdef><type>float8 </type> <parameter>move</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

    <para>
This function splits the input geometries and then moves every resulting
component falling on the right (for negative 'move') or on the left (for
positive 'move') of given 'wrap' line in the direction specified by the
'move' parameter, finally re-unioning the pieces togheter.
    </para>

		<note><para>
This is useful to "recenter" long-lat input to have features
of interest not spawned from one side to the other.
    </para></note>

		<para>Availability: 2.3.0</para>

		<para>&Z_support;</para>
<!-- TODO: check these
		<para>&P_support;</para>
		<para>&T_support;</para>
-->
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
-- Move all components of the given geometries whose bounding box
-- falls completely on the left of x=0 to +360
select ST_WrapX(the_geom, 0, 360);

-- Move all components of the given geometries whose bounding box
-- falls completely on the left of x=-30 to +360
select ST_WrapX(the_geom, -30, 360);
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Shift_Longitude" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Simplify">
	  <refnamediv>
		<refname>ST_Simplify</refname>
		<refpurpose>Returns a "simplified" version of the given geometry using
				the Douglas-Peucker algorithm.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Simplify</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
			<paramdef><type>boolean</type> <parameter>preserveCollapsed</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a "simplified" version of the given geometry using
				the Douglas-Peucker algorithm. Will actually do something only with
				(multi)lines and (multi)polygons but you can safely call it with
				any kind of geometry. Since simplification occurs on a
				object-by-object basis you can also feed a GeometryCollection to
				this function.</para>

    <para>The "preserve collapsed" flag will retain objects that would otherwise
      be too small given the tolerance. For example, a 1m long line simplified with a 10m
      tolerance. If the preserve flag is given, the line will not disappear. This flag
      is useful for rendering engines, to avoid having large numbers of very
      small objects disappear from a map leaving surprising gaps.</para>

		<note><para>Note that returned geometry might lose its
				simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
		<note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>

		<para>Availability: 1.2.2</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>A circle simplified too much becomes a triangle, medium an octagon, </para>
				<programlisting>
SELECT ST_Npoints(the_geom) As np_before, ST_NPoints(ST_Simplify(the_geom,0.1)) As np01_notbadcircle, ST_NPoints(ST_Simplify(the_geom,0.5)) As np05_notquitecircle,
ST_NPoints(ST_Simplify(the_geom,1)) As np1_octagon, ST_NPoints(ST_Simplify(the_geom,10)) As np10_triangle,
(ST_Simplify(the_geom,100) is null) As  np100_geometrygoesaway
FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) As foo;
-result
 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_triangle | np100_geometrygoesaway
-----------+-------------------+---------------------+-------------+---------------+------------------------
		49 |                33 |                  17 |           9 |             4 | t

				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_IsSimple" />, <xref linkend="ST_SimplifyPreserveTopology" />, Topology <xref linkend="TP_ST_Simplify"/></para>
		  </refsection>
	</refentry>

	<refentry id="ST_SimplifyPreserveTopology">
	  <refnamediv>
		<refname>ST_SimplifyPreserveTopology</refname>
		<refpurpose>Returns a "simplified" version of the given geometry using
			the Douglas-Peucker algorithm. Will avoid creating derived
			geometries (polygons in particular) that are invalid.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SimplifyPreserveTopology</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>Returns a "simplified" version of the given geometry using
			the Douglas-Peucker algorithm. Will avoid creating derived
			geometries (polygons in particular) that are invalid. Will actually do something only with
				(multi)lines and (multi)polygons but you can safely call it with
				any kind of geometry. Since simplification occurs on a
				object-by-object basis you can also feed a GeometryCollection to
				this function.</para>

		<para>Performed by the GEOS module.</para>
		<note><para>Requires GEOS 3.0.0+</para></note>
		<para>Availability: 1.3.3</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>Same example as Simplify, but we see Preserve Topology prevents oversimplification.  The circle can at most become a square.</para>
				<programlisting>
SELECT ST_Npoints(the_geom) As np_before, ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.1)) As np01_notbadcircle, ST_NPoints(ST_SimplifyPreserveTopology(the_geom,0.5)) As np05_notquitecircle,
ST_NPoints(ST_SimplifyPreserveTopology(the_geom,1)) As np1_octagon, ST_NPoints(ST_SimplifyPreserveTopology(the_geom,10)) As np10_square,
ST_NPoints(ST_SimplifyPreserveTopology(the_geom,100)) As  np100_stillsquare
FROM (SELECT ST_Buffer('POINT(1 3)', 10,12) As the_geom) As foo;

--result--
 np_before | np01_notbadcircle | np05_notquitecircle | np1_octagon | np10_square | np100_stillsquare
-----------+-------------------+---------------------+-------------+---------------+-------------------
		49 |                33 |                  17 |           9 |             5 |                 5
				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Simplify" /></para>
		  </refsection>
	</refentry>

<refentry id="ST_SimplifyVW">
	  <refnamediv>
		<refname>ST_SimplifyVW</refname>
		<refpurpose>Returns a "simplified" version of the given geometry using the Visvalingam-Whyatt algorithm</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SimplifyVW</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>tolerance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para> Returns a "simplified" version of the given geometry using the Visvalingam-Whyatt algorithm.
		Will actually do something only with (multi)lines and (multi)polygons but you can safely call it with any kind of geometry.
		Since simplification occurs on a object-by-object basis you can also feed a GeometryCollection to this function.</para>

		<note><para>Note that returned geometry might lose its
				simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
		<note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>
		<note><para>This function handles 3D and the third dimension will affect the result.</para></note>
		<para>Availability: 2.2.0</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>A LineString is simplified with a minimum area threshold of 30.</para>
				<programlisting>

select ST_AsText(ST_SimplifyVW(geom,30)) simplified
FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As foo;
-result
 simplified
-----------+-------------------+
LINESTRING(5 2,7 25,10 10)

				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_SetEffectiveArea" />, <xref linkend="ST_Simplify" />, <xref linkend="ST_SimplifyPreserveTopology" />, Topology <xref linkend="TP_ST_Simplify"/></para>
		  </refsection>
	</refentry>
		<refentry id="ST_SetEffectiveArea">
	  <refnamediv>
		<refname>ST_SetEffectiveArea</refname>
		<refpurpose>
			Sets the effective area for each vertex, storing the value in the M ordinate.  A simplified geometry can then be generated by filtering on the M ordinate.
		</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SetEffectiveArea</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>threshold = 0</parameter></paramdef>
			<paramdef><type>integer</type> <parameter>set_area = 1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>
			Sets the effective area for each vertex, using the Visvalingam-Whyatt algorithm.
			The effective area is stored as the M-value of the vertex.
			If the optional "theshold" parameter is used, a simplified geometry will be returned, containing only vertices with an effective area
            greater than or equal to the threshold value.
			</para><para>
			This function can be used for server-side simplification when a threshold is specified.  Another option is to use a threshold value of zero.
			In this case, the full geometry will be returned with effective areas as M-values, which can be used by the client to simplify very quickly.
			</para><para>
			Will actually do something only with
			(multi)lines and (multi)polygons but you can safely call it with
			any kind of geometry. Since simplification occurs on a
			object-by-object basis you can also feed a GeometryCollection to
			this function.
			</para>


		<note><para>Note that returned geometry might lose its
				simplicity (see <xref linkend="ST_IsSimple" />)</para></note>
		<note><para>Note topology may not be preserved and may result in invalid geometries.  Use  (see <xref linkend="ST_SimplifyPreserveTopology" />) to preserve topology.</para></note>
		<note><para>The output geometry will lose all previous information in the M-values</para></note>
		<note><para>This function handles 3D and the third dimension will affect the effective area</para></note>
		<para>Availability: 2.2.0</para>
	  </refsection>

		  <refsection>
			<title>Examples</title>
			<para>
				Calculating the effective area of a LineString.  Because we use a threshold value of zero, all vertices in the input geometry are returned.
			</para>
				<programlisting>

select ST_AsText(ST_SetEffectiveArea(geom)) all_pts, ST_AsText(ST_SetEffectiveArea(geom,30) ) thrshld_30
FROM (SELECT  'LINESTRING(5 2, 3 8, 6 20, 7 25, 10 10)'::geometry geom) As foo;
-result
 all_pts | thrshld_30
-----------+-------------------+
LINESTRING M (5 2 3.40282346638529e+38,3 8 29,6 20 1.5,7 25 49.5,10 10 3.40282346638529e+38) | LINESTRING M (5 2 3.40282346638529e+38,7 25 49.5,10 10 3.40282346638529e+38)

				</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_SimplifyVW" /></para>
		  </refsection>
	</refentry>

    <refentry id="ST_Split">
        <refnamediv>
            <refname>ST_Split</refname>
            <refpurpose>Returns a collection of geometries resulting by splitting a geometry.</refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>
              <funcprototype>
                <funcdef>geometry <function>ST_Split</function></funcdef>
                <paramdef><type>geometry</type> <parameter>input</parameter></paramdef>
                <paramdef><type>geometry</type> <parameter>blade</parameter></paramdef>
              </funcprototype>
            </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>
            <para>
            The function supports splitting a line by (multi)point, (multi)line or (multi)polygon boundary, a (multi)polygon by line. The returned geometry is always a collection.
            </para>

            <para>
            Think of this function as the opposite of ST_Union.
            Theoretically applying ST_Union to the elements of the returned collection
            should always yield the original geometry.
            </para>

            <para>Availability: 2.0.0</para>
            <para>Changed: 2.2.0 support for splitting a line by a multiline, a multipoint or (multi)polygon boundary was introduced.</para>

            <note><para>To improve the robustness of ST_Split it may be convenient to <xref linkend="ST_Snap"/> the input to the blade in advance using a very low tolerance. Otherwise the internally used coordinate grid may cause tolerance problems, where coordinates of input and blade do not fall onto each other and the input is not being split correctly (see <ulink url="http://trac.osgeo.org/postgis/ticket/2192">#2192</ulink>).</para></note>

            <note><para>
When a (multi)polygon is passed as as the blade, its linear component
(the boundary) is used for cutting the input.
            </para></note>

        </refsection>
        <refsection>
            <title>Examples</title>
            <para>Polygon Cut by Line</para>
            <informaltable>
                <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split01.png" />
                              </imageobject>
                              <caption><para>Before Split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                               </para>
                        </entry>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split02.png" />
                              </imageobject>
                              <caption><para>After split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                              </para>
                        </entry>
                    </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <programlisting>
-- this creates a geometry collection consisting of the 2 halves of the polygon
-- this is similar to the example we demonstrated in ST_BuildArea
SELECT ST_Split(circle, line)
FROM (SELECT
    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,
    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

-- result --
 GEOMETRYCOLLECTION(POLYGON((150 90,149.039264020162 80.2454838991936,146.193976625564 70.8658283817455,..), POLYGON(..)))

-- To convert to individual polygons, you can use ST_Dump or ST_GeometryN
SELECT ST_AsText((ST_Dump(ST_Split(circle, line))).geom) As wkt
FROM (SELECT
    ST_MakeLine(ST_MakePoint(10, 10),ST_MakePoint(190, 190)) As line,
    ST_Buffer(ST_GeomFromText('POINT(100 90)'), 50) As circle) As foo;

-- result --
wkt
---------------
POLYGON((150 90,149.039264020162 80.2454838991936,..))
POLYGON((60.1371179574584 60.1371179574584,58.4265193848728 62.2214883490198,53.8060233744357 ..))
            </programlisting>
            <para>Multilinestring Cut by point</para>
            <informaltable>
                <tgroup cols="2">
                    <tbody>
                      <row>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split03.png" />
                              </imageobject>
                              <caption><para>Before Split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                               </para>
                        </entry>
                        <entry>
                                               <para>
                            <informalfigure>
                            <mediaobject>
                              <imageobject>
                                <imagedata fileref="images/st_split04.png" />
                              </imageobject>
                              <caption><para>After split</para></caption>
                            </mediaobject>
                            </informalfigure>
                                               </para>
                        </entry>
                    </row>
                    </tbody>
                </tgroup>
            </informaltable>
            <programlisting>
SELECT ST_AsText(ST_Split(mline, pt)) As wktcut
        FROM (SELECT
    ST_GeomFromText('MULTILINESTRING((10 10, 190 190), (15 15, 30 30, 100 90))') As mline,
    ST_Point(30,30) As pt) As foo;

wktcut
------
GEOMETRYCOLLECTION(
    LINESTRING(10 10,30 30),
    LINESTRING(30 30,190 190),
    LINESTRING(15 15,30 30),
    LINESTRING(30 30,100 90)
)
            </programlisting>
        </refsection>
        <refsection>
        <title>See Also</title>
        <para>
<xref linkend="ST_AsText" />,
<xref linkend="ST_BuildArea" />,
<xref linkend="ST_Dump" />,
<xref linkend="ST_GeometryN" />,
<xref linkend="ST_Union" />,
<xref linkend="ST_Subdivide" />
        </para>
        </refsection>
    </refentry>

	<refentry id="ST_SymDifference">
	  <refnamediv>
		<refname>ST_SymDifference</refname>

		<refpurpose>Returns a geometry that represents the portions of A and B
			that do not intersect. It is called a symmetric difference because
			ST_SymDifference(A,B) = ST_SymDifference(B,A).</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SymDifference</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>geomB</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a geometry that represents the portions of A and B
			that do not intersect. It is called a symmetric difference because
			ST_SymDifference(A,B) = ST_SymDifference(B,A). One can think of this as ST_Union(geomA,geomB) - ST_Intersection(A,B).
			</para>

		<para>Performed by the GEOS module</para>

		<note><para>Do not call with a GeometryCollection as an argument</para></note>

		<para>&sfs_compliant; s2.1.1.3</para>
		<para>&sqlmm_compliant; SQL-MM 3: 5.1.21</para>
		<para>&Z_support; However it seems to only consider x y when
		  doing the difference and tacks back on the Z-Index</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<informaltable>
			  <tgroup cols="2">
				<tbody>
				  <row>
					<entry>
						<para>
							<informalfigure>
								<mediaobject>
								  <imageobject>
									<imagedata fileref="images/st_symdifference01.png" />
								  </imageobject>
								  <caption><para>The original linestrings shown together</para></caption>
								</mediaobject>
							</informalfigure>
						</para>
					</entry>

					<entry>
						<para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_symdifference02.png" />
							  </imageobject>
							  <caption><para>The symmetric difference of the two linestrings</para></caption>
							</mediaobject>
						  </informalfigure>
					</para>
				</entry>
				  </row>
		</tbody>
	</tgroup>
</informaltable>
<programlisting>
--Safe for 2d - symmetric difference of 2 linestrings
SELECT ST_AsText(
	ST_SymDifference(
		ST_GeomFromText('LINESTRING(50 100, 50 200)'),
		ST_GeomFromText('LINESTRING(50 50, 50 150)')
	)
);

st_astext
---------
MULTILINESTRING((50 150,50 200),(50 50,50 100))
</programlisting>

<programlisting>

--When used in 3d doesn't quite do the right thing
SELECT ST_AsEWKT(ST_SymDifference(ST_GeomFromEWKT('LINESTRING(1 2 1, 1 4 2)'),
	ST_GeomFromEWKT('LINESTRING(1 1 3, 1 3 4)')))

st_astext
------------
MULTILINESTRING((1 3 2.75,1 4 2),(1 1 3,1 2 2.25))
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Difference" />, <xref linkend="ST_Intersection" />, <xref linkend="ST_Union" /></para>
	  </refsection>
</refentry>


	<refentry id="ST_Subdivide">
	  <refnamediv>
		<refname>ST_Subdivide</refname>
		<refpurpose>Returns a set of geometry where no geometry in the set has more than the specified number of vertices.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>setof geometry <function>ST_Subdivide</function></funcdef>
				<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
				<paramdef><type>integer</type> <parameter>max_vertices=256</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

    <para>
Turns a single geometry into a set in which each element has fewer than
the maximum allowed number of vertices. Useful for converting excessively
large polygons and other objects into small portions that fit within the
database page size. Uses the same envelope clipping as ST_ClipByBox2D does,
recursively subdividing the input geometry until all portions have less than the
maximum vertex count. Minimum vertice count allowed is 8 and if you try to specify lower than 8, it will throw an error.
    </para>

		<para>Clipping performed by the GEOS module.</para>
		<note><para>Requires GEOS 3.5.0+</para></note>

		<para>Availability: 2.2.0 requires GEOS &gt;= 3.5.0.</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>
			<programlisting>-- Create a new subdivided table suitable for joining to the original
CREATE TABLE subdivided_geoms AS
SELECT pkey, ST_Subdivide(geom) AS geom
FROM original_geoms;
 </programlisting>

				<informaltable>
				  <tgroup cols="1">
					<tbody>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_subdivide01.png" />
							  </imageobject>
							  <caption><para>Subdivide max 10 vertices</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>SELECT row_number() OVER() As rn, ST_AsText(geom) As wkt
FROM ( SELECT ST_SubDivide('POLYGON((132 10,119 23,85 35,68 29,66 28,49 42,32 56,22 64,32 110,40 119,36 150,
57 158,75 171,92 182,114 184,132 186,146 178,176 184,179 162,184 141,190 122,
190 100,185 79,186 56,186 52,178 34,168 18,147 13,132 10))'::geometry,10))  As f(geom);</programlisting>
<screen>rn |                          wkt
---+---------------------------------------------------------------------------
 1 | POLYGON((22 64,29.3913043478263 98.000000000001,106.000000000001 98.00000000001,
        106.000000000001 27.5882352941173,85 35,68 29,66 28,49 42,32 56,22 64))
 2 | POLYGON((29.3913043478263 98.000000000001,32 110,40 119,36 150,57 158,
        75 11,92 182,106.000000000001 183.272727272727,106.000000000001 98.000000000001,
        29.913043478263 98.000000000001))
 3 | POLYGON((106.000000000001 27.5882352941173,106.000000000001 98.00000000000,
 189.52380952381 98.000000000001,185 79,186 56,186 52,178 34,168 18,147 13,
 132 0,119 23,106.000000000001 27.5882352941173))
 4 | POLYGON((106.000000000001 98.000000000001,106.000000000001 183.27272727272,
    114 184,132 186,146 178,176 184,179 162,184 141,190 122,190 100,189.5238095238
 98.000000000001,106.000000000001 98.000000000001))</screen>
						  </para></entry>
					  </row>
					  <row>
						<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_subdivide02.png" />
							  </imageobject>
							  <caption><para>Useful in conjunction with ST_Segmentize to create additional vertices that can then be used for splitting</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>SELECT ST_AsText(ST_SubDivide(ST_Segmentize('LINESTRING(0 0, 100 100, 150 150)'::geometry,10),8));</programlisting>
<screen>LINESTRING(0 0,7.07106781186547 7.07106781186547,14.1421356237309 14.1421356237309,21.2132034355964 21.2132034355964,28.2842712474619 28.2842712474619,35.3553390593274 35.3553390593274,37.499999999998 37.499999999998)
LINESTRING(37.499999999998 37.499999999998,42.4264068711929 42.4264068711929,49.4974746830583 49.4974746830583,56.5685424949238 56.5685424949238,63.6396103067893 63.6396103067893,70.7106781186548 70.7106781186548,74.999999999998 74.999999999998)
LINESTRING(74.999999999998 74.999999999998,77.7817459305202 77.7817459305202,84.8528137423857 84.8528137423857,91.9238815542512 91.9238815542512,98.9949493661167 98.9949493661167,100 100,107.071067811865 107.071067811865,112.499999999998 112.499999999998)
LINESTRING(112.499999999998 112.499999999998,114.142135623731 114.142135623731,121.213203435596 121.213203435596,128.284271247462 128.284271247462,135.355339059327 135.355339059327,142.426406871193 142.426406871193,149.497474683058 149.497474683058,149.999999999998 149.999999999998)</screen>
						  </para></entry>
					  </row>
				</tbody></tgroup></informaltable>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para>
<xref linkend="ST_AsText" />,
<xref linkend="ST_ClipByBox2D" />,
<xref linkend="ST_Segmentize" />,
<xref linkend="ST_Split" />
    </para>
	  </refsection>
	</refentry>

	<refentry id="ST_SwapOrdinates">
	  <refnamediv>
		<refname>ST_SwapOrdinates</refname>
		<refpurpose>Returns a version of the given geometry with
				given ordinate values swapped.
    </refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SwapOrdinates</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
			<paramdef><type>cstring</type> <parameter>ords</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>
Returns a version of the given geometry with given ordinates swapped.
    </para>
		<para>
The <varname>ords</varname> parameter is a 2-characters string naming
the ordinates to swap. Valid names are: x,y,z and m.
    </para>
		<para>Availability: 2.2.0</para>
		<para>&curve_support;</para>
		<para>&Z_support;</para>
		<para>&M_support;</para>
		<para>&P_support;</para>
		<para>&T_support;</para>
	  </refsection>

	  <refsection>
		<title>Example</title>
		<programlisting><![CDATA[
-- Scale M value by 2
SELECT ST_AsText(
  ST_SwapOrdinates(
    ST_Scale(
      ST_SwapOrdinates(g,'xm'),
      2, 1
    ),
  'xm')
) FROM ( SELECT 'POINT ZM (0 0 0 2)'::geometry g ) foo;
     st_astext
--------------------
 POINT ZM (0 0 0 4)
		 ]]></programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para> <xref linkend="ST_FlipCoordinates" /> </para>
	  </refsection>

	</refentry>

<refentry id="ST_Union">
  <refnamediv>
	<refname>ST_Union</refname>
	<refpurpose>Returns a geometry that represents the point set union of
		the Geometries.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
	<funcsynopsis>
	  <funcprototype>
		<funcdef>geometry <function>ST_Union</function></funcdef>
		<paramdef><type>geometry set</type> <parameter>g1field</parameter></paramdef>
	  </funcprototype>
	  <funcprototype>
		<funcdef>geometry <function>ST_Union</function></funcdef>
		<paramdef><type>geometry</type> <parameter>g1</parameter></paramdef>
		<paramdef><type>geometry</type> <parameter>g2</parameter></paramdef>
	  </funcprototype>
	  <funcprototype>
		<funcdef>geometry <function>ST_Union</function></funcdef>
		<paramdef><type>geometry[]</type> <parameter>g1_array</parameter></paramdef>
	  </funcprototype>
	</funcsynopsis>
  </refsynopsisdiv>

  <refsection>
	<title>Description</title>
	<para> Output type can be a MULTI*, single geometry, or Geometry Collection. Comes in 2 variants.  Variant 1 unions 2 geometries resulting in a new geometry with no intersecting regions.
		Variant 2 is an aggregate function that takes a set of geometries and unions
		them into a single ST_Geometry resulting in no intersecting regions.</para>

	<para>Aggregate version: This function returns a MULTI geometry or NON-MULTI geometry
		from a set of geometries. The ST_Union() function is an "aggregate"
		function in the terminology of PostgreSQL. That means that it
		operates on rows of data, in the same way the SUM() and AVG()
		functions do and like most aggregates, it also ignores NULL geometries.</para>

	<para>Non-Aggregate version: This function returns a geometry being a union of two
		input geometries. Output type can be a MULTI*, NON-MULTI or
		GEOMETRYCOLLECTION. If any are NULL, then NULL is returned.</para>

	<note><para>ST_Collect and ST_Union are often interchangeable.
		ST_Union is in general orders of magnitude slower than ST_Collect
		because it tries to dissolve boundaries and reorder geometries to ensure that a constructed Multi* doesn't
		have intersecting regions.</para></note>

	<para>Performed by the GEOS module.</para>
	<para>NOTE: this function was formerly called GeomUnion(), which
		was renamed from "Union" because UNION is an SQL reserved
		word.</para>
	<para>Availability: 1.4.0 - ST_Union was enhanced. ST_Union(geomarray) was introduced and also faster aggregate collection in PostgreSQL.  If you are using GEOS 3.1.0+
		ST_Union will use the faster Cascaded Union algorithm described in
		<ulink
		url="http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html">http://blog.cleverelephant.ca/2009/01/must-faster-unions-in-postgis-14.html</ulink></para>

	<para>&sfs_compliant; s2.1.1.3</para>
	<note><para>Aggregate version is not explicitly defined in OGC SPEC.</para></note>
	<para>&sqlmm_compliant; SQL-MM 3: 5.1.19
		the z-index (elevation) when polygons are involved.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>Aggregate example</para>
			<programlisting>
SELECT stusps,
	   ST_Multi(ST_Union(f.the_geom)) as singlegeom
	 FROM sometable As f
GROUP BY stusps
			  </programlisting>
		<para>Non-Aggregate example</para>
			<programlisting>
SELECT ST_AsText(ST_Union(ST_GeomFromText('POINT(1 2)'),
	ST_GeomFromText('POINT(-2 3)') ) )

st_astext
----------
MULTIPOINT(-2 3,1 2)


SELECT ST_AsText(ST_Union(ST_GeomFromText('POINT(1 2)'),
		ST_GeomFromText('POINT(1 2)') ) );
st_astext
----------
POINT(1 2)

--3d example - sort of supports 3d (and with mixed dimensions!)
SELECT ST_AsEWKT(st_union(the_geom))
FROM
(SELECT ST_GeomFromEWKT('POLYGON((-7 4.2,-7.1 4.2,-7.1 4.3,
-7 4.2))') as the_geom
UNION ALL
SELECT ST_GeomFromEWKT('POINT(5 5 5)') as the_geom
UNION ALL
	SELECT ST_GeomFromEWKT('POINT(-2 3 1)') as the_geom
UNION ALL
SELECT ST_GeomFromEWKT('LINESTRING(5 5 5, 10 10 10)') as the_geom ) as foo;

st_asewkt
---------
GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 4.2 5,-7.1 4.2 5,-7.1 4.3 5,-7 4.2 5)));

--3d example not mixing dimensions
SELECT ST_AsEWKT(st_union(the_geom))
FROM
(SELECT ST_GeomFromEWKT('POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2,
-7 4.2 2))') as the_geom
UNION ALL
SELECT ST_GeomFromEWKT('POINT(5 5 5)') as the_geom
UNION ALL
	SELECT ST_GeomFromEWKT('POINT(-2 3 1)') as the_geom
UNION ALL
SELECT ST_GeomFromEWKT('LINESTRING(5 5 5, 10 10 10)') as the_geom ) as foo;

st_asewkt
---------
GEOMETRYCOLLECTION(POINT(-2 3 1),LINESTRING(5 5 5,10 10 10),POLYGON((-7 4.2 2,-7.1 4.2 3,-7.1 4.3 2,-7 4.2 2)))

--Examples using new Array construct
SELECT ST_Union(ARRAY(SELECT the_geom FROM sometable));

SELECT ST_AsText(ST_Union(ARRAY[ST_GeomFromText('LINESTRING(1 2, 3 4)'),
			ST_GeomFromText('LINESTRING(3 4, 4 5)')])) As wktunion;

--wktunion---
MULTILINESTRING((3 4,4 5),(1 2,3 4))

			  </programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para>
			<xref linkend="ST_Collect" />
			<xref linkend="ST_UnaryUnion" />
		</para>
	  </refsection>
	</refentry>

	<refentry id="ST_UnaryUnion">
	  <refnamediv>
		<refname>ST_UnaryUnion</refname>

		<refpurpose>Like ST_Union, but working at the geometry component level.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_UnaryUnion</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
		Unlike ST_Union, ST_UnaryUnion does dissolve boundaries
		between components of a multipolygon (invalid)
		and does perform union between the components of a
		geometrycollection.
		Each components of the input geometry is assumed to be
		valid, so you won't get a valid multipolygon out of a
		bow-tie polygon (invalid).
		</para>

		<para>
		You may use this function to node a set of linestrings.
		You may mix ST_UnaryUnion with ST_Collect to fine-tune
		how many geometries at once you want to dissolve to
		be nice on both memory size and CPU time, finding the
		balance between ST_Union and ST_MemUnion.
		</para>

		<para>&Z_support;</para>

		<para>Availability: 2.0.0 - requires GEOS &gt;= 3.3.0.</para>
	  </refsection>


	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
			<xref linkend="ST_Union" />,
			<xref linkend="ST_MemUnion" />,
			<xref linkend="ST_Collect" />,
			<xref linkend="ST_Node" />
		</para>
	  </refsection>
	</refentry>

	<refentry id="ST_VoronoiLines">
	  <refnamediv>
		<refname>ST_VoronoiLines</refname>

		<refpurpose>Returns the boundaries between the cells of the Voronoi diagram constructed from the vertices of a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_VoronoiLines</function></funcdef>
			<paramdef>
				<parameter>g1</parameter>
				<type>geometry</type>
			</paramdef>
			<paramdef choice="opt">
				<parameter>tolerance</parameter>
				<type>float8</type>
			</paramdef>
			<paramdef choice="opt">
				<parameter>extend_to</parameter>
				<type>geometry</type>
			</paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>
		<para>
			ST_VoronoiLines computes a two-dimensional <ulink url="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</ulink> from the vertices of
			the supplied geometry and returns the boundaries between cells in that diagram as a MultiLineString.
			Returns null if input geometry is null. Returns an empty geometry collection if the input geometry contains only one vertex. Returns an empty geometry collection if the extend_to envelope has zero area.
		</para>
		<para>
			Optional parameters:
			<itemizedlist>
				<listitem>
					<para> 'tolerance' : The distance within which vertices will be considered equivalent.  Robustness of the algorithm can be improved by supplying a nonzero tolerance distance.  (default = 0.0)</para>
				</listitem>
				<listitem>
					<para>'extend_to' : If a geometry is supplied as the "extend_to" parameter, the diagram will be extended to cover the envelope of the "extend_to" geometry, unless
						that envelope is smaller than the default envelope (default = NULL, default envelope is boundingbox of input geometry extended by about 50% in each direction).</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>Availability: 2.3.0 - requires GEOS &gt;= 3.5.0.</para>
	  </refsection>

	  <!-- Examples -->
	  <refsection>
		<title>Examples</title>
		<informaltable>
		  <tgroup cols="1">
			<tbody>
			 <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_voronoi03.png" />
					  </imageobject>
					  <caption><para>Voronoi lines with tolerance of 30 units</para></caption>
					</mediaobject>
				  </informalfigure>
					<programlisting>SELECT ST_VoronoiLines(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g</programlisting>
<screen> -- ST_AsText output
MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 -45.7142857142858,36.8181818181818 92.2727272727273))
</screen>
				</para></entry>
			  </row>
		</tbody>
		</tgroup>
		</informaltable>

	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
			<xref linkend="ST_DelaunayTriangles" />,
			<xref linkend="ST_VoronoiPolygons" />,
			<xref linkend="ST_Collect" />
		</para>
	  </refsection>
	</refentry>

	<refentry id="ST_VoronoiPolygons">
	  <refnamediv>
		<refname>ST_VoronoiPolygons</refname>

		<refpurpose>Returns the cells of the Voronoi diagram constructed from the vertices of a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_VoronoiPolygons</function></funcdef>
			<paramdef>
				<parameter>g1</parameter>
				<type>geometry</type>
			</paramdef>
			<paramdef choice="opt">
				<parameter>tolerance</parameter>
				<type>float8</type>
			</paramdef>
			<paramdef choice="opt">
				<parameter>extend_to</parameter>
				<type>geometry</type>
			</paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
			ST_VoronoiPolygons computes a two-dimensional <ulink url="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi diagram</ulink> from the vertices of
			the supplied geometry.  The result is a GeometryCollection of Polygons that covers an envelope larger than the extent of the input vertices.
			Returns null if input geometry is null. Returns an empty geometry collection if the input geometry contains only one vertex. Returns an empty geometry collection if the extend_to envelope has zero area.
		</para>

		<para>
			Optional parameters:
			<itemizedlist>
				<listitem>
					<para> 'tolerance' : The distance within which vertices will be considered equivalent.  Robustness of the algorithm can be improved by supplying a nonzero tolerance distance.  (default = 0.0)</para>
				</listitem>
				<listitem>
					<para>'extend_to' : If a geometry is supplied as the "extend_to" parameter, the diagram will be extended to cover the envelope of the "extend_to" geometry, unless
						that envelope is smaller than the default envelope (default = NULL, default envelope is boundingbox of input geometry extended by about 50% in each direction).
					</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>Availability: 2.3.0 - requires GEOS &gt;= 3.5.0.</para>
	  </refsection>

	  <!-- Examples -->
	  <refsection>
		<title>Examples</title>
		<informaltable>
		  <tgroup cols="1">
			<tbody>
			  <row>
				<entry>
					<para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_voronoi01.png" />
					  </imageobject>
					  <caption><para>Points overlaid on top of Voronoi diagram</para></caption>
					</mediaobject>
					</informalfigure>
					<programlisting>SELECT
	ST_VoronoiPolygons(geom) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g;</programlisting>
<screen> -- ST_AsText output
GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 43.3333333333333)),
POLYGON((55 -90,-110 -90,-110 43.3333333333333,36.8181818181818 92.2727272727273,55 79.2857142857143,55 -90)),
POLYGON((230 47.5,230 -20.7142857142857,55 79.2857142857143,36.8181818181818 92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 -20.7142857142857,230 -90,55 -90,55 79.2857142857143,230 -20.7142857142857)),
POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 270)))
</screen>
					</para>
				</entry>
			</row>
			<row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_voronoi02.png" />
					  </imageobject>
					  <caption><para>Voronoi with tolerance of 30 units</para></caption>
					</mediaobject>
				  </informalfigure>
					<programlisting>SELECT ST_VoronoiPolygons(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g;</programlisting>
<screen> -- ST_AsText output
GEOMETRYCOLLECTION(POLYGON((-110 43.3333333333333,-110 270,100.5 270,59.3478260869565 132.826086956522,36.8181818181818 92.2727272727273,-110 43.3333333333333)),
POLYGON((230 47.5,230 -45.7142857142858,36.8181818181818 92.2727272727273,59.3478260869565 132.826086956522,230 47.5)),POLYGON((230 -45.7142857142858,230 -90,-110 -90,-110 43.3333333333333,36.8181818181818 92.2727272727273,230 -45.7142857142858)),
POLYGON((100.5 270,230 270,230 47.5,59.3478260869565 132.826086956522,100.5 270)))
</screen>
				</para></entry>
			  </row>
			 <row>
				<entry><para><informalfigure>
					<mediaobject>
					  <imageobject>
						<imagedata fileref="images/st_voronoi03.png" />
					  </imageobject>
					  <caption><para>Voronoi with tolerance of 30 units as MultiLineString</para></caption>
					</mediaobject>
				  </informalfigure>
					<programlisting>SELECT ST_VoronoiLines(geom, 30) As geom
FROM (SELECT 'MULTIPOINT (50 30, 60 30, 100 100,10 150, 110 120)'::geometry As geom ) As g</programlisting>
<screen> -- ST_AsText output
MULTILINESTRING((135.555555555556 270,36.8181818181818 92.2727272727273),(36.8181818181818 92.2727272727273,-110 43.3333333333333),(230 -45.7142857142858,36.8181818181818 92.2727272727273))
</screen>
				</para></entry>
			  </row>
		</tbody>
		</tgroup>
		</informaltable>

	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
			<xref linkend="ST_DelaunayTriangles" />,
			<xref linkend="ST_VoronoiLines" />,
			<xref linkend="ST_Collect" />
		</para>
	  </refsection>
	</refentry>
</sect1>
