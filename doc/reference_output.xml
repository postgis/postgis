<?xml version="1.0" encoding="UTF-8"?>

  <sect1 id="Geometry_Outputs">
	  <sect1info>
			<abstract>
			<para>These functions convert geometry objects into various textual or binary formats.</para>
			</abstract>
		</sect1info>

	  <title>Geometry Output</title>

    <sect2>
      <title>Well-Known Text (WKT)</title>

	  <refentry id="ST_AsEWKT">
		  <refnamediv>
			<refname>ST_AsEWKT</refname>
			<refpurpose>Return the Well-Known Text (WKT) representation of the geometry with SRID meta data.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>text <function>ST_AsEWKT</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>text <function>ST_AsEWKT</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>text <function>ST_AsEWKT</function></funcdef>
				<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>text <function>ST_AsEWKT</function></funcdef>
				<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Returns the Well-Known Text representation of the geometry prefixed with the SRID.
            The optional <parameter>maxdecimaldigits</parameter> argument may be used to reduce the maximum number
			of decimal digits after floating point used in output (defaults to 15).</para>

            <para>To perform the inverse conversion of EWKT representation to PostGIS geometry
                use <xref linkend="ST_GeomFromEWKT" />.</para>

      <warning>
			<para>Using the <parameter>maxdecimaldigits</parameter> parameter
            can cause output geometry to become invalid.
            To avoid this use <xref linkend="ST_ReducePrecision" />
            with a suitable gridsize first.
            </para>
      </warning>

			<note>
			  <para>The WKT spec does not include the SRID.  To get the OGC WKT format use <xref linkend="ST_AsText" />.</para>
			</note>
			<warning>
        <para>WKT format does not maintain precision so to prevent floating truncation,
        use <xref linkend="ST_AsBinary" /> or <xref linkend="ST_AsEWKB" /> format for transport.</para>
			</warning>

            <para>Enhanced: 3.1.0 support for optional precision parameter.</para>
			<para>Enhanced: 2.0.0 support for Geography, Polyhedral surfaces, Triangles and TIN was introduced.</para>

			<para>&Z_support;</para>
			<para>&curve_support;</para>
			<para>&P_support;</para>
			<para>&T_support;</para>
		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsEWKT('0103000020E61000000100000005000000000000
			000000000000000000000000000000000000000000000000000000
			F03F000000000000F03F000000000000F03F000000000000F03
			F000000000000000000000000000000000000000000000000'::geometry);

		   st_asewkt
--------------------------------
SRID=4326;POLYGON((0 0,0 1,1 1,1 0,0 0))
(1 row)

SELECT ST_AsEWKT('0108000080030000000000000060E30A4100000000785C0241000000000000F03F0000000018
E20A4100000000485F024100000000000000400000000018
E20A4100000000305C02410000000000000840')

--st_asewkt---
CIRCULARSTRING(220268 150415 1,220227 150505 2,220227 150406 3)
</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>
			<para>
<xref linkend="ST_AsBinary" />,
<xref linkend="ST_AsEWKB" />,
<xref linkend="ST_AsText" />,
<xref linkend="ST_GeomFromEWKT" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_AsText">
		  <refnamediv>
			<refname>ST_AsText</refname>
			<refpurpose>Return the Well-Known Text (WKT) representation of the geometry/geography without SRID metadata.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>text <function>ST_AsText</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>text <function>ST_AsText</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits = 15</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>text <function>ST_AsText</function></funcdef>
				<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>text <function>ST_AsText</function></funcdef>
				<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits = 15</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Returns the OGC <link linkend="OpenGISWKBWKT">Well-Known Text</link> (WKT) representation of the geometry/geography.
            The optional <parameter>maxdecimaldigits</parameter> argument may be used to limit the number
			of digits after the decimal point in output ordinates (defaults to 15).</para>

			<para>To perform the inverse conversion of WKT representation to PostGIS geometry
            use <xref linkend="ST_GeomFromText" />.</para>

			<note>
			  <para>The standard OGC WKT representation does not include the SRID.
              To include the SRID as part of the output representation, use the non-standard
				PostGIS function <xref linkend="ST_AsEWKT" /></para>
			</note>
      <warning>
			<para>The textual representation of numbers in WKT may not maintain full floating-point precision.
            To ensure full accuracy for data storage or transport it is best to use
            <link linkend="OpenGISWKBWKT">Well-Known Binary</link> (WKB) format
            (see  <xref linkend="ST_AsBinary" /> and <parameter>maxdecimaldigits</parameter>).</para>
      </warning>

      <warning>
			<para>Using the <parameter>maxdecimaldigits</parameter> parameter
            can cause output geometry to become invalid.
            To avoid this use <xref linkend="ST_ReducePrecision" />
            with a suitable gridsize first.
            </para>
      </warning>

			<para>Availability: 1.5 - support for geography was introduced.</para>
			<para>Enhanced: 2.5 - optional parameter precision introduced.</para>
			<para>&sfs_compliant; s2.1.1.1</para>
			<para>&sqlmm_compliant; SQL-MM 3: 5.1.25</para>
			<para>&curve_support;</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText('01030000000100000005000000000000000000
000000000000000000000000000000000000000000000000
F03F000000000000F03F000000000000F03F000000000000F03
F000000000000000000000000000000000000000000000000');

    st_astext
--------------------------------
 POLYGON((0 0,0 1,1 1,1 0,0 0))
</programlisting>

<para>Full precision output is the default.</para>
			<programlisting>SELECT ST_AsText('POINT(111.1111111 1.1111111)'));
    st_astext
------------------------------
 POINT(111.1111111 1.1111111)
</programlisting>

<para>The <parameter>maxdecimaldigits</parameter> argument can be used to limit output precision.</para>
			<programlisting>SELECT ST_AsText('POINT(111.1111111 1.1111111)'), 2);
    st_astext
--------------------
 POINT(111.11 1.11)
</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>

			<para><xref linkend="ST_AsBinary" />, <xref linkend="ST_AsEWKB" />, <xref linkend="ST_AsEWKT" />, <xref linkend="ST_GeomFromText" /></para>
		  </refsection>
	</refentry>

    </sect2>
	<!-- ==============================================================================  -->

    <sect2>
      <title>Well-Known Binary (WKB)</title>

		  <refentry id="ST_AsBinary">
		  <refnamediv>
			<refname>ST_AsBinary</refname>
			<refpurpose>Return the OGC/ISO Well-Known Binary (WKB) representation of the geometry/geography without SRID meta data.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsBinary</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsBinary</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>text </type><parameter>NDR_or_XDR</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsBinary</function></funcdef>
				<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsBinary</function></funcdef>
				<paramdef><type>geography </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>text </type><parameter>NDR_or_XDR</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Returns the OGC/ISO <link linkend="OpenGISWKBWKT">Well-Known Binary</link> (WKB) representation of the geometry.
            The first function variant defaults to encoding using server machine endian.
            The second function variant takes a text argument
			specifying the endian encoding, either little-endian ('NDR') or big-endian ('XDR').</para>

			<para>WKB format is useful to read geometry data from the
			database and maintaining full numeric precision.
            This avoids the precision rounding that can happen with text formats such as WKT.</para>

			<para>To perform the inverse conversion of WKB to PostGIS geometry use <xref linkend="ST_GeomFromWKB" />.</para>

			<note>
			  <para>The OGC/ISO WKB format does not include the SRID.  To get the EWKB format which does include the SRID use <xref linkend="ST_AsEWKB" /></para>
			</note>

			<note>
			  <para>The default behavior in PostgreSQL 9.0 has been changed to output bytea in hex encoding.
                If your GUI tools require the old behavior, then SET bytea_output='escape' in your database.</para>
			</note>

			<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>
			<para>Enhanced: 2.0.0 support for higher coordinate dimensions was introduced.</para>
			<para>Enhanced: 2.0.0 support for specifying endian with geography was introduced.</para>
			<para>Availability: 1.5.0 geography support was introduced.</para>
			<para>Changed: 2.0.0 Inputs to this function can not be unknown -- must be geometry.  Constructs such as <code>ST_AsBinary('POINT(1 2)')</code> are no longer valid and you will get an <code>n st_asbinary(unknown)  is not unique error</code>.  Code like that
			needs to be changed to <code>ST_AsBinary('POINT(1 2)'::geometry);</code>.  If that is not possible, then install <filename>legacy.sql</filename>.</para>
			<para>&sfs_compliant; s2.1.1.1</para>
			<para>&sqlmm_compliant; SQL-MM 3: 5.1.37</para>
			<para>&curve_support;</para>
			<para>&P_support;</para>
			<para>&T_support;</para>
			<para>&Z_support;</para>
		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsBinary(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));

		   st_asbinary
--------------------------------
\x01030000000100000005000000000000000000000000000000000000000000000000000000000000
000000f03f000000000000f03f000000000000f03f000000000000f03f0000000000000000000000
00000000000000000000000000
</programlisting>
			<programlisting>SELECT ST_AsBinary(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326), 'XDR');
		   st_asbinary
--------------------------------
\x000000000300000001000000050000000000000000000000000000000000000000000000003ff000
00000000003ff00000000000003ff00000000000003ff00000000000000000000000000000000000
00000000000000000000000000
</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>
			<para>
<xref linkend="ST_GeomFromWKB" />,
<xref linkend="ST_AsEWKB" />,
<xref linkend="ST_AsTWKB" />,
<xref linkend="ST_AsText" />,
			</para>
		  </refsection>
	</refentry>

	<refentry id="ST_AsEWKB">
		  <refnamediv>
			<refname>ST_AsEWKB</refname>
			<refpurpose>Return the Extended Well-Known Binary (EWKB) representation of the geometry with SRID meta data.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsEWKB</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsEWKB</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>text </type><parameter>NDR_or_XDR</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>
			<para>Returns the <link linkend="EWKB_EWKT">Extended Well-Known Binary</link> (EWKB) representation of the geometry with SRID metadata.
            The first function variant defaults to encoding using server machine endian.
            The second function variant takes a text argument
			specifying the endian encoding, either little-endian ('NDR') or big-endian ('XDR').</para>

			<para>WKB format is useful to read geometry data from the
			database and maintaining full numeric precision.
            This avoids the precision rounding that can happen with text formats such as WKT.</para>

			<para>To perform the inverse conversion of EWKB to PostGIS geometry use <xref linkend="ST_GeomFromEWKB" />.</para>

			<note>
			  <para>To get the OGC/ISO WKB format use <xref linkend="ST_AsBinary" />.
              Note that OGC/ISO WKB format does not include the SRID.  </para>
			</note>

			<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>
			<para>&Z_support;</para>
			<para>&curve_support;</para>
			<para>&P_support;</para>
			<para>&T_support;</para>
		  </refsection>


		  <refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsEWKB(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));

		   st_asewkb
--------------------------------
\x0103000020e610000001000000050000000000000000000000000000000000000000000000000000
00000000000000f03f000000000000f03f000000000000f03f000000000000f03f00000000000000
0000000000000000000000000000000000
</programlisting>
		<programlisting>
			SELECT ST_AsEWKB(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326), 'XDR');
		   st_asewkb
--------------------------------
\x0020000003000010e600000001000000050000000000000000000000000000000000000000000000
003ff00000000000003ff00000000000003ff00000000000003ff000000000000000000000000000
0000000000000000000000000000000000
		</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsBinary" />, <xref linkend="ST_GeomFromEWKB" />, <xref linkend="ST_SRID" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_AsHEXEWKB">
	  <refnamediv>
		<refname>ST_AsHEXEWKB</refname>

		<refpurpose>Returns a Geometry in HEXEWKB format (as text) using either
			little-endian (NDR) or big-endian (XDR) encoding.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>text <function>ST_AsHEXEWKB</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>text </type> <parameter>NDRorXDR</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>text <function>ST_AsHEXEWKB</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a Geometry in HEXEWKB format (as text) using either
			little-endian (NDR) or big-endian (XDR) encoding.  If no encoding is specified, then NDR is used.</para>

		<note>
		  <para>Availability: 1.2.2</para>
		</note>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>SELECT ST_AsHEXEWKB(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));
		which gives same answer as

		SELECT ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326)::text;

		st_ashexewkb
		--------
		0103000020E6100000010000000500
		00000000000000000000000000000000
		00000000000000000000000000000000F03F
		000000000000F03F000000000000F03F000000000000F03
		F000000000000000000000000000000000000000000000000</programlisting>
	  </refsection>
	</refentry>


    </sect2>

	<!-- ==============================================================================  -->

    <sect2>
      <title>Other Formats</title>

	<refentry id="ST_AsEncodedPolyline">
		<refnamediv>
		<refname>ST_AsEncodedPolyline</refname>
		<refpurpose>Returns an Encoded Polyline from a LineString geometry.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
		  <funcdef>text <function>ST_AsEncodedPolyline</function></funcdef>
		  <paramdef><type>geometry</type> <parameter>geom</parameter></paramdef>
		  <paramdef choice="opt"><type>integer </type> <parameter>precision=5</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
		<title>Description</title>

		<para>Returns the geometry as an Encoded Polyline. This format is used by Google Maps with precision=5 and by Open Source Routing Machine with precision=5 and 6.</para>
		<para>Optional <varname>precision</varname> specifies how many decimal places will be preserved in Encoded Polyline. Value should be the same on encoding and decoding, or coordinates will be incorrect.</para>

		<para>Availability: 2.2.0</para>
		</refsection>

		<refsection>
		<title>Examples</title>
	<para>Basic </para>
	<programlisting>
	SELECT ST_AsEncodedPolyline(GeomFromEWKT('SRID=4326;LINESTRING(-120.2 38.5,-120.95 40.7,-126.453 43.252)'));
	--result--
	|_p~iF~ps|U_ulLnnqC_mqNvxq`@
	</programlisting>

	<para>Use in conjunction with geography linestring and geography segmentize, and put on google maps</para>
	<programlisting>-- the SQL for Boston to San Francisco, segments every 100 KM
	SELECT ST_AsEncodedPolyline(
		ST_Segmentize(
			ST_GeogFromText('LINESTRING(-71.0519 42.4935,-122.4483 37.64)'),
				100000)::geometry) As encodedFlightPath;</programlisting>


	<para>javascript will look something like this where $ variable you replace with query result</para>
	<programlisting><![CDATA[<script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?libraries=geometry"></script>
<script type="text/javascript">
	 flightPath = new google.maps.Polyline({
			path:  google.maps.geometry.encoding.decodePath("$encodedFlightPath"),
			map: map,
			strokeColor: '#0000CC',
			strokeOpacity: 1.0,
			strokeWeight: 4
		});
</script>
	]]></programlisting>
	</refsection>
		<!-- Optionally add a "See Also" section -->
		<refsection>
		<title>See Also</title>
		<para><xref linkend="ST_LineFromEncodedPolyline" />, <xref linkend="ST_Segmentize" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_AsFlatGeobuf">
	  <refnamediv>
		<refname>ST_AsFlatGeobuf</refname>

		<refpurpose>Return a FlatGeobuf representation of a set of rows.</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
		<funcsynopsis>
		<funcprototype>
				<funcdef>bytea <function>ST_AsFlatGeobuf</function></funcdef>
				<paramdef><type>anyelement set </type> <parameter>row</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>bytea <function>ST_AsFlatGeobuf</function></funcdef>
				<paramdef><type>anyelement </type> <parameter>row</parameter></paramdef>
				<paramdef><type>bool </type> <parameter>index</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>bytea <function>ST_AsFlatGeobuf</function></funcdef>
				<paramdef><type>anyelement </type> <parameter>row</parameter></paramdef>
				<paramdef><type>bool </type> <parameter>index</parameter></paramdef>
				<paramdef><type>text </type> <parameter>geom_name</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
			Return a FlatGeobuf representation (<ulink url="http://flatgeobuf.org">http://flatgeobuf.org</ulink>)
			of a set of rows corresponding to a FeatureCollection.

			NOTE: PostgreSQL bytea cannot exceed 1GB.
		</para>

		<para><varname>row</varname> row data with at least a geometry column.</para>
		<para><varname>index</varname> toggle spatial index creation. Default is false.</para>
		<para><varname>geom_name</varname> is the name of the geometry column in the row data. If NULL it will default to the first found geometry column.</para>

		<para>Availability: 3.2.0</para>
	  </refsection>
	</refentry>

	<refentry id="ST_AsGeobuf">
	  <refnamediv>
		<refname>ST_AsGeobuf</refname>

		<refpurpose>Return a Geobuf representation of a set of rows.</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
		<funcsynopsis>
		<funcprototype>
				<funcdef>bytea <function>ST_AsGeobuf</function></funcdef>
				<paramdef><type>anyelement set </type> <parameter>row</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>bytea <function>ST_AsGeobuf</function></funcdef>
				<paramdef><type>anyelement </type> <parameter>row</parameter></paramdef>
				<paramdef><type>text </type> <parameter>geom_name</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
			Return a Geobuf representation (<ulink url="https://github.com/mapbox/geobuf">https://github.com/mapbox/geobuf</ulink>) of a set of rows corresponding to a FeatureCollection.
			Every input geometry is analyzed to determine maximum precision for optimal storage.
			Note that Geobuf in its current form cannot be streamed so the full output will be assembled in memory.
		</para>

		<para><varname>row</varname> row data with at least a geometry column.</para>
		<para><varname>geom_name</varname> is the name of the geometry column in the row data. If NULL it will default to the first found geometry column.</para>

		<para>Availability: 2.4.0</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting><![CDATA[SELECT encode(ST_AsGeobuf(q, 'geom'), 'base64')
    FROM (SELECT ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))') AS geom) AS q;
 st_asgeobuf
----------------------------------
 GAAiEAoOCgwIBBoIAAAAAgIAAAE=

		]]>
		</programlisting>
	  </refsection>
	</refentry>


	<refentry id="ST_AsGeoJSON">
	  <refnamediv>
		<refname>ST_AsGeoJSON</refname>

		<refpurpose>Return a geometry as a GeoJSON element.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>text <function>ST_AsGeoJSON</function></funcdef>
				<paramdef><type>record </type> <parameter>feature</parameter></paramdef>
				<paramdef choice="opt"><type>text </type> <parameter>geomcolumnname</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=9</parameter></paramdef>
				<paramdef choice="opt"><type>boolean </type> <parameter>pretty_bool=false</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGeoJSON</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=9</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>options=8</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGeoJSON</function></funcdef>
				<paramdef><type>geography </type> <parameter>geog</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=9</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>options=0</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		  <para>Returns a geometry as a GeoJSON "geometry", or a row as a GeoJSON "feature".
          (See the <ulink url="https://tools.ietf.org/html/rfc7946">GeoJSON specifications RFC 7946</ulink>).
 2D and 3D Geometries are both supported.
 GeoJSON only support SFS 1.1 geometry types (no curve support for example).</para>

			<para>The <varname>maxdecimaldigits</varname> argument may be used to reduce the maximum number of decimal places used in output (defaults to 9). If you are using EPSG:4326 and are outputting the geometry only for display, <varname>maxdecimaldigits</varname>=6 can be a good choice for many maps.</para>

      <warning>
			<para>Using the <parameter>maxdecimaldigits</parameter> parameter
            can cause output geometry to become invalid.
            To avoid this use <xref linkend="ST_ReducePrecision" />
            with a suitable gridsize first.
            </para>
      </warning>

			<para>The <varname>options</varname> argument can be used to add BBOX or CRS in GeoJSON output:
			  <itemizedlist>
				<listitem>
				  <para>0: means no option</para>
				</listitem>

				<listitem>
				  <para>1: GeoJSON BBOX</para>
				</listitem>

				<listitem>
				  <para>2: GeoJSON Short CRS (e.g EPSG:4326)</para>
				</listitem>

				<listitem>
				  <para>4: GeoJSON Long CRS (e.g urn:ogc:def:crs:EPSG::4326)</para>
				</listitem>

				<listitem>
				  <para>8: GeoJSON Short CRS if not EPSG:4326 (default)</para>
				</listitem>
			  </itemizedlist>
			</para>

            <para>The GeoJSON specification states that polygons are oriented using the Right-Hand Rule,
            and some clients require this orientation.
            This can be ensured by using <xref linkend="ST_ForcePolygonCCW"/>.
            The specification also requires that geometry be in the WGS84 coordinate system
            (SRID = 4326).
            If necessary geometry can be projected into WGS84 using <xref linkend="ST_Transform"/>:
            <code>ST_Transform( geom, 4326 )</code>.
            </para>

            <para>GeoJSON can be tested and viewed online at <ulink url="http://geojson.io/">geojson.io</ulink>
            and <ulink url="http://geojson.io/">geojsonlint.com</ulink>.
            It is widely supported by web mapping frameworks:
                <itemizedlist>
                <listitem><para><ulink url="https://openlayers.org/en/latest/examples/geojson.html">OpenLayers GeoJSON Example</ulink></para></listitem>
                <listitem><para><ulink url="https://leafletjs.com/examples/geojson/">Leaflet GeoJSON Example</ulink></para></listitem>
                <listitem><para><ulink url="https://www.mapbox.com/mapbox-gl-js/example/multiple-geometries/">Mapbox GL GeoJSON Example</ulink></para></listitem>
                </itemizedlist>
            </para>

			<para>Availability: 1.3.4</para>
			<para>Availability: 1.5.0 geography support was introduced.</para>
			<para>Changed: 2.0.0 support default args and named args.</para>
			<para>Changed: 3.0.0 support records as input</para>
			<para>Changed: 3.0.0 output SRID if not EPSG:4326.</para>
			<para>&Z_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>

<para>Generate a FeatureCollection:</para>
<programlisting>SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(ST_AsGeoJSON(t.*)::json)
    )
FROM ( VALUES (1, 'one', 'POINT(1 1)'::geometry),
              (2, 'two', 'POINT(2 2)'),
              (3, 'three', 'POINT(3 3)')
     ) as t(id, name, geom);</programlisting>
<screen>{"type" : "FeatureCollection", "features" : [{"type": "Feature", "geometry": {"type":"Point","coordinates":[1,1]}, "properties": {"id": 1, "name": "one"}}, {"type": "Feature", "geometry": {"type":"Point","coordinates":[2,2]}, "properties": {"id": 2, "name": "two"}}, {"type": "Feature", "geometry": {"type":"Point","coordinates":[3,3]}, "properties": {"id": 3, "name": "three"}}]}</screen>

<para>Generate a Feature:</para>
		<programlisting>SELECT ST_AsGeoJSON(t.*)
FROM (VALUES (1, 'one', 'POINT(1 1)'::geometry)) AS t(id, name, geom);</programlisting>
<screen>                                                  st_asgeojson
-----------------------------------------------------------------------------------------------------------------
 {"type": "Feature", "geometry": {"type":"Point","coordinates":[1,1]}, "properties": {"id": 1, "name": "one"}}
</screen>

<para>An alternate way to generate Features with an <varname>id</varname> property
is to use JSONB functions and operators:</para>
		<programlisting>SELECT jsonb_build_object(
    'type',       'Feature',
    'id',         id,
    'geometry',   ST_AsGeoJSON(geom)::jsonb,
    'properties', to_jsonb( t.* ) - 'id' - 'geom'
    ) AS json
FROM (VALUES (1, 'one', 'POINT(1 1)'::geometry)) AS t(id, name, geom);</programlisting>
<screen>                                                  json
-----------------------------------------------------------------------------------------------------------------
 {"id": 1, "type": "Feature", "geometry": {"type": "Point", "coordinates": [1, 1]}, "properties": {"name": "one"}}
</screen>

<para>Don't forget to transform your data to WGS84 longitude, latitude to conform with the GeoJSON specification:</para>
		<programlisting>SELECT ST_AsGeoJSON(ST_Transform(geom,4326)) from fe_edges limit 1;</programlisting>
<screen>					   st_asgeojson
-----------------------------------------------------------------------------------------------------------

{"type":"MultiLineString","coordinates":[[[-89.734634999999997,31.492072000000000],
[-89.734955999999997,31.492237999999997]]]}
</screen>
<para>3D geometries are supported:</para>
<programlisting>SELECT ST_AsGeoJSON('LINESTRING(1 2 3, 4 5 6)');</programlisting>
<screen>{"type":"LineString","coordinates":[[1,2,3],[4,5,6]]}</screen>
	  </refsection>
  <refsection>
    <title>See Also</title>

    <para><xref linkend="ST_GeomFromGeoJSON" />, <xref linkend="ST_ForcePolygonCCW" />, <xref linkend="ST_Transform" /> </para>
  </refsection>

	</refentry>


	<refentry id="ST_AsGML">
	  <refnamediv>
		<refname>ST_AsGML</refname>
		<refpurpose>Return the geometry as a GML version 2 or 3 element.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>text <function>ST_AsGML</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>options=0</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsGML</function></funcdef>
				<paramdef><type>geography </type> <parameter>geog</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>options=0</parameter></paramdef>
				<paramdef choice="opt"><type>text </type> <parameter>nprefix=null</parameter></paramdef>
				<paramdef choice="opt"><type>text </type> <parameter>id=null</parameter></paramdef>
			</funcprototype>


			<funcprototype>
				<funcdef>text <function>ST_AsGML</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>options=0</parameter></paramdef>
				<paramdef choice="opt"><type>text </type> <parameter>nprefix=null</parameter></paramdef>
				<paramdef choice="opt"><type>text </type> <parameter>id=null</parameter></paramdef>
			</funcprototype>

			<funcprototype>
				<funcdef>text <function>ST_AsGML</function></funcdef>
				<paramdef><type>integer </type> <parameter>version</parameter></paramdef>
				<paramdef><type>geography </type> <parameter>geog</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>options=0</parameter></paramdef>
				<paramdef choice="opt"><type>text </type> <parameter>nprefix=null</parameter></paramdef>
				<paramdef choice="opt"><type>text </type> <parameter>id=null</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the geometry as a Geography Markup Language (GML) element. The version parameter,
			if specified, may be either 2 or 3. If no version parameter is
			specified then the default is assumed to be 2. The <varname>maxdecimaldigits</varname> argument
			may be used to reduce the maximum number of decimal places
			used in output (defaults to 15).</para>

      <warning>
			<para>Using the <parameter>maxdecimaldigits</parameter> parameter
            can cause output geometry to become invalid.
            To avoid this use <xref linkend="ST_ReducePrecision" />
            with a suitable gridsize first.
            </para>
      </warning>

		<para>GML 2 refer to 2.1.2 version, GML 3 to 3.1.1 version</para>
		<para>The 'options' argument is a bitfield. It could be used to define CRS output type
					in GML output, and to declare data as lat/lon:
						  <itemizedlist>
								<listitem>
								  <para>0: GML Short CRS (e.g EPSG:4326), default value</para>
								</listitem>

								<listitem>
								  <para>1: GML Long CRS (e.g urn:ogc:def:crs:EPSG::4326)</para>
								</listitem>

								<listitem>
								  <para>2: For GML 3 only, remove srsDimension attribute from output.</para>
								</listitem>

								<listitem>
								  <para>4: For GML 3 only, use &lt;LineString&gt; rather than &lt;Curve&gt; tag for lines.</para>
								</listitem>

								<listitem>
								  <para>16: Declare that datas are lat/lon (e.g srid=4326). Default is to assume that data are planars.
								  This option is useful for GML 3.1.1 output only, related to axis order. So if you set it, it will swap the coordinates
								  so order is lat lon instead of database lon lat.</para>
								</listitem>

								<listitem>
								  <para>32: Output the box of the geometry (envelope).</para>
								</listitem>
						  </itemizedlist>
						</para>

		<para>The 'namespace prefix' argument may be used to specify a custom
namespace prefix or no prefix (if empty). If null or omitted 'gml' prefix is used</para>


		  <para>Availability: 1.3.2</para>
		  <para>Availability: 1.5.0 geography support was introduced.</para>
		  <para>Enhanced: 2.0.0 prefix support was introduced. Option 4 for GML3 was introduced to allow using LineString instead of Curve tag for lines. GML3 Support for Polyhedral surfaces and TINS was introduced. Option 32 was introduced to output the box.</para>
		  <para>Changed: 2.0.0 use default named args</para>
		  <para>Enhanced: 2.1.0 id support was introduced, for GML 3.</para>

		<note><para>Only version 3+ of ST_AsGML supports Polyhedral Surfaces and TINS.</para></note>
        <para>&sqlmm_compliant; SQL-MM IEC 13249-3: 17.2</para>
		<para>&Z_support;</para>
		<para>&P_support;</para>
		<para>&T_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples: Version 2</title>
		<programlisting><![CDATA[SELECT ST_AsGML(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));
		st_asgml
		--------
		<gml:Polygon srsName="EPSG:4326"><gml:outerBoundaryIs><gml:LinearRing><gml:coordinates>0,0 0,1 1,1 1,0 0,0</gml:coordinates></gml:LinearRing></gml:outerBoundaryIs></gml:Polygon>]]>
			</programlisting>
	  </refsection>
		<refsection>
		<title>Examples: Version 3</title>
		<programlisting>-- Flip coordinates and output extended EPSG (16 | 1)--
<![CDATA[SELECT ST_AsGML(3, ST_GeomFromText('POINT(5.234234233242 6.34534534534)',4326), 5, 17);
			st_asgml
			--------
		<gml:Point srsName="urn:ogc:def:crs:EPSG::4326"><gml:pos>6.34535 5.23423</gml:pos></gml:Point>]]>
			</programlisting>
		<programlisting>-- Output the envelope (32) --
<![CDATA[SELECT ST_AsGML(3, ST_GeomFromText('LINESTRING(1 2, 3 4, 10 20)',4326), 5, 32);
		st_asgml
		--------
	<gml:Envelope srsName="EPSG:4326">
		<gml:lowerCorner>1 2</gml:lowerCorner>
		<gml:upperCorner>10 20</gml:upperCorner>
	</gml:Envelope>]]>
			</programlisting>

		<programlisting>-- Output the envelope (32) , reverse (lat lon instead of lon lat) (16), long srs (1)= 32 | 16 | 1 = 49 --
<![CDATA[SELECT ST_AsGML(3, ST_GeomFromText('LINESTRING(1 2, 3 4, 10 20)',4326), 5, 49);
	st_asgml
	--------
<gml:Envelope srsName="urn:ogc:def:crs:EPSG::4326">
	<gml:lowerCorner>2 1</gml:lowerCorner>
	<gml:upperCorner>20 10</gml:upperCorner>
</gml:Envelope>]]>
			</programlisting>

		<programlisting>-- Polyhedral Example --
SELECT ST_AsGML(3, ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),
((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),
((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),
((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )'));
	st_asgml
	--------
<![CDATA[ <gml:PolyhedralSurface>
<gml:polygonPatches>
   <gml:PolygonPatch>
		<gml:exterior>
			  <gml:LinearRing>
				   <gml:posList srsDimension="3">0 0 0 0 0 1 0 1 1 0 1 0 0 0 0</gml:posList>
			  </gml:LinearRing>
		</gml:exterior>
   </gml:PolygonPatch>
   <gml:PolygonPatch>
		<gml:exterior>
			  <gml:LinearRing>
				   <gml:posList srsDimension="3">0 0 0 0 1 0 1 1 0 1 0 0 0 0 0</gml:posList>
			  </gml:LinearRing>
		</gml:exterior>
   </gml:PolygonPatch>
   <gml:PolygonPatch>
		<gml:exterior>
			  <gml:LinearRing>
				   <gml:posList srsDimension="3">0 0 0 1 0 0 1 0 1 0 0 1 0 0 0</gml:posList>
			  </gml:LinearRing>
		</gml:exterior>
   </gml:PolygonPatch>
   <gml:PolygonPatch>
		<gml:exterior>
			  <gml:LinearRing>
				   <gml:posList srsDimension="3">1 1 0 1 1 1 1 0 1 1 0 0 1 1 0</gml:posList>
			  </gml:LinearRing>
		</gml:exterior>
   </gml:PolygonPatch>
   <gml:PolygonPatch>
		<gml:exterior>
			  <gml:LinearRing>
				   <gml:posList srsDimension="3">0 1 0 0 1 1 1 1 1 1 1 0 0 1 0</gml:posList>
			  </gml:LinearRing>
		</gml:exterior>
   </gml:PolygonPatch>
   <gml:PolygonPatch>
		<gml:exterior>
			  <gml:LinearRing>
				   <gml:posList srsDimension="3">0 0 1 1 0 1 1 1 1 0 1 1 0 0 1</gml:posList>
			  </gml:LinearRing>
		</gml:exterior>
   </gml:PolygonPatch>
</gml:polygonPatches>
</gml:PolyhedralSurface>]]>
			</programlisting>

	  </refsection>
  <refsection>
    <title>See Also</title>

    <para><xref linkend="ST_GeomFromGML" /></para>
  </refsection>
	</refentry>


	<refentry id="ST_AsKML">
	  <refnamediv>
		<refname>ST_AsKML</refname>

		<refpurpose>Return the geometry as a KML element.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>

			<funcprototype>
				<funcdef>text <function>ST_AsKML</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
				<paramdef choice="opt"><type>text </type> <parameter>nprefix=NULL</parameter></paramdef>
			</funcprototype>

			<funcprototype>
				<funcdef>text <function>ST_AsKML</function></funcdef>
				<paramdef><type>geography </type> <parameter>geog</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
				<paramdef choice="opt"><type>text </type> <parameter>nprefix=NULL</parameter></paramdef>
			</funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the geometry as a Keyhole Markup Language (KML) element.
			default maximum number of decimal places is 15,
			default namespace is no prefix.</para>

      <warning>
			<para>Using the <parameter>maxdecimaldigits</parameter> parameter
            can cause output geometry to become invalid.
            To avoid this use <xref linkend="ST_ReducePrecision" />
            with a suitable gridsize first.
            </para>
      </warning>

		<note>
		  <para>Requires PostGIS be compiled with Proj support.  Use <xref linkend="PostGIS_Full_Version" /> to confirm you have proj support compiled in.</para>
		</note>

		<note>
		  <para>Availability: 1.2.2 - later variants that include version param came in 1.3.2</para>
		</note>
		<note>
		  <para>Enhanced: 2.0.0 - Add prefix namespace, use default and named args</para>
		</note>
		<note>
		  <para>Changed: 3.0.0 - Removed the "versioned" variant signature</para>
		</note>

		<note>
			<para>AsKML output will not work with geometries that do not have an SRID</para>
		</note>

		<para>&Z_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting><![CDATA[SELECT ST_AsKML(ST_GeomFromText('POLYGON((0 0,0 1,1 1,1 0,0 0))',4326));

		st_askml
		--------
		<Polygon><outerBoundaryIs><LinearRing><coordinates>0,0 0,1 1,1 1,0 0,0</coordinates></LinearRing></outerBoundaryIs></Polygon>

		--3d linestring
		SELECT ST_AsKML('SRID=4326;LINESTRING(1 2 3, 4 5 6)');
		<LineString><coordinates>1,2,3 4,5,6</coordinates></LineString>
		]]>
		</programlisting>
	  </refsection>
	 <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsSVG" />, <xref linkend="ST_AsGML" /></para>
	  </refsection>
	</refentry>

		<refentry id="ST_AsLatLonText">
		  <refnamediv>
			<refname>ST_AsLatLonText</refname>
			<refpurpose>Return the Degrees, Minutes, Seconds representation of the given point.</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>text <function>ST_AsLatLonText</function></funcdef>
				<paramdef><type>geometry </type> <parameter>pt</parameter></paramdef>
				<paramdef><type>text </type> <parameter>format=''</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Returns the Degrees, Minutes, Seconds representation of the point.</para>

			<note>
			  <para>It is assumed the point is in a lat/lon projection.  The X (lon) and Y (lat) coordinates are normalized in the output
				to the "normal" range (-180 to +180 for lon, -90 to +90 for lat).</para>
			</note>
				<para>
					The text parameter is a format string containing the format for the resulting text, similar to a date format string.  Valid tokens
					are "D" for degrees, "M" for minutes, "S" for seconds, and "C" for cardinal direction (NSEW).  DMS tokens may be repeated to indicate
					desired width and precision ("SSS.SSSS" means "  1.0023").
				</para>
				<para>
					"M", "S", and "C" are optional.  If "C" is omitted, degrees are
					shown with a "-" sign if south or west.  If "S" is omitted, minutes will be shown as decimal with as many digits of precision
					as you specify.  If "M" is also omitted, degrees are shown as decimal with as many digits precision as you specify.
				</para>
				<para>
					If the format string is omitted (or zero-length) a default format will be used.
				</para>
				<para>
			</para>

			<para>Availability: 2.0</para>
		  </refsection>


		  <refsection>
			<title>Examples</title>
<para>Default format.</para>
<programlisting>
SELECT (ST_AsLatLonText('POINT (-3.2342342 -2.32498)'));
      st_aslatlontext
----------------------------
 2°19'29.928"S 3°14'3.243"W
</programlisting>
<para>Providing a format (same as the default).</para>
<programlisting>
SELECT (ST_AsLatLonText('POINT (-3.2342342 -2.32498)', 'D°M''S.SSS"C'));
      st_aslatlontext
----------------------------
 2°19'29.928"S 3°14'3.243"W
</programlisting>
<para>Characters other than D, M, S, C and . are just passed through.</para>
<programlisting>
SELECT (ST_AsLatLonText('POINT (-3.2342342 -2.32498)', 'D degrees, M minutes, S seconds to the C'));
                                   st_aslatlontext
--------------------------------------------------------------------------------------
 2 degrees, 19 minutes, 30 seconds to the S 3 degrees, 14 minutes, 3 seconds to the W
</programlisting>
<para>Signed degrees instead of cardinal directions.</para>
<programlisting>
SELECT (ST_AsLatLonText('POINT (-3.2342342 -2.32498)', 'D°M''S.SSS"'));
      st_aslatlontext
----------------------------
 -2°19'29.928" -3°14'3.243"
</programlisting>
<para>Decimal degrees.</para>
<programlisting>
SELECT (ST_AsLatLonText('POINT (-3.2342342 -2.32498)', 'D.DDDD degrees C'));
          st_aslatlontext
-----------------------------------
 2.3250 degrees S 3.2342 degrees W
</programlisting>
<para>Excessively large values are normalized.</para>
<programlisting>
SELECT (ST_AsLatLonText('POINT (-302.2342342 -792.32498)'));
        st_aslatlontext
-------------------------------
 72°19'29.928"S 57°45'56.757"E
</programlisting>
		  </refsection>

		  <!-- Optionally add a "See Also" section -->
	</refentry>

    <refentry id="ST_AsMARC21">
        <refnamediv>
            <refname>ST_AsMARC21</refname>
            <refpurpose>Returns geometry as a MARC21/XML record with a geographic datafield (034).</refpurpose>
        </refnamediv>

        <refsynopsisdiv>
            <funcsynopsis>

                <funcprototype>
                    <funcdef>
                        text
                        <function>ST_AsMARC21</function>
                    </funcdef>
                    <paramdef>
                        <type>geometry </type>
                        <parameter>geom</parameter>
                    </paramdef>
                    <paramdef choice="opt">
                        <type>text </type>
                        <parameter>format='hdddmmss'</parameter>
                    </paramdef>
                </funcprototype>

            </funcsynopsis>
        </refsynopsisdiv>

        <refsection>
            <title>Description</title>

            <para>This function returns a MARC21/XML record with <ulink url="https://www.loc.gov/marc/bibliographic/bd034.html">Coded Cartographic Mathematical Data</ulink> representing the bounding box of a given geometry.
            The <varname>format</varname> parameter allows to encode the coordinates in subfields <varname>$d</varname>,<varname>$e</varname>,<varname>$f</varname> and <varname>$g</varname> in all formats supported by the MARC21/XML standard. Valid formats are:</para>

            <itemizedlist>
            <listitem><para>cardinal direction, degrees, minutes and seconds (default): <varname>hdddmmss</varname></para></listitem>
            <listitem><para>decimal degrees with cardinal direction: <varname>hddd.dddddd</varname></para></listitem>
            <listitem><para>decimal degrees without cardinal direction: <varname>ddd.dddddd</varname></para></listitem>
            <listitem><para>decimal minutes with cardinal direction: <varname>hdddmm.mmmm</varname></para></listitem>
            <listitem><para>decimal minutes without cardinal direction: <varname>dddmm.mmmm</varname></para></listitem>
            <listitem><para>decimal seconds with cardinal direction: <varname>hdddmmss.sss</varname></para></listitem>
            </itemizedlist>

        <para>The decimal sign may be also a comma, e.g. <varname>hdddmm,mmmm</varname>.</para>
        <para>The precision of decimal formats can be limited by the number of characters after the decimal sign, e.g. <varname>hdddmm.mm</varname> for decimal minutes with a precision of two decimals.</para>
        <para>This function ignores the Z and M dimensions.</para>

            <para>
                LOC MARC21/XML versions supported:
                <itemizedlist>
                    <listitem>
                        <para><ulink url="https://www.loc.gov/standards/marcxml/">MARC21/XML 1.1</ulink></para>
                    </listitem>
                </itemizedlist>
            </para>

            <para>Availability: 3.3.0 </para>

            <note>
                <para>This function does not support non lon/lat geometries, as they are not supported by the MARC21/XML standard (Coded Cartographic Mathematical Data).</para>
            </note>

            <note>
                <para>
                    The MARC21/XML Standard does not provide any means to annotate the spatial reference system for Coded Cartographic Mathematical Data, which means that this information will be lost after conversion to MARC21/XML.
                </para>
            </note>

        </refsection>

        <refsection>
            <title>Examples</title>

            <para>Converting a <varname>POINT</varname> to MARC21/XML formated as hdddmmss (default)</para>
            <programlisting><![CDATA[

                SELECT ST_AsMARC21('SRID=4326;POINT(-4.504289 54.253312)'::geometry);

                                st_asmarc21
                -------------------------------------------------
                <record xmlns="http://www.loc.gov/MARC21/slim">
                    <datafield tag="034" ind1="1" ind2=" ">
                        <subfield code="a">a</subfield>
                        <subfield code="d">W0043015</subfield>
                        <subfield code="e">W0043015</subfield>
                        <subfield code="f">N0541512</subfield>
                        <subfield code="g">N0541512</subfield>
                    </datafield>
                </record>

            ]]>
            </programlisting>

            <para>Converting a <varname>POLYGON</varname> to MARC21/XML formated in decimal degrees</para>
            <programlisting><![CDATA[

                SELECT ST_AsMARC21('SRID=4326;POLYGON((-4.5792388916015625 54.18172660239091,-4.56756591796875 54.196993557130355,-4.546623229980469 54.18313300502024,-4.5792388916015625 54.18172660239091))'::geometry,'hddd.dddd');

                <record xmlns="http://www.loc.gov/MARC21/slim">
                    <datafield tag="034" ind1="1" ind2=" ">
                        <subfield code="a">a</subfield>
                        <subfield code="d">W004.5792</subfield>
                        <subfield code="e">W004.5466</subfield>
                        <subfield code="f">N054.1970</subfield>
                        <subfield code="g">N054.1817</subfield>
                    </datafield>
                </record>

            ]]>
            </programlisting>

            <para>Converting a <varname>GEOMETRYCOLLECTION</varname> to MARC21/XML formated in decimal minutes. The geometries order in the MARC21/XML output correspond to their order in the collection.</para>
            <programlisting><![CDATA[

                SELECT ST_AsMARC21('SRID=4326;GEOMETRYCOLLECTION(POLYGON((13.1 52.65,13.516666666666667 52.65,13.516666666666667 52.38333333333333,13.1 52.38333333333333,13.1 52.65)),POINT(-4.5 54.25))'::geometry,'hdddmm.mmmm');

                                st_asmarc21
                -------------------------------------------------
                <record xmlns="http://www.loc.gov/MARC21/slim">
                    <datafield tag="034" ind1="1" ind2=" ">
                        <subfield code="a">a</subfield>
                        <subfield code="d">E01307.0000</subfield>
                        <subfield code="e">E01331.0000</subfield>
                        <subfield code="f">N05240.0000</subfield>
                        <subfield code="g">N05224.0000</subfield>
                    </datafield>
                    <datafield tag="034" ind1="1" ind2=" ">
                        <subfield code="a">a</subfield>
                        <subfield code="d">W00430.0000</subfield>
                        <subfield code="e">W00430.0000</subfield>
                        <subfield code="f">N05415.0000</subfield>
                        <subfield code="g">N05415.0000</subfield>
                    </datafield>
                </record>

            ]]>
            </programlisting>

        </refsection>
        <refsection>
            <title>See Also</title>
            <para><xref linkend="ST_GeomFromMARC21" /></para>
        </refsection>
    </refentry>

	<refentry id="ST_AsMVTGeom">
	  <refnamediv>
		<refname>ST_AsMVTGeom</refname>

		<refpurpose>Transforms a geometry into the coordinate space of a MVT tile.</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>geometry <function>ST_AsMVTGeom</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
				<paramdef><type>box2d </type> <parameter>bounds</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>extent=4096</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>buffer=256</parameter></paramdef>
				<paramdef choice="opt"><type>boolean </type> <parameter>clip_geom=true</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Transforms a geometry into the coordinate space of a MVT (<ulink url="https://www.mapbox.com/vector-tiles/">Mapbox Vector Tile</ulink>) tile,
        clipping it to the tile bounds if required.
        The geometry must be in the coordinate system of the target map (using <xref linkend="ST_Transform" /> if needed).
        Commonly this is <ulink url="https://en.wikipedia.org/wiki/Web_Mercator_projection">Web Mercator</ulink> (SRID:3857).
        </para>
		<para>The function attempts to preserve geometry validity, and corrects it if needed.
        This may cause the result geometry to collapse to a lower dimension.
		</para>
        <para>The rectangular bounds of the tile in the target map coordinate space must be provided,
        so the geometry can be transformed, and clipped if required.
        The bounds can be generated using <xref linkend="ST_TileEnvelope" />.
        </para>
        <para>
        This function is used to convert geometry into the tile coordinate space required by <xref linkend="ST_AsMVT" />.
        </para>

		<para><varname>geom</varname> is the geometry to transform, in the coordinate system of the target map.</para>
		<para><varname>bounds</varname> is the rectangular bounds of the tile in map coordinate space, with no buffer.</para>
		<para><varname>extent</varname> is the tile extent size in tile coordinate space as defined by the <ulink url="https://www.mapbox.com/vector-tiles/specification/">MVT specification</ulink>. Defaults to 4096.</para>
		<para><varname>buffer</varname> is the buffer size in tile coordinate space for geometry clippig. Defaults to 256.</para>
		<para><varname>clip_geom</varname> is a boolean to control if geometries are clipped or encoded as-is. Defaults to true.</para>

		<para>Availability: 2.4.0</para>

        <note>
            <para>From 3.0, Wagyu can be chosen at configure time to clip and validate MVT polygons. This library is faster and produces more correct results than the GEOS default, but it might drop small polygons.</para>
        </note>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>
SELECT ST_AsText(ST_AsMVTGeom(
	ST_GeomFromText('POLYGON ((0 0, 10 0, 10 5, 0 -5, 0 0))'),
	ST_MakeBox2D(ST_Point(0, 0), ST_Point(4096, 4096)),
	4096, 0, false));
                              st_astext
--------------------------------------------------------------------
 MULTIPOLYGON(((5 4096,10 4091,10 4096,5 4096)),((5 4096,0 4101,0 4096,5 4096)))
		</programlisting>

    <para>Canonical example for a Web Mercator tile using a computed tile bounds to query and clip geometry.
    </para>
		<programlisting>
<![CDATA[SELECT ST_AsMVTGeom(
            ST_Transform( geom, 3857 ),
            ST_TileEnvelope(12, 513, 412), extent => 4096, buffer => 64) AS geom
  FROM data
  WHERE geom && ST_TileEnvelope(12, 513, 412, margin => (64.0 / 4096))
]]>
</programlisting>

	  </refsection>

    <refsection>
        <title>See Also</title>
            <para>
                <xref linkend="ST_AsMVT" />,
                <xref linkend="ST_TileEnvelope" />,
                <xref linkend="PostGIS_Wagyu_Version" />
            </para>
        </refsection>
	</refentry>

	<refentry id="ST_AsMVT">
	  <refnamediv>
		<refname>ST_AsMVT</refname>

		<refpurpose>Aggregate function returning a MVT representation of a set of rows.</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
		<funcsynopsis>
		<funcprototype>
				<funcdef>bytea <function>ST_AsMVT</function></funcdef>
				<paramdef><type>anyelement set </type> <parameter>row</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>bytea <function>ST_AsMVT</function></funcdef>
				<paramdef><type>anyelement </type> <parameter>row</parameter></paramdef>
				<paramdef><type>text </type> <parameter>name</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>bytea <function>ST_AsMVT</function></funcdef>
				<paramdef><type>anyelement </type> <parameter>row</parameter></paramdef>
				<paramdef><type>text </type> <parameter>name</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>extent</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>bytea <function>ST_AsMVT</function></funcdef>
				<paramdef><type>anyelement </type> <parameter>row</parameter></paramdef>
				<paramdef><type>text </type> <parameter>name</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>extent</parameter></paramdef>
				<paramdef><type>text </type> <parameter>geom_name</parameter></paramdef>
			</funcprototype>
		  <funcprototype>
				<funcdef>bytea <function>ST_AsMVT</function></funcdef>
				<paramdef><type>anyelement </type> <parameter>row</parameter></paramdef>
				<paramdef><type>text </type> <parameter>name</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>extent</parameter></paramdef>
				<paramdef><type>text </type> <parameter>geom_name</parameter></paramdef>
				<paramdef><type>text </type> <parameter>feature_id_name</parameter></paramdef>
      </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>An aggregate function which returns a binary <ulink url="https://www.mapbox.com/vector-tiles/">Mapbox Vector Tile</ulink>
		representation of a set of rows corresponding to a tile layer.
		The rows must contain a geometry column which will be encoded as a feature geometry.
		The geometry must be in tile coordinate space
		and valid as per the <ulink url="https://www.mapbox.com/vector-tiles/specification/">MVT specification</ulink>.
		<xref linkend="ST_AsMVTGeom" /> can be used to transform geometry into tile coordinate space.
		Other row columns are encoded as feature attributes.
		</para>

		<para>The <ulink url="https://www.mapbox.com/vector-tiles/">Mapbox Vector Tile</ulink> format
		can store features with varying	sets of attributes.
		To use this capability supply a JSONB column in the row data containing Json objects one level deep.
		The keys and values in the JSONB values will be encoded as feature attributes.
		</para>

		<para>
		Tiles with multiple layers can be created by concatenating multiple calls to this function
		using <varname>||</varname> or <varname>STRING_AGG</varname>.
		</para>

		<important>
			<para>Do not call with a <varname>GEOMETRYCOLLECTION</varname> as an element in the row.
			However you can use <xref linkend="ST_AsMVTGeom" /> to prepare a geometry collection for inclusion.</para>
		</important>

	  <para><varname>row</varname> row data with at least a geometry column.</para>
		<para><varname>name</varname> is the name of the layer. Default is the string "default".</para>
		<para><varname>extent</varname> is the tile extent in screen space as defined by the specification. Default is 4096.</para>
		<para><varname>geom_name</varname> is the name of the geometry column in the row data. Default is the first geometry column. Note that PostgreSQL by default automatically <ulink url="https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS">folds unquoted identifiers to lower case</ulink>, which means that unless the geometry column is quoted, e.g. <varname>"MyMVTGeom"</varname>, this parameter must be provided as lowercase.</para>
		<para><varname>feature_id_name</varname> is the name of the Feature ID column in the row data. If NULL or negative the Feature ID is not set. The first column matching name and valid type (smallint, integer, bigint) will be used as Feature ID, and any subsequent column will be added as a property. JSON properties are not supported.</para>


	    <para>Enhanced: 3.0 - added support for Feature ID.</para>
	    <para>Enhanced: 2.5.0 - added support parallel query.</para>
		<para>Availability: 2.4.0</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting><![CDATA[WITH mvtgeom AS
(
  SELECT ST_AsMVTGeom(geom, ST_TileEnvelope(12, 513, 412), extent => 4096, buffer => 64) AS geom, name, description
  FROM points_of_interest
  WHERE geom && ST_TileEnvelope(12, 513, 412, margin => (64.0 / 4096))
)
SELECT ST_AsMVT(mvtgeom.*)
FROM mvtgeom;
]]></programlisting>

	  </refsection>

		<refsection>
			<title>See Also</title>
				<para>
					<xref linkend="ST_AsMVTGeom" />, <xref linkend="ST_TileEnvelope" />
				</para>
		  </refsection>
	</refentry>

	<refentry id="ST_AsSVG">
	  <refnamediv>
		<refname>ST_AsSVG</refname>

		<refpurpose>Returns SVG path data for a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>text <function>ST_AsSVG</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>rel=0</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
			</funcprototype>
			<funcprototype>
				<funcdef>text <function>ST_AsSVG</function></funcdef>
				<paramdef><type>geography </type> <parameter>geog</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>rel=0</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return the geometry as Scalar Vector Graphics (SVG) path data. Use 1 as second
			argument to have the path data implemented in terms of relative
			moves, the default (or 0) uses absolute moves. Third argument may
			be used to reduce the maximum number of decimal digits used in
			output (defaults to 15). Point geometries will be rendered as
			cx/cy when 'rel' arg is 0, x/y when 'rel' is 1. Multipoint
			geometries are delimited by commas (","), GeometryCollection
			geometries are delimited by semicolons (";").</para>

		<note>
		  <para>Availability: 1.2.2. Availability: 1.4.0  Changed in PostGIS 1.4.0 to include L command in absolute path to conform to <ulink
			url="http://www.w3.org/TR/SVG/paths.html#PathDataBNF">http://www.w3.org/TR/SVG/paths.html#PathDataBNF</ulink></para>
		</note>
		<para>Changed: 2.0.0 to use default args and support named args</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>SELECT ST_AsSVG('POLYGON((0 0,0 1,1 1,1 0,0 0))');

		st_assvg
		--------
		M 0 0 L 0 -1 1 -1 1 0 Z</programlisting>
	  </refsection>
	</refentry>
		<refentry id="ST_AsTWKB">
		  <refnamediv>
			<refname>ST_AsTWKB</refname>
			<refpurpose>Returns the geometry as TWKB, aka "Tiny Well-Known Binary"</refpurpose>
		  </refnamediv>

		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsTWKB</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>decimaldigits_xy=0</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>decimaldigits_z=0</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>decimaldigits_m=0</parameter></paramdef>
				<paramdef><type>boolean </type> <parameter>include_sizes=false</parameter></paramdef>
				<paramdef><type>boolean </type> <parameter>include_bounding boxes=false</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>bytea <function>ST_AsTWKB</function></funcdef>
				<paramdef><type>geometry[] </type> <parameter>geometries</parameter></paramdef>
				<paramdef><type>bigint[] </type> <parameter>unique_ids</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>decimaldigits_xy=0</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>decimaldigits_z=0</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>decimaldigits_m=0</parameter></paramdef>
				<paramdef><type>boolean </type> <parameter>include_sizes=false</parameter></paramdef>
				<paramdef><type>boolean </type> <parameter>include_bounding_boxes=false</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		  </refsynopsisdiv>
		  <refsection>
			<title>Description</title>
			<para>Returns the geometry in TWKB (Tiny Well-Known Binary) format. TWKB is a <ulink url="https://github.com/TWKB/Specification/blob/master/twkb.md">compressed binary format</ulink> with a focus on minimizing the size of the output. </para>
			<para>The decimal digits parameters control how much precision is stored in the output. By default, values are rounded to the nearest unit before encoding. If you want to transfer more precision, increase the number. For example, a value of 1 implies that the first digit to the right of the decimal point will be preserved.</para>
			<para>The sizes and bounding boxes parameters control whether optional information about the encoded length of the object and the bounds of the object are included in the output. By default they are not. Do not turn them on unless your client software has a use for them, as they just use up space (and saving space is the point of TWKB).</para>
			<para>The array-input form of the function is used to convert a collection of geometries and unique identifiers into a TWKB collection that preserves the identifiers. This is useful for clients that expect to unpack a collection and then access further information about the objects inside. You can create the arrays using the <ulink url="https://www.postgresql.org/docs/current/functions-aggregate.html">array_agg</ulink> function. The other parameters operate the same as for the simple form of the function.</para>
			<note>
			  <para>The format specification is available online at <ulink url="https://github.com/TWKB/Specification">https://github.com/TWKB/Specification</ulink>, and code for building a JavaScript client can be found at <ulink url="https://github.com/TWKB/twkb.js">https://github.com/TWKB/twkb.js</ulink>.</para>
			</note>

			<para>Enhanced: 2.4.0 memory and speed improvements.</para>
			<para>Availability: 2.2.0</para>
		  </refsection>


		  <refsection>
			<title>Examples</title>
<programlisting>
SELECT ST_AsTWKB('LINESTRING(1 1,5 5)'::geometry);
                 st_astwkb
--------------------------------------------
\x02000202020808

</programlisting>
<para>To create an aggregate TWKB object including identifiers aggregate the desired geometries and objects first, using "array_agg()", then call the appropriate TWKB function.
</para>
<programlisting>
SELECT ST_AsTWKB(array_agg(geom), array_agg(gid)) FROM mytable;
                 st_astwkb
--------------------------------------------
\x040402020400000202
</programlisting>

		  </refsection>

		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_GeomFromTWKB" />, <xref linkend="ST_AsBinary" />, <xref linkend="ST_AsEWKB" />, <xref linkend="ST_AsEWKT" />, <xref linkend="ST_GeomFromText" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_AsX3D">
	  <refnamediv>
		<refname>ST_AsX3D</refname>

		<refpurpose>Returns a Geometry in X3D xml node element format: ISO-IEC-19776-1.2-X3DEncodings-XML</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
	     <funcsynopsis>
	         <funcprototype>
				<funcdef>text <function>ST_AsX3D</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxdecimaldigits=15</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>options=0</parameter></paramdef>
			</funcprototype>
	    </funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a geometry as an X3D xml formatted node element  <ulink url="http://www.web3d.org/standards/number/19776-1">http://www.web3d.org/standards/number/19776-1</ulink>.  If <varname>maxdecimaldigits</varname> (precision) is not specified then defaults to 15. </para>
		<note>
		    <para>There are various options for translating PostGIS geometries to X3D since X3D geometry types don't map directly to PostGIS geometry types and some newer X3D types that might be better mappings we have avoided since most rendering tools don't currently support them.
		        These are the mappings we have settled on.  Feel free to post a bug ticket if you have thoughts on the idea or ways we can allow people to denote their preferred mappings.</para>
		    <para>Below is how we currently map PostGIS 2D/3D types to X3D types</para>
		</note>

        <para>The 'options' argument is a bitfield. For PostGIS 2.2+, this is used to denote whether to represent coordinates with X3D GeoCoordinates Geospatial node and also whether to flip the x/y axis.  By default, <code>ST_AsX3D</code> outputs in database form (long,lat or X,Y), but X3D default of lat/lon, y/x may be preferred.</para>

        <itemizedlist>
            <listitem>
              <para>0: X/Y in database order (e.g. long/lat = X,Y is standard database order), default value, and non-spatial coordinates (just regular old Coordinate tag).</para>
            </listitem>

            <listitem>
              <para>1: Flip X and Y.  If used in conjunction with the GeoCoordinate option switch, then output will be default "latitude_first" and coordinates will be flipped as well.</para>
            </listitem>

            <listitem>
              <para>2: Output coordinates in GeoSpatial GeoCoordinates.  This option will throw an error if geometries are not in WGS 84 long lat (srid: 4326). This is currently the only GeoCoordinate type supported.  <ulink url="http://www.web3d.org/documents/specifications/19775-1/V3.2/Part01/components/geodata.html#Specifyingaspatialreference">Refer to X3D specs specifying a spatial reference system.</ulink>. Default output will be <code>GeoCoordinate geoSystem='"GD" "WE" "longitude_first"'</code>.  If
              you prefer the X3D default of  <code>GeoCoordinate geoSystem='"GD" "WE" "latitude_first"'</code> use <code>(2 + 1)</code> = <code>3</code> </para>
            </listitem>
        </itemizedlist>


		<informaltable>
				<tgroup cols="3">
					<thead>
					  <row>
						<entry>PostGIS Type</entry>
						<entry>2D X3D Type</entry>
						<entry>3D X3D Type</entry>
					  </row>
					</thead>
					<tbody>
					  <row>
						<entry>LINESTRING</entry>
						<entry>not yet implemented - will be PolyLine2D</entry>
						<entry>LineSet</entry>
					  </row>
					  <row>
						<entry>MULTILINESTRING</entry>
						<entry>not yet implemented - will be PolyLine2D</entry>
						<entry>IndexedLineSet</entry>
					  </row>
					  <row>
						<entry>MULTIPOINT</entry>
						<entry>Polypoint2D</entry>
						<entry>PointSet</entry>
					  </row>
					  <row>
						<entry>POINT</entry>
						<entry>outputs the space delimited coordinates</entry>
						<entry>outputs the space delimited coordinates</entry>
					  </row>
					  <row>
						<entry>(MULTI) POLYGON, POLYHEDRALSURFACE</entry>
						<entry>Invalid X3D markup</entry>
						<entry>IndexedFaceSet (inner rings currently output as another faceset)</entry>
					  </row>
					  <row>
						<entry>TIN</entry>
						<entry>TriangleSet2D (Not Yet Implemented)</entry>
						<entry>IndexedTriangleSet</entry>
					  </row>
				</tbody>
			</tgroup>
		</informaltable>
		<note><para>2D geometry support not yet complete.  Inner rings currently just drawn as separate polygons.  We are working on these.</para></note>
		<para>Lots of advancements happening in 3D space particularly with <ulink url="https://www.web3d.org/wiki/index.php/X3D_and_HTML5">X3D Integration with HTML5</ulink></para>
		<para>There is also a nice open source X3D viewer you can use to view rendered geometries. Free Wrl <ulink url="http://freewrl.sourceforge.net/">http://freewrl.sourceforge.net/</ulink> binaries available for Mac, Linux, and Windows. Use the FreeWRL_Launcher packaged to view the geometries.</para>
		<para>Also check out <ulink url="https://git.osgeo.org/gitea/robe/postgis_x3d_viewer">PostGIS minimalist X3D viewer</ulink>  that utilizes this function and <ulink url="http://www.x3dom.org/">x3dDom html/js open source toolkit</ulink>.</para>
		<para>Availability: 2.0.0: ISO-IEC-19776-1.2-X3DEncodings-XML</para>
		<para>Enhanced: 2.2.0: Support for GeoCoordinates and axis (x/y, long/lat) flipping.  Look at options for details.</para>
		<!-- Optionally mention 3d support -->
		<para>&Z_support;</para>
        <!-- Optionally mention supports Polyhedral Surface  -->
        <para>&P_support;</para>

        <!-- Optionally mention support for Triangles and TINS  -->
        <para>&T_support;</para>

	  </refsection>

	  <refsection>
		<title>Example: Create a fully functional X3D document - This will generate a cube that is viewable in FreeWrl and other X3D viewers.</title>
		<programlisting><![CDATA[SELECT '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "http://www.web3d.org/specifications/x3d-3.0.dtd">
<X3D>
  <Scene>
    <Transform>
      <Shape>
       <Appearance>
            <Material emissiveColor=''0 0 1''/>
       </Appearance> ' ||
       ST_AsX3D( ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),
((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),
((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),
((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )')) ||
      '</Shape>
    </Transform>
  </Scene>
</X3D>' As x3ddoc;]]>

		x3ddoc
		--------
<![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "http://www.web3d.org/specifications/x3d-3.0.dtd">
<X3D>
  <Scene>
    <Transform>
      <Shape>
       <Appearance>
            <Material emissiveColor='0 0 1'/>
       </Appearance>
       <IndexedFaceSet  coordIndex='0 1 2 3 -1 4 5 6 7 -1 8 9 10 11 -1 12 13 14 15 -1 16 17 18 19 -1 20 21 22 23'>
            <Coordinate point='0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0 0 0 0 0 1 0 0 1 0 1 0 0 1 1 1 0 1 1 1 1 0 1 1 0 0 0 1 0 0 1 1 1 1 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1' />
      </IndexedFaceSet>
      </Shape>
    </Transform>
  </Scene>
</X3D>]]></programlisting>
	  </refsection>
      <refsection>
         <title>PostGIS buildings</title>
         <para>
            Copy and paste the output of this query to
            <ulink url="http://postgis.net/docs/support/viewers/x3d_viewer.htm">x3d scene viewer</ulink>
            and click Show
         </para>
         <programlisting><![CDATA[SELECT string_agg('<Shape>' || ST_AsX3D(ST_Extrude(geom, 0,0, i*0.5)) ||
    '<Appearance>
          <Material diffuseColor="' || (0.01*i)::text || ' 0.8 0.2" specularColor="' || (0.05*i)::text || ' 0 0.5"/>
        </Appearance>
    </Shape>', '')
FROM ST_Subdivide(ST_Letters('PostGIS'),20) WITH ORDINALITY AS f(geom,i);]]></programlisting>
        <informalfigure>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="images/st_asx3d01.png" />
                </imageobject>
                <caption><para>Buildings formed by subdividing PostGIS and extrusion</para></caption>
            </mediaobject>
        </informalfigure>
      </refsection>
	   <refsection>
		<title>Example: An Octagon elevated 3 Units and decimal precision of 6</title>
		<programlisting>SELECT ST_AsX3D(
ST_Translate(
    ST_Force_3d(
        ST_Buffer(ST_Point(10,10),5, 'quad_segs=2')), 0,0,
    3)
  ,6) As x3dfrag;

x3dfrag
--------
<![CDATA[<IndexedFaceSet coordIndex="0 1 2 3 4 5 6 7">
    <Coordinate point="15 10 3 13.535534 6.464466 3 10 5 3 6.464466 6.464466 3 5 10 3 6.464466 13.535534 3 10 15 3 13.535534 13.535534 3 " />
</IndexedFaceSet>]]></programlisting>
	  </refsection>
	  <refsection>
		<title>Example: TIN</title>
		<programlisting><![CDATA[SELECT ST_AsX3D(ST_GeomFromEWKT('TIN (((
                0 0 0,
                0 0 1,
                0 1 0,
                0 0 0
            )), ((
                0 0 0,
                0 1 0,
                1 1 0,
                0 0 0
            ))
            )')) As x3dfrag;]]>

		x3dfrag
		--------
<![CDATA[<IndexedTriangleSet  index='0 1 2 3 4 5'><Coordinate point='0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1 1 0'/></IndexedTriangleSet>]]></programlisting>
	  </refsection>
	  <refsection>
		<title>Example: Closed multilinestring (the boundary of a polygon with holes)</title>
		<programlisting><![CDATA[SELECT ST_AsX3D(
		    ST_GeomFromEWKT('MULTILINESTRING((20 0 10,16 -12 10,0 -16 10,-12 -12 10,-20 0 10,-12 16 10,0 24 10,16 16 10,20 0 10),
  (12 0 10,8 8 10,0 12 10,-8 8 10,-8 0 10,-8 -4 10,0 -8 10,8 -4 10,12 0 10))')
) As x3dfrag;]]>

		x3dfrag
		--------
<![CDATA[<IndexedLineSet  coordIndex='0 1 2 3 4 5 6 7 0 -1 8 9 10 11 12 13 14 15 8'>
    <Coordinate point='20 0 10 16 -12 10 0 -16 10 -12 -12 10 -20 0 10 -12 16 10 0 24 10 16 16 10 12 0 10 8 8 10 0 12 10 -8 8 10 -8 0 10 -8 -4 10 0 -8 10 8 -4 10 ' />
 </IndexedLineSet>]]></programlisting>
	  </refsection>
	</refentry>

	<refentry id="ST_GeoHash">
	  <refnamediv>
		<refname>ST_GeoHash</refname>

		<refpurpose>Return a GeoHash representation of the geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>text <function>ST_GeoHash</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
				<paramdef choice="opt"><type>integer </type> <parameter>maxchars=full_precision_of_point</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Return a GeoHash representation (<ulink url="http://en.wikipedia.org/wiki/Geohash">http://en.wikipedia.org/wiki/Geohash</ulink>) of the geometry. A GeoHash encodes a point into a text form that is sortable and searchable based on prefixing.  A shorter GeoHash is a less precise representation of a point.  It can also be thought of as a box, that contains the actual point.</para>

		<para>If no <varname>maxchars</varname> is specified ST_GeoHash returns a GeoHash based on full precision of the input geometry type. Points return a GeoHash with 20 characters of precision (about enough to hold the full double precision of the input). Other types return a GeoHash with a variable amount of precision, based on the size of the feature. Larger features are represented with less precision, smaller features with more precision. The idea is that the box implied by the GeoHash will always contain the input feature.</para>

		<para>If <varname>maxchars</varname> is specified ST_GeoHash returns a GeoHash with at most that many characters so a possibly lower precision representation of the input geometry. For non-points, the starting point of the calculation is the center of the bounding box of the geometry.</para>

		<para>Availability: 1.4.0</para>

		<note>
			<para>ST_GeoHash will not work with geometries that are not in geographic (lon/lat) coordinates.</para>
		</note>

		<para>&curve_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting><![CDATA[SELECT ST_GeoHash(ST_SetSRID(ST_Point(-126,48),4326));

	 st_geohash
----------------------
 c0w3hf1s70w3hf1s70w3

SELECT ST_GeoHash(ST_SetSRID(ST_Point(-126,48),4326),5);

 st_geohash
------------
 c0w3h
		]]>
		</programlisting>
	  </refsection>
	 <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_GeomFromGeoHash" /></para>
	  </refsection>
	</refentry>

		</sect2>
  </sect1>
