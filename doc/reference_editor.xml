<?xml version="1.0" encoding="UTF-8"?>
  <sect1 id="Geometry_Editors">
	  <title>Geometry Editors</title>

		<refentry id="ST_AddPoint">
		  <refnamediv>
			<refname>ST_AddPoint</refname>
			<refpurpose>Add a point to a LineString.</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_AddPoint</function></funcdef>
				<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>point</parameter></paramdef>
			  </funcprototype>
			 </funcsynopsis>
			 <funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_AddPoint</function></funcdef>
				<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>point</parameter></paramdef>
				<paramdef><type>integer</type> <parameter>position</parameter></paramdef>
			  </funcprototype>
			 </funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Adds a point to a LineString before point &lt;position&gt;
				(0-based index). Third parameter can be omitted or set to -1 for
				appending.</para>
			<para>Availability: 1.1.0</para>
			<para>&Z_support;</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
			<programlisting>
		--guarantee all linestrings in a table are closed
		--by adding the start point of each linestring to the end of the line string
		--only for those that are not closed
		UPDATE sometable
		SET the_geom = ST_AddPoint(the_geom, ST_StartPoint(the_geom))
		FROM sometable
		WHERE ST_IsClosed(the_geom) = false;

		--Adding point to a 3-d line
		SELECT ST_AsEWKT(ST_AddPoint(ST_GeomFromEWKT('LINESTRING(0 0 1, 1 1 1)'), ST_MakePoint(1, 2, 3)));

		--result
		st_asewkt
		----------
		LINESTRING(0 0 1,1 1 1,1 2 3)
			</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_RemovePoint"/>, <xref linkend="ST_SetPoint" /></para>
		  </refsection>
	</refentry>

	<refentry id="ST_Affine">
	  <refnamediv>
		<refname>ST_Affine</refname>

		<refpurpose>Apply a 3d affine transformation to a geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Affine</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>a</parameter></paramdef>
			<paramdef><type>float </type> <parameter>b</parameter></paramdef>
			<paramdef><type>float </type> <parameter>c</parameter></paramdef>
			<paramdef><type>float </type> <parameter>d</parameter></paramdef>
			<paramdef><type>float </type> <parameter>e</parameter></paramdef>
			<paramdef><type>float </type> <parameter>f</parameter></paramdef>
			<paramdef><type>float </type> <parameter>g</parameter></paramdef>
			<paramdef><type>float </type> <parameter>h</parameter></paramdef>
			<paramdef><type>float </type> <parameter>i</parameter></paramdef>
			<paramdef><type>float </type> <parameter>xoff</parameter></paramdef>
			<paramdef><type>float </type> <parameter>yoff</parameter></paramdef>
			<paramdef><type>float </type> <parameter>zoff</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_Affine</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>a</parameter></paramdef>
			<paramdef><type>float </type> <parameter>b</parameter></paramdef>
			<paramdef><type>float </type> <parameter>d</parameter></paramdef>
			<paramdef><type>float </type> <parameter>e</parameter></paramdef>
			<paramdef><type>float </type> <parameter>xoff</parameter></paramdef>
			<paramdef><type>float </type> <parameter>yoff</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Applies a 3d affine transformation to the geometry to do things like translate, rotate, scale in one step.</para>
		<para>
		Version 1: The
			call <programlisting>ST_Affine(geom, a, b, c, d, e, f, g, h, i, xoff, yoff, zoff) </programlisting>
			represents the transformation matrix <programlisting>/ a  b  c  xoff \
| d  e  f  yoff |
| g  h  i  zoff |
\ 0  0  0     1 /</programlisting> and the vertices are transformed as
			follows: <programlisting>x' = a*x + b*y + c*z + xoff
y' = d*x + e*y + f*z + yoff
z' = g*x + h*y + i*z + zoff</programlisting> All of the translate / scale
			functions below are expressed via such an affine
			transformation.</para>
		<para>Version 2: Applies a 2d affine transformation to the geometry. The
			call <programlisting>ST_Affine(geom, a, b, d, e, xoff, yoff)</programlisting>
			represents the transformation matrix <programlisting>/  a  b  0  xoff  \       /  a  b  xoff  \
|  d  e  0  yoff  | rsp.  |  d  e  yoff  |
|  0  0  1     0  |       \  0  0     1  /
\  0  0  0     1  /</programlisting> and the vertices are transformed as
			follows: <programlisting>x' = a*x + b*y + xoff
y' = d*x + e*y + yoff
z' = z </programlisting> This method is a subcase of the 3D method
			above.</para>

		<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>
		<para>Availability: 1.1.2. Name changed from Affine to ST_Affine in 1.2.2</para>
		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>

		<para>&P_support;</para>
		<para>&T_support;</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Rotate a 3d line 180 degrees about the z axis.  Note this is long-hand for doing ST_Rotate();
 SELECT ST_AsEWKT(ST_Affine(the_geom,  cos(pi()), -sin(pi()), 0,  sin(pi()), cos(pi()), 0,  0, 0, 1,  0, 0, 0)) As using_affine,
	 ST_AsEWKT(ST_Rotate(the_geom, pi())) As using_rotate
	FROM (SELECT ST_GeomFromEWKT('LINESTRING(1 2 3, 1 4 3)') As the_geom) As foo;
        using_affine         |        using_rotate
-----------------------------+-----------------------------
 LINESTRING(-1 -2 3,-1 -4 3) | LINESTRING(-1 -2 3,-1 -4 3)
(1 row)

--Rotate a 3d line 180 degrees in both the x and z axis
SELECT ST_AsEWKT(ST_Affine(the_geom, cos(pi()), -sin(pi()), 0, sin(pi()), cos(pi()), -sin(pi()), 0, sin(pi()), cos(pi()), 0, 0, 0))
	FROM (SELECT ST_GeomFromEWKT('LINESTRING(1 2 3, 1 4 3)') As the_geom) As foo;
           st_asewkt
-------------------------------
 LINESTRING(-1 -2 -3,-1 -4 -3)
(1 row)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Rotate" />, <xref linkend="ST_Scale" />, <xref linkend="ST_Translate" />, <xref linkend="ST_TransScale" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force2D">
	  <refnamediv>
		<refname>ST_Force2D</refname>

		<refpurpose>Force the geometries into a "2-dimensional mode".</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force2D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into a "2-dimensional mode" so that
		all output representations will only have the X and Y coordinates.
		This is useful for force OGC-compliant output (since OGC only
		specifies 2-D geometries).</para>

		<para>Enhanced: 2.0.0 support for Polyhedral surfaces was introduced.</para>
		<para>Changed: 2.1.0. Up to 2.0.x this was called ST_Force_2D.</para>
		<para>&curve_support;</para>
		<para>&P_support;</para>
		<para>&Z_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsEWKT(ST_Force2D(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
		st_asewkt
-------------------------------------
CIRCULARSTRING(1 1,2 3,4 5,6 7,5 6)

SELECT  ST_AsEWKT(ST_Force2D('POLYGON((0 0 2,0 5 2,5 0 2,0 0 2),(1 1 2,3 1 2,1 3 2,1 1 2))'));

				  st_asewkt
----------------------------------------------
 POLYGON((0 0,0 5,5 0,0 0),(1 1,3 1,1 3,1 1))

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Force_3D"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_3D">
	  <refnamediv>
		<refname>ST_Force3D</refname>

		<refpurpose>Force the geometries into XYZ mode.  This is an alias for ST_Force3DZ.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force3D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into XYZ mode.  This is an alias for ST_Force_3DZ. If a geometry has no Z component, then a 0 Z coordinate is tacked on.</para>

		<para>Enhanced: 2.0.0 support for Polyhedral surfaces was introduced.</para>
		<para>Changed: 2.1.0. Up to 2.0.x this was called ST_Force_3D.</para>
		<para>&P_support;</para>
		<para>&curve_support;</para>
		<para>&Z_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
		--Nothing happens to an already 3D geometry
		SELECT ST_AsEWKT(ST_Force3D(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
				   st_asewkt
-----------------------------------------------
 CIRCULARSTRING(1 1 2,2 3 2,4 5 2,6 7 2,5 6 2)


SELECT  ST_AsEWKT(ST_Force3D('POLYGON((0 0,0 5,5 0,0 0),(1 1,3 1,1 3,1 1))'));

						 st_asewkt
--------------------------------------------------------------
 POLYGON((0 0 0,0 5 0,5 0 0,0 0 0),(1 1 0,3 1 0,1 3 0,1 1 0))
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>, <xref linkend="ST_Force2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3DZ"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_3DZ">
	  <refnamediv>
		<refname>ST_Force3DZ</refname>

		<refpurpose>Force the geometries into XYZ mode.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force3DZ</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into XYZ mode.  This is a synonym for ST_Force3DZ. If a geometry has no Z component, then a 0 Z coordinate is tacked on.</para>

		<para>Enhanced: 2.0.0 support for Polyhedral surfaces was introduced.</para>
		<para>Changed: 2.1.0. Up to 2.0.x this was called ST_Force_3DZ.</para>
		<para>&P_support;</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Nothing happens to an already 3D geometry
SELECT ST_AsEWKT(ST_Force3DZ(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
				   st_asewkt
-----------------------------------------------
 CIRCULARSTRING(1 1 2,2 3 2,4 5 2,6 7 2,5 6 2)


SELECT  ST_AsEWKT(ST_Force3DZ('POLYGON((0 0,0 5,5 0,0 0),(1 1,3 1,1 3,1 1))'));

						 st_asewkt
--------------------------------------------------------------
 POLYGON((0 0 0,0 5 0,5 0 0,0 0 0),(1 1 0,3 1 0,1 3 0,1 1 0))
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>, <xref linkend="ST_Force2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3D"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_3DM">
	  <refnamediv>
		<refname>ST_Force3DM</refname>

		<refpurpose>Force the geometries into XYM mode.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force3DM</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into XYM mode.  If a geometry has no M component, then a 0 M coordinate is tacked on.  If it has a Z component, then Z is removed</para>


		  <para>Changed: 2.1.0. Up to 2.0.x this was called ST_Force_3DM.</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Nothing happens to an already 3D geometry
SELECT ST_AsEWKT(ST_Force3DM(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
				   st_asewkt
------------------------------------------------
 CIRCULARSTRINGM(1 1 0,2 3 0,4 5 0,6 7 0,5 6 0)


SELECT  ST_AsEWKT(ST_Force3DM('POLYGON((0 0 1,0 5 1,5 0 1,0 0 1),(1 1 1,3 1 1,1 3 1,1 1 1))'));

						  st_asewkt
---------------------------------------------------------------
 POLYGONM((0 0 0,0 5 0,5 0 0,0 0 0),(1 1 0,3 1 0,1 3 0,1 1 0))

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>,  <xref linkend="ST_Force2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3D"/>, <xref linkend="ST_GeomFromEWKT"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Force_4D">
	  <refnamediv>
		<refname>ST_Force4D</refname>

		<refpurpose>Force the geometries into XYZM mode.  </refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Force4D</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Forces the geometries into XYZM mode.  0 is tacked on for missing Z and M dimensions. </para>

		  <para>Changed: 2.1.0. Up to 2.0.x this was called ST_Force_4D.</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Nothing happens to an already 3D geometry
SELECT ST_AsEWKT(ST_Force4D(ST_GeomFromEWKT('CIRCULARSTRING(1 1 2, 2 3 2, 4 5 2, 6 7 2, 5 6 2)')));
						st_asewkt
---------------------------------------------------------
 CIRCULARSTRING(1 1 2 0,2 3 2 0,4 5 2 0,6 7 2 0,5 6 2 0)



SELECT  ST_AsEWKT(ST_Force4D('MULTILINESTRINGM((0 0 1,0 5 2,5 0 3,0 0 4),(1 1 1,3 1 1,1 3 1,1 1 1))'));

									  st_asewkt
--------------------------------------------------------------------------------------
 MULTILINESTRING((0 0 0 1,0 5 0 2,5 0 0 3,0 0 0 4),(1 1 0 1,3 1 0 1,1 3 0 1,1 1 0 1))

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>, <xref linkend="ST_Force2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3D"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_ForcePolygonCCW">
		<refnamediv>
			<refname>
				ST_ForcePolygonCCW
			</refname>
			<refpurpose>
				Orients all exterior rings counter-clockwise and all interior rings clockwise.
			</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>
						geometry
						<function>ST_ForcePolygonCCW</function>
					</funcdef>
					<paramdef>
						<type>geometry</type>
						<parameter>geom</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>
				Forces (Multi)Polygons to use a counter-clockwise orientation for
				their exterior ring, and a clockwise orientation for their interior
				rings.  Non-polygonal geometries are returned unchanged.
			</para>

			<para>&Z_support;</para>
			<para>&M_support;</para>
		</refsection>

		<refsection>
			<title>See Also</title>
			<para>
				<xref linkend="ST_ForcePolygonCW" />,
				<xref linkend="ST_IsPolygonCCW" />,
				<xref linkend="ST_IsPolygonCW" />
			</para>
		</refsection>
	</refentry>

	<refentry id="ST_Force_Collection">
	  <refnamediv>
		<refname>ST_ForceCollection</refname>

		<refpurpose>Convert the geometry into a GEOMETRYCOLLECTION.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_ForceCollection</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Converts the geometry into a GEOMETRYCOLLECTION. This is
			useful for simplifying the WKB representation.</para>

		<para>Enhanced: 2.0.0 support for Polyhedral surfaces was introduced.</para>
		<para>Availability: 1.2.2, prior to 1.3.4 this function will crash with Curves.  This is fixed in 1.3.4+</para>
		<para>Changed: 2.1.0. Up to 2.0.x this was called ST_Force_Collection.</para>

		<para>&P_support;</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>

SELECT  ST_AsEWKT(ST_ForceCollection('POLYGON((0 0 1,0 5 1,5 0 1,0 0 1),(1 1 1,3 1 1,1 3 1,1 1 1))'));

								   st_asewkt
----------------------------------------------------------------------------------
 GEOMETRYCOLLECTION(POLYGON((0 0 1,0 5 1,5 0 1,0 0 1),(1 1 1,3 1 1,1 3 1,1 1 1)))


  SELECT ST_AsText(ST_ForceCollection('CIRCULARSTRING(220227 150406,2220227 150407,220227 150406)'));
								   st_astext
--------------------------------------------------------------------------------
 GEOMETRYCOLLECTION(CIRCULARSTRING(220227 150406,2220227 150407,220227 150406))
(1 row)

		</programlisting>

		<programlisting>
-- POLYHEDRAL example --
SELECT ST_AsEWKT(ST_ForceCollection('POLYHEDRALSURFACE(((0 0 0,0 0 1,0 1 1,0 1 0,0 0 0)),
 ((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0)),
 ((0 0 0,1 0 0,1 0 1,0 0 1,0 0 0)),
 ((1 1 0,1 1 1,1 0 1,1 0 0,1 1 0)),
 ((0 1 0,0 1 1,1 1 1,1 1 0,0 1 0)),
 ((0 0 1,1 0 1,1 1 1,0 1 1,0 0 1)))'))

								   st_asewkt
----------------------------------------------------------------------------------
GEOMETRYCOLLECTION(
  POLYGON((0 0 0,0 0 1,0 1 1,0 1 0,0 0 0)),
  POLYGON((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0)),
  POLYGON((0 0 0,1 0 0,1 0 1,0 0 1,0 0 0)),
  POLYGON((1 1 0,1 1 1,1 0 1,1 0 0,1 1 0)),
  POLYGON((0 1 0,0 1 1,1 1 1,1 1 0,0 1 0)),
  POLYGON((0 0 1,1 0 1,1 1 1,0 1 1,0 0 1))
)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT"/>,  <xref linkend="ST_Force2D"/>, <xref linkend="ST_Force_3DM"/>, <xref linkend="ST_Force_3D"/>, <xref linkend="ST_GeomFromEWKT"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_ForcePolygonCW">
		<refnamediv>
			<refname>
				ST_ForcePolygonCW
			</refname>
			<refpurpose>
				Orients all exterior rings clockwise and all interior rings counter-clockwise.
			</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>
						geometry
						<function>ST_ForcePolygonCW</function>
					</funcdef>
					<paramdef>
						<type>geometry</type>
						<parameter>geom</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>
				Forces (Multi)Polygons to use a clockwise orientation for
				their exterior ring, and a counter-clockwise orientation for their interior
				rings.  Non-polygonal geometries are returned unchanged.
			</para>

			<para>&Z_support;</para>
			<para>&M_support;</para>
		</refsection>

		<refsection>
			<title>See Also</title>
			<para>
				<xref linkend="ST_ForcePolygonCCW" />,
				<xref linkend="ST_IsPolygonCCW" />,
				<xref linkend="ST_IsPolygonCW" />
			</para>
		</refsection>
	</refentry>

	<refentry id="ST_ForceSFS">
	  <refnamediv>
		<refname>ST_ForceSFS</refname>

		<refpurpose>Force the geometries to use SFS 1.1 geometry types only.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_ForceSFS</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
		  </funcprototype>
		  <funcprototype>
			<funcdef>geometry <function>ST_ForceSFS</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>text </type> <parameter>version</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>&P_support;</para>
		<para>&T_support;</para>
		<para>&curve_support;</para>
		<para>&Z_support;</para>
	  </refsection>
	</refentry>


	<refentry id="ST_ForceRHR">
		<refnamediv>
			<refname>ST_ForceRHR</refname>

			<refpurpose>Force the orientation of the vertices in a polygon to follow the
				Right-Hand-Rule.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>geometry
						<function>ST_ForceRHR</function></funcdef>
						<paramdef><type>geometry</type> <parameter>g</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Forces the orientation of the vertices in a polygon to follow a
				Right-Hand-Rule, in which the area that is bounded by the
				polygon is to the right of the boundary. In particular, the exterior ring is
				orientated in a clockwise direction and the interior rings in a counter-clockwise
				direction.  This function is a synonym for <xref linkend="ST_ForcePolygonCW" /></para>

			<note>
				<para>
					The above definition of the Right-Hand-Rule conflicts with definitions used in other contexts.  To avoid confusion, it is recommended to use ST_ForcePolygonCW.
				</para>
			</note>

			<para>Enhanced: 2.0.0 support for Polyhedral surfaces was introduced.</para>
			<para>&Z_support;</para>
			<para>&P_support;</para>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsEWKT(
  ST_ForceRHR(
	'POLYGON((0 0 2, 5 0 2, 0 5 2, 0 0 2),(1 1 2, 1 3 2, 3 1 2, 1 1 2))'
  )
);
						  st_asewkt
--------------------------------------------------------------
 POLYGON((0 0 2,0 5 2,5 0 2,0 0 2),(1 1 2,3 1 2,1 3 2,1 1 2))
(1 row)</programlisting>
		</refsection>

		<refsection>
			<title>See Also</title>

			<para>
				<xref linkend="ST_ForcePolygonCCW"/>,
				<xref linkend="ST_ForcePolygonCW"/>,
				<xref linkend="ST_IsPolygonCCW"/>,
				<xref linkend="ST_IsPolygonCW"/>,
				<xref linkend="ST_BuildArea"/>,
				<xref linkend="ST_Polygonize"/>,
				<xref linkend="ST_Reverse"/></para>
		</refsection>
	</refentry>

	<refentry id="ST_ForceCurve">
		<refnamediv>
			<refname>ST_ForceCurve</refname>

			<refpurpose>Upcast a geometry into its curved type, if applicable.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>geometry
						<function>ST_ForceCurve</function></funcdef>
						<paramdef><type>geometry</type> <parameter>g</parameter></paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>
                        Turns a geometry into its curved representation, if applicable:
                        lines become compoundcurves, multilines become multicurves
                        polygons become curvepolygons multipolygons become multisurfaces. If the geometry input is already a curved representation returns back same as input.
                        </para>

		        <para>Availability: 2.2.0</para>
			<para>&Z_support;</para>
				<!-- Optionally mention Circular String Support -->
				<para>&curve_support;</para>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText(
  ST_ForceCurve(
	'POLYGON((0 0 2, 5 0 2, 0 5 2, 0 0 2),(1 1 2, 1 3 2, 3 1 2, 1 1 2))'::geometry
  )
);
                              st_astext
----------------------------------------------------------------------
 CURVEPOLYGON Z ((0 0 2,5 0 2,0 5 2,0 0 2),(1 1 2,1 3 2,3 1 2,1 1 2))
(1 row)</programlisting>
		</refsection>

		<refsection>
			<title>See Also</title>

			<para><xref linkend="ST_LineToCurve"/></para>
		</refsection>
	</refentry>

	<refentry id="ST_LineMerge">
		<refnamediv>
			<refname>ST_LineMerge</refname>

			<refpurpose>Return a (set of) LineString(s) formed by sewing together
			a MULTILINESTRING.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_LineMerge</function></funcdef>
				<paramdef><type>geometry </type> <parameter>amultilinestring</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns a (set of) LineString(s) formed by sewing together
			the constituent line work of a MULTILINESTRING. </para>
			<note><para>Only use with MULTILINESTRING/LINESTRINGs. If you feed a polygon or geometry collection into this function, it
			will return an empty GEOMETRYCOLLECTION</para></note>

			<para>Availability: 1.1.0</para>
			<note><para>requires GEOS &gt;= 2.1.0</para></note>
			<warning><para>Will strip the M dimension.</para></warning>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText(ST_LineMerge(
ST_GeomFromText('MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45 -33,-46 -32))')
		)
);
st_astext
--------------------------------------------------------------------------------------------------
LINESTRING(-29 -27,-30 -29.7,-36 -31,-45 -33,-46 -32)
(1 row)

--If can't be merged - original MULTILINESTRING is returned
SELECT ST_AsText(ST_LineMerge(
ST_GeomFromText('MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45.2 -33.2,-46 -32))')
)
);
st_astext
----------------
MULTILINESTRING((-45.2 -33.2,-46 -32),(-29 -27,-30 -29.7,-36 -31,-45 -33))

-- example with Z dimension
SELECT ST_AsText(ST_LineMerge(
ST_GeomFromText('MULTILINESTRING((-29 -27 11,-30 -29.7 10,-36 -31 5,-45 -33 6), (-29 -27 12,-30 -29.7 5), (-45 -33 1,-46 -32 11))')
		)
);
st_astext
--------------------------------------------------------------------------------------------------
LINESTRING Z (-30 -29.7 5,-29 -27 11,-30 -29.7 10,-36 -31 5,-45 -33 1,-46 -32 11)
(1 row)
			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Segmentize" />, <xref linkend="ST_LineSubstring" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_CollectionExtract">
		<refnamediv>
			<refname>ST_CollectionExtract</refname>

			<refpurpose>
Given a (multi)geometry, return a (multi)geometry consisting only of elements of the specified type.
			</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_CollectionExtract</function></funcdef>
				<paramdef><type>geometry </type> <parameter>collection</parameter></paramdef>
				<paramdef><type>integer </type> <parameter>type</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>
Given a (multi)geometry, returns a (multi)geometry consisting only of elements of the specified type.
Sub-geometries that are not the specified type are ignored. If there are no sub-geometries of the right type, an EMPTY geometry will be returned.
Only points, lines and polygons are supported. Type numbers are 1 == POINT, 2 == LINESTRING, 3 == POLYGON.
			</para>

			<para>Availability: 1.5.0</para>

			<note><para>
Prior to 1.5.3 this function returned non-collection inputs untouched, no matter type.
In 1.5.3 non-matching single geometries result in a NULL return.
In of 2.0.0 every case of missing match results in a typed EMPTY return.
			</para></note>

			<warning><para>When specifying 3 == POLYGON a multipolygon is returned even when the edges are shared.  This results in an invalid multipolygon for many cases
			such as applying this function on an <xref linkend="ST_Split" /> result.</para></warning>

		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>-- Constants: 1 == POINT, 2 == LINESTRING, 3 == POLYGON
SELECT ST_AsText(ST_CollectionExtract(ST_GeomFromText('GEOMETRYCOLLECTION(GEOMETRYCOLLECTION(POINT(0 0)))'),1));
st_astext
---------------
MULTIPOINT(0 0)
(1 row)

SELECT ST_AsText(ST_CollectionExtract(ST_GeomFromText('GEOMETRYCOLLECTION(GEOMETRYCOLLECTION(LINESTRING(0 0, 1 1)),LINESTRING(2 2, 3 3))'),2));
st_astext
---------------
MULTILINESTRING((0 0, 1 1), (2 2, 3 3))
(1 row)
			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_Multi" />, <xref linkend="ST_Dump" />, <xref linkend="ST_CollectionHomogenize" /></para>
		</refsection>
	</refentry>

		<refentry id="ST_CollectionHomogenize">
			<refnamediv>
				<refname>ST_CollectionHomogenize</refname>

				<refpurpose>
	Given a geometry collection, return the "simplest" representation of the contents.
				</refpurpose>
			</refnamediv>

			<refsynopsisdiv>
				<funcsynopsis>
				  <funcprototype>
					<funcdef>geometry <function>ST_CollectionHomogenize</function></funcdef>
					<paramdef><type>geometry </type> <parameter>collection</parameter></paramdef>
				  </funcprototype>
				</funcsynopsis>
			</refsynopsisdiv>

			<refsection>
				<title>Description</title>

				<para>
					Given a geometry collection, returns the "simplest" representation of the contents.  Singletons will be returned as singletons.  Collections that are homogeneous will be returned as the appropriate multi-type.
				</para>

				<warning><para>When specifying 3 == POLYGON a multipolygon is returned even when the edges are shared.  This results in an invalid multipolygon for many cases
			such as applying this function on an <xref linkend="ST_Split" /> result.</para></warning>


				<para>Availability: 2.0.0</para>

			</refsection>

			<refsection>
				<title>Examples</title>

				<programlisting>
  SELECT ST_AsText(ST_CollectionHomogenize('GEOMETRYCOLLECTION(POINT(0 0))'));

	st_astext
	------------
	 POINT(0 0)
	(1 row)

  SELECT ST_AsText(ST_CollectionHomogenize('GEOMETRYCOLLECTION(POINT(0 0),POINT(1 1))'));

	st_astext
	---------------------
	 MULTIPOINT(0 0,1 1)
	(1 row)

				</programlisting>
			</refsection>
			<refsection>
				<title>See Also</title>
				<para><xref linkend="ST_Multi" />, <xref linkend="ST_CollectionExtract" /></para>
			</refsection>
		</refentry>

	<refentry id="ST_Multi">
		<refnamediv>
			<refname>ST_Multi</refname>

			<refpurpose>Return the geometry as a MULTI* geometry.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_Multi</function></funcdef>
				<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns the geometry as a MULTI* geometry. If the geometry
				is already a MULTI*, it is returned unchanged.</para>

		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText(ST_Multi(ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,
			743265 2967450,743265.625 2967416,743238 2967416))')));
			st_astext
			--------------------------------------------------------------------------------------------------
			MULTIPOLYGON(((743238 2967416,743238 2967450,743265 2967450,743265.625 2967416,
			743238 2967416)))
			(1 row)
			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsText" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_Normalize">
		<refnamediv>
			<refname>ST_Normalize</refname>

			<refpurpose>Return the geometry in its canonical form.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_Normalize</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>
        Returns the geometry in its normalized/canonical form.
        May reorder vertices in polygon rings, rings in a polygon,
        elements in a multi-geometry complex.
      </para>

			<para>
        Mostly only useful for testing purposes (comparing expected
        and obtained results).
      </para>

      <para>Availability: 2.3.0</para>

		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>
SELECT ST_AsText(ST_Normalize(ST_GeomFromText(
  'GEOMETRYCOLLECTION(
    POINT(2 3),
    MULTILINESTRING((0 0, 1 1),(2 2, 3 3)),
    POLYGON(
      (0 10,0 0,10 0,10 10,0 10),
      (4 2,2 2,2 4,4 4,4 2),
      (6 8,8 8,8 6,6 6,6 8)
    )
  )'
)));
                                                                     st_astext
----------------------------------------------------------------------------------------------------------------------------------------------------
 GEOMETRYCOLLECTION(POLYGON((0 0,0 10,10 10,10 0,0 0),(6 6,8 6,8 8,6 8,6 6),(2 2,4 2,4 4,2 4,2 2)),MULTILINESTRING((2 2,3 3),(0 0,1 1)),POINT(2 3))
(1 row)
			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para>
        <xref linkend="ST_Equals" />,
      </para>
		</refsection>
	</refentry>

	<refentry id="ST_QuantizeCoordinates">
		<refnamediv>
			<refname>
				ST_QuantizeCoordinates
			</refname>
			<refpurpose>
				Sets least significant bits of coordinates to zero
			</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
				<funcprototype>
					<funcdef>
						geometry
						<function>ST_QuantizeCoordinates</function>
					</funcdef>
					<paramdef>
						<type>geometry</type>
						<parameter>g</parameter>
					</paramdef>
					<paramdef>
						<type>int</type>
						<parameter>prec_x</parameter>
					</paramdef>
					<paramdef>
						<type>int</type>
						<parameter>prec_y</parameter>
					</paramdef>
					<paramdef>
						<type>int</type>
						<parameter>prec_z</parameter>
					</paramdef>
					<paramdef>
						<type>int</type>
						<parameter>prec_m</parameter>
					</paramdef>
				</funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>
			<para>
				<code>ST_QuantizeCoordinates</code> determines the number of bits
				(<code>N</code>) required to represent a coordinate value with a
				specified number of digits after the decimal point, and then sets
				all but the <code>N</code> most significant bits to zero. The
				resulting coordinate value will still round to the original value,
				but will have improved compressiblity. This can result in a
				significant disk usage reduction provided that the geometry column
				is using a <ulink
				url="https://www.postgresql.org/docs/current/static/storage-toast.html#STORAGE-TOAST-ONDISK">
				compressible storage type</ulink>. The function allows
				specification of a different number of digits after the decimal
				point in each dimension; unspecified dimensions are assumed to have
				the precsion of the <code>x</code> dimension. Negative digits are
				interpreted to refer digits to the left of the decimal point, (i.e.,
				<code>prec_x=-2</code> will preserve coordinate values to the
				nearest 100.
			</para>
			<para>
				The coordinates produced by <code>ST_QuantizeCoordinates</code> are
				independent of the geometry that contains those coordinates and the
				relative position of those coordinates within the geometry. As a result,
				existing topological relationships between geometries are unaffected
				by use of this function. The function may produce invalid geometry
				when it is called with a number of digits lower than the intrinsic
				precision of the geometry.
			</para>
			<para>Availability: 2.5.0</para>
		</refsection>
		<refsection>
			<title>Technical Background</title>
			<para>
				PostGIS stores all coordinate values as double-precision floating
				point integers, which can reliably represent 15 significant digits.
				However, PostGIS may be used to manage data that intrinsically has
				fewer than 15 significant digits. An example is TIGER data, which is
				provided as geographic coordinates with six digits of precision
				after the decimal point (thus requiring only nine significant digits
				of longitude and eight significant digits of latitude.)
			</para>
			<para>
				When 15 significant digits are available, there are many possible
				representations of a number with 9 significant digits.  A double
				precision floating point number uses 52 explicit bits to represent
				the significand (mantissa) of the coordinate. Only 30 bits are needed
				to represent a mantissa with 9 significant digits, leaving 22
				insignificant bits; we can set their value to anything we like and
				still end up with a number that rounds to our input value.  For
				example, the value 100.123456 can be represented by the floating
				point numbers closest to 100.123456000000, 100.123456000001, and
				100.123456432199. All are equally valid, in that
				<code>ST_AsText(geom, 6)</code> will return the same result with
				any of these inputs. As we can set these bits to any value,
				<code>ST_QuantizeCoordinates</code> sets the 22 insignificant
				bits to zero. For a long coordinate sequence this creates a
				pattern of blocks of consecutive zeros that is compressed
				by PostgreSQL more effeciently.
			</para>

			<note>
				<para>
					Only the on-disk size of the geometry is potentially affected by
					<code>ST_QuantizeCoordinates</code>.  <xref linkend="ST_MemSize" />,
					which reports the in-memory usage of the geometry, will return the
					the same value regardless of the disk space used by a geometry.
				</para>
			</note>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText(ST_QuantizeCoordinates('POINT (100.123456 0)'::geometry, 4));
st_astext
-------------------------
POINT(100.123455047607 0)
			</programlisting>

			<programlisting>WITH test AS (SELECT 'POINT (123.456789123456 123.456789123456)'::geometry AS geom)
SELECT
  digits,
  encode(ST_QuantizeCoordinates(geom, digits), 'hex'),
  ST_AsText(ST_QuantizeCoordinates(geom, digits))
FROM test, generate_series(15, -15, -1) AS digits;

digits  |                   encode                   |                st_astext
--------+--------------------------------------------+------------------------------------------
15      | 01010000005f9a72083cdd5e405f9a72083cdd5e40 | POINT(123.456789123456 123.456789123456)
14      | 01010000005f9a72083cdd5e405f9a72083cdd5e40 | POINT(123.456789123456 123.456789123456)
13      | 01010000005f9a72083cdd5e405f9a72083cdd5e40 | POINT(123.456789123456 123.456789123456)
12      | 01010000005c9a72083cdd5e405c9a72083cdd5e40 | POINT(123.456789123456 123.456789123456)
11      | 0101000000409a72083cdd5e40409a72083cdd5e40 | POINT(123.456789123456 123.456789123456)
10      | 0101000000009a72083cdd5e40009a72083cdd5e40 | POINT(123.456789123455 123.456789123455)
9       | 0101000000009072083cdd5e40009072083cdd5e40 | POINT(123.456789123418 123.456789123418)
8       | 0101000000008072083cdd5e40008072083cdd5e40 | POINT(123.45678912336 123.45678912336)
7       | 0101000000000070083cdd5e40000070083cdd5e40 | POINT(123.456789121032 123.456789121032)
6       | 0101000000000040083cdd5e40000040083cdd5e40 | POINT(123.456789076328 123.456789076328)
5       | 0101000000000000083cdd5e40000000083cdd5e40 | POINT(123.456789016724 123.456789016724)
4       | 0101000000000000003cdd5e40000000003cdd5e40 | POINT(123.456787109375 123.456787109375)
3       | 0101000000000000003cdd5e40000000003cdd5e40 | POINT(123.456787109375 123.456787109375)
2       | 01010000000000000038dd5e400000000038dd5e40 | POINT(123.45654296875 123.45654296875)
1       | 01010000000000000000dd5e400000000000dd5e40 | POINT(123.453125 123.453125)
0       | 01010000000000000000dc5e400000000000dc5e40 | POINT(123.4375 123.4375)
-1      | 01010000000000000000c05e400000000000c05e40 | POINT(123 123)
-2      | 01010000000000000000005e400000000000005e40 | POINT(120 120)
-3      | 010100000000000000000058400000000000005840 | POINT(96 96)
-4      | 010100000000000000000058400000000000005840 | POINT(96 96)
-5      | 010100000000000000000058400000000000005840 | POINT(96 96)
-6      | 010100000000000000000058400000000000005840 | POINT(96 96)
-7      | 010100000000000000000058400000000000005840 | POINT(96 96)
-8      | 010100000000000000000058400000000000005840 | POINT(96 96)
-9      | 010100000000000000000058400000000000005840 | POINT(96 96)
-10     | 010100000000000000000058400000000000005840 | POINT(96 96)
-11     | 010100000000000000000058400000000000005840 | POINT(96 96)
-12     | 010100000000000000000058400000000000005840 | POINT(96 96)
-13     | 010100000000000000000058400000000000005840 | POINT(96 96)
-14     | 010100000000000000000058400000000000005840 | POINT(96 96)
-15     | 010100000000000000000058400000000000005840 | POINT(96 96)
</programlisting>

		</refsection>

		<refsection>
			<title>See Also</title>

			<para><xref linkend="ST_SnapToGrid" /></para>
		</refsection>

	</refentry>


	<refentry id="ST_RemovePoint">
	  <refnamediv>
		<refname>ST_RemovePoint</refname>
		<refpurpose>Remove point from a linestring.</refpurpose>
	  </refnamediv>
	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RemovePoint</function></funcdef>
			<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
			<paramdef><type>integer</type> <parameter>offset</parameter></paramdef>
		  </funcprototype>
		 </funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Remove a point from a linestring, given its 0-based index. Useful for turning a closed ring into an open line string</para>
		<para>Availability: 1.1.0</para>
		<para>&Z_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>
--guarantee no LINESTRINGS are closed
--by removing the end point.  The below assumes the_geom is of type LINESTRING
UPDATE sometable
	SET the_geom = ST_RemovePoint(the_geom, ST_NPoints(the_geom) - 1)
	FROM sometable
	WHERE ST_IsClosed(the_geom) = true;
		</programlisting>
	  </refsection>
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_AddPoint"/>, <xref linkend="ST_NPoints"/>, <xref linkend="ST_NumPoints"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Reverse">
	  <refnamediv>
		<refname>ST_Reverse</refname>
		<refpurpose>Return the geometry with vertex order reversed.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Reverse</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
		  </funcprototype>
		 </funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Can be used on any geometry and reverses the order of the vertexes.</para>

		<para>Enhanced: 2.4.0 support for curves was introduced.</para>
		<para>&Z_support;</para>
		<para>&P_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<programlisting>
SELECT ST_AsText(the_geom) as line, ST_AsText(ST_Reverse(the_geom)) As reverseline
FROM
(SELECT ST_MakeLine(ST_MakePoint(1,2),
		ST_MakePoint(1,10)) As the_geom) as foo;
--result
		line         |     reverseline
---------------------+----------------------
LINESTRING(1 2,1 10) | LINESTRING(1 10,1 2)
</programlisting>
	  </refsection>
	</refentry>

	<refentry id="ST_Rotate">
	  <refnamediv>
		<refname>ST_Rotate</refname>

		<refpurpose>Rotate a geometry rotRadians counter-clockwise about an origin.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Rotate</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>rotRadians</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
                        <funcdef>geometry <function>ST_Rotate</function></funcdef>
                        <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
                        <paramdef><type>float</type> <parameter>rotRadians</parameter></paramdef>
                        <paramdef><type>float</type> <parameter>x0</parameter></paramdef>
                        <paramdef><type>float</type> <parameter>y0</parameter></paramdef>
                  </funcprototype>

		  <funcprototype>
                        <funcdef>geometry <function>ST_Rotate</function></funcdef>
                        <paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
                        <paramdef><type>float</type> <parameter>rotRadians</parameter></paramdef>
                        <paramdef><type>geometry</type> <parameter>pointOrigin</parameter></paramdef>
                  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Rotates geometry rotRadians counter-clockwise about the origin. The rotation origin can be
			specified either as a POINT geometry, or as x and y coordinates. If the origin is not
			specified, the geometry is rotated about POINT(0 0).</para>

		<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>
		<para>Enhanced: 2.0.0 additional parameters for specifying the origin of rotation were added.</para>
		<para>Availability: 1.1.2. Name changed from Rotate to ST_Rotate in 1.2.2</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
		<para>&P_support;</para>
		<para>&T_support;</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Rotate 180 degrees
SELECT ST_AsEWKT(ST_Rotate('LINESTRING (50 160, 50 50, 100 50)', pi()));
               st_asewkt
---------------------------------------
 LINESTRING(-50 -160,-50 -50,-100 -50)
(1 row)

--Rotate 30 degrees counter-clockwise at x=50, y=160
SELECT ST_AsEWKT(ST_Rotate('LINESTRING (50 160, 50 50, 100 50)', pi()/6, 50, 160));
                                 st_asewkt
---------------------------------------------------------------------------
 LINESTRING(50 160,105 64.7372055837117,148.301270189222 89.7372055837117)
(1 row)

--Rotate 60 degrees clockwise from centroid
SELECT ST_AsEWKT(ST_Rotate(geom, -pi()/3, ST_Centroid(geom)))
FROM (SELECT 'LINESTRING (50 160, 50 50, 100 50)'::geometry AS geom) AS foo;
                           st_asewkt
--------------------------------------------------------------
 LINESTRING(116.4225 130.6721,21.1597 75.6721,46.1597 32.3708)
(1 row)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_RotateX" />, <xref linkend="ST_RotateY" />, <xref linkend="ST_RotateZ" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_RotateX">
	  <refnamediv>
		<refname>ST_RotateX</refname>

		<refpurpose>Rotate a geometry rotRadians about the X axis.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RotateX</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>rotRadians</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Rotate a geometry geomA - rotRadians about the X axis.</para>

		<note><para><code>ST_RotateX(geomA,  rotRadians)</code>
			is short-hand for <code>ST_Affine(geomA, 1, 0, 0, 0, cos(rotRadians), -sin(rotRadians), 0, sin(rotRadians), cos(rotRadians), 0, 0, 0)</code>.</para></note>

		<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>
		<para>Availability: 1.1.2. Name changed from RotateX to ST_RotateX in 1.2.2</para>
		<para>&P_support;</para>
		<para>&Z_support;</para>
		<para>&T_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Rotate a line 90 degrees along x-axis
SELECT ST_AsEWKT(ST_RotateX(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), pi()/2));
		 st_asewkt
---------------------------
 LINESTRING(1 -3 2,1 -1 1)
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_RotateY" />, <xref linkend="ST_RotateZ" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_RotateY">
	  <refnamediv>
		<refname>ST_RotateY</refname>

		<refpurpose>Rotate a geometry rotRadians about the Y axis.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RotateY</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>rotRadians</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Rotate a geometry geomA - rotRadians about the y axis.</para>

		<note><para><code>ST_RotateY(geomA,  rotRadians)</code>
			is short-hand for <code>ST_Affine(geomA,  cos(rotRadians), 0, sin(rotRadians),  0, 1, 0,  -sin(rotRadians), 0, cos(rotRadians), 0,  0, 0)</code>.</para></note>

		<para>Availability: 1.1.2. Name changed from RotateY to ST_RotateY in 1.2.2</para>
		<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>

		<para>&P_support;</para>
		<para>&Z_support;</para>
		<para>&T_support;</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Rotate a line 90 degrees along y-axis
 SELECT ST_AsEWKT(ST_RotateY(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), pi()/2));
		 st_asewkt
---------------------------
 LINESTRING(3 2 -1,1 1 -1)
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_RotateX" />, <xref linkend="ST_RotateZ" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_RotateZ">
	  <refnamediv>
		<refname>ST_RotateZ</refname>

		<refpurpose>Rotate a geometry rotRadians about the Z axis.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_RotateZ</function></funcdef>
			<paramdef><type>geometry</type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>rotRadians</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Rotate a geometry geomA - rotRadians about the Z axis.</para>

		<note><para>This is a synonym for ST_Rotate</para></note>
		<note><para><code>ST_RotateZ(geomA,  rotRadians)</code>
			is short-hand for <code>SELECT ST_Affine(geomA,  cos(rotRadians), -sin(rotRadians), 0,  sin(rotRadians), cos(rotRadians), 0,  0, 0, 1,  0, 0, 0)</code>.</para></note>

		<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>

		<para>Availability: 1.1.2. Name changed from RotateZ to ST_RotateZ in 1.2.2</para>
		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>

		<para>&Z_support;</para>
		<para>&curve_support;</para>
		<para>&P_support;</para>
		<para>&T_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Rotate a line 90 degrees along z-axis
SELECT ST_AsEWKT(ST_RotateZ(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), pi()/2));
		 st_asewkt
---------------------------
 LINESTRING(-2 1 3,-1 1 1)

 --Rotate a curved circle around z-axis
SELECT ST_AsEWKT(ST_RotateZ(the_geom, pi()/2))
FROM (SELECT ST_LineToCurve(ST_Buffer(ST_GeomFromText('POINT(234 567)'), 3)) As the_geom) As foo;

													   st_asewkt
----------------------------------------------------------------------------------------------------------------------------
 CURVEPOLYGON(CIRCULARSTRING(-567 237,-564.87867965644 236.12132034356,-564 234,-569.12132034356 231.87867965644,-567 237))

</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_RotateX" />, <xref linkend="ST_RotateY" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Scale">
	  <refnamediv>
		<refname>ST_Scale</refname>

		<refpurpose>Scale a geometry by given factors.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>

		  <funcprototype>
			<funcdef>geometry <function>ST_Scale</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>XFactor</parameter></paramdef>
			<paramdef><type>float</type> <parameter>YFactor</parameter></paramdef>
			<paramdef><type>float</type> <parameter>ZFactor</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_Scale</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>XFactor</parameter></paramdef>
			<paramdef><type>float</type> <parameter>YFactor</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_Scale</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
			<paramdef><type>geometry</type> <parameter>factor</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_Scale</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
			<paramdef><type>geometry</type> <parameter>factor</parameter></paramdef>
			<paramdef><type>geometry</type> <parameter>origin</parameter></paramdef>
		  </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Scales the geometry to a new size by multiplying the
			ordinates with the corresponding factor parameters.
		</para>

		<para>
The version taking a geometry as the <varname>factor</varname> parameter
allows passing a 2d, 3dm, 3dz or 4d point to set scaling factor for all
supported dimensions. Missing dimensions in the <varname>factor</varname>
point are equivalent to no scaling the corresponding dimension.
    </para>
    <para>
        The three-geometry variant allows a "false origin" for the scaling to be passed in. This allows "scaling in place", for example using the centroid of the geometry as the false origin. Without a false origin, scaling takes place relative to the actual origin, so all coordinates are just multipled by the scale factor.
    </para>

		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>


		<para>Availability: 1.1.0.</para>
		<para>Enhanced: 2.0.0 support for Polyhedral surfaces, Triangles and TIN was introduced.</para>
                <para>Enhanced: 2.2.0 support for scaling all dimension (<varname>factor</varname> parameter) was introduced.</para>
                <para>Enhanced: 2.5.0 support for scaling relative to a local origin (<varname>origin</varname> parameter) was introduced.</para>
		<para>&P_support;</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
		<para>&T_support;</para>
		<para>&M_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>--Version 1: scale X, Y, Z
SELECT ST_AsEWKT(ST_Scale(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), 0.5, 0.75, 0.8));
			  st_asewkt
--------------------------------------
 LINESTRING(0.5 1.5 2.4,0.5 0.75 0.8)

--Version 2: Scale X Y
 SELECT ST_AsEWKT(ST_Scale(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), 0.5, 0.75));
			st_asewkt
----------------------------------
 LINESTRING(0.5 1.5 3,0.5 0.75 1)

--Version 3: Scale X Y Z M
 SELECT ST_AsEWKT(ST_Scale(ST_GeomFromEWKT('LINESTRING(1 2 3 4, 1 1 1 1)'),
   ST_MakePoint(0.5, 0.75, 2, -1)));
			       st_asewkt
----------------------------------------
 LINESTRING(0.5 1.5 6 -4,0.5 0.75 2 -1)

--Version 4: Scale X Y using false origin
SELECT ST_AsText(ST_Scale('LINESTRING(1 1, 2 2)', 'POINT(2 2)', 'POINT(1 1)'::geometry));
      st_astext
---------------------
 LINESTRING(1 1,3 3)

</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_TransScale" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Segmentize">
		<refnamediv>
			<refname>ST_Segmentize</refname>

			<refpurpose>Return a modified geometry/geography having no segment longer than the
			given distance.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_Segmentize</function></funcdef>
				<paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
				<paramdef><type>float </type> <parameter>max_segment_length</parameter></paramdef>
			  </funcprototype>
			  <funcprototype>
				<funcdef>geography <function>ST_Segmentize</function></funcdef>
				<paramdef><type>geography </type> <parameter>geog</parameter></paramdef>
				<paramdef><type>float </type> <parameter>max_segment_length</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Returns a modified geometry having no segment longer than the
			given <varname>max_segment_length</varname>.  Distance computation is performed in 2d
			only. For geometry, length units are in units of spatial reference.  For geography, units are in meters.</para>
			<para>Availability: 1.2.2</para>
			<para>Enhanced: 3.0.0 Segmentize geometry now uses equal length segments</para>
			<para>Enhanced: 2.3.0 Segmentize geography now uses equal length segments</para>
			<para>Enhanced: 2.1.0 support for geography was introduced.</para>
			<para>Changed: 2.1.0 As a result of the introduction of geography support: The construct <code>SELECT ST_Segmentize('LINESTRING(1 2, 3 4)',0.5);</code> will result in ambiguous function error.  You need to have properly typed object e.g. a geometry/geography column, use ST_GeomFromText, ST_GeogFromText or
				<code>SELECT ST_Segmentize('LINESTRING(1 2, 3 4)'::geometry,0.5);</code></para>
			<note><para>This will only increase segments.  It will not lengthen segments shorter than
			max length</para></note>
		</refsection>

		<refsection>
			<title>Examples</title>

			<programlisting>SELECT ST_AsText(ST_Segmentize(
ST_GeomFromText('MULTILINESTRING((-29 -27,-30 -29.7,-36 -31,-45 -33),(-45 -33,-46 -32))')
		,5)
);
st_astext
--------------------------------------------------------------------------------------------------
MULTILINESTRING((-29 -27,-30 -29.7,-34.886615700134 -30.758766735029,-36 -31,
-40.8809353009198 -32.0846522890933,-45 -33),
(-45 -33,-46 -32))
(1 row)

SELECT ST_AsText(ST_Segmentize(ST_GeomFromText('POLYGON((-29 28, -30 40, -29 28))'),10));
st_astext
-----------------------
POLYGON((-29 28,-29.8304547985374 37.9654575824488,-30 40,-29.1695452014626 30.0345424175512,-29 28))
(1 row)

			</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_LineSubstring" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_SetPoint">
		  <refnamediv>
			<refname>ST_SetPoint</refname>
			<refpurpose>Replace point of a linestring with a given point.</refpurpose>
		  </refnamediv>
		  <refsynopsisdiv>
			 <funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_SetPoint</function></funcdef>
				<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
				<paramdef><type>integer</type> <parameter>zerobasedposition</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>point</parameter></paramdef>
			  </funcprototype>
			 </funcsynopsis>
		  </refsynopsisdiv>

		  <refsection>
			<title>Description</title>

			<para>Replace point N of linestring with given point. Index is
			0-based.Negative index are counted backwards, so that -1 is last point.
				This is especially useful in triggers when trying to maintain relationship of joints when one vertex moves.</para>
			<para>Availability: 1.1.0</para>
			<para>Updated 2.3.0 : negative indexing</para>

			<para>&Z_support;</para>
		  </refsection>

		  <refsection>
			<title>Examples</title>
			<programlisting>
--Change first point in line string from -1 3 to -1 1
SELECT ST_AsText(ST_SetPoint('LINESTRING(-1 2,-1 3)', 0, 'POINT(-1 1)'));
	   st_astext
-----------------------
 LINESTRING(-1 1,-1 3)

---Change last point in a line string (lets play with 3d linestring this time)
SELECT ST_AsEWKT(ST_SetPoint(foo.the_geom, ST_NumPoints(foo.the_geom) - 1, ST_GeomFromEWKT('POINT(-1 1 3)')))
FROM (SELECT ST_GeomFromEWKT('LINESTRING(-1 2 3,-1 3 4, 5 6 7)') As the_geom) As foo;
	   st_asewkt
-----------------------
LINESTRING(-1 2 3,-1 3 4,-1 1 3)

SELECT ST_AsText(ST_SetPoint(g, -3, p))
FROM ST_GEomFromText('LINESTRING(0 0, 1 1, 2 2, 3 3, 4 4)') AS g
	, ST_PointN(g,1) as p;
	   st_astext
-----------------------
LINESTRING(0 0,1 1,0 0,3 3,4 4)

			</programlisting>
		  </refsection>
		  <refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AddPoint"/>, <xref linkend="ST_NPoints"/>, <xref linkend="ST_NumPoints"/>, <xref linkend="ST_PointN"/>, <xref linkend="ST_RemovePoint"/></para>
		  </refsection>
	</refentry>

	<refentry id="ST_SetSRID">
	  <refnamediv>
		<refname>ST_SetSRID</refname>

		<refpurpose>Set the SRID on a geometry to a particular integer
		value.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SetSRID</function></funcdef>

			<paramdef><type>geometry </type>
			<parameter>geom</parameter></paramdef>

			<paramdef><type>integer </type>
			<parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Sets the SRID on a geometry to a particular integer value.
		Useful in constructing bounding boxes for queries.</para>

		<note>
		  <para>This function does not transform the geometry coordinates in any way -
		  it simply sets the meta data defining the spatial reference system the geometry is assumed to be in.
		  Use <xref linkend="ST_Transform"/> if you want to transform the
		  geometry into a new projection.</para>
		</note>
		<para>&sfs_compliant;</para>
		<para>&curve_support;</para>
	  </refsection>

	  <refsection>
			<title>Examples</title>
			<para>-- Mark a point as WGS 84 long lat --</para>
			<programlisting>SELECT ST_SetSRID(ST_Point(-123.365556, 48.428611),4326) As wgs84long_lat;
-- the ewkt representation (wrap with ST_AsEWKT) -
SRID=4326;POINT(-123.365556 48.428611)
			</programlisting>
			<para>-- Mark a point as WGS 84 long lat and then transform to web mercator (Spherical Mercator) --</para>
			<programlisting>SELECT ST_Transform(ST_SetSRID(ST_Point(-123.365556, 48.428611),4326),3785) As spere_merc;
-- the ewkt representation (wrap with ST_AsEWKT) -
SRID=3785;POINT(-13732990.8753491 6178458.96425423)
			</programlisting>
		</refsection>

	  <refsection>
		<title>See Also</title>

		<para><xref linkend="spatial_ref_sys" />, <xref linkend="ST_AsEWKT"/>,  <xref linkend="ST_Point" />, <xref linkend="ST_SRID"/>, <xref linkend="ST_Transform"/>, <xref linkend="UpdateGeometrySRID"/></para>
	  </refsection>

	</refentry>

	<refentry id="ST_SnapToGrid">
	  <refnamediv>
		<refname>ST_SnapToGrid</refname>

		<refpurpose>
		Snap all points of the input geometry to a regular grid.
		</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_SnapToGrid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>originX</parameter></paramdef>
			<paramdef><type>float </type> <parameter>originY</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeX</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeY</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_SnapToGrid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeX</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeY</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_SnapToGrid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float </type> <parameter>size</parameter></paramdef>
		  </funcprototype>

		  <funcprototype>
			<funcdef>geometry <function>ST_SnapToGrid</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>pointOrigin</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeX</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeY</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeZ</parameter></paramdef>
			<paramdef><type>float </type> <parameter>sizeM</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Variant 1,2,3: Snap all points of the input geometry to the grid defined by
			its origin and cell size. Remove consecutive points falling on the
			same cell, eventually returning NULL if output points are not
			enough to define a geometry of the given type. Collapsed
			geometries in a collection are stripped from it.
			Useful for reducing precision.
		</para>

		<para>Variant 4:  Introduced 1.1.0 - Snap all points of the input geometry to the grid defined by
			its origin (the second argument, must be a point) and cell sizes.
			Specify 0 as size for any dimension you don't want to snap to a
			grid.</para>

		<note>
		  <para>The returned geometry might lose its simplicity (see
		  <xref linkend="ST_IsSimple" />).</para>
		</note>

		<note>
		  <para>Before release 1.1.0 this function always returned a 2d
		  geometry. Starting at 1.1.0 the returned geometry will have same
		  dimensionality as the input one with higher dimension values
		  untouched. Use the version taking a second geometry argument to
		  define all grid dimensions.</para>
		</note>

		<para>Availability: 1.0.0RC1</para>
		<para>Availability: 1.1.0 - Z and M support</para>

		<para>&Z_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--Snap your geometries to a precision grid of 10^-3
UPDATE mytable
   SET the_geom = ST_SnapToGrid(the_geom, 0.001);

SELECT ST_AsText(ST_SnapToGrid(
			ST_GeomFromText('LINESTRING(1.1115678 2.123, 4.111111 3.2374897, 4.11112 3.23748667)'),
			0.001)
		);
			  st_astext
-------------------------------------
 LINESTRING(1.112 2.123,4.111 3.237)
 --Snap a 4d geometry
SELECT ST_AsEWKT(ST_SnapToGrid(
	ST_GeomFromEWKT('LINESTRING(-1.1115678 2.123 2.3456 1.11111,
		4.111111 3.2374897 3.1234 1.1111, -1.11111112 2.123 2.3456 1.1111112)'),
 ST_GeomFromEWKT('POINT(1.12 2.22 3.2 4.4444)'),
 0.1, 0.1, 0.1, 0.01) );
								  st_asewkt
------------------------------------------------------------------------------
 LINESTRING(-1.08 2.12 2.3 1.1144,4.12 3.22 3.1 1.1144,-1.08 2.12 2.3 1.1144)


--With a 4d geometry - the ST_SnapToGrid(geom,size) only touches x and y coords but keeps m and z the same
SELECT ST_AsEWKT(ST_SnapToGrid(ST_GeomFromEWKT('LINESTRING(-1.1115678 2.123 3 2.3456,
		4.111111 3.2374897 3.1234 1.1111)'),
	   0.01)      );
						st_asewkt
---------------------------------------------------------
 LINESTRING(-1.11 2.12 3 2.3456,4.11 3.24 3.1234 1.1111)

		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
		<xref linkend="ST_Snap" />,
		<xref linkend="ST_AsEWKT" />,
		<xref linkend="ST_AsText" />,
		<xref linkend="ST_GeomFromText" />,
		<xref linkend="ST_GeomFromEWKT" />,
		<xref linkend="ST_Simplify" />
		</para>
	  </refsection>
	</refentry>

		<refentry id="ST_Snap">
	  <refnamediv>
		<refname>ST_Snap</refname>

		<refpurpose>
	Snap segments and vertices of input geometry
	to vertices of a reference geometry.
		</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Snap</function></funcdef>
			<paramdef><type>geometry </type> <parameter>input</parameter></paramdef>
			<paramdef><type>geometry </type> <parameter>reference</parameter></paramdef>
			<paramdef><type>float </type> <parameter>tolerance</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>
 Snaps the vertices and segments of a geometry
 another Geometry's vertices.
 A snap distance tolerance is used to control where snapping is performed.
  The result geometry is the input geometry with the vertices snapped.
	If no snapping occurs then the input geometry is returned unchanged.
		</para>
		<para>
 Snapping one geometry to another can improve
 robustness for overlay operations by eliminating
 nearly-coincident edges
 (which cause problems during noding and intersection calculation).
		</para>

		<para>
 Too much snapping can result in invalid topology
 being created, so the number and location of snapped vertices
 is decided using heuristics to determine when it
 is safe to snap.
 This can result in some potential snaps being omitted, however.
		</para>

		<note>
		  <para>
		  The returned geometry might lose its simplicity (see
		  <xref linkend="ST_IsSimple" />) and validity (see
		  <xref linkend="ST_IsValid" />).
		  </para>
		</note>

		<para>Availability: 2.0.0 requires GEOS &gt;= 3.3.0.</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
			<informaltable>
				  <tgroup cols="2">
					<colspec colname="column1" />
					<colspec colname="column2" />
					<spanspec namest="column1" nameend="column2" spanname="span-horiz" align="center" />
					<tbody>
					  <row>
						<entry spanname="span-horiz"><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_snap01.png" />
							  </imageobject>
							  <caption><para>A multipolygon shown with a linestring (before any snapping)</para></caption>
							</mediaobject>
						  </informalfigure></para>
					   </entry>
					  </row>
					  <row>
					   <entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_snap02.png" />
							  </imageobject>
							  <caption><para>A multipolygon snapped to linestring to tolerance: 1.01 of distance.
							  The new multipolygon is shown with reference linestring</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(ST_Snap(poly,line, ST_Distance(poly,line)*1.01)) AS polysnapped
FROM (SELECT
   ST_GeomFromText('MULTIPOLYGON(
     ((26 125, 26 200, 126 200, 126 125, 26 125 ),
      ( 51 150, 101 150, 76 175, 51 150 )),
      (( 151 100, 151 200, 176 175, 151 100 )))') As poly,
       ST_GeomFromText('LINESTRING (5 107, 54 84, 101 100)') As line

	) As foo;

                             polysnapped
---------------------------------------------------------------------
 MULTIPOLYGON(((26 125,26 200,126 200,126 125,101 100,26 125),
 (51 150,101 150,76 175,51 150)),((151 100,151 200,176 175,151 100)))
				</programlisting></para>
					</entry>
					<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_snap04.png" />
							  </imageobject>
							  <caption><para>A multipolygon snapped to linestring to tolerance: 1.25 of distance.
							  The new multipolygon is shown with reference linestring</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(
    ST_Snap(poly,line, ST_Distance(poly,line)*1.25)
  ) AS polysnapped
FROM (SELECT
  ST_GeomFromText('MULTIPOLYGON(
    (( 26 125, 26 200, 126 200, 126 125, 26 125 ),
      ( 51 150, 101 150, 76 175, 51 150 )),
      (( 151 100, 151 200, 176 175, 151 100 )))') As poly,
       ST_GeomFromText('LINESTRING (5 107, 54 84, 101 100)') As line

	) As foo;

                             polysnapped
---------------------------------------------------------------------
MULTIPOLYGON(((5 107,26 200,126 200,126 125,101 100,54 84,5 107),
(51 150,101 150,76 175,51 150)),((151 100,151 200,176 175,151 100)))
				</programlisting></para>
						</entry>
					</row>
					<row>
					   <entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_snap03.png" />
							  </imageobject>
							  <caption><para>The linestring snapped to the original multipolygon  at tolerance 1.01 of distance.
							  The new linestring is shown with reference multipolygon</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(
   ST_Snap(line, poly, ST_Distance(poly,line)*1.01)
  ) AS linesnapped
FROM (SELECT
  ST_GeomFromText('MULTIPOLYGON(
     ((26 125, 26 200, 126 200, 126 125, 26 125),
      (51 150, 101 150, 76 175, 51 150 )),
      ((151 100, 151 200, 176 175, 151 100)))') As poly,
       ST_GeomFromText('LINESTRING (5 107, 54 84, 101 100)') As line
	) As foo;

              linesnapped
----------------------------------------
 LINESTRING(5 107,26 125,54 84,101 100)
				</programlisting>
						  </para>
					</entry>
					<entry><para><informalfigure>
							<mediaobject>
							  <imageobject>
								<imagedata fileref="images/st_snap05.png" />
							  </imageobject>
							  <caption><para>The linestring snapped to the original multipolygon  at tolerance 1.25 of distance.
							  The new linestring is shown with reference multipolygon</para></caption>
							</mediaobject>
						  </informalfigure>
				<programlisting>
SELECT ST_AsText(
 ST_Snap(line, poly, ST_Distance(poly,line)*1.25)
  ) AS linesnapped
FROM (SELECT
  ST_GeomFromText('MULTIPOLYGON(
     (( 26 125, 26 200, 126 200, 126 125, 26 125 ),
      (51 150, 101 150, 76 175, 51 150 )),
      ((151 100, 151 200, 176 175, 151 100 )))') As poly,
       ST_GeomFromText('LINESTRING (5 107, 54 84, 101 100)') As line
	) As foo;
              linesnapped
---------------------------------------
LINESTRING(26 125,54 84,101 100)
				</programlisting></para>
					</entry>
				</row>
		</tbody>
	</tgroup>
</informaltable>

	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para>
		<xref linkend="ST_SnapToGrid" />
		</para>
	  </refsection>
	</refentry>

	<refentry id="ST_Transform">
	  <refnamediv>
		<refname>ST_Transform</refname>

		<refpurpose>Return a new geometry with its coordinates transformed to
			a different spatial reference.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Transform</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>

          <funcprototype>
              <funcdef>geometry <function>ST_Transform</function></funcdef>
              <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
              <paramdef><type>text </type> <parameter>to_proj</parameter></paramdef>
          </funcprototype>

          <funcprototype>
              <funcdef>geometry <function>ST_Transform</function></funcdef>
              <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
              <paramdef><type>text </type> <parameter>from_proj</parameter></paramdef>
              <paramdef><type>text </type> <parameter>to_proj</parameter></paramdef>
          </funcprototype>

          <funcprototype>
              <funcdef>geometry <function>ST_Transform</function></funcdef>
              <paramdef><type>geometry </type> <parameter>geom</parameter></paramdef>
              <paramdef><type>text </type> <parameter>from_proj</parameter></paramdef>
              <paramdef><type>integer </type> <parameter>to_srid</parameter></paramdef>
          </funcprototype>

		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

        <para>Returns a new geometry with its coordinates transformed to
            a different spatial reference system. The destination spatial
			reference <varname>to_srid</varname> may be identified by a valid
			SRID integer parameter (i.e. it must exist in the
			<varname>spatial_ref_sys</varname> table).
			Alternatively, a spatial reference defined as a PROJ.4 string
			can be used for <varname>to_proj</varname> and/or
			<varname>from_proj</varname>, however these methods are not
			optimized. If the destination spatial reference system is
			expressed with a PROJ.4 string instead of an SRID, the SRID of the
			output geometry will be set to zero. With the exception of functions with
			<varname>from_proj</varname>, input geometries must have a defined SRID.
		</para>

		<para>ST_Transform is often confused with ST_SetSRID().  ST_Transform actually changes the coordinates
		of a geometry from one spatial reference system to another, while ST_SetSRID() simply changes the SRID identifier of
		the geometry.</para>

		<note>
		  <para>Requires PostGIS be compiled with Proj support.  Use <xref linkend="PostGIS_Full_Version" /> to confirm you have proj support compiled in.</para>
		</note>

		<note>
		  <para>If using more than one transformation, it is useful to have a functional index on the commonly used
			transformations to take advantage of index usage.</para>
		</note>

		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>

		<para>Enhanced: 2.0.0 support for Polyhedral surfaces was introduced.</para>
		<para>Enhanced: 2.3.0 support for direct PROJ.4 text was introduced.</para>
		<para>&sqlmm_compliant; SQL-MM 3: 5.1.6</para>
		<para>&curve_support;</para>
		<para>&P_support;</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>Change Massachusetts state plane US feet geometry to WGS 84 long lat</para>
		<programlisting>
SELECT ST_AsText(ST_Transform(ST_GeomFromText('POLYGON((743238 2967416,743238 2967450,
	743265 2967450,743265.625 2967416,743238 2967416))',2249),4326)) As wgs_geom;

 wgs_geom
---------------------------
 POLYGON((-71.1776848522251 42.3902896512902,-71.1776843766326 42.3903829478009,
-71.1775844305465 42.3903826677917,-71.1775825927231 42.3902893647987,-71.177684
8522251 42.3902896512902));
(1 row)

--3D Circular String example
SELECT ST_AsEWKT(ST_Transform(ST_GeomFromEWKT('SRID=2249;CIRCULARSTRING(743238 2967416 1,743238 2967450 2,743265 2967450 3,743265.625 2967416 3,743238 2967416 4)'),4326));

				 st_asewkt
--------------------------------------------------------------------------------------
 SRID=4326;CIRCULARSTRING(-71.1776848522251 42.3902896512902 1,-71.1776843766326 42.3903829478009 2,
 -71.1775844305465 42.3903826677917 3,
 -71.1775825927231 42.3902893647987 3,-71.1776848522251 42.3902896512902 4)

		</programlisting>
		<para>Example of creating a partial functional index.  For tables where you are not sure all the geometries
			will be filled in, its best to use a partial index that leaves out null geometries which will both conserve space and make your index smaller and more efficient.</para>
		<programlisting>
CREATE INDEX idx_the_geom_26986_parcels
  ON parcels
  USING gist
  (ST_Transform(the_geom, 26986))
  WHERE the_geom IS NOT NULL;
		</programlisting>

		<para>Examples of using PROJ.4 text to transform with custom spatial references.</para>
		<programlisting>
-- Find intersection of two polygons near the North pole, using a custom Gnomic projection
-- See http://boundlessgeo.com/2012/02/flattening-the-peel/
 WITH data AS (
   SELECT
     ST_GeomFromText('POLYGON((170 50,170 72,-130 72,-130 50,170 50))', 4326) AS p1,
     ST_GeomFromText('POLYGON((-170 68,-170 90,-141 90,-141 68,-170 68))', 4326) AS p2,
     '+proj=gnom +ellps=WGS84 +lat_0=70 +lon_0=-160 +no_defs'::text AS gnom
 )
 SELECT ST_AsText(
   ST_Transform(
     ST_Intersection(ST_Transform(p1, gnom), ST_Transform(p2, gnom)),
   gnom, 4326))
 FROM data;
                                          st_astext
 --------------------------------------------------------------------------------
  POLYGON((-170 74.053793645338,-141 73.4268621378904,-141 68,-170 68,-170 74.053793645338))
		</programlisting>

	  </refsection>
	  <refsection>
		<title>Configuring transformation behaviour</title>
			<para>Sometimes coordinate transformation involving a grid-shift
				can fail, for example if PROJ.4 has not been built with
				grid-shift files or the coordinate does not lie within the
				range for which the grid shift is defined. By default, PostGIS
				will throw an error if a grid shift file is not present, but
				this behaviour can be configured on a per-SRID basis either
				by testing different <varname>to_proj</varname> values of
				PROJ.4 text, or altering the <varname>proj4text</varname> value
				within the <varname>spatial_ref_sys</varname> table.
			</para>
				<para>For example, the proj4text parameter +datum=NAD87 is a shorthand form for the following +nadgrids parameter:</para>
				<programlisting>+nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat</programlisting>
				<para>The @ prefix means no error is reported if the files are not present, but if the end of the list is reached with no file having been appropriate (ie. found and overlapping) then an error is issued.</para>
				<para>If, conversely, you wanted to ensure that at least the standard files were present, but that if all files were scanned without a hit a null transformation is applied you could use:</para>
				<programlisting>+nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat,null</programlisting>
				<para>The null grid shift file is a valid grid shift file covering the whole world and applying no shift. So for a complete example, if you wanted to alter PostGIS so that transformations to SRID 4267 that didn't lie within the correct range did not throw an ERROR, you would use the following:</para>
				<programlisting>UPDATE spatial_ref_sys SET proj4text = '+proj=longlat +ellps=clrk66 +nadgrids=@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat,null +no_defs' WHERE srid = 4267;</programlisting>
		  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="PostGIS_Full_Version" />, <xref linkend="ST_AsText" />, <xref linkend="ST_SetSRID" />, <xref linkend="UpdateGeometrySRID"/></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Translate">
	  <refnamediv>
		<refname>ST_Translate</refname>

		<refpurpose>Translate a geometry by given offsets.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Translate</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltax</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltay</parameter></paramdef>
		  </funcprototype>
		  <funcprototype>
			<funcdef>geometry <function>ST_Translate</function></funcdef>
			<paramdef><type>geometry </type> <parameter>g1</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltax</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltay</parameter></paramdef>
			<paramdef><type>float </type> <parameter>deltaz</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a new geometry whose coordinates are translated delta x,delta y,delta z units. Units are
		based on the units defined in spatial reference (SRID) for this geometry.</para>

		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>

		<para>Availability: 1.2.2</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>

	  <refsection>
		<title>Examples</title>
		<para>Move a point 1 degree longitude</para>
		<programlisting>
	SELECT ST_AsText(ST_Translate(ST_GeomFromText('POINT(-71.01 42.37)',4326),1,0)) As wgs_transgeomtxt;

	wgs_transgeomtxt
	---------------------
	POINT(-70.01 42.37)
		</programlisting>
		<para>Move a linestring 1 degree longitude and 1/2 degree latitude</para>
		<programlisting>SELECT ST_AsText(ST_Translate(ST_GeomFromText('LINESTRING(-71.01 42.37,-71.11 42.38)',4326),1,0.5)) As wgs_transgeomtxt;
		   wgs_transgeomtxt
	---------------------------------------
	LINESTRING(-70.01 42.87,-70.11 42.88)
		</programlisting>
		<para>Move a 3d point</para>
		<programlisting>SELECT ST_AsEWKT(ST_Translate(CAST('POINT(0 0 0)' As geometry), 5, 12,3));
	st_asewkt
	---------
	POINT(5 12 3)
		</programlisting>
		<para>Move a curve and a point</para>
<programlisting>SELECT ST_AsText(ST_Translate(ST_Collect('CURVEPOLYGON(CIRCULARSTRING(4 3,3.12 0.878,1 0,-1.121 5.1213,6 7, 8 9,4 3))','POINT(1 3)'),1,2));
														 st_astext
------------------------------------------------------------------------------------------------------------
 GEOMETRYCOLLECTION(CURVEPOLYGON(CIRCULARSTRING(5 5,4.12 2.878,2 2,-0.121 7.1213,7 9,9 11,5 5)),POINT(2 5))
</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="ST_Affine" />, <xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromText" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_TransScale">
	  <refnamediv>
		<refname>ST_TransScale</refname>

		<refpurpose>Translate a geometry by given factors and offsets.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_TransScale</function></funcdef>
			<paramdef><type>geometry </type> <parameter>geomA</parameter></paramdef>
			<paramdef><type>float</type> <parameter>deltaX</parameter></paramdef>
			<paramdef><type>float</type> <parameter>deltaY</parameter></paramdef>
			<paramdef><type>float</type> <parameter>XFactor</parameter></paramdef>
			<paramdef><type>float</type> <parameter>YFactor</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Translates the geometry using the deltaX and deltaY args,
			then scales it using the XFactor, YFactor args, working in 2D only.</para>

		<note><para><code>ST_TransScale(geomA, deltaX, deltaY, XFactor, YFactor)</code>
			is short-hand for <code>ST_Affine(geomA, XFactor, 0, 0, 0, YFactor, 0,
			0, 0, 1, deltaX*XFactor, deltaY*YFactor, 0)</code>.</para></note>

		<note><para>Prior to 1.3.4, this function crashes if used with geometries that contain CURVES.  This is fixed in 1.3.4+</para></note>


		<para>Availability: 1.1.0.</para>
		<para>&Z_support;</para>
		<para>&curve_support;</para>
	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>SELECT ST_AsEWKT(ST_TransScale(ST_GeomFromEWKT('LINESTRING(1 2 3, 1 1 1)'), 0.5, 1, 1, 2));
		  st_asewkt
-----------------------------
 LINESTRING(1.5 6 3,1.5 4 1)


--Buffer a point to get an approximation of a circle, convert to curve and then translate 1,2 and scale it 3,4
  SELECT ST_AsText(ST_Transscale(ST_LineToCurve(ST_Buffer('POINT(234 567)', 3)),1,2,3,4));
														  st_astext
------------------------------------------------------------------------------------------------------------------------------
 CURVEPOLYGON(CIRCULARSTRING(714 2276,711.363961030679 2267.51471862576,705 2264,698.636038969321 2284.48528137424,714 2276))

</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_Affine" />, <xref linkend="ST_Translate" /></para>
	  </refsection>
	</refentry>



  </sect1>
