<?xml version="1.0" encoding="UTF-8"?>
  <sect1 id="Geometry_Constructors">
	  <title>Geometry Constructors</title>

	<refentry id="ST_LineFromMultiPoint">
	  <refnamediv>
		<refname>ST_LineFromMultiPoint</refname>

		<refpurpose>Creates a LineString from a MultiPoint geometry.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_LineFromMultiPoint</function></funcdef>
			<paramdef><type>geometry </type> <parameter>aMultiPoint</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Creates a LineString from a MultiPoint geometry.</para>
		<para>&Z_support;</para>

	  </refsection>

	  <refsection>
		<title>Examples</title>

		<programlisting>
--Create a 3d line string from a 3d multipoint
SELECT ST_AsEWKT(ST_LineFromMultiPoint(ST_GeomFromEWKT('MULTIPOINT(1 2 3, 4 5 6, 7 8 9)')));
--result--
LINESTRING(1 2 3,4 5 6,7 8 9)
		</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_Collect" />, <xref linkend="ST_MakeLine" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_MakeLine">
		<refnamediv>
		<refname>ST_MakeLine</refname>

		<refpurpose>Creates a Linestring from point, multipoint, or line geometries.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
			<funcprototype>
				<funcdef>geometry <function>ST_MakeLine</function></funcdef>
				<paramdef><type>geometry set</type> <parameter>geoms</parameter></paramdef>
			</funcprototype>

			<funcprototype>
				<funcdef>geometry <function>ST_MakeLine</function></funcdef>
				<paramdef><type>geometry</type> <parameter>geom1</parameter></paramdef>
				<paramdef><type>geometry</type> <parameter>geom2</parameter></paramdef>
			</funcprototype>

			<funcprototype>
				<funcdef>geometry <function>ST_MakeLine</function></funcdef>
				<paramdef><type>geometry[]</type> <parameter>geoms_array</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
		<title>Description</title>

		<para>ST_MakeLine comes in 3 forms: a spatial aggregate that takes
			rows of point, multipoint, or line geometries and returns a line string, a
			function that takes an array of point, multipoint, or line, and a regular
			function that takes two point, multipoint, or line geometries. You
			might want to use a subselect to order points before feeding them
			to  the aggregate version of this function.</para>

		<para>Inputs other than point, multipoint, or lines are ignored.</para>
		<para>
			When adding line components common nodes at the beginning of lines are removed from the output. Common nodes in point and multipoint inputs are not removed.
		</para>

		<para>&Z_support;</para>

		<para>Availability: 2.3.0 -  Support for multipoint input elements was introduced</para>
		<para>Availability: 2.0.0 -  Support for linestring input elements was introduced</para>
		<para>Availability: 1.4.0 -  ST_MakeLine(geomarray) was introduced. ST_MakeLine aggregate functions was enhanced to handle more points faster.</para>

		</refsection>

		<refsection>
		<title>Examples: Spatial Aggregate version</title>
		<para>This example takes a sequence of GPS points and creates one record for each
			gps travel where the geometry field is a line string composed of the gps points
			in the order of the travel.</para>

		<programlisting>
-- For pre-PostgreSQL 9.0 - this usually works,
-- but the planner may on occasion choose not to respect the order of the subquery
SELECT gps.gps_track, ST_MakeLine(gps.the_geom) As newgeom
	FROM (SELECT gps_track, gps_time, the_geom
			FROM gps_points ORDER BY gps_track, gps_time) As gps
	GROUP BY gps.gps_track;</programlisting>

		<programlisting>
-- If you are using PostgreSQL 9.0+
-- (you can use the new ORDER BY support for aggregates)
-- this is a guaranteed way to get a correctly ordered linestring
-- Your order by part can order by more than one column if needed
SELECT gps.gps_track, ST_MakeLine(gps.the_geom ORDER BY gps_time) As newgeom
	FROM gps_points As gps
	GROUP BY gps.gps_track;</programlisting>
		</refsection>
		<refsection>
			<title>Examples: Non-Spatial Aggregate version</title>

			<para>First example is a simple one off line string composed of 2 points.  The second formulates
				line strings from 2 points a user draws.  The third is a one-off that joins 2 3d points to create a line in 3d space.</para>
			<programlisting>
SELECT ST_AsText(ST_MakeLine(ST_MakePoint(1,2), ST_MakePoint(3,4)));
	  st_astext
---------------------
 LINESTRING(1 2,3 4)

SELECT userpoints.id, ST_MakeLine(startpoint, endpoint) As drawn_line
	FROM userpoints ;

SELECT ST_AsEWKT(ST_MakeLine(ST_MakePoint(1,2,3), ST_MakePoint(3,4,5)));
		st_asewkt
-------------------------
 LINESTRING(1 2 3,3 4 5)
			</programlisting>
		</refsection>

		<refsection>
			<title>Examples: Using Array version</title>

			<programlisting>
SELECT ST_MakeLine(ARRAY(SELECT ST_Centroid(the_geom) FROM visit_locations ORDER BY visit_time));

--Making a 3d line with 3 3-d points
SELECT ST_AsEWKT(ST_MakeLine(ARRAY[ST_MakePoint(1,2,3),
				ST_MakePoint(3,4,5), ST_MakePoint(6,6,6)]));
		st_asewkt
-------------------------
LINESTRING(1 2 3,3 4 5,6 6 6)
			</programlisting>
		</refsection>

	<!-- TODO: add an example using lines -->

		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromText" />, <xref linkend="ST_MakePoint" /></para>
		</refsection>
	</refentry>


	<refentry id="ST_MakeEnvelope">
		<refnamediv>
		<refname>ST_MakeEnvelope</refname>

		<refpurpose>Creates a rectangular Polygon formed from the given minimums and maximums. Input
			values must be in SRS specified by the SRID.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakeEnvelope</function></funcdef>
			<paramdef><type>double precision</type> <parameter>xmin</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>ymin</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>xmax</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>ymax</parameter></paramdef>
			<paramdef choice="opt"><type>integer </type> <parameter>srid=unknown</parameter></paramdef>
		  </funcprototype>
		 </funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a rectangular Polygon formed from the minima and maxima. by the given shell. Input
				values must be in SRS specified by the SRID.  If no SRID is specified the unknown spatial reference system is assumed</para>

			<para>Availability: 1.5</para>
			<para>Enhanced: 2.0: Ability to specify an envelope without specifying an SRID was introduced.</para>

		</refsection>

		<refsection>
		<title>Example: Building a bounding box polygon</title>
		 <programlisting>
SELECT ST_AsText(ST_MakeEnvelope(10, 10, 11, 11, 4326));

st_asewkt
-----------
POLYGON((10 10, 10 11, 11 11, 11 10, 10 10))
			  </programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_MakePoint" />, <xref linkend="ST_MakeLine" />, <xref linkend="ST_MakePolygon" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_MakePolygon">
		<refnamediv>
		<refname>ST_MakePolygon</refname>

		<refpurpose>Creates a Polygon formed by the given shell. Input
			geometries must be closed LINESTRINGS.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePolygon</function></funcdef>
			<paramdef><type>geometry</type> <parameter>linestring</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePolygon</function></funcdef>
			<paramdef><type>geometry</type> <parameter>outerlinestring</parameter></paramdef>
			<paramdef><type>geometry[]</type> <parameter>interiorlinestrings</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a Polygon formed by the given shell. Input
				geometries must be closed LINESTRINGS. Comes in 2 variants.</para>
			<para>Variant 1:  Takes one closed linestring.</para>
			<para>Variant 2:  Creates a Polygon formed by the given shell and array of
			holes. You can construct a geometry array using the PostgreSQL array_agg, ARRAY[] and
			ARRAY() constructs. Input geometries must be closed LINESTRINGS.</para>
			<note>
				<para>This function will not accept a MULTILINESTRING.  Use <xref linkend="ST_LineMerge" /> or <xref linkend="ST_Dump" /> to generate line strings.</para>
			</note>

			<para>&Z_support;</para>
		</refsection>

		<refsection>
		<title>Examples: Single closed LINESTRING</title>
		 <programlisting>
--2d line
SELECT ST_MakePolygon(ST_GeomFromText('LINESTRING(75.15 29.53,77 29,77.6 29.5, 75.15 29.53)'));
--If linestring is not closed
--you can add the start point to close it
SELECT ST_MakePolygon(ST_AddPoint(foo.open_line, ST_StartPoint(foo.open_line)))
FROM (
SELECT ST_GeomFromText('LINESTRING(75.15 29.53,77 29,77.6 29.5)') As open_line) As foo;

--3d closed line
SELECT ST_MakePolygon(ST_GeomFromText('LINESTRING(75.15 29.53 1,77 29 1,77.6 29.5 1, 75.15 29.53 1)'));

st_asewkt
-----------
POLYGON((75.15 29.53 1,77 29 1,77.6 29.5 1,75.15 29.53 1))

--measured line --
SELECT ST_MakePolygon(ST_GeomFromText('LINESTRINGM(75.15 29.53 1,77 29 1,77.6 29.5 2, 75.15 29.53 2)'));

st_asewkt
----------
POLYGONM((75.15 29.53 1,77 29 1,77.6 29.5 2,75.15 29.53 2))
			  </programlisting>
		</refsection>
		<refsection>
			<title>Examples: Outer shell with inner shells</title>

			<para>Build a donut with an ant hole</para>
		   <programlisting>
SELECT ST_MakePolygon(
		ST_ExteriorRing(ST_Buffer(foo.line,10)),
	ARRAY[ST_Translate(foo.line,1,1),
		ST_ExteriorRing(ST_Buffer(ST_MakePoint(20,20),1)) ]
	)
FROM
	(SELECT ST_ExteriorRing(ST_Buffer(ST_MakePoint(10,10),10,10))
		As line )
		As foo;
		</programlisting>
		<para>Build province boundaries with holes
		representing lakes in the province from a set of
		province polygons/multipolygons and water linestrings.
		<note><para>The CASE construct is used because feeding a null array into
		ST_MakePolygon results in NULL.</para></note>
		<note><para>A left join is used to guarantee we get all provinces back even if they have no lakes.</para></note></para>
		<programlisting>
	SELECT p.gid, p.province_name,
		CASE WHEN
			array_agg(w.the_geom) IS NULL THEN p.the_geom
		ELSE  ST_MakePolygon(ST_LineMerge(ST_Boundary(p.the_geom)), array_agg(w.the_geom)) END
	FROM
		provinces p LEFT JOIN waterlines w
			ON (ST_Within(w.the_geom, p.the_geom) AND ST_IsClosed(w.the_geom))
	GROUP BY p.gid, p.province_name, p.the_geom;

	--Same example above but utilizing a correlated subquery
	--and PostgreSQL built-in ARRAY() function that converts a row set to an array

	SELECT p.gid,  p.province_name, CASE WHEN
		EXISTS(SELECT w.the_geom
			FROM waterlines w
			WHERE ST_Within(w.the_geom, p.the_geom)
			AND ST_IsClosed(w.the_geom))
		THEN
		ST_MakePolygon(ST_LineMerge(ST_Boundary(p.the_geom)),
			ARRAY(SELECT w.the_geom
				FROM waterlines w
				WHERE ST_Within(w.the_geom, p.the_geom)
				AND ST_IsClosed(w.the_geom)))
		ELSE p.the_geom END As the_geom
	FROM
		provinces p;
			  </programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para>
				<xref linkend="ST_Boundary" />,
				<xref linkend="ST_AddPoint" />,
				<xref linkend="ST_GeometryType" />,
				<xref linkend="ST_IsClosed" />,
				<xref linkend="ST_LineMerge" />,
				<xref linkend="ST_BuildArea" />
			</para>
		</refsection>
	</refentry>

	<refentry id="ST_MakePoint">
		<refnamediv>
		<refname>ST_MakePoint</refname>

		<refpurpose>Creates a 2D, 3DZ or 4D point geometry.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePoint</function></funcdef>
			<paramdef><type>double precision</type> <parameter>x</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>y</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePoint</function></funcdef>
			<paramdef><type>double precision</type> <parameter>x</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>y</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>z</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_MakePoint</function></funcdef>
			<paramdef><type>double precision</type> <parameter>x</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>y</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>z</parameter></paramdef>
			<paramdef><type>double precision</type> <parameter>m</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a 2D, 3DZ or 4D point geometry (geometry with measure).
			<varname>ST_MakePoint</varname> while not being OGC compliant is
			generally faster and more precise than <xref linkend="ST_GeomFromText" />
			and <xref linkend="ST_PointFromText" />.  It is also easier to use if
			you have raw coordinates rather than WKT.</para>

			<note><para>Note x is longitude and y is latitude</para></note>
			<note><para>Use <xref linkend="ST_MakePointM" /> if you need to make a point with x, y and m.</para></note>
			<para>&Z_support;</para>

		</refsection>

		<refsection>
		<title>Examples</title>
		 <programlisting>--Return point with unknown SRID
SELECT ST_MakePoint(-71.1043443253471, 42.3150676015829);

--Return point marked as WGS 84 long lat
SELECT ST_SetSRID(ST_MakePoint(-71.1043443253471, 42.3150676015829),4326);

--Return a 3D point (e.g. has altitude)
SELECT ST_MakePoint(1, 2,1.5);

--Get z of point
SELECT ST_Z(ST_MakePoint(1, 2,1.5));
result
-------
1.5</programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_GeomFromText" />, <xref linkend="ST_PointFromText" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_MakePointM" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_MakePointM">
		<refnamediv>
		<refname>ST_MakePointM</refname>

		<refpurpose>Creates a point geometry with an x y and m coordinate.</refpurpose>
		</refnamediv>

		<refsynopsisdiv>
			<funcsynopsis>
			  <funcprototype>
				<funcdef>geometry <function>ST_MakePointM</function></funcdef>
				<paramdef><type>float</type> <parameter>x</parameter></paramdef>
				<paramdef><type>float</type> <parameter>y</parameter></paramdef>
				<paramdef><type>float</type> <parameter>m</parameter></paramdef>
			  </funcprototype>
			</funcsynopsis>
		</refsynopsisdiv>

		<refsection>
			<title>Description</title>

			<para>Creates a point with x, y and measure coordinates. </para>
			<note><para>Note x is longitude and y is latitude.</para></note>
		</refsection>

		<refsection>
		<title>Examples</title>
			<para>We use ST_AsEWKT in these examples to show the text representation instead of ST_AsText because ST_AsText does not
			support returning M.</para>
		 <programlisting>
--Return EWKT representation of point with unknown SRID
SELECT ST_AsEWKT(ST_MakePointM(-71.1043443253471, 42.3150676015829, 10));

--result
				   st_asewkt
-----------------------------------------------
 POINTM(-71.1043443253471 42.3150676015829 10)

--Return EWKT representation of point with measure marked as WGS 84 long lat
SELECT ST_AsEWKT(ST_SetSRID(ST_MakePointM(-71.1043443253471, 42.3150676015829,10),4326));

						st_asewkt
---------------------------------------------------------
SRID=4326;POINTM(-71.1043443253471 42.3150676015829 10)

--Return a 3d point (e.g. has altitude)
SELECT ST_MakePoint(1, 2,1.5);

--Get m of point
SELECT ST_M(ST_MakePointM(-71.1043443253471, 42.3150676015829,10));
result
-------
10
			  </programlisting>
		</refsection>
		<refsection>
			<title>See Also</title>
			<para><xref linkend="ST_AsEWKT" />, <xref linkend="ST_MakePoint" />, <xref linkend="ST_SetSRID" /></para>
		</refsection>
	</refentry>

	<refentry id="ST_Point">
	  <refnamediv>
		<refname>ST_Point</refname>

		<refpurpose>Returns an ST_Point with the given coordinate values. OGC alias for ST_MakePoint.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Point</function></funcdef>
			<paramdef><type>float </type> <parameter>x_lon</parameter></paramdef>
			<paramdef><type>float </type> <parameter>y_lat</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns an ST_Point with the given coordinate values. MM compliant alias for ST_MakePoint that takes just an x and y.</para>


		<para>&sqlmm_compliant; SQL-MM 3: 6.1.2</para>

	  </refsection>


	  <refsection>
		<title>Examples: Geometry</title>

		<programlisting>SELECT ST_SetSRID(ST_Point(-71.1043443253471, 42.3150676015829),4326)</programlisting>
	  </refsection>

	  <refsection>
		<title>Examples: Geography</title>

		<programlisting>SELECT CAST(ST_SetSRID(ST_Point(-71.1043443253471, 42.3150676015829),4326) As geography);</programlisting>
		<programlisting>-- the :: is PostgreSQL short-hand for casting.
SELECT ST_SetSRID(ST_Point(-71.1043443253471, 42.3150676015829),4326)::geography;</programlisting>

        <programlisting>--If your point coordinates are in a different spatial reference from WGS-84 long lat, then you need to transform before casting
-- This example we convert a point in Pennsylvania State Plane feet to WGS 84 and then geography
SELECT ST_Transform(ST_SetSRID(ST_Point(3637510, 3014852),2273),4326)::geography;</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para><xref linkend="Geography_Basics" />, <xref linkend="ST_MakePoint" />, <xref linkend="ST_SetSRID" />, <xref linkend="ST_Transform" /></para>
	  </refsection>
	</refentry>

	<refentry id="ST_Polygon">
	  <refnamediv>
		<refname>ST_Polygon</refname>

		<refpurpose>Returns a polygon built from the specified linestring and SRID.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>geometry <function>ST_Polygon</function></funcdef>
			<paramdef><type>geometry </type> <parameter>aLineString</parameter></paramdef>
			<paramdef><type>integer </type> <parameter>srid</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Returns a polygon built from the specified linestring and SRID.</para>

		<!-- optionally mention that this function uses indexes if appropriate -->
		<note>
		  <para>ST_Polygon is similar to first version of ST_MakePolygon except it also sets the spatial ref sys (SRID) of the polygon. Will not work with MULTILINESTRINGS
			so use LineMerge to merge multilines.  Also does not create polygons with holes.  Use ST_MakePolygon for that.</para>
		</note>

		<para>&sfs_compliant;</para>
		<para>&sqlmm_compliant; SQL-MM 3: 8.3.2</para>
		<para>&Z_support;</para>

	  </refsection>


	  <refsection>
		<title>Examples</title>

		<programlisting>
--a 2d polygon
SELECT ST_Polygon(ST_GeomFromText('LINESTRING(75.15 29.53,77 29,77.6 29.5, 75.15 29.53)'), 4326);

--result--
POLYGON((75.15 29.53,77 29,77.6 29.5,75.15 29.53))
--a 3d polygon
SELECT ST_AsEWKT(ST_Polygon(ST_GeomFromEWKT('LINESTRING(75.15 29.53 1,77 29 1,77.6 29.5 1, 75.15 29.53 1)'), 4326));

result
------
SRID=4326;POLYGON((75.15 29.53 1,77 29 1,77.6 29.5 1,75.15 29.53 1))
			</programlisting>
	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>

		<para> <xref linkend="ST_AsEWKT" />, <xref linkend="ST_AsText" />, <xref linkend="ST_GeomFromEWKT" />, <xref linkend="ST_GeomFromText" />, <xref linkend="ST_LineMerge" />, <xref linkend="ST_MakePolygon" /></para>
	  </refsection>
	</refentry>

  </sect1>
